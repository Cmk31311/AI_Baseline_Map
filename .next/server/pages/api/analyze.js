"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/analyze";
exports.ids = ["pages/api/analyze"];
exports.modules = {

/***/ "(api-node)/./lib/analysis/baseline.loader.ts":
/*!*****************************************!*\
  !*** ./lib/analysis/baseline.loader.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearRulesCache: () => (/* binding */ clearRulesCache),\n/* harmony export */   getCachedBaselineRules: () => (/* binding */ getCachedBaselineRules),\n/* harmony export */   getDefaultBaselineRules: () => (/* binding */ getDefaultBaselineRules),\n/* harmony export */   getDependencyUpgradeTemplate: () => (/* binding */ getDependencyUpgradeTemplate),\n/* harmony export */   getLanguageRules: () => (/* binding */ getLanguageRules),\n/* harmony export */   getPatternQuickFix: () => (/* binding */ getPatternQuickFix),\n/* harmony export */   isRulesCacheValid: () => (/* binding */ isRulesCacheValid),\n/* harmony export */   loadBaselineRules: () => (/* binding */ loadBaselineRules),\n/* harmony export */   loadBaselineRulesWithFallback: () => (/* binding */ loadBaselineRulesWithFallback),\n/* harmony export */   shouldIgnorePath: () => (/* binding */ shouldIgnorePath),\n/* harmony export */   shouldScanFile: () => (/* binding */ shouldScanFile),\n/* harmony export */   validateRulesStructure: () => (/* binding */ validateRulesStructure)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yaml */ \"yaml\");\n/* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(yaml__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _baseline_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./baseline.types */ \"(api-node)/./lib/analysis/baseline.types.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_baseline_types__WEBPACK_IMPORTED_MODULE_4__]);\n_baseline_types__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\nconst __filename = (0,url__WEBPACK_IMPORTED_MODULE_2__.fileURLToPath)(\"file:///C:/Users/Ckhadar/Downloads/AI_Baseline_Map/lib/analysis/baseline.loader.ts\");\nconst __dirname = (0,path__WEBPACK_IMPORTED_MODULE_1__.dirname)(__filename);\n// Cache for loaded rules\nlet rulesCache = null;\nlet rulesCacheTimestamp = 0;\n/**\r\n * Load baseline rules from YAML configuration file\r\n * @param configPath Optional path to config file, defaults to config/baseline.rules.yaml\r\n * @returns Parsed and validated baseline rules\r\n */ function loadBaselineRules(configPath) {\n    const defaultPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(__dirname, '../../config/baseline.rules.yaml');\n    const path = configPath || defaultPath;\n    try {\n        // Check if we have cached rules and they're still valid\n        const stats = (__webpack_require__(/*! fs */ \"fs\").statSync)(path);\n        const mtime = stats.mtime.getTime();\n        if (rulesCache && mtime <= rulesCacheTimestamp) {\n            return rulesCache;\n        }\n        // Read and parse YAML file\n        const yamlContent = (0,fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync)(path, 'utf8');\n        const rawRules = yaml__WEBPACK_IMPORTED_MODULE_3___default().parse(yamlContent);\n        // Validate and parse rules\n        const rules = (0,_baseline_types__WEBPACK_IMPORTED_MODULE_4__.validateBaselineRules)(rawRules);\n        // Update cache\n        rulesCache = rules;\n        rulesCacheTimestamp = mtime;\n        return rules;\n    } catch (error) {\n        throw new Error(`Failed to load baseline rules from ${path}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\r\n * Get cached baseline rules without file system access\r\n * @returns Cached rules or throws if not loaded\r\n */ function getCachedBaselineRules() {\n    if (!rulesCache) {\n        throw new Error('Baseline rules not loaded. Call loadBaselineRules() first.');\n    }\n    return rulesCache;\n}\n/**\r\n * Clear the rules cache (useful for testing)\r\n */ function clearRulesCache() {\n    rulesCache = null;\n    rulesCacheTimestamp = 0;\n}\n/**\r\n * Check if rules are cached and up to date\r\n * @param configPath Optional path to config file\r\n * @returns True if cached rules are valid\r\n */ function isRulesCacheValid(configPath) {\n    if (!rulesCache) return false;\n    try {\n        const defaultPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(__dirname, '../../config/baseline.rules.yaml');\n        const path = configPath || defaultPath;\n        const stats = (__webpack_require__(/*! fs */ \"fs\").statSync)(path);\n        const mtime = stats.mtime.getTime();\n        return mtime <= rulesCacheTimestamp;\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Get default baseline rules (fallback if file loading fails)\r\n * @returns Minimal default rules\r\n */ function getDefaultBaselineRules() {\n    return {\n        language_runtimes: {\n            node: '>=18.0.0',\n            python: '>=3.10.0',\n            java: '>=17.0.0',\n            go: '>=1.21.0',\n            dotnet: '>=6.0.0'\n        },\n        package_mins: {\n            node: {\n                react: '>=18.0.0',\n                next: '>=13.0.0',\n                express: '>=4.18.0'\n            },\n            python: {\n                numpy: '>=1.22.0',\n                pandas: '>=1.4.0',\n                torch: '>=2.0.0'\n            },\n            java: {},\n            go: {},\n            dotnet: {}\n        },\n        deprecated_patterns: {\n            node: [\n                {\n                    pattern: 'fs\\\\.exists\\\\(',\n                    message: 'fs.exists() is deprecated, use fs.access() or fs.stat()',\n                    alternative: 'Use fs.access() or fs.promises.access()'\n                }\n            ],\n            python: [\n                {\n                    pattern: 'numpy\\\\.asscalar',\n                    message: 'numpy.asscalar is deprecated, use item() instead',\n                    alternative: 'Use numpy.item() or direct array indexing'\n                }\n            ],\n            java: [],\n            go: [],\n            dotnet: []\n        },\n        scan_file_exts: [\n            '.py',\n            '.js',\n            '.ts',\n            '.tsx',\n            '.jsx',\n            '.java',\n            '.go',\n            '.cs'\n        ],\n        ignore_paths: [\n            '/node_modules/',\n            '/.venv/',\n            '/venv/',\n            '/dist/',\n            '/build/',\n            '/.git/'\n        ],\n        max_file_size: 2097152,\n        max_files: 50000,\n        quick_fixes: {\n            dependency_upgrade: {\n                node: 'npm install {package}@{version}',\n                python: 'pip install \\'{package}>={version}\\'',\n                java: 'Update {package} to version {version} in pom.xml or build.gradle',\n                go: 'go get {package}@{version}',\n                dotnet: 'dotnet add package {package} --version {version}'\n            },\n            pattern_replacement: {\n                node: {\n                    'fs.exists(': 'Use fs.access() or fs.promises.access()'\n                },\n                python: {\n                    'numpy.asscalar': 'Use .item() method instead'\n                },\n                java: {},\n                go: {},\n                dotnet: {}\n            }\n        }\n    };\n}\n/**\r\n * Load baseline rules with fallback to defaults\r\n * @param configPath Optional path to config file\r\n * @returns Baseline rules (loaded or default)\r\n */ function loadBaselineRulesWithFallback(configPath) {\n    try {\n        return loadBaselineRules(configPath);\n    } catch (error) {\n        console.warn(`Failed to load baseline rules: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        console.warn('Using default baseline rules');\n        return getDefaultBaselineRules();\n    }\n}\n/**\r\n * Validate that a rules object has all required fields\r\n * @param rules Rules object to validate\r\n * @returns True if valid\r\n */ function validateRulesStructure(rules) {\n    try {\n        (0,_baseline_types__WEBPACK_IMPORTED_MODULE_4__.validateBaselineRules)(rules);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Get rules for a specific language\r\n * @param rules Baseline rules\r\n * @param language Language to get rules for\r\n * @returns Rules specific to the language\r\n */ function getLanguageRules(rules, language) {\n    return {\n        packageMins: rules.package_mins[language] || {},\n        deprecatedPatterns: rules.deprecated_patterns[language] || [],\n        runtime: rules.language_runtimes[language]\n    };\n}\n/**\r\n * Check if a file extension should be scanned\r\n * @param rules Baseline rules\r\n * @param extension File extension (with or without dot)\r\n * @returns True if should be scanned\r\n */ function shouldScanFile(rules, extension) {\n    const ext = extension.startsWith('.') ? extension : `.${extension}`;\n    return rules.scan_file_exts.includes(ext);\n}\n/**\r\n * Check if a path should be ignored\r\n * @param rules Baseline rules\r\n * @param filePath File path to check\r\n * @returns True if should be ignored\r\n */ function shouldIgnorePath(rules, filePath) {\n    if (!filePath || !rules.ignore_paths) {\n        return false;\n    }\n    return rules.ignore_paths.some((ignorePath)=>filePath.includes(ignorePath) || filePath.startsWith(ignorePath));\n}\n/**\r\n * Get quick fix template for dependency upgrade\r\n * @param rules Baseline rules\r\n * @param language Language\r\n * @returns Template string\r\n */ function getDependencyUpgradeTemplate(rules, language) {\n    return rules.quick_fixes.dependency_upgrade[language] || 'Update {package} to {version}';\n}\n/**\r\n * Get quick fix for pattern replacement\r\n * @param rules Baseline rules\r\n * @param language Language\r\n * @param pattern Pattern to replace\r\n * @returns Quick fix suggestion or undefined\r\n */ function getPatternQuickFix(rules, language, pattern) {\n    return rules.quick_fixes.pattern_replacement[language]?.[pattern];\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL2xpYi9hbmFseXNpcy9iYXNlbGluZS5sb2FkZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0c7QUFDRDtBQUNaO0FBQ2dEO0FBRXhFLE1BQU1NLGFBQWFILGtEQUFhQSxDQUFDLG9GQUFlO0FBQ2hELE1BQU1LLFlBQVlOLDZDQUFPQSxDQUFDSTtBQUUxQix5QkFBeUI7QUFDekIsSUFBSUcsYUFBbUM7QUFDdkMsSUFBSUMsc0JBQThCO0FBRWxDOzs7O0NBSUMsR0FDTSxTQUFTQyxrQkFBa0JDLFVBQW1CO0lBQ25ELE1BQU1DLGNBQWNaLDBDQUFJQSxDQUFDTyxXQUFXO0lBQ3BDLE1BQU1NLE9BQU9GLGNBQWNDO0lBRTNCLElBQUk7UUFDRix3REFBd0Q7UUFDeEQsTUFBTUUsUUFBUUMsOENBQXNCLENBQUNGO1FBQ3JDLE1BQU1JLFFBQVFILE1BQU1HLEtBQUssQ0FBQ0MsT0FBTztRQUVqQyxJQUFJVixjQUFjUyxTQUFTUixxQkFBcUI7WUFDOUMsT0FBT0Q7UUFDVDtRQUVBLDJCQUEyQjtRQUMzQixNQUFNVyxjQUFjcEIsZ0RBQVlBLENBQUNjLE1BQU07UUFDdkMsTUFBTU8sV0FBV2pCLGlEQUFVLENBQUNnQjtRQUU1QiwyQkFBMkI7UUFDM0IsTUFBTUcsUUFBUWxCLHNFQUFxQkEsQ0FBQ2dCO1FBRXBDLGVBQWU7UUFDZlosYUFBYWM7UUFDYmIsc0JBQXNCUTtRQUV0QixPQUFPSztJQUNULEVBQUUsT0FBT0MsT0FBTztRQUNkLE1BQU0sSUFBSUMsTUFBTSxDQUFDLG1DQUFtQyxFQUFFWCxLQUFLLEVBQUUsRUFBRVUsaUJBQWlCQyxRQUFRRCxNQUFNRSxPQUFPLEdBQUcsaUJBQWlCO0lBQzNIO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxTQUFTQztJQUNkLElBQUksQ0FBQ2xCLFlBQVk7UUFDZixNQUFNLElBQUlnQixNQUFNO0lBQ2xCO0lBQ0EsT0FBT2hCO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNB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LFdBQVc7SUFDbkUsT0FBT3pDLE1BQU13QixjQUFjLENBQUNvQixRQUFRLENBQUNGO0FBQ3ZDO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTRyxpQkFBaUI3QyxLQUFvQixFQUFFOEMsUUFBZ0I7SUFDckUsSUFBSSxDQUFDQSxZQUFZLENBQUM5QyxNQUFNeUIsWUFBWSxFQUFFO1FBQ3BDLE9BQU87SUFDVDtJQUNBLE9BQU96QixNQUFNeUIsWUFBWSxDQUFDc0IsSUFBSSxDQUFDQyxDQUFBQSxhQUM3QkYsU0FBU0YsUUFBUSxDQUFDSSxlQUFlRixTQUFTSCxVQUFVLENBQUNLO0FBRXpEO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTQyw2QkFBNkJqRCxLQUFvQixFQUFFb0MsUUFBa0U7SUFDbkksT0FBT3BDLE1BQU00QixXQUFXLENBQUNDLGtCQUFrQixDQUFDTyxTQUFTLElBQUk7QUFDM0Q7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTYyxtQkFDZGxELEtBQW9CLEVBQ3BCb0MsUUFBbUUsRUFDbkVkLE9BQWU7SUFFZixPQUFPdEIsTUFBTTRCLFdBQVcsQ0FBQ0UsbUJBQW1CLENBQUNNLFNBQVMsRUFBRSxDQUFDZCxRQUFRO0FBQ25FIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxiYXNlbGluZS5sb2FkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVhZEZpbGVTeW5jIH0gZnJvbSAnZnMnO1xyXG5pbXBvcnQgeyBqb2luLCBkaXJuYW1lIH0gZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tICd1cmwnO1xyXG5pbXBvcnQgWUFNTCBmcm9tICd5YW1sJztcclxuaW1wb3J0IHsgQmFzZWxpbmVSdWxlcywgdmFsaWRhdGVCYXNlbGluZVJ1bGVzIH0gZnJvbSAnLi9iYXNlbGluZS50eXBlcyc7XHJcblxyXG5jb25zdCBfX2ZpbGVuYW1lID0gZmlsZVVSTFRvUGF0aChpbXBvcnQubWV0YS51cmwpO1xyXG5jb25zdCBfX2Rpcm5hbWUgPSBkaXJuYW1lKF9fZmlsZW5hbWUpO1xyXG5cclxuLy8gQ2FjaGUgZm9yIGxvYWRlZCBydWxlc1xyXG5sZXQgcnVsZXNDYWNoZTogQmFzZWxpbmVSdWxlcyB8IG51bGwgPSBudWxsO1xyXG5sZXQgcnVsZXNDYWNoZVRpbWVzdGFtcDogbnVtYmVyID0gMDtcclxuXHJcbi8qKlxyXG4gKiBMb2FkIGJhc2VsaW5lIHJ1bGVzIGZyb20gWUFNTCBjb25maWd1cmF0aW9uIGZpbGVcclxuICogQHBhcmFtIGNvbmZpZ1BhdGggT3B0aW9uYWwgcGF0aCB0byBjb25maWcgZmlsZSwgZGVmYXVsdHMgdG8gY29uZmlnL2Jhc2VsaW5lLnJ1bGVzLnlhbWxcclxuICogQHJldHVybnMgUGFyc2VkIGFuZCB2YWxpZGF0ZWQgYmFzZWxpbmUgcnVsZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkQmFzZWxpbmVSdWxlcyhjb25maWdQYXRoPzogc3RyaW5nKTogQmFzZWxpbmVSdWxlcyB7XHJcbiAgY29uc3QgZGVmYXVsdFBhdGggPSBqb2luKF9fZGlybmFtZSwgJy4uLy4uL2NvbmZpZy9iYXNlbGluZS5ydWxlcy55YW1sJyk7XHJcbiAgY29uc3QgcGF0aCA9IGNvbmZpZ1BhdGggfHwgZGVmYXVsdFBhdGg7XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgY2FjaGVkIHJ1bGVzIGFuZCB0aGV5J3JlIHN0aWxsIHZhbGlkXHJcbiAgICBjb25zdCBzdGF0cyA9IHJlcXVpcmUoJ2ZzJykuc3RhdFN5bmMocGF0aCk7XHJcbiAgICBjb25zdCBtdGltZSA9IHN0YXRzLm10aW1lLmdldFRpbWUoKTtcclxuICAgIFxyXG4gICAgaWYgKHJ1bGVzQ2FjaGUgJiYgbXRpbWUgPD0gcnVsZXNDYWNoZVRpbWVzdGFtcCkge1xyXG4gICAgICByZXR1cm4gcnVsZXNDYWNoZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUmVhZCBhbmQgcGFyc2UgWUFNTCBmaWxlXHJcbiAgICBjb25zdCB5YW1sQ29udGVudCA9IHJlYWRGaWxlU3luYyhwYXRoLCAndXRmOCcpO1xyXG4gICAgY29uc3QgcmF3UnVsZXMgPSBZQU1MLnBhcnNlKHlhbWxDb250ZW50KTtcclxuICAgIFxyXG4gICAgLy8gVmFsaWRhdGUgYW5kIHBhcnNlIHJ1bGVzXHJcbiAgICBjb25zdCBydWxlcyA9IHZhbGlkYXRlQmFzZWxpbmVSdWxlcyhyYXdSdWxlcyk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjYWNoZVxyXG4gICAgcnVsZXNDYWNoZSA9IHJ1bGVzO1xyXG4gICAgcnVsZXNDYWNoZVRpbWVzdGFtcCA9IG10aW1lO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcnVsZXM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgYmFzZWxpbmUgcnVsZXMgZnJvbSAke3BhdGh9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBjYWNoZWQgYmFzZWxpbmUgcnVsZXMgd2l0aG91dCBmaWxlIHN5c3RlbSBhY2Nlc3NcclxuICogQHJldHVybnMgQ2FjaGVkIHJ1bGVzIG9yIHRocm93cyBpZiBub3QgbG9hZGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVkQmFzZWxpbmVSdWxlcygpOiBCYXNlbGluZVJ1bGVzIHtcclxuICBpZiAoIXJ1bGVzQ2FjaGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQmFzZWxpbmUgcnVsZXMgbm90IGxvYWRlZC4gQ2FsbCBsb2FkQmFzZWxpbmVSdWxlcygpIGZpcnN0LicpO1xyXG4gIH1cclxuICByZXR1cm4gcnVsZXNDYWNoZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFyIHRoZSBydWxlcyBjYWNoZSAodXNlZnVsIGZvciB0ZXN0aW5nKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyUnVsZXNDYWNoZSgpOiB2b2lkIHtcclxuICBydWxlc0NhY2hlID0gbnVsbDtcclxuICBydWxlc0NhY2hlVGltZXN0YW1wID0gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHJ1bGVzIGFyZSBjYWNoZWQgYW5kIHVwIHRvIGRhdGVcclxuICogQHBhcmFtIGNvbmZpZ1BhdGggT3B0aW9uYWwgcGF0aCB0byBjb25maWcgZmlsZVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGNhY2hlZCBydWxlcyBhcmUgdmFsaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1J1bGVzQ2FjaGVWYWxpZChjb25maWdQYXRoPzogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgaWYgKCFydWxlc0NhY2hlKSByZXR1cm4gZmFsc2U7XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGRlZmF1bHRQYXRoID0gam9pbihfX2Rpcm5hbWUsICcuLi8uLi9jb25maWcvYmFzZWxpbmUucnVsZXMueWFtbCcpO1xyXG4gICAgY29uc3QgcGF0aCA9IGNvbmZpZ1BhdGggfHwgZGVmYXVsdFBhdGg7XHJcbiAgICBjb25zdCBzdGF0cyA9IHJlcXVpcmUoJ2ZzJykuc3RhdFN5bmMocGF0aCk7XHJcbiAgICBjb25zdCBtdGltZSA9IHN0YXRzLm10aW1lLmdldFRpbWUoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG10aW1lIDw9IHJ1bGVzQ2FjaGVUaW1lc3RhbXA7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGRlZmF1bHQgYmFzZWxpbmUgcnVsZXMgKGZhbGxiYWNrIGlmIGZpbGUgbG9hZGluZyBmYWlscylcclxuICogQHJldHVybnMgTWluaW1hbCBkZWZhdWx0IHJ1bGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEJhc2VsaW5lUnVsZXMoKTogQmFzZWxpbmVSdWxlcyB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGxhbmd1YWdlX3J1bnRpbWVzOiB7XHJcbiAgICAgIG5vZGU6ICc+PTE4LjAuMCcsXHJcbiAgICAgIHB5dGhvbjogJz49My4xMC4wJyxcclxuICAgICAgamF2YTogJz49MTcuMC4wJyxcclxuICAgICAgZ286ICc+PTEuMjEuMCcsXHJcbiAgICAgIGRvdG5ldDogJz49Ni4wLjAnLFxyXG4gICAgfSxcclxuICAgIHBhY2thZ2VfbWluczoge1xyXG4gICAgICBub2RlOiB7XHJcbiAgICAgICAgcmVhY3Q6ICc+PTE4LjAuMCcsXHJcbiAgICAgICAgbmV4dDogJz49MTMuMC4wJyxcclxuICAgICAgICBleHByZXNzOiAnPj00LjE4LjAnLFxyXG4gICAgICB9LFxyXG4gICAgICBweXRob246IHtcclxuICAgICAgICBudW1weTogJz49MS4yMi4wJyxcclxuICAgICAgICBwYW5kYXM6ICc+PTEuNC4wJyxcclxuICAgICAgICB0b3JjaDogJz49Mi4wLjAnLFxyXG4gICAgICB9LFxyXG4gICAgICBqYXZhOiB7fSxcclxuICAgICAgZ286IHt9LFxyXG4gICAgICBkb3RuZXQ6IHt9LFxyXG4gICAgfSxcclxuICAgIGRlcHJlY2F0ZWRfcGF0dGVybnM6IHtcclxuICAgICAgbm9kZTogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIHBhdHRlcm46ICdmc1xcXFwuZXhpc3RzXFxcXCgnLFxyXG4gICAgICAgICAgbWVzc2FnZTogJ2ZzLmV4aXN0cygpIGlzIGRlcHJlY2F0ZWQsIHVzZSBmcy5hY2Nlc3MoKSBvciBmcy5zdGF0KCknLFxyXG4gICAgICAgICAgYWx0ZXJuYXRpdmU6ICdVc2UgZnMuYWNjZXNzKCkgb3IgZnMucHJvbWlzZXMuYWNjZXNzKCknLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIHB5dGhvbjogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIHBhdHRlcm46ICdudW1weVxcXFwuYXNzY2FsYXInLFxyXG4gICAgICAgICAgbWVzc2FnZTogJ251bXB5LmFzc2NhbGFyIGlzIGRlcHJlY2F0ZWQsIHVzZSBpdGVtKCkgaW5zdGVhZCcsXHJcbiAgICAgICAgICBhbHRlcm5hdGl2ZTogJ1VzZSBudW1weS5pdGVtKCkgb3IgZGlyZWN0IGFycmF5IGluZGV4aW5nJyxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBqYXZhOiBbXSxcclxuICAgICAgZ286IFtdLFxyXG4gICAgICBkb3RuZXQ6IFtdLFxyXG4gICAgfSxcclxuICAgIHNjYW5fZmlsZV9leHRzOiBbJy5weScsICcuanMnLCAnLnRzJywgJy50c3gnLCAnLmpzeCcsICcuamF2YScsICcuZ28nLCAnLmNzJ10sXHJcbiAgICBpZ25vcmVfcGF0aHM6IFsnL25vZGVfbW9kdWxlcy8nLCAnLy52ZW52LycsICcvdmVudi8nLCAnL2Rpc3QvJywgJy9idWlsZC8nLCAnLy5naXQvJ10sXHJcbiAgICBtYXhfZmlsZV9zaXplOiAyMDk3MTUyLCAvLyAyTUJcclxuICAgIG1heF9maWxlczogNTAwMDAsXHJcbiAgICBxdWlja19maXhlczoge1xyXG4gICAgICBkZXBlbmRlbmN5X3VwZ3JhZGU6IHtcclxuICAgICAgICBub2RlOiAnbnBtIGluc3RhbGwge3BhY2thZ2V9QHt2ZXJzaW9ufScsXHJcbiAgICAgICAgcHl0aG9uOiAncGlwIGluc3RhbGwgXFwne3BhY2thZ2V9Pj17dmVyc2lvbn1cXCcnLFxyXG4gICAgICAgIGphdmE6ICdVcGRhdGUge3BhY2thZ2V9IHRvIHZlcnNpb24ge3ZlcnNpb259IGluIHBvbS54bWwgb3IgYnVpbGQuZ3JhZGxlJyxcclxuICAgICAgICBnbzogJ2dvIGdldCB7cGFja2FnZX1Ae3ZlcnNpb259JyxcclxuICAgICAgICBkb3RuZXQ6ICdkb3RuZXQgYWRkIHBhY2thZ2Uge3BhY2thZ2V9IC0tdmVyc2lvbiB7dmVyc2lvbn0nLFxyXG4gICAgICB9LFxyXG4gICAgICBwYXR0ZXJuX3JlcGxhY2VtZW50OiB7XHJcbiAgICAgICAgbm9kZToge1xyXG4gICAgICAgICAgJ2ZzLmV4aXN0cygnOiAnVXNlIGZzLmFjY2VzcygpIG9yIGZzLnByb21pc2VzLmFjY2VzcygpJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB5dGhvbjoge1xyXG4gICAgICAgICAgJ251bXB5LmFzc2NhbGFyJzogJ1VzZSAuaXRlbSgpIG1ldGhvZCBpbnN0ZWFkJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGphdmE6IHt9LFxyXG4gICAgICAgIGdvOiB7fSxcclxuICAgICAgICBkb3RuZXQ6IHt9LFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZCBiYXNlbGluZSBydWxlcyB3aXRoIGZhbGxiYWNrIHRvIGRlZmF1bHRzXHJcbiAqIEBwYXJhbSBjb25maWdQYXRoIE9wdGlvbmFsIHBhdGggdG8gY29uZmlnIGZpbGVcclxuICogQHJldHVybnMgQmFzZWxpbmUgcnVsZXMgKGxvYWRlZCBvciBkZWZhdWx0KVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRCYXNlbGluZVJ1bGVzV2l0aEZhbGxiYWNrKGNvbmZpZ1BhdGg/OiBzdHJpbmcpOiBCYXNlbGluZVJ1bGVzIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGxvYWRCYXNlbGluZVJ1bGVzKGNvbmZpZ1BhdGgpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBsb2FkIGJhc2VsaW5lIHJ1bGVzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gICAgY29uc29sZS53YXJuKCdVc2luZyBkZWZhdWx0IGJhc2VsaW5lIHJ1bGVzJyk7XHJcbiAgICByZXR1cm4gZ2V0RGVmYXVsdEJhc2VsaW5lUnVsZXMoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSB0aGF0IGEgcnVsZXMgb2JqZWN0IGhhcyBhbGwgcmVxdWlyZWQgZmllbGRzXHJcbiAqIEBwYXJhbSBydWxlcyBSdWxlcyBvYmplY3QgdG8gdmFsaWRhdGVcclxuICogQHJldHVybnMgVHJ1ZSBpZiB2YWxpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUnVsZXNTdHJ1Y3R1cmUocnVsZXM6IGFueSk6IHJ1bGVzIGlzIEJhc2VsaW5lUnVsZXMge1xyXG4gIHRyeSB7XHJcbiAgICB2YWxpZGF0ZUJhc2VsaW5lUnVsZXMocnVsZXMpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHJ1bGVzIGZvciBhIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgdG8gZ2V0IHJ1bGVzIGZvclxyXG4gKiBAcmV0dXJucyBSdWxlcyBzcGVjaWZpYyB0byB0aGUgbGFuZ3VhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5ndWFnZVJ1bGVzKHJ1bGVzOiBCYXNlbGluZVJ1bGVzLCBsYW5ndWFnZToga2V5b2YgQmFzZWxpbmVSdWxlc1sncGFja2FnZV9taW5zJ10pIHtcclxuICByZXR1cm4ge1xyXG4gICAgcGFja2FnZU1pbnM6IHJ1bGVzLnBhY2thZ2VfbWluc1tsYW5ndWFnZV0gfHwge30sXHJcbiAgICBkZXByZWNhdGVkUGF0dGVybnM6IHJ1bGVzLmRlcHJlY2F0ZWRfcGF0dGVybnNbbGFuZ3VhZ2VdIHx8IFtdLFxyXG4gICAgcnVudGltZTogcnVsZXMubGFuZ3VhZ2VfcnVudGltZXNbbGFuZ3VhZ2VdLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGZpbGUgZXh0ZW5zaW9uIHNob3VsZCBiZSBzY2FubmVkXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gZXh0ZW5zaW9uIEZpbGUgZXh0ZW5zaW9uICh3aXRoIG9yIHdpdGhvdXQgZG90KVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHNob3VsZCBiZSBzY2FubmVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkU2NhbkZpbGUocnVsZXM6IEJhc2VsaW5lUnVsZXMsIGV4dGVuc2lvbjogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgZXh0ID0gZXh0ZW5zaW9uLnN0YXJ0c1dpdGgoJy4nKSA/IGV4dGVuc2lvbiA6IGAuJHtleHRlbnNpb259YDtcclxuICByZXR1cm4gcnVsZXMuc2Nhbl9maWxlX2V4dHMuaW5jbHVkZXMoZXh0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgcGF0aCBzaG91bGQgYmUgaWdub3JlZFxyXG4gKiBAcGFyYW0gcnVsZXMgQmFzZWxpbmUgcnVsZXNcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aCB0byBjaGVja1xyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHNob3VsZCBiZSBpZ25vcmVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkSWdub3JlUGF0aChydWxlczogQmFzZWxpbmVSdWxlcywgZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIGlmICghZmlsZVBhdGggfHwgIXJ1bGVzLmlnbm9yZV9wYXRocykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gcnVsZXMuaWdub3JlX3BhdGhzLnNvbWUoaWdub3JlUGF0aCA9PiBcclxuICAgIGZpbGVQYXRoLmluY2x1ZGVzKGlnbm9yZVBhdGgpIHx8IGZpbGVQYXRoLnN0YXJ0c1dpdGgoaWdub3JlUGF0aClcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHF1aWNrIGZpeCB0ZW1wbGF0ZSBmb3IgZGVwZW5kZW5jeSB1cGdyYWRlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2VcclxuICogQHJldHVybnMgVGVtcGxhdGUgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeVVwZ3JhZGVUZW1wbGF0ZShydWxlczogQmFzZWxpbmVSdWxlcywgbGFuZ3VhZ2U6IGtleW9mIEJhc2VsaW5lUnVsZXNbJ3F1aWNrX2ZpeGVzJ11bJ2RlcGVuZGVuY3lfdXBncmFkZSddKTogc3RyaW5nIHtcclxuICByZXR1cm4gcnVsZXMucXVpY2tfZml4ZXMuZGVwZW5kZW5jeV91cGdyYWRlW2xhbmd1YWdlXSB8fCAnVXBkYXRlIHtwYWNrYWdlfSB0byB7dmVyc2lvbn0nO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHF1aWNrIGZpeCBmb3IgcGF0dGVybiByZXBsYWNlbWVudFxyXG4gKiBAcGFyYW0gcnVsZXMgQmFzZWxpbmUgcnVsZXNcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXHJcbiAqIEBwYXJhbSBwYXR0ZXJuIFBhdHRlcm4gdG8gcmVwbGFjZVxyXG4gKiBAcmV0dXJucyBRdWljayBmaXggc3VnZ2VzdGlvbiBvciB1bmRlZmluZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXR0ZXJuUXVpY2tGaXgoXHJcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXMsIFxyXG4gIGxhbmd1YWdlOiBrZXlvZiBCYXNlbGluZVJ1bGVzWydxdWlja19maXhlcyddWydwYXR0ZXJuX3JlcGxhY2VtZW50J10sIFxyXG4gIHBhdHRlcm46IHN0cmluZ1xyXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gIHJldHVybiBydWxlcy5xdWlja19maXhlcy5wYXR0ZXJuX3JlcGxhY2VtZW50W2xhbmd1YWdlXT8uW3BhdHRlcm5dO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJyZWFkRmlsZVN5bmMiLCJqb2luIiwiZGlybmFtZSIsImZpbGVVUkxUb1BhdGgiLCJZQU1MIiwidmFsaWRhdGVCYXNlbGluZVJ1bGVzIiwiX19maWxlbmFtZSIsInVybCIsIl9fZGlybmFtZSIsInJ1bGVzQ2FjaGUiLCJydWxlc0NhY2hlVGltZXN0YW1wIiwibG9hZEJhc2VsaW5lUnVsZXMiLCJjb25maWdQYXRoIiwiZGVmYXVsdFBhdGgiLCJwYXRoIiwic3RhdHMiLCJyZXF1aXJlIiwic3RhdFN5bmMiLCJtdGltZSIsImdldFRpbWUiLCJ5YW1sQ29udGVudCIsInJhd1J1bGVzIiwicGFyc2UiLCJydWxlcyIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiZ2V0Q2FjaGVkQmFzZWxpbmVSdWxlcyIsImNsZWFyUnVsZXNDYWNoZSIsImlzUnVsZXNDYWNoZVZhbGlkIiwiZ2V0RGVmYXVsdEJhc2VsaW5lUnVsZXMiLCJsYW5ndWFnZV9ydW50aW1lcyIsIm5vZGUiLCJweXRob24iLCJqYXZhIiwiZ28iLCJkb3RuZXQiLCJwYWNrYWdlX21pbnMiLCJyZWFjdCIsIm5leHQiLCJleHByZXNzIiwibnVtcHkiLCJwYW5kYXMiLCJ0b3JjaCIsImRlcHJlY2F0ZWRfcGF0dGVybnMiLCJwYXR0ZXJuIiwiYWx0ZXJuYXRpdmUiLCJzY2FuX2ZpbGVfZXh0cyIsImlnbm9yZV9wYXRocyIsIm1heF9maWxlX3NpemUiLCJtYXhfZmlsZXMiLCJxdWlja19maXhlcyIsImRlcGVuZGVuY3lfdXBncmFkZSIsInBhdHRlcm5fcmVwbGFjZW1lbnQiLCJsb2FkQmFzZWxpbmVSdWxlc1dpdGhGYWxsYmFjayIsImNvbnNvbGUiLCJ3YXJuIiwidmFsaWRhdGVSdWxlc1N0cnVjdHVyZSIsImdldExhbmd1YWdlUnVsZXMiLCJsYW5ndWFnZSIsInBhY2thZ2VNaW5zIiwiZGVwcmVjYXRlZFBhdHRlcm5zIiwicnVudGltZSIsInNob3VsZFNjYW5GaWxlIiwiZXh0ZW5zaW9uIiwiZXh0Iiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwic2hvdWxkSWdub3JlUGF0aCIsImZpbGVQYXRoIiwic29tZSIsImlnbm9yZVBhdGgiLCJnZXREZXBlbmRlbmN5VXBncmFkZVRlbXBsYXRlIiwiZ2V0UGF0dGVyblF1aWNrRml4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./lib/analysis/baseline.loader.ts\n");

/***/ }),

/***/ "(api-node)/./lib/analysis/baseline.types.ts":
/*!****************************************!*\
  !*** ./lib/analysis/baseline.types.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalysisContextSchema: () => (/* binding */ AnalysisContextSchema),\n/* harmony export */   AnalysisErrorSchema: () => (/* binding */ AnalysisErrorSchema),\n/* harmony export */   AnalyzeResponseSchema: () => (/* binding */ AnalyzeResponseSchema),\n/* harmony export */   BaselineRulesSchema: () => (/* binding */ BaselineRulesSchema),\n/* harmony export */   DependencyFindingSchema: () => (/* binding */ DependencyFindingSchema),\n/* harmony export */   DeprecatedPatternSchema: () => (/* binding */ DeprecatedPatternSchema),\n/* harmony export */   ExtractedFileSchema: () => (/* binding */ ExtractedFileSchema),\n/* harmony export */   FindingSchema: () => (/* binding */ FindingSchema),\n/* harmony export */   LanguageRuntimesSchema: () => (/* binding */ LanguageRuntimesSchema),\n/* harmony export */   LanguageSchema: () => (/* binding */ LanguageSchema),\n/* harmony export */   LanguageSummarySchema: () => (/* binding */ LanguageSummarySchema),\n/* harmony export */   PackageMinsSchema: () => (/* binding */ PackageMinsSchema),\n/* harmony export */   PatternFindingSchema: () => (/* binding */ PatternFindingSchema),\n/* harmony export */   ProjectManifestSchema: () => (/* binding */ ProjectManifestSchema),\n/* harmony export */   QuickFixesSchema: () => (/* binding */ QuickFixesSchema),\n/* harmony export */   ReportSchema: () => (/* binding */ ReportSchema),\n/* harmony export */   ReportSummarySchema: () => (/* binding */ ReportSummarySchema),\n/* harmony export */   StatusSchema: () => (/* binding */ StatusSchema),\n/* harmony export */   getStatusBadgeClass: () => (/* binding */ getStatusBadgeClass),\n/* harmony export */   getStatusColor: () => (/* binding */ getStatusColor),\n/* harmony export */   getStatusIcon: () => (/* binding */ getStatusIcon),\n/* harmony export */   isDependencyFinding: () => (/* binding */ isDependencyFinding),\n/* harmony export */   isPatternFinding: () => (/* binding */ isPatternFinding),\n/* harmony export */   validateAnalyzeResponse: () => (/* binding */ validateAnalyzeResponse),\n/* harmony export */   validateBaselineRules: () => (/* binding */ validateBaselineRules),\n/* harmony export */   validateFinding: () => (/* binding */ validateFinding),\n/* harmony export */   validateReport: () => (/* binding */ validateReport)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"zod\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([zod__WEBPACK_IMPORTED_MODULE_0__]);\nzod__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n// Language types\nconst LanguageSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.enum([\n    'python',\n    'node',\n    'java',\n    'go',\n    'dotnet'\n]);\n// Status types\nconst StatusSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.enum([\n    'ok',\n    'affected',\n    'unknown'\n]);\n// Finding types\nconst DependencyFindingSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    kind: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('dependency'),\n    lang: LanguageSchema,\n    component: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    foundVersion: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),\n    baselineRequired: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),\n    status: StatusSchema,\n    reason: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    file: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    quickFix: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().optional()\n});\nconst PatternFindingSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    kind: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('pattern'),\n    lang: LanguageSchema,\n    file: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    line: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    status: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('affected'),\n    reason: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal('deprecated-api'),\n    issue: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    pattern: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    quickFix: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().optional()\n});\nconst FindingSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.discriminatedUnion('kind', [\n    DependencyFindingSchema,\n    PatternFindingSchema\n]);\n// Summary types\nconst LanguageSummarySchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    ok: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    affected: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    unknown: zod__WEBPACK_IMPORTED_MODULE_0__.z.number()\n});\nconst ReportSummarySchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    ok: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    affected: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    unknown: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    byLanguage: zod__WEBPACK_IMPORTED_MODULE_0__.z.record(LanguageSchema, LanguageSummarySchema)\n});\n// Report type\nconst ReportSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    findings: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(FindingSchema),\n    summary: ReportSummarySchema,\n    metadata: zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n        analysisId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n        timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n        projectName: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().optional(),\n        detectedLanguages: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LanguageSchema),\n        totalFiles: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n        scannedFiles: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n        skippedFiles: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n        groqAnalysis: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n            analysis: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n            filename: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n            timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()\n        })).optional()\n    })\n});\n// Rules configuration types\nconst DeprecatedPatternSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    pattern: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    message: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    alternative: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()\n});\nconst PackageMinsSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.z.record(zod__WEBPACK_IMPORTED_MODULE_0__.z.string(), zod__WEBPACK_IMPORTED_MODULE_0__.z.string()));\nconst LanguageRuntimesSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.z.string());\nconst QuickFixesSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    dependency_upgrade: zod__WEBPACK_IMPORTED_MODULE_0__.z.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.z.string()),\n    pattern_replacement: zod__WEBPACK_IMPORTED_MODULE_0__.z.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.z.record(zod__WEBPACK_IMPORTED_MODULE_0__.z.string(), zod__WEBPACK_IMPORTED_MODULE_0__.z.string()))\n});\nconst BaselineRulesSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    language_runtimes: LanguageRuntimesSchema,\n    package_mins: PackageMinsSchema,\n    deprecated_patterns: zod__WEBPACK_IMPORTED_MODULE_0__.z.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.z.array(DeprecatedPatternSchema)),\n    scan_file_exts: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.string()),\n    ignore_paths: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.string()),\n    max_file_size: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    max_files: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    quick_fixes: QuickFixesSchema\n});\n// API types\nconst AnalyzeResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    analysisId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    summary: ReportSummarySchema,\n    artifacts: zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n        jsonUrl: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n        csvUrl: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()\n    }),\n    report: ReportSchema.optional()\n});\n// Project detection types\nconst ProjectManifestSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    language: LanguageSchema,\n    file: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    dependencies: zod__WEBPACK_IMPORTED_MODULE_0__.z.record(zod__WEBPACK_IMPORTED_MODULE_0__.z.string(), zod__WEBPACK_IMPORTED_MODULE_0__.z.string()).optional(),\n    devDependencies: zod__WEBPACK_IMPORTED_MODULE_0__.z.record(zod__WEBPACK_IMPORTED_MODULE_0__.z.string(), zod__WEBPACK_IMPORTED_MODULE_0__.z.string()).optional(),\n    peerDependencies: zod__WEBPACK_IMPORTED_MODULE_0__.z.record(zod__WEBPACK_IMPORTED_MODULE_0__.z.string(), zod__WEBPACK_IMPORTED_MODULE_0__.z.string()).optional(),\n    optionalDependencies: zod__WEBPACK_IMPORTED_MODULE_0__.z.record(zod__WEBPACK_IMPORTED_MODULE_0__.z.string(), zod__WEBPACK_IMPORTED_MODULE_0__.z.string()).optional()\n});\n// File processing types\nconst ExtractedFileSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    path: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    content: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    size: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    language: LanguageSchema.optional()\n});\n// Analysis context types\nconst AnalysisContextSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    rules: BaselineRulesSchema,\n    extractedFiles: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(ExtractedFileSchema),\n    manifests: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(ProjectManifestSchema),\n    detectedLanguages: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(LanguageSchema)\n});\n// Error types\nconst AnalysisErrorSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    code: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    message: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    details: zod__WEBPACK_IMPORTED_MODULE_0__.z.any().optional()\n});\n// Validation helpers\nfunction validateFinding(finding) {\n    return FindingSchema.parse(finding);\n}\nfunction validateReport(report) {\n    return ReportSchema.parse(report);\n}\nfunction validateBaselineRules(rules) {\n    return BaselineRulesSchema.parse(rules);\n}\nfunction validateAnalyzeResponse(response) {\n    return AnalyzeResponseSchema.parse(response);\n}\n// Type guards\nfunction isDependencyFinding(finding) {\n    return finding.kind === 'dependency';\n}\nfunction isPatternFinding(finding) {\n    return finding.kind === 'pattern';\n}\n// Status helpers\nfunction getStatusIcon(status) {\n    switch(status){\n        case 'ok':\n            return '✅';\n        case 'affected':\n            return '⚠️';\n        case 'unknown':\n            return '❓';\n        default:\n            return '❓';\n    }\n}\nfunction getStatusColor(status) {\n    switch(status){\n        case 'ok':\n            return 'text-green-600';\n        case 'affected':\n            return 'text-yellow-600';\n        case 'unknown':\n            return 'text-gray-600';\n        default:\n            return 'text-gray-600';\n    }\n}\nfunction getStatusBadgeClass(status) {\n    switch(status){\n        case 'ok':\n            return 'bg-green-100 text-green-800';\n        case 'affected':\n            return 'bg-yellow-100 text-yellow-800';\n        case 'unknown':\n            return 'bg-gray-100 text-gray-800';\n        default:\n            return 'bg-gray-100 text-gray-800';\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL2xpYi9hbmFseXNpcy9iYXNlbGluZS50eXBlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdCO0FBRXhCLGlCQUFpQjtBQUNWLE1BQU1DLGlCQUFpQkQsa0NBQUNBLENBQUNFLElBQUksQ0FBQztJQUFDO0lBQVU7SUFBUTtJQUFRO0lBQU07Q0FBUyxFQUFFO0FBR2pGLGVBQWU7QUFDUixNQUFNQyxlQUFlSCxrQ0FBQ0EsQ0FBQ0UsSUFBSSxDQUFDO0lBQUM7SUFBTTtJQUFZO0NBQVUsRUFBRTtBQUdsRSxnQkFBZ0I7QUFDVCxNQUFNRSwwQkFBMEJKLGtDQUFDQSxDQUFDSyxNQUFNLENBQUM7SUFDOUNDLE1BQU1OLGtDQUFDQSxDQUFDTyxPQUFPLENBQUM7SUFDaEJDLE1BQU1QO0lBQ05RLFdBQVdULGtDQUFDQSxDQUFDVSxNQUFNO0lBQ25CQyxjQUFjWCxrQ0FBQ0EsQ0FBQ1UsTUFBTSxHQUFHRSxRQUFRO0lBQ2pDQyxrQkFBa0JiLGtDQUFDQSxDQUFDVSxNQUFNLEdBQUdFLFFBQVE7SUFDckNFLFFBQVFYO0lBQ1JZLFFBQVFmLGtDQUFDQSxDQUFDVSxNQUFNO0lBQ2hCTSxNQUFNaEIsa0NBQUNBLENBQUNVLE1BQU07SUFDZE8sVUFBVWpCLGtDQUFDQSxDQUFDVSxNQUFNLEdBQUdRLFFBQVE7QUFDL0IsR0FBRztBQUVJLE1BQU1DLHVCQUF1Qm5CLGtDQUFDQSxDQUFDSyxNQUFNLENBQUM7SUFDM0NDLE1BQU1OLGtDQUFDQSxDQUFDTyxPQUFPLENBQUM7SUFDaEJDLE1BQU1QO0lBQ05lLE1BQU1oQixrQ0FBQ0EsQ0FBQ1UsTUFBTTtJQUNkVSxNQUFNcEIsa0NBQUNBLENBQUNxQixNQUFNO0lBQ2RQLFFBQVFkLGtDQUFDQSxDQUFDTyxPQUFPLENBQUM7SUFDbEJRLFFBQVFmLGtDQUFDQSxDQUFDTyxPQUFPLENBQUM7SUFDbEJlLE9BQU90QixrQ0FBQ0EsQ0FBQ1UsTUFBTTtJQUNmYSxTQUFT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O0FBRU8sU0FBU1ksd0JBQXdCQyxRQUFpQjtJQUN2RCxPQUFPN0Isc0JBQXNCeUIsS0FBSyxDQUFDSTtBQUNyQztBQUVBLGNBQWM7QUFDUCxTQUFTQyxvQkFBb0JOLE9BQWdCO0lBQ2xELE9BQU9BLFFBQVFuRixJQUFJLEtBQUs7QUFDMUI7QUFFTyxTQUFTMEYsaUJBQWlCUCxPQUFnQjtJQUMvQyxPQUFPQSxRQUFRbkYsSUFBSSxLQUFLO0FBQzFCO0FBRUEsaUJBQWlCO0FBQ1YsU0FBUzJGLGNBQWNuRixNQUFjO0lBQzFDLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1Q7WUFDRSxPQUFPO0lBQ1g7QUFDRjtBQUVPLFNBQVNvRixlQUFlcEYsTUFBYztJQUMzQyxPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTztJQUNYO0FBQ0Y7QUFFTyxTQUFTcUYsb0JBQW9CckYsTUFBYztJQUNoRCxPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTztJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcYW5hbHlzaXNcXGJhc2VsaW5lLnR5cGVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xyXG5cclxuLy8gTGFuZ3VhZ2UgdHlwZXNcclxuZXhwb3J0IGNvbnN0IExhbmd1YWdlU2NoZW1hID0gei5lbnVtKFsncHl0aG9uJywgJ25vZGUnLCAnamF2YScsICdnbycsICdkb3RuZXQnXSk7XHJcbmV4cG9ydCB0eXBlIExhbmd1YWdlID0gei5pbmZlcjx0eXBlb2YgTGFuZ3VhZ2VTY2hlbWE+O1xyXG5cclxuLy8gU3RhdHVzIHR5cGVzXHJcbmV4cG9ydCBjb25zdCBTdGF0dXNTY2hlbWEgPSB6LmVudW0oWydvaycsICdhZmZlY3RlZCcsICd1bmtub3duJ10pO1xyXG5leHBvcnQgdHlwZSBTdGF0dXMgPSB6LmluZmVyPHR5cGVvZiBTdGF0dXNTY2hlbWE+O1xyXG5cclxuLy8gRmluZGluZyB0eXBlc1xyXG5leHBvcnQgY29uc3QgRGVwZW5kZW5jeUZpbmRpbmdTY2hlbWEgPSB6Lm9iamVjdCh7XHJcbiAga2luZDogei5saXRlcmFsKCdkZXBlbmRlbmN5JyksXHJcbiAgbGFuZzogTGFuZ3VhZ2VTY2hlbWEsXHJcbiAgY29tcG9uZW50OiB6LnN0cmluZygpLFxyXG4gIGZvdW5kVmVyc2lvbjogei5zdHJpbmcoKS5udWxsYWJsZSgpLFxyXG4gIGJhc2VsaW5lUmVxdWlyZWQ6IHouc3RyaW5nKCkubnVsbGFibGUoKSxcclxuICBzdGF0dXM6IFN0YXR1c1NjaGVtYSxcclxuICByZWFzb246IHouc3RyaW5nKCksXHJcbiAgZmlsZTogei5zdHJpbmcoKSxcclxuICBxdWlja0ZpeDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxyXG59KTtcclxuXHJcbmV4cG9ydCBjb25zdCBQYXR0ZXJuRmluZGluZ1NjaGVtYSA9IHoub2JqZWN0KHtcclxuICBraW5kOiB6LmxpdGVyYWwoJ3BhdHRlcm4nKSxcclxuICBsYW5nOiBMYW5ndWFnZVNjaGVtYSxcclxuICBmaWxlOiB6LnN0cmluZygpLFxyXG4gIGxpbmU6IHoubnVtYmVyKCksXHJcbiAgc3RhdHVzOiB6LmxpdGVyYWwoJ2FmZmVjdGVkJyksXHJcbiAgcmVhc29uOiB6LmxpdGVyYWwoJ2RlcHJlY2F0ZWQtYXBpJyksXHJcbiAgaXNzdWU6IHouc3RyaW5nKCksXHJcbiAgcGF0dGVybjogei5zdHJpbmcoKSxcclxuICBxdWlja0ZpeDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxyXG59KTtcclxuXHJcbmV4cG9ydCBjb25zdCBGaW5kaW5nU2NoZW1hID0gei5kaXNjcmltaW5hdGVkVW5pb24oJ2tpbmQnLCBbXHJcbiAgRGVwZW5kZW5jeUZpbmRpbmdTY2hlbWEsXHJcbiAgUGF0dGVybkZpbmRpbmdTY2hlbWEsXHJcbl0pO1xyXG5cclxuZXhwb3J0IHR5cGUgRGVwZW5kZW5jeUZpbmRpbmcgPSB6LmluZmVyPHR5cGVvZiBEZXBlbmRlbmN5RmluZGluZ1NjaGVtYT47XHJcbmV4cG9ydCB0eXBlIFBhdHRlcm5GaW5kaW5nID0gei5pbmZlcjx0eXBlb2YgUGF0dGVybkZpbmRpbmdTY2hlbWE+O1xyXG5leHBvcnQgdHlwZSBGaW5kaW5nID0gei5pbmZlcjx0eXBlb2YgRmluZGluZ1NjaGVtYT47XHJcblxyXG4vLyBTdW1tYXJ5IHR5cGVzXHJcbmV4cG9ydCBjb25zdCBMYW5ndWFnZVN1bW1hcnlTY2hlbWEgPSB6Lm9iamVjdCh7XHJcbiAgb2s6IHoubnVtYmVyKCksXHJcbiAgYWZmZWN0ZWQ6IHoubnVtYmVyKCksXHJcbiAgdW5rbm93bjogei5udW1iZXIoKSxcclxufSk7XHJcblxyXG5leHBvcnQgY29uc3QgUmVwb3J0U3VtbWFyeVNjaGVtYSA9IHoub2JqZWN0KHtcclxuICBvazogei5udW1iZXIoKSxcclxuICBhZmZlY3RlZDogei5udW1iZXIoKSxcclxuICB1bmtub3duOiB6Lm51bWJlcigpLFxyXG4gIGJ5TGFuZ3VhZ2U6IHoucmVjb3JkKExhbmd1YWdlU2NoZW1hLCBMYW5ndWFnZVN1bW1hcnlTY2hlbWEpLFxyXG59KTtcclxuXHJcbi8vIFJlcG9ydCB0eXBlXHJcbmV4cG9ydCBjb25zdCBSZXBvcnRTY2hlbWEgPSB6Lm9iamVjdCh7XHJcbiAgZmluZGluZ3M6IHouYXJyYXkoRmluZGluZ1NjaGVtYSksXHJcbiAgc3VtbWFyeTogUmVwb3J0U3VtbWFyeVNjaGVtYSxcclxuICBtZXRhZGF0YTogei5vYmplY3Qoe1xyXG4gICAgYW5hbHlzaXNJZDogei5zdHJpbmcoKSxcclxuICAgIHRpbWVzdGFtcDogei5zdHJpbmcoKSxcclxuICAgIHByb2plY3ROYW1lOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXHJcbiAgICBkZXRlY3RlZExhbmd1YWdlczogei5hcnJheShMYW5ndWFnZVNjaGVtYSksXHJcbiAgICB0b3RhbEZpbGVzOiB6Lm51bWJlcigpLFxyXG4gICAgc2Nhbm5lZEZpbGVzOiB6Lm51bWJlcigpLFxyXG4gICAgc2tpcHBlZEZpbGVzOiB6Lm51bWJlcigpLFxyXG4gICAgZ3JvcUFuYWx5c2lzOiB6LmFycmF5KHoub2JqZWN0KHtcclxuICAgICAgYW5hbHlzaXM6IHouc3RyaW5nKCksXHJcbiAgICAgIGZpbGVuYW1lOiB6LnN0cmluZygpLFxyXG4gICAgICB0aW1lc3RhbXA6IHouc3RyaW5nKCksXHJcbiAgICB9KSkub3B0aW9uYWwoKSxcclxuICB9KSxcclxufSk7XHJcblxyXG5leHBvcnQgdHlwZSBMYW5ndWFnZVN1bW1hcnkgPSB6LmluZmVyPHR5cGVvZiBMYW5ndWFnZVN1bW1hcnlTY2hlbWE+O1xyXG5leHBvcnQgdHlwZSBSZXBvcnRTdW1tYXJ5ID0gei5pbmZlcjx0eXBlb2YgUmVwb3J0U3VtbWFyeVNjaGVtYT47XHJcbmV4cG9ydCB0eXBlIFJlcG9ydCA9IHouaW5mZXI8dHlwZW9mIFJlcG9ydFNjaGVtYT47XHJcblxyXG4vLyBSdWxlcyBjb25maWd1cmF0aW9uIHR5cGVzXHJcbmV4cG9ydCBjb25zdCBEZXByZWNhdGVkUGF0dGVyblNjaGVtYSA9IHoub2JqZWN0KHtcclxuICBwYXR0ZXJuOiB6LnN0cmluZygpLFxyXG4gIG1lc3NhZ2U6IHouc3RyaW5nKCksXHJcbiAgYWx0ZXJuYXRpdmU6IHouc3RyaW5nKCksXHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IFBhY2thZ2VNaW5zU2NoZW1hID0gei5yZWNvcmQoTGFuZ3VhZ2VTY2hlbWEsIHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpKTtcclxuXHJcbmV4cG9ydCBjb25zdCBMYW5ndWFnZVJ1bnRpbWVzU2NoZW1hID0gei5yZWNvcmQoTGFuZ3VhZ2VTY2hlbWEsIHouc3RyaW5nKCkpO1xyXG5cclxuZXhwb3J0IGNvbnN0IFF1aWNrRml4ZXNTY2hlbWEgPSB6Lm9iamVjdCh7XHJcbiAgZGVwZW5kZW5jeV91cGdyYWRlOiB6LnJlY29yZChMYW5ndWFnZVNjaGVtYSwgei5zdHJpbmcoKSksXHJcbiAgcGF0dGVybl9yZXBsYWNlbWVudDogei5yZWNvcmQoTGFuZ3VhZ2VTY2hlbWEsIHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpKSxcclxufSk7XHJcblxyXG5leHBvcnQgY29uc3QgQmFzZWxpbmVSdWxlc1NjaGVtYSA9IHoub2JqZWN0KHtcclxuICBsYW5ndWFnZV9ydW50aW1lczogTGFuZ3VhZ2VSdW50aW1lc1NjaGVtYSxcclxuICBwYWNrYWdlX21pbnM6IFBhY2thZ2VNaW5zU2NoZW1hLFxyXG4gIGRlcHJlY2F0ZWRfcGF0dGVybnM6IHoucmVjb3JkKExhbmd1YWdlU2NoZW1hLCB6LmFycmF5KERlcHJlY2F0ZWRQYXR0ZXJuU2NoZW1hKSksXHJcbiAgc2Nhbl9maWxlX2V4dHM6IHouYXJyYXkoei5zdHJpbmcoKSksXHJcbiAgaWdub3JlX3BhdGhzOiB6LmFycmF5KHouc3RyaW5nKCkpLFxyXG4gIG1heF9maWxlX3NpemU6IHoubnVtYmVyKCksXHJcbiAgbWF4X2ZpbGVzOiB6Lm51bWJlcigpLFxyXG4gIHF1aWNrX2ZpeGVzOiBRdWlja0ZpeGVzU2NoZW1hLFxyXG59KTtcclxuXHJcbmV4cG9ydCB0eXBlIERlcHJlY2F0ZWRQYXR0ZXJuID0gei5pbmZlcjx0eXBlb2YgRGVwcmVjYXRlZFBhdHRlcm5TY2hlbWE+O1xyXG5leHBvcnQgdHlwZSBQYWNrYWdlTWlucyA9IHouaW5mZXI8dHlwZW9mIFBhY2thZ2VNaW5zU2NoZW1hPjtcclxuZXhwb3J0IHR5cGUgTGFuZ3VhZ2VSdW50aW1lcyA9IHouaW5mZXI8dHlwZW9mIExhbmd1YWdlUnVudGltZXNTY2hlbWE+O1xyXG5leHBvcnQgdHlwZSBRdWlja0ZpeGVzID0gei5pbmZlcjx0eXBlb2YgUXVpY2tGaXhlc1NjaGVtYT47XHJcbmV4cG9ydCB0eXBlIEJhc2VsaW5lUnVsZXMgPSB6LmluZmVyPHR5cGVvZiBCYXNlbGluZVJ1bGVzU2NoZW1hPjtcclxuXHJcbi8vIEFQSSB0eXBlc1xyXG5leHBvcnQgY29uc3QgQW5hbHl6ZVJlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xyXG4gIGFuYWx5c2lzSWQ6IHouc3RyaW5nKCksXHJcbiAgc3VtbWFyeTogUmVwb3J0U3VtbWFyeVNjaGVtYSxcclxuICBhcnRpZmFjdHM6IHoub2JqZWN0KHtcclxuICAgIGpzb25Vcmw6IHouc3RyaW5nKCksXHJcbiAgICBjc3ZVcmw6IHouc3RyaW5nKCksXHJcbiAgfSksXHJcbiAgcmVwb3J0OiBSZXBvcnRTY2hlbWEub3B0aW9uYWwoKSxcclxufSk7XHJcblxyXG5leHBvcnQgdHlwZSBBbmFseXplUmVzcG9uc2UgPSB6LmluZmVyPHR5cGVvZiBBbmFseXplUmVzcG9uc2VTY2hlbWE+O1xyXG5cclxuLy8gUHJvamVjdCBkZXRlY3Rpb24gdHlwZXNcclxuZXhwb3J0IGNvbnN0IFByb2plY3RNYW5pZmVzdFNjaGVtYSA9IHoub2JqZWN0KHtcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2VTY2hlbWEsXHJcbiAgZmlsZTogei5zdHJpbmcoKSxcclxuICBkZXBlbmRlbmNpZXM6IHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpLm9wdGlvbmFsKCksXHJcbiAgZGV2RGVwZW5kZW5jaWVzOiB6LnJlY29yZCh6LnN0cmluZygpLCB6LnN0cmluZygpKS5vcHRpb25hbCgpLFxyXG4gIHBlZXJEZXBlbmRlbmNpZXM6IHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpLm9wdGlvbmFsKCksXHJcbiAgb3B0aW9uYWxEZXBlbmRlbmNpZXM6IHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpLm9wdGlvbmFsKCksXHJcbn0pO1xyXG5cclxuZXhwb3J0IHR5cGUgUHJvamVjdE1hbmlmZXN0ID0gei5pbmZlcjx0eXBlb2YgUHJvamVjdE1hbmlmZXN0U2NoZW1hPjtcclxuXHJcbi8vIEZpbGUgcHJvY2Vzc2luZyB0eXBlc1xyXG5leHBvcnQgY29uc3QgRXh0cmFjdGVkRmlsZVNjaGVtYSA9IHoub2JqZWN0KHtcclxuICBwYXRoOiB6LnN0cmluZygpLFxyXG4gIGNvbnRlbnQ6IHouc3RyaW5nKCksXHJcbiAgc2l6ZTogei5udW1iZXIoKSxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2VTY2hlbWEub3B0aW9uYWwoKSxcclxufSk7XHJcblxyXG5leHBvcnQgdHlwZSBFeHRyYWN0ZWRGaWxlID0gei5pbmZlcjx0eXBlb2YgRXh0cmFjdGVkRmlsZVNjaGVtYT47XHJcblxyXG4vLyBBbmFseXNpcyBjb250ZXh0IHR5cGVzXHJcbmV4cG9ydCBjb25zdCBBbmFseXNpc0NvbnRleHRTY2hlbWEgPSB6Lm9iamVjdCh7XHJcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNTY2hlbWEsXHJcbiAgZXh0cmFjdGVkRmlsZXM6IHouYXJyYXkoRXh0cmFjdGVkRmlsZVNjaGVtYSksXHJcbiAgbWFuaWZlc3RzOiB6LmFycmF5KFByb2plY3RNYW5pZmVzdFNjaGVtYSksXHJcbiAgZGV0ZWN0ZWRMYW5ndWFnZXM6IHouYXJyYXkoTGFuZ3VhZ2VTY2hlbWEpLFxyXG59KTtcclxuXHJcbmV4cG9ydCB0eXBlIEFuYWx5c2lzQ29udGV4dCA9IHouaW5mZXI8dHlwZW9mIEFuYWx5c2lzQ29udGV4dFNjaGVtYT47XHJcblxyXG4vLyBFcnJvciB0eXBlc1xyXG5leHBvcnQgY29uc3QgQW5hbHlzaXNFcnJvclNjaGVtYSA9IHoub2JqZWN0KHtcclxuICBjb2RlOiB6LnN0cmluZygpLFxyXG4gIG1lc3NhZ2U6IHouc3RyaW5nKCksXHJcbiAgZGV0YWlsczogei5hbnkoKS5vcHRpb25hbCgpLFxyXG59KTtcclxuXHJcbmV4cG9ydCB0eXBlIEFuYWx5c2lzRXJyb3IgPSB6LmluZmVyPHR5cGVvZiBBbmFseXNpc0Vycm9yU2NoZW1hPjtcclxuXHJcbi8vIFV0aWxpdHkgdHlwZXMgZm9yIFVJXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmlsdGVyT3B0aW9ucyB7XHJcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZTtcclxuICBzdGF0dXM/OiBTdGF0dXM7XHJcbiAgc2VhcmNoVGV4dD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTb3J0T3B0aW9ucyB7XHJcbiAgZmllbGQ6ICdjb21wb25lbnQnIHwgJ2ZpbGUnIHwgJ3N0YXR1cycgfCAncmVhc29uJztcclxuICBkaXJlY3Rpb246ICdhc2MnIHwgJ2Rlc2MnO1xyXG59XHJcblxyXG4vLyBDU1YgZXhwb3J0IHR5cGVzXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ1NWUm93IHtcclxuICBLaW5kOiBzdHJpbmc7XHJcbiAgTGFuZ3VhZ2U6IHN0cmluZztcclxuICBDb21wb25lbnQ6IHN0cmluZztcclxuICBGaWxlOiBzdHJpbmc7XHJcbiAgTGluZTogc3RyaW5nO1xyXG4gIFN0YXR1czogc3RyaW5nO1xyXG4gIFJlYXNvbjogc3RyaW5nO1xyXG4gICdRdWljayBGaXgnOiBzdHJpbmc7XHJcbiAgJ0ZvdW5kIFZlcnNpb24nOiBzdHJpbmc7XHJcbiAgJ1JlcXVpcmVkIFZlcnNpb24nOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8vIFZhbGlkYXRpb24gaGVscGVyc1xyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaW5kaW5nKGZpbmRpbmc6IHVua25vd24pOiBGaW5kaW5nIHtcclxuICByZXR1cm4gRmluZGluZ1NjaGVtYS5wYXJzZShmaW5kaW5nKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVwb3J0KHJlcG9ydDogdW5rbm93bik6IFJlcG9ydCB7XHJcbiAgcmV0dXJuIFJlcG9ydFNjaGVtYS5wYXJzZShyZXBvcnQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNlbGluZVJ1bGVzKHJ1bGVzOiB1bmtub3duKTogQmFzZWxpbmVSdWxlcyB7XHJcbiAgcmV0dXJuIEJhc2VsaW5lUnVsZXNTY2hlbWEucGFyc2UocnVsZXMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBbmFseXplUmVzcG9uc2UocmVzcG9uc2U6IHVua25vd24pOiBBbmFseXplUmVzcG9uc2Uge1xyXG4gIHJldHVybiBBbmFseXplUmVzcG9uc2VTY2hlbWEucGFyc2UocmVzcG9uc2UpO1xyXG59XHJcblxyXG4vLyBUeXBlIGd1YXJkc1xyXG5leHBvcnQgZnVuY3Rpb24gaXNEZXBlbmRlbmN5RmluZGluZyhmaW5kaW5nOiBGaW5kaW5nKTogZmluZGluZyBpcyBEZXBlbmRlbmN5RmluZGluZyB7XHJcbiAgcmV0dXJuIGZpbmRpbmcua2luZCA9PT0gJ2RlcGVuZGVuY3knO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNQYXR0ZXJuRmluZGluZyhmaW5kaW5nOiBGaW5kaW5nKTogZmluZGluZyBpcyBQYXR0ZXJuRmluZGluZyB7XHJcbiAgcmV0dXJuIGZpbmRpbmcua2luZCA9PT0gJ3BhdHRlcm4nO1xyXG59XHJcblxyXG4vLyBTdGF0dXMgaGVscGVyc1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdHVzSWNvbihzdGF0dXM6IFN0YXR1cyk6IHN0cmluZyB7XHJcbiAgc3dpdGNoIChzdGF0dXMpIHtcclxuICAgIGNhc2UgJ29rJzpcclxuICAgICAgcmV0dXJuICfinIUnO1xyXG4gICAgY2FzZSAnYWZmZWN0ZWQnOlxyXG4gICAgICByZXR1cm4gJ+KaoO+4jyc7XHJcbiAgICBjYXNlICd1bmtub3duJzpcclxuICAgICAgcmV0dXJuICfinZMnO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuICfinZMnO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXR1c0NvbG9yKHN0YXR1czogU3RhdHVzKTogc3RyaW5nIHtcclxuICBzd2l0Y2ggKHN0YXR1cykge1xyXG4gICAgY2FzZSAnb2snOlxyXG4gICAgICByZXR1cm4gJ3RleHQtZ3JlZW4tNjAwJztcclxuICAgIGNhc2UgJ2FmZmVjdGVkJzpcclxuICAgICAgcmV0dXJuICd0ZXh0LXllbGxvdy02MDAnO1xyXG4gICAgY2FzZSAndW5rbm93bic6XHJcbiAgICAgIHJldHVybiAndGV4dC1ncmF5LTYwMCc7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gJ3RleHQtZ3JheS02MDAnO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXR1c0JhZGdlQ2xhc3Moc3RhdHVzOiBTdGF0dXMpOiBzdHJpbmcge1xyXG4gIHN3aXRjaCAoc3RhdHVzKSB7XHJcbiAgICBjYXNlICdvayc6XHJcbiAgICAgIHJldHVybiAnYmctZ3JlZW4tMTAwIHRleHQtZ3JlZW4tODAwJztcclxuICAgIGNhc2UgJ2FmZmVjdGVkJzpcclxuICAgICAgcmV0dXJuICdiZy15ZWxsb3ctMTAwIHRleHQteWVsbG93LTgwMCc7XHJcbiAgICBjYXNlICd1bmtub3duJzpcclxuICAgICAgcmV0dXJuICdiZy1ncmF5LTEwMCB0ZXh0LWdyYXktODAwJztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiAnYmctZ3JheS0xMDAgdGV4dC1ncmF5LTgwMCc7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ6IiwiTGFuZ3VhZ2VTY2hlbWEiLCJlbnVtIiwiU3RhdHVzU2NoZW1hIiwiRGVwZW5kZW5jeUZpbmRpbmdTY2hlbWEiLCJvYmplY3QiLCJraW5kIiwibGl0ZXJhbCIsImxhbmciLCJjb21wb25lbnQiLCJzdHJpbmciLCJmb3VuZFZlcnNpb24iLCJudWxsYWJsZSIsImJhc2VsaW5lUmVxdWlyZWQiLCJzdGF0dXMiLCJyZWFzb24iLCJmaWxlIiwicXVpY2tGaXgiLCJvcHRpb25hbCIsIlBhdHRlcm5GaW5kaW5nU2NoZW1hIiwibGluZSIsIm51bWJlciIsImlzc3VlIiwicGF0dGVybiIsIkZpbmRpbmdTY2hlbWEiLCJkaXNjcmltaW5hdGVkVW5pb24iLCJMYW5ndWFnZVN1bW1hcnlTY2hlbWEiLCJvayIsImFmZmVjdGVkIiwidW5rbm93biIsIlJlcG9ydFN1bW1hcnlTY2hlbWEiLCJieUxhbmd1YWdlIiwicmVjb3JkIiwiUmVwb3J0U2NoZW1hIiwiZmluZGluZ3MiLCJhcnJheSIsInN1bW1hcnkiLCJtZXRhZGF0YSIsImFuYWx5c2lzSWQiLCJ0aW1lc3RhbXAiLCJwcm9qZWN0TmFtZSIsImRldGVjdGVkTGFuZ3VhZ2VzIiwidG90YWxGaWxlcyIsInNjYW5uZWRGaWxlcyIsInNraXBwZWRGaWxlcyIsImdyb3FBbmFseXNpcyIsImFuYWx5c2lzIiwiZmlsZW5hbWUiLCJEZXByZWNhdGVkUGF0dGVyblNjaGVtYSIsIm1lc3NhZ2UiLCJhbHRlcm5hdGl2ZSIsIlBhY2thZ2VNaW5zU2NoZW1hIiwiTGFuZ3VhZ2VSdW50aW1lc1NjaGVtYSIsIlF1aWNrRml4ZXNTY2hlbWEiLCJkZXBlbmRlbmN5X3VwZ3JhZGUiLCJwYXR0ZXJuX3JlcGxhY2VtZW50IiwiQmFzZWxpbmVSdWxlc1NjaGVtYSIsImxhbmd1YWdlX3J1bnRpbWVzIiwicGFja2FnZV9taW5zIiwiZGVwcmVjYXRlZF9wYXR0ZXJucyIsInNjYW5fZmlsZV9leHRzIiwiaWdub3JlX3BhdGhzIiwibWF4X2ZpbGVfc2l6ZSIsIm1heF9maWxlcyIsInF1aWNrX2ZpeGVzIiwiQW5hbHl6ZVJlc3BvbnNlU2NoZW1hIiwiYXJ0aWZhY3RzIiwianNvblVybCIsImNzdlVybCIsInJlcG9ydCIsIlByb2plY3RNYW5pZmVzdFNjaGVtYSIsImxhbmd1YWdlIiwiZGVwZW5kZW5jaWVzIiwiZGV2RGVwZW5kZW5jaWVzIiwicGVlckRlcGVuZGVuY2llcyIsIm9wdGlvbmFsRGVwZW5kZW5jaWVzIiwiRXh0cmFjdGVkRmlsZVNjaGVtYSIsInBhdGgiLCJjb250ZW50Iiwic2l6ZSIsIkFuYWx5c2lzQ29udGV4dFNjaGVtYSIsInJ1bGVzIiwiZXh0cmFjdGVkRmlsZXMiLCJtYW5pZmVzdHMiLCJBbmFseXNpc0Vycm9yU2NoZW1hIiwiY29kZSIsImRldGFpbHMiLCJhbnkiLCJ2YWxpZGF0ZUZpbmRpbmciLCJmaW5kaW5nIiwicGFyc2UiLCJ2YWxpZGF0ZVJlcG9ydCIsInZhbGlkYXRlQmFzZWxpbmVSdWxlcyIsInZhbGlkYXRlQW5hbHl6ZVJlc3BvbnNlIiwicmVzcG9uc2UiLCJpc0RlcGVuZGVuY3lGaW5kaW5nIiwiaXNQYXR0ZXJuRmluZGluZyIsImdldFN0YXR1c0ljb24iLCJnZXRTdGF0dXNDb2xvciIsImdldFN0YXR1c0JhZGdlQ2xhc3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./lib/analysis/baseline.types.ts\n");

/***/ }),

/***/ "(api-node)/./lib/analysis/compare.ts":
/*!*********************************!*\
  !*** ./lib/analysis/compare.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareVersions: () => (/* binding */ compareVersions),\n/* harmony export */   getLatestStableVersion: () => (/* binding */ getLatestStableVersion),\n/* harmony export */   getVersionDifference: () => (/* binding */ getVersionDifference),\n/* harmony export */   isPreRelease: () => (/* binding */ isPreRelease),\n/* harmony export */   parseVersion: () => (/* binding */ parseVersion),\n/* harmony export */   satisfiesRequirement: () => (/* binding */ satisfiesRequirement)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"semver\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\r\n * Compare two version strings\r\n * @param version1 First version\r\n * @param version2 Second version (baseline)\r\n * @param language Language context for parsing\r\n * @returns Comparison result\r\n */ function compareVersions(version1, version2, language) {\n    try {\n        const v1 = parseVersion(version1, language);\n        const v2 = parseVersion(version2, language);\n        if (!v1 || !v2) {\n            return 'unknown';\n        }\n        // Use semver for Node.js packages\n        if (language === 'node') {\n            return compareWithSemver(v1, v2);\n        }\n        // Use custom comparison for other languages\n        return compareVersionsCustom(v1, v2, language);\n    } catch (error) {\n        console.warn(`Version comparison failed: ${error}`);\n        return 'unknown';\n    }\n}\n/**\r\n * Compare versions using semver (for Node.js)\r\n * @param version1 First version\r\n * @param version2 Second version\r\n * @returns Comparison result\r\n */ function compareWithSemver(version1, version2) {\n    try {\n        // Clean versions for semver\n        const v1 = cleanVersionForSemver(version1);\n        const v2 = cleanVersionForSemver(version2);\n        if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(v1) || !semver__WEBPACK_IMPORTED_MODULE_0___default().valid(v2)) {\n            return 'unknown';\n        }\n        const result = semver__WEBPACK_IMPORTED_MODULE_0___default().compare(v1, v2);\n        if (result > 0) return 'greater';\n        if (result < 0) return 'less';\n        return 'equal';\n    } catch (error) {\n        return 'unknown';\n    }\n}\n/**\r\n * Clean version string for semver parsing\r\n * @param version Version string\r\n * @returns Cleaned version\r\n */ function cleanVersionForSemver(version) {\n    // Remove common prefixes and suffixes\n    let cleaned = version.replace(/^v/, '') // Remove v prefix\n    .replace(/^[~^>=<!=]+/, '') // Remove operators\n    .trim();\n    // Handle pre-release versions\n    if (cleaned.includes('-')) {\n        const parts = cleaned.split('-');\n        cleaned = parts[0];\n    }\n    // Handle build metadata\n    if (cleaned.includes('+')) {\n        const parts = cleaned.split('+');\n        cleaned = parts[0];\n    }\n    return cleaned;\n}\n/**\r\n * Custom version comparison for non-Node.js languages\r\n * @param version1 First version\r\n * @param version2 Second version\r\n * @param language Language context\r\n * @returns Comparison result\r\n */ function compareVersionsCustom(version1, version2, language) {\n    try {\n        const v1Parts = parseVersionParts(version1, language);\n        const v2Parts = parseVersionParts(version2, language);\n        if (!v1Parts || !v2Parts) {\n            return 'unknown';\n        }\n        // Compare major, minor, patch\n        for(let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++){\n            const v1Part = v1Parts[i] || 0;\n            const v2Part = v2Parts[i] || 0;\n            if (v1Part > v2Part) return 'greater';\n            if (v1Part < v2Part) return 'less';\n        }\n        return 'equal';\n    } catch (error) {\n        return 'unknown';\n    }\n}\n/**\r\n * Parse version into numeric parts\r\n * @param version Version string\r\n * @param language Language context\r\n * @returns Array of numeric parts\r\n */ function parseVersionParts(version, language) {\n    try {\n        // Clean version\n        let cleaned = version.replace(/^v/, '').replace(/^[~^>=<!=]+/, '').trim();\n        // Handle different version formats\n        if (language === 'python') {\n            // Python: 1.2.3, 1.2, 1.2.3a1, 1.2.3b1, 1.2.3rc1\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        } else if (language === 'java') {\n            // Java: 1.8.0, 11, 17.0.1\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        } else if (language === 'go') {\n            // Go: v1.21.0, 1.21.0\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        } else if (language === 'dotnet') {\n            // .NET: 6.0.0, 7.0.0-preview.1\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        }\n        // Split by dots and convert to numbers\n        const parts = cleaned.split('.').map((part)=>{\n            const num = parseInt(part, 10);\n            return isNaN(num) ? 0 : num;\n        });\n        return parts.length > 0 ? parts : null;\n    } catch (error) {\n        return null;\n    }\n}\n/**\r\n * Parse version string and extract version number\r\n * @param versionString Version string (may contain operators)\r\n * @param language Language context\r\n * @returns Clean version string\r\n */ function parseVersion(versionString, language) {\n    if (!versionString || versionString === '*') {\n        return '0.0.0';\n    }\n    // Remove common operators and prefixes\n    let clean = versionString.replace(/^[~^>=<!=]+/, '') // Remove operators\n    .replace(/^v/, '') // Remove v prefix\n    .trim();\n    // Handle special cases\n    if (clean === 'latest' || clean === '') {\n        return '0.0.0';\n    }\n    // Handle Python version specifiers\n    if (language === 'python') {\n        // Remove Python-specific operators\n        clean = clean.replace(/^[~=!<>]+/, '');\n    }\n    // Handle Go version suffixes\n    if (language === 'go') {\n        // Remove +incompatible, +incompatible.20210101, etc.\n        clean = clean.replace(/\\+.*$/, '');\n    }\n    // Handle Java version ranges\n    if (language === 'java') {\n        // Extract version from ranges like [1.0,2.0) or (1.0,2.0]\n        const rangeMatch = clean.match(/[\\[\\(]([^,]+),/);\n        if (rangeMatch) {\n            clean = rangeMatch[1];\n        }\n    }\n    return clean;\n}\n/**\r\n * Check if a version satisfies a requirement\r\n * @param version Version to check\r\n * @param requirement Requirement (e.g., \">=1.0.0\", \"~1.2.3\")\r\n * @param language Language context\r\n * @returns True if version satisfies requirement\r\n */ function satisfiesRequirement(version, requirement, language) {\n    try {\n        if (language === 'node') {\n            // Use semver for Node.js\n            const cleanVersion = cleanVersionForSemver(version);\n            if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(cleanVersion)) return false;\n            return semver__WEBPACK_IMPORTED_MODULE_0___default().satisfies(cleanVersion, requirement);\n        }\n        // Custom logic for other languages\n        return satisfiesRequirementCustom(version, requirement, language);\n    } catch (error) {\n        return false;\n    }\n}\n/**\r\n * Custom requirement satisfaction check\r\n * @param version Version to check\r\n * @param requirement Requirement\r\n * @param language Language context\r\n * @returns True if version satisfies requirement\r\n */ function satisfiesRequirementCustom(version, requirement, language) {\n    try {\n        const cleanVersion = parseVersion(version, language);\n        const cleanRequirement = parseVersion(requirement, language);\n        if (!cleanVersion || !cleanRequirement) return false;\n        // Extract operator from requirement\n        const operatorMatch = requirement.match(/^([~^>=<!=]+)/);\n        const operator = operatorMatch ? operatorMatch[1] : '>=';\n        const comparison = compareVersions(cleanVersion, cleanRequirement, language);\n        switch(operator){\n            case '>=':\n                return comparison === 'greater' || comparison === 'equal';\n            case '>':\n                return comparison === 'greater';\n            case '<=':\n                return comparison === 'less' || comparison === 'equal';\n            case '<':\n                return comparison === 'less';\n            case '=':\n            case '==':\n                return comparison === 'equal';\n            case '~':\n                // Tilde: allow patch-level changes\n                return satisfiesTilde(cleanVersion, cleanRequirement, language);\n            case '^':\n                // Caret: allow minor-level changes\n                return satisfiesCaret(cleanVersion, cleanRequirement, language);\n            default:\n                return comparison === 'equal';\n        }\n    } catch (error) {\n        return false;\n    }\n}\n/**\r\n * Check if version satisfies tilde requirement\r\n * @param version Version to check\r\n * @param requirement Requirement\r\n * @param language Language context\r\n * @returns True if satisfies\r\n */ function satisfiesTilde(version, requirement, language) {\n    const vParts = parseVersionParts(version, language);\n    const rParts = parseVersionParts(requirement, language);\n    if (!vParts || !rParts) return false;\n    // Major and minor must match, patch can be higher\n    if (vParts[0] !== rParts[0]) return false;\n    if (vParts[1] !== rParts[1]) return false;\n    return vParts[2] >= (rParts[2] || 0);\n}\n/**\r\n * Check if version satisfies caret requirement\r\n * @param version Version to check\r\n * @param requirement Requirement\r\n * @param language Language context\r\n * @returns True if satisfies\r\n */ function satisfiesCaret(version, requirement, language) {\n    const vParts = parseVersionParts(version, language);\n    const rParts = parseVersionParts(requirement, language);\n    if (!vParts || !rParts) return false;\n    // Major must match, minor and patch can be higher\n    if (vParts[0] !== rParts[0]) return false;\n    return vParts[1] > (rParts[1] || 0) || vParts[1] === (rParts[1] || 0) && vParts[2] >= (rParts[2] || 0);\n}\n/**\r\n * Get version difference description\r\n * @param version1 First version\r\n * @param version2 Second version\r\n * @param language Language context\r\n * @returns Description of difference\r\n */ function getVersionDifference(version1, version2, language) {\n    const comparison = compareVersions(version1, version2, language);\n    switch(comparison){\n        case 'greater':\n            return `${version1} is newer than ${version2}`;\n        case 'less':\n            return `${version1} is older than ${version2}`;\n        case 'equal':\n            return `${version1} matches ${version2}`;\n        case 'unknown':\n            return `Cannot compare ${version1} with ${version2}`;\n        default:\n            return 'Unknown comparison';\n    }\n}\n/**\r\n * Check if a version is a pre-release\r\n * @param version Version string\r\n * @param language Language context\r\n * @returns True if pre-release\r\n */ function isPreRelease(version, language) {\n    const clean = parseVersion(version, language);\n    // Check for common pre-release indicators\n    return /[a-zA-Z]/.test(clean) || clean.includes('-') || clean.includes('alpha') || clean.includes('beta') || clean.includes('rc') || clean.includes('preview');\n}\n/**\r\n * Get the latest stable version from a list\r\n * @param versions Array of version strings\r\n * @param language Language context\r\n * @returns Latest stable version or null\r\n */ function getLatestStableVersion(versions, language) {\n    const stableVersions = versions.filter((v)=>!isPreRelease(v, language));\n    if (stableVersions.length === 0) return null;\n    let latest = stableVersions[0];\n    for (const version of stableVersions){\n        if (compareVersions(version, latest, language) === 'greater') {\n            latest = version;\n        }\n    }\n    return latest;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU3FDLHVCQUNkQyxRQUFrQixFQUNsQnZELFFBQWtCO0lBRWxCLE1BQU13RCxpQkFBaUJELFNBQVNFLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBSyxDQUFDTixhQUFhTSxHQUFHMUQ7SUFFN0QsSUFBSXdELGVBQWU5QixNQUFNLEtBQUssR0FBRyxPQUFPO0lBRXhDLElBQUlpQyxTQUFTSCxjQUFjLENBQUMsRUFBRTtJQUU5QixLQUFLLE1BQU0zQyxXQUFXMkMsZUFBZ0I7UUFDcEMsSUFBSTNELGdCQUFnQmdCLFNBQVM4QyxRQUFRM0QsY0FBYyxXQUFXO1lBQzVEMkQsU0FBUzlDO1FBQ1g7SUFDRjtJQUVBLE9BQU84QztBQUNUIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxjb21wYXJlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcclxuaW1wb3J0IHsgTGFuZ3VhZ2UgfSBmcm9tICcuL2Jhc2VsaW5lLnR5cGVzJztcclxuXHJcbmV4cG9ydCB0eXBlIENvbXBhcmlzb25SZXN1bHQgPSAnZ3JlYXRlcicgfCAnZXF1YWwnIHwgJ2xlc3MnIHwgJ3Vua25vd24nO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmUgdHdvIHZlcnNpb24gc3RyaW5nc1xyXG4gKiBAcGFyYW0gdmVyc2lvbjEgRmlyc3QgdmVyc2lvblxyXG4gKiBAcGFyYW0gdmVyc2lvbjIgU2Vjb25kIHZlcnNpb24gKGJhc2VsaW5lKVxyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dCBmb3IgcGFyc2luZ1xyXG4gKiBAcmV0dXJucyBDb21wYXJpc29uIHJlc3VsdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyhcclxuICB2ZXJzaW9uMTogc3RyaW5nLFxyXG4gIHZlcnNpb24yOiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IENvbXBhcmlzb25SZXN1bHQge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB2MSA9IHBhcnNlVmVyc2lvbih2ZXJzaW9uMSwgbGFuZ3VhZ2UpO1xyXG4gICAgY29uc3QgdjIgPSBwYXJzZVZlcnNpb24odmVyc2lvbjIsIGxhbmd1YWdlKTtcclxuICAgIFxyXG4gICAgaWYgKCF2MSB8fCAhdjIpIHtcclxuICAgICAgcmV0dXJuICd1bmtub3duJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVXNlIHNlbXZlciBmb3IgTm9kZS5qcyBwYWNrYWdlc1xyXG4gICAgaWYgKGxhbmd1YWdlID09PSAnbm9kZScpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmVXaXRoU2VtdmVyKHYxLCB2Mik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFVzZSBjdXN0b20gY29tcGFyaXNvbiBmb3Igb3RoZXIgbGFuZ3VhZ2VzXHJcbiAgICByZXR1cm4gY29tcGFyZVZlcnNpb25zQ3VzdG9tKHYxLCB2MiwgbGFuZ3VhZ2UpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYFZlcnNpb24gY29tcGFyaXNvbiBmYWlsZWQ6ICR7ZXJyb3J9YCk7XHJcbiAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXBhcmUgdmVyc2lvbnMgdXNpbmcgc2VtdmVyIChmb3IgTm9kZS5qcylcclxuICogQHBhcmFtIHZlcnNpb24xIEZpcnN0IHZlcnNpb25cclxuICogQHBhcmFtIHZlcnNpb24yIFNlY29uZCB2ZXJzaW9uXHJcbiAqIEByZXR1cm5zIENvbXBhcmlzb24gcmVzdWx0XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wYXJlV2l0aFNlbXZlcih2ZXJzaW9uMTogc3RyaW5nLCB2ZXJzaW9uMjogc3RyaW5nKTogQ29tcGFyaXNvblJlc3VsdCB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIENsZWFuIHZlcnNpb25zIGZvciBzZW12ZXJcclxuICAgIGNvbnN0IHYxID0gY2xlYW5WZXJzaW9uRm9yU2VtdmVyKHZlcnNpb24xKTtcclxuICAgIGNvbnN0IHYyID0gY2xlYW5WZXJzaW9uRm9yU2VtdmVyKHZlcnNpb24yKTtcclxuICAgIFxyXG4gICAgaWYgKCFzZW12ZXIudmFsaWQodjEpIHx8ICFzZW12ZXIudmFsaWQodjIpKSB7XHJcbiAgICAgIHJldHVybiAndW5rbm93bic7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3VsdCA9IHNlbXZlci5jb21wYXJlKHYxLCB2Mik7XHJcbiAgICBcclxuICAgIGlmIChyZXN1bHQgPiAwKSByZXR1cm4gJ2dyZWF0ZXInO1xyXG4gICAgaWYgKHJlc3VsdCA8IDApIHJldHVybiAnbGVzcyc7XHJcbiAgICByZXR1cm4gJ2VxdWFsJztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuICd1bmtub3duJztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhbiB2ZXJzaW9uIHN0cmluZyBmb3Igc2VtdmVyIHBhcnNpbmdcclxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiBzdHJpbmdcclxuICogQHJldHVybnMgQ2xlYW5lZCB2ZXJzaW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGVhblZlcnNpb25Gb3JTZW12ZXIodmVyc2lvbjogc3RyaW5nKTogc3RyaW5nIHtcclxuICAvLyBSZW1vdmUgY29tbW9uIHByZWZpeGVzIGFuZCBzdWZmaXhlc1xyXG4gIGxldCBjbGVhbmVkID0gdmVyc2lvblxyXG4gICAgLnJlcGxhY2UoL152LywgJycpIC8vIFJlbW92ZSB2IHByZWZpeFxyXG4gICAgLnJlcGxhY2UoL15bfl4+PTwhPV0rLywgJycpIC8vIFJlbW92ZSBvcGVyYXRvcnNcclxuICAgIC50cmltKCk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHByZS1yZWxlYXNlIHZlcnNpb25zXHJcbiAgaWYgKGNsZWFuZWQuaW5jbHVkZXMoJy0nKSkge1xyXG4gICAgY29uc3QgcGFydHMgPSBjbGVhbmVkLnNwbGl0KCctJyk7XHJcbiAgICBjbGVhbmVkID0gcGFydHNbMF07XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBidWlsZCBtZXRhZGF0YVxyXG4gIGlmIChjbGVhbmVkLmluY2x1ZGVzKCcrJykpIHtcclxuICAgIGNvbnN0IHBhcnRzID0gY2xlYW5lZC5zcGxpdCgnKycpO1xyXG4gICAgY2xlYW5lZCA9IHBhcnRzWzBdO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gY2xlYW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEN1c3RvbSB2ZXJzaW9uIGNvbXBhcmlzb24gZm9yIG5vbi1Ob2RlLmpzIGxhbmd1YWdlc1xyXG4gKiBAcGFyYW0gdmVyc2lvbjEgRmlyc3QgdmVyc2lvblxyXG4gKiBAcGFyYW0gdmVyc2lvbjIgU2Vjb25kIHZlcnNpb25cclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgQ29tcGFyaXNvbiByZXN1bHRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9uc0N1c3RvbShcclxuICB2ZXJzaW9uMTogc3RyaW5nLFxyXG4gIHZlcnNpb24yOiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IENvbXBhcmlzb25SZXN1bHQge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB2MVBhcnRzID0gcGFyc2VWZXJzaW9uUGFydHModmVyc2lvbjEsIGxhbmd1YWdlKTtcclxuICAgIGNvbnN0IHYyUGFydHMgPSBwYXJzZVZlcnNpb25QYXJ0cyh2ZXJzaW9uMiwgbGFuZ3VhZ2UpO1xyXG4gICAgXHJcbiAgICBpZiAoIXYxUGFydHMgfHwgIXYyUGFydHMpIHtcclxuICAgICAgcmV0dXJuICd1bmtub3duJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ29tcGFyZSBtYWpvciwgbWlub3IsIHBhdGNoXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHYxUGFydHMubGVuZ3RoLCB2MlBhcnRzLmxlbmd0aCk7IGkrKykge1xyXG4gICAgICBjb25zdCB2MVBhcnQgPSB2MVBhcnRzW2ldIHx8IDA7XHJcbiAgICAgIGNvbnN0IHYyUGFydCA9IHYyUGFydHNbaV0gfHwgMDtcclxuICAgICAgXHJcbiAgICAgIGlmICh2MVBhcnQgPiB2MlBhcnQpIHJldHVybiAnZ3JlYXRlcic7XHJcbiAgICAgIGlmICh2MVBhcnQgPCB2MlBhcnQpIHJldHVybiAnbGVzcyc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAnZXF1YWwnO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHZlcnNpb24gaW50byBudW1lcmljIHBhcnRzXHJcbiAqIEBwYXJhbSB2ZXJzaW9uIFZlcnNpb24gc3RyaW5nXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIEFycmF5IG9mIG51bWVyaWMgcGFydHNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlVmVyc2lvblBhcnRzKHZlcnNpb246IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogbnVtYmVyW10gfCBudWxsIHtcclxuICB0cnkge1xyXG4gICAgLy8gQ2xlYW4gdmVyc2lvblxyXG4gICAgbGV0IGNsZWFuZWQgPSB2ZXJzaW9uXHJcbiAgICAgIC5yZXBsYWNlKC9edi8sICcnKVxyXG4gICAgICAucmVwbGFjZSgvXlt+Xj49PCE9XSsvLCAnJylcclxuICAgICAgLnRyaW0oKTtcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIGRpZmZlcmVudCB2ZXJzaW9uIGZvcm1hdHNcclxuICAgIGlmIChsYW5ndWFnZSA9PT0gJ3B5dGhvbicpIHtcclxuICAgICAgLy8gUHl0aG9uOiAxLjIuMywgMS4yLCAxLjIuM2ExLCAxLjIuM2IxLCAxLjIuM3JjMVxyXG4gICAgICBjbGVhbmVkID0gY2xlYW5lZC5yZXBsYWNlKC9bYS16QS1aXS4qJC8sICcnKTsgLy8gUmVtb3ZlIHByZS1yZWxlYXNlIGluZm9cclxuICAgIH0gZWxzZSBpZiAobGFuZ3VhZ2UgPT09ICdqYXZhJykge1xyXG4gICAgICAvLyBKYXZhOiAxLjguMCwgMTEsIDE3LjAuMVxyXG4gICAgICBjbGVhbmVkID0gY2xlYW5lZC5yZXBsYWNlKC9bYS16QS1aXS4qJC8sICcnKTsgLy8gUmVtb3ZlIHByZS1yZWxlYXNlIGluZm9cclxuICAgIH0gZWxzZSBpZiAobGFuZ3VhZ2UgPT09ICdnbycpIHtcclxuICAgICAgLy8gR286IHYxLjIxLjAsIDEuMjEuMFxyXG4gICAgICBjbGVhbmVkID0gY2xlYW5lZC5yZXBsYWNlKC9bYS16QS1aXS4qJC8sICcnKTsgLy8gUmVtb3ZlIHByZS1yZWxlYXNlIGluZm9cclxuICAgIH0gZWxzZSBpZiAobGFuZ3VhZ2UgPT09ICdkb3RuZXQnKSB7XHJcbiAgICAgIC8vIC5ORVQ6IDYuMC4wLCA3LjAuMC1wcmV2aWV3LjFcclxuICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvW2EtekEtWl0uKiQvLCAnJyk7IC8vIFJlbW92ZSBwcmUtcmVsZWFzZSBpbmZvXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNwbGl0IGJ5IGRvdHMgYW5kIGNvbnZlcnQgdG8gbnVtYmVyc1xyXG4gICAgY29uc3QgcGFydHMgPSBjbGVhbmVkLnNwbGl0KCcuJykubWFwKHBhcnQgPT4ge1xyXG4gICAgICBjb25zdCBudW0gPSBwYXJzZUludChwYXJ0LCAxMCk7XHJcbiAgICAgIHJldHVybiBpc05hTihudW0pID8gMCA6IG51bTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzIDogbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgdmVyc2lvbiBzdHJpbmcgYW5kIGV4dHJhY3QgdmVyc2lvbiBudW1iZXJcclxuICogQHBhcmFtIHZlcnNpb25TdHJpbmcgVmVyc2lvbiBzdHJpbmcgKG1heSBjb250YWluIG9wZXJhdG9ycylcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgQ2xlYW4gdmVyc2lvbiBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVZlcnNpb24odmVyc2lvblN0cmluZzogc3RyaW5nLCBsYW5ndWFnZTogTGFuZ3VhZ2UpOiBzdHJpbmcge1xyXG4gIGlmICghdmVyc2lvblN0cmluZyB8fCB2ZXJzaW9uU3RyaW5nID09PSAnKicpIHtcclxuICAgIHJldHVybiAnMC4wLjAnO1xyXG4gIH1cclxuICBcclxuICAvLyBSZW1vdmUgY29tbW9uIG9wZXJhdG9ycyBhbmQgcHJlZml4ZXNcclxuICBsZXQgY2xlYW4gPSB2ZXJzaW9uU3RyaW5nXHJcbiAgICAucmVwbGFjZSgvXlt+Xj49PCE9XSsvLCAnJykgLy8gUmVtb3ZlIG9wZXJhdG9yc1xyXG4gICAgLnJlcGxhY2UoL152LywgJycpIC8vIFJlbW92ZSB2IHByZWZpeFxyXG4gICAgLnRyaW0oKTtcclxuICBcclxuICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlc1xyXG4gIGlmIChjbGVhbiA9PT0gJ2xhdGVzdCcgfHwgY2xlYW4gPT09ICcnKSB7XHJcbiAgICByZXR1cm4gJzAuMC4wJztcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIFB5dGhvbiB2ZXJzaW9uIHNwZWNpZmllcnNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdweXRob24nKSB7XHJcbiAgICAvLyBSZW1vdmUgUHl0aG9uLXNwZWNpZmljIG9wZXJhdG9yc1xyXG4gICAgY2xlYW4gPSBjbGVhbi5yZXBsYWNlKC9eW349ITw+XSsvLCAnJyk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBHbyB2ZXJzaW9uIHN1ZmZpeGVzXHJcbiAgaWYgKGxhbmd1YWdlID09PSAnZ28nKSB7XHJcbiAgICAvLyBSZW1vdmUgK2luY29tcGF0aWJsZSwgK2luY29tcGF0aWJsZS4yMDIxMDEwMSwgZXRjLlxyXG4gICAgY2xlYW4gPSBjbGVhbi5yZXBsYWNlKC9cXCsuKiQvLCAnJyk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBKYXZhIHZlcnNpb24gcmFuZ2VzXHJcbiAgaWYgKGxhbmd1YWdlID09PSAnamF2YScpIHtcclxuICAgIC8vIEV4dHJhY3QgdmVyc2lvbiBmcm9tIHJhbmdlcyBsaWtlIFsxLjAsMi4wKSBvciAoMS4wLDIuMF1cclxuICAgIGNvbnN0IHJhbmdlTWF0Y2ggPSBjbGVhbi5tYXRjaCgvW1xcW1xcKF0oW14sXSspLC8pO1xyXG4gICAgaWYgKHJhbmdlTWF0Y2gpIHtcclxuICAgICAgY2xlYW4gPSByYW5nZU1hdGNoWzFdO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gY2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZlcnNpb24gc2F0aXNmaWVzIGEgcmVxdWlyZW1lbnRcclxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiB0byBjaGVja1xyXG4gKiBAcGFyYW0gcmVxdWlyZW1lbnQgUmVxdWlyZW1lbnQgKGUuZy4sIFwiPj0xLjAuMFwiLCBcIn4xLjIuM1wiKVxyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHZlcnNpb24gc2F0aXNmaWVzIHJlcXVpcmVtZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2F0aXNmaWVzUmVxdWlyZW1lbnQoXHJcbiAgdmVyc2lvbjogc3RyaW5nLFxyXG4gIHJlcXVpcmVtZW50OiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IGJvb2xlYW4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAobGFuZ3VhZ2UgPT09ICdub2RlJykge1xyXG4gICAgICAvLyBVc2Ugc2VtdmVyIGZvciBOb2RlLmpzXHJcbiAgICAgIGNvbnN0IGNsZWFuVmVyc2lvbiA9IGNsZWFuVmVyc2lvbkZvclNlbXZlcih2ZXJzaW9uKTtcclxuICAgICAgaWYgKCFzZW12ZXIudmFsaWQoY2xlYW5WZXJzaW9uKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHNlbXZlci5zYXRpc2ZpZXMoY2xlYW5WZXJzaW9uLCByZXF1aXJlbWVudCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEN1c3RvbSBsb2dpYyBmb3Igb3RoZXIgbGFuZ3VhZ2VzXHJcbiAgICByZXR1cm4gc2F0aXNmaWVzUmVxdWlyZW1lbnRDdXN0b20odmVyc2lvbiwgcmVxdWlyZW1lbnQsIGxhbmd1YWdlKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEN1c3RvbSByZXF1aXJlbWVudCBzYXRpc2ZhY3Rpb24gY2hlY2tcclxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiB0byBjaGVja1xyXG4gKiBAcGFyYW0gcmVxdWlyZW1lbnQgUmVxdWlyZW1lbnRcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgVHJ1ZSBpZiB2ZXJzaW9uIHNhdGlzZmllcyByZXF1aXJlbWVudFxyXG4gKi9cclxuZnVuY3Rpb24gc2F0aXNmaWVzUmVxdWlyZW1lbnRDdXN0b20oXHJcbiAgdmVyc2lvbjogc3RyaW5nLFxyXG4gIHJlcXVpcmVtZW50OiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IGJvb2xlYW4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjbGVhblZlcnNpb24gPSBwYXJzZVZlcnNpb24odmVyc2lvbiwgbGFuZ3VhZ2UpO1xyXG4gICAgY29uc3QgY2xlYW5SZXF1aXJlbWVudCA9IHBhcnNlVmVyc2lvbihyZXF1aXJlbWVudCwgbGFuZ3VhZ2UpO1xyXG4gICAgXHJcbiAgICBpZiAoIWNsZWFuVmVyc2lvbiB8fCAhY2xlYW5SZXF1aXJlbWVudCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IG9wZXJhdG9yIGZyb20gcmVxdWlyZW1lbnRcclxuICAgIGNvbnN0IG9wZXJhdG9yTWF0Y2ggPSByZXF1aXJlbWVudC5tYXRjaCgvXihbfl4+PTwhPV0rKS8pO1xyXG4gICAgY29uc3Qgb3BlcmF0b3IgPSBvcGVyYXRvck1hdGNoID8gb3BlcmF0b3JNYXRjaFsxXSA6ICc+PSc7XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBjb21wYXJlVmVyc2lvbnMoY2xlYW5WZXJzaW9uLCBjbGVhblJlcXVpcmVtZW50LCBsYW5ndWFnZSk7XHJcbiAgICBcclxuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcclxuICAgICAgY2FzZSAnPj0nOlxyXG4gICAgICAgIHJldHVybiBjb21wYXJpc29uID09PSAnZ3JlYXRlcicgfHwgY29tcGFyaXNvbiA9PT0gJ2VxdWFsJztcclxuICAgICAgY2FzZSAnPic6XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPT09ICdncmVhdGVyJztcclxuICAgICAgY2FzZSAnPD0nOlxyXG4gICAgICAgIHJldHVybiBjb21wYXJpc29uID09PSAnbGVzcycgfHwgY29tcGFyaXNvbiA9PT0gJ2VxdWFsJztcclxuICAgICAgY2FzZSAnPCc6XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPT09ICdsZXNzJztcclxuICAgICAgY2FzZSAnPSc6XHJcbiAgICAgIGNhc2UgJz09JzpcclxuICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gJ2VxdWFsJztcclxuICAgICAgY2FzZSAnfic6XHJcbiAgICAgICAgLy8gVGlsZGU6IGFsbG93IHBhdGNoLWxldmVsIGNoYW5nZXNcclxuICAgICAgICByZXR1cm4gc2F0aXNmaWVzVGlsZGUoY2xlYW5WZXJzaW9uLCBjbGVhblJlcXVpcmVtZW50LCBsYW5ndWFnZSk7XHJcbiAgICAgIGNhc2UgJ14nOlxyXG4gICAgICAgIC8vIENhcmV0OiBhbGxvdyBtaW5vci1sZXZlbCBjaGFuZ2VzXHJcbiAgICAgICAgcmV0dXJuIHNhdGlzZmllc0NhcmV0KGNsZWFuVmVyc2lvbiwgY2xlYW5SZXF1aXJlbWVudCwgbGFuZ3VhZ2UpO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBjb21wYXJpc29uID09PSAnZXF1YWwnO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdmVyc2lvbiBzYXRpc2ZpZXMgdGlsZGUgcmVxdWlyZW1lbnRcclxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiB0byBjaGVja1xyXG4gKiBAcGFyYW0gcmVxdWlyZW1lbnQgUmVxdWlyZW1lbnRcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgVHJ1ZSBpZiBzYXRpc2ZpZXNcclxuICovXHJcbmZ1bmN0aW9uIHNhdGlzZmllc1RpbGRlKFxyXG4gIHZlcnNpb246IHN0cmluZyxcclxuICByZXF1aXJlbWVudDogc3RyaW5nLFxyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxyXG4pOiBib29sZWFuIHtcclxuICBjb25zdCB2UGFydHMgPSBwYXJzZVZlcnNpb25QYXJ0cyh2ZXJzaW9uLCBsYW5ndWFnZSk7XHJcbiAgY29uc3QgclBhcnRzID0gcGFyc2VWZXJzaW9uUGFydHMocmVxdWlyZW1lbnQsIGxhbmd1YWdlKTtcclxuICBcclxuICBpZiAoIXZQYXJ0cyB8fCAhclBhcnRzKSByZXR1cm4gZmFsc2U7XHJcbiAgXHJcbiAgLy8gTWFqb3IgYW5kIG1pbm9yIG11c3QgbWF0Y2gsIHBhdGNoIGNhbiBiZSBoaWdoZXJcclxuICBpZiAodlBhcnRzWzBdICE9PSByUGFydHNbMF0pIHJldHVybiBmYWxzZTtcclxuICBpZiAodlBhcnRzWzFdICE9PSByUGFydHNbMV0pIHJldHVybiBmYWxzZTtcclxuICBcclxuICByZXR1cm4gdlBhcnRzWzJdID49IChyUGFydHNbMl0gfHwgMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2ZXJzaW9uIHNhdGlzZmllcyBjYXJldCByZXF1aXJlbWVudFxyXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIHRvIGNoZWNrXHJcbiAqIEBwYXJhbSByZXF1aXJlbWVudCBSZXF1aXJlbWVudFxyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHNhdGlzZmllc1xyXG4gKi9cclxuZnVuY3Rpb24gc2F0aXNmaWVzQ2FyZXQoXHJcbiAgdmVyc2lvbjogc3RyaW5nLFxyXG4gIHJlcXVpcmVtZW50OiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IHZQYXJ0cyA9IHBhcnNlVmVyc2lvblBhcnRzKHZlcnNpb24sIGxhbmd1YWdlKTtcclxuICBjb25zdCByUGFydHMgPSBwYXJzZVZlcnNpb25QYXJ0cyhyZXF1aXJlbWVudCwgbGFuZ3VhZ2UpO1xyXG4gIFxyXG4gIGlmICghdlBhcnRzIHx8ICFyUGFydHMpIHJldHVybiBmYWxzZTtcclxuICBcclxuICAvLyBNYWpvciBtdXN0IG1hdGNoLCBtaW5vciBhbmQgcGF0Y2ggY2FuIGJlIGhpZ2hlclxyXG4gIGlmICh2UGFydHNbMF0gIT09IHJQYXJ0c1swXSkgcmV0dXJuIGZhbHNlO1xyXG4gIFxyXG4gIHJldHVybiB2UGFydHNbMV0gPiAoclBhcnRzWzFdIHx8IDApIHx8IFxyXG4gICAgICAgICAodlBhcnRzWzFdID09PSAoclBhcnRzWzFdIHx8IDApICYmIHZQYXJ0c1syXSA+PSAoclBhcnRzWzJdIHx8IDApKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB2ZXJzaW9uIGRpZmZlcmVuY2UgZGVzY3JpcHRpb25cclxuICogQHBhcmFtIHZlcnNpb24xIEZpcnN0IHZlcnNpb25cclxuICogQHBhcmFtIHZlcnNpb24yIFNlY29uZCB2ZXJzaW9uXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIERlc2NyaXB0aW9uIG9mIGRpZmZlcmVuY2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzaW9uRGlmZmVyZW5jZShcclxuICB2ZXJzaW9uMTogc3RyaW5nLFxyXG4gIHZlcnNpb24yOiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IHN0cmluZyB7XHJcbiAgY29uc3QgY29tcGFyaXNvbiA9IGNvbXBhcmVWZXJzaW9ucyh2ZXJzaW9uMSwgdmVyc2lvbjIsIGxhbmd1YWdlKTtcclxuICBcclxuICBzd2l0Y2ggKGNvbXBhcmlzb24pIHtcclxuICAgIGNhc2UgJ2dyZWF0ZXInOlxyXG4gICAgICByZXR1cm4gYCR7dmVyc2lvbjF9IGlzIG5ld2VyIHRoYW4gJHt2ZXJzaW9uMn1gO1xyXG4gICAgY2FzZSAnbGVzcyc6XHJcbiAgICAgIHJldHVybiBgJHt2ZXJzaW9uMX0gaXMgb2xkZXIgdGhhbiAke3ZlcnNpb24yfWA7XHJcbiAgICBjYXNlICdlcXVhbCc6XHJcbiAgICAgIHJldHVybiBgJHt2ZXJzaW9uMX0gbWF0Y2hlcyAke3ZlcnNpb24yfWA7XHJcbiAgICBjYXNlICd1bmtub3duJzpcclxuICAgICAgcmV0dXJuIGBDYW5ub3QgY29tcGFyZSAke3ZlcnNpb24xfSB3aXRoICR7dmVyc2lvbjJ9YDtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiAnVW5rbm93biBjb21wYXJpc29uJztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZlcnNpb24gaXMgYSBwcmUtcmVsZWFzZVxyXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIHN0cmluZ1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHByZS1yZWxlYXNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQcmVSZWxlYXNlKHZlcnNpb246IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgY2xlYW4gPSBwYXJzZVZlcnNpb24odmVyc2lvbiwgbGFuZ3VhZ2UpO1xyXG4gIFxyXG4gIC8vIENoZWNrIGZvciBjb21tb24gcHJlLXJlbGVhc2UgaW5kaWNhdG9yc1xyXG4gIHJldHVybiAvW2EtekEtWl0vLnRlc3QoY2xlYW4pIHx8IFxyXG4gICAgICAgICBjbGVhbi5pbmNsdWRlcygnLScpIHx8IFxyXG4gICAgICAgICBjbGVhbi5pbmNsdWRlcygnYWxwaGEnKSB8fFxyXG4gICAgICAgICBjbGVhbi5pbmNsdWRlcygnYmV0YScpIHx8XHJcbiAgICAgICAgIGNsZWFuLmluY2x1ZGVzKCdyYycpIHx8XHJcbiAgICAgICAgIGNsZWFuLmluY2x1ZGVzKCdwcmV2aWV3Jyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGxhdGVzdCBzdGFibGUgdmVyc2lvbiBmcm9tIGEgbGlzdFxyXG4gKiBAcGFyYW0gdmVyc2lvbnMgQXJyYXkgb2YgdmVyc2lvbiBzdHJpbmdzXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIExhdGVzdCBzdGFibGUgdmVyc2lvbiBvciBudWxsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF0ZXN0U3RhYmxlVmVyc2lvbihcclxuICB2ZXJzaW9uczogc3RyaW5nW10sXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IHN0cmluZyB8IG51bGwge1xyXG4gIGNvbnN0IHN0YWJsZVZlcnNpb25zID0gdmVyc2lvbnMuZmlsdGVyKHYgPT4gIWlzUHJlUmVsZWFzZSh2LCBsYW5ndWFnZSkpO1xyXG4gIFxyXG4gIGlmIChzdGFibGVWZXJzaW9ucy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xyXG4gIFxyXG4gIGxldCBsYXRlc3QgPSBzdGFibGVWZXJzaW9uc1swXTtcclxuICBcclxuICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygc3RhYmxlVmVyc2lvbnMpIHtcclxuICAgIGlmIChjb21wYXJlVmVyc2lvbnModmVyc2lvbiwgbGF0ZXN0LCBsYW5ndWFnZSkgPT09ICdncmVhdGVyJykge1xyXG4gICAgICBsYXRlc3QgPSB2ZXJzaW9uO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gbGF0ZXN0O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJzZW12ZXIiLCJjb21wYXJlVmVyc2lvbnMiLCJ2ZXJzaW9uMSIsInZlcnNpb24yIiwibGFuZ3VhZ2UiLCJ2MSIsInBhcnNlVmVyc2lvbiIsInYyIiwiY29tcGFyZVdpdGhTZW12ZXIiLCJjb21wYXJlVmVyc2lvbnNDdXN0b20iLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiY2xlYW5WZXJzaW9uRm9yU2VtdmVyIiwidmFsaWQiLCJyZXN1bHQiLCJjb21wYXJlIiwidmVyc2lvbiIsImNsZWFuZWQiLCJyZXBsYWNlIiwidHJpbSIsImluY2x1ZGVzIiwicGFydHMiLCJzcGxpdCIsInYxUGFydHMiLCJwYXJzZVZlcnNpb25QYXJ0cyIsInYyUGFydHMiLCJpIiwiTWF0aCIsIm1heCIsImxlbmd0aCIsInYxUGFydCIsInYyUGFydCIsIm1hcCIsInBhcnQiLCJudW0iLCJwYXJzZUludCIsImlzTmFOIiwidmVyc2lvblN0cmluZyIsImNsZWFuIiwicmFuZ2VNYXRjaCIsIm1hdGNoIiwic2F0aXNmaWVzUmVxdWlyZW1lbnQiLCJyZXF1aXJlbWVudCIsImNsZWFuVmVyc2lvbiIsInNhdGlzZmllcyIsInNhdGlzZmllc1JlcXVpcmVtZW50Q3VzdG9tIiwiY2xlYW5SZXF1aXJlbWVudCIsIm9wZXJhdG9yTWF0Y2giLCJvcGVyYXRvciIsImNvbXBhcmlzb24iLCJzYXRpc2ZpZXNUaWxkZSIsInNhdGlzZmllc0NhcmV0IiwidlBhcnRzIiwiclBhcnRzIiwiZ2V0VmVyc2lvbkRpZmZlcmVuY2UiLCJpc1ByZVJlbGVhc2UiLCJ0ZXN0IiwiZ2V0TGF0ZXN0U3RhYmxlVmVyc2lvbiIsInZlcnNpb25zIiwic3RhYmxlVmVyc2lvbnMiLCJmaWx0ZXIiLCJ2IiwibGF0ZXN0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./lib/analysis/compare.ts\n");

/***/ }),

/***/ "(api-node)/./lib/analysis/deps.ts":
/*!******************************!*\
  !*** ./lib/analysis/deps.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeDependencies: () => (/* binding */ analyzeDependencies),\n/* harmony export */   filterDependenciesByLanguage: () => (/* binding */ filterDependenciesByLanguage),\n/* harmony export */   getBaselineVersion: () => (/* binding */ getBaselineVersion),\n/* harmony export */   getDependencySummary: () => (/* binding */ getDependencySummary),\n/* harmony export */   groupDependenciesByStatus: () => (/* binding */ groupDependenciesByStatus),\n/* harmony export */   hasBaselineRule: () => (/* binding */ hasBaselineRule),\n/* harmony export */   isValidVersion: () => (/* binding */ isValidVersion),\n/* harmony export */   normalizePackageName: () => (/* binding */ normalizePackageName),\n/* harmony export */   parseVersion: () => (/* binding */ parseVersion),\n/* harmony export */   sortDependencies: () => (/* binding */ sortDependencies)\n/* harmony export */ });\n/* harmony import */ var _compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compare */ \"(api-node)/./lib/analysis/compare.ts\");\n\n/**\r\n * Analyze dependencies from project manifests\r\n * @param manifests Array of project manifests\r\n * @param rules Baseline rules\r\n * @returns Array of dependency findings\r\n */ function analyzeDependencies(manifests, rules) {\n    const findings = [];\n    for (const manifest of manifests){\n        if (!manifest.dependencies) continue;\n        const languageRules = rules.package_mins[manifest.language] || {};\n        for (const [packageName, foundVersion] of Object.entries(manifest.dependencies)){\n            const baselineVersion = languageRules[packageName];\n            if (!baselineVersion) {\n                // No baseline rule for this package\n                findings.push({\n                    kind: 'dependency',\n                    lang: manifest.language,\n                    component: packageName,\n                    foundVersion,\n                    baselineRequired: null,\n                    status: 'unknown',\n                    reason: 'no-baseline-rule',\n                    file: manifest.file\n                });\n                continue;\n            }\n            // Compare versions\n            const comparison = (0,_compare__WEBPACK_IMPORTED_MODULE_0__.compareVersions)(foundVersion, baselineVersion, manifest.language);\n            let status;\n            let reason;\n            switch(comparison){\n                case 'greater':\n                case 'equal':\n                    status = 'ok';\n                    reason = 'meets-baseline';\n                    break;\n                case 'less':\n                    status = 'affected';\n                    reason = 'below-baseline';\n                    break;\n                case 'unknown':\n                    status = 'unknown';\n                    reason = 'version-parse-error';\n                    break;\n                default:\n                    status = 'unknown';\n                    reason = 'unknown-comparison';\n            }\n            findings.push({\n                kind: 'dependency',\n                lang: manifest.language,\n                component: packageName,\n                foundVersion,\n                baselineRequired: baselineVersion,\n                status,\n                reason,\n                file: manifest.file,\n                quickFix: getDependencyQuickFix(rules, manifest.language, packageName, baselineVersion)\n            });\n        }\n    }\n    return findings;\n}\n/**\r\n * Get quick fix for dependency upgrade\r\n * @param rules Baseline rules\r\n * @param language Language\r\n * @param packageName Package name\r\n * @param version Required version\r\n * @returns Quick fix string\r\n */ function getDependencyQuickFix(rules, language, packageName, version) {\n    const template = rules.quick_fixes.dependency_upgrade[language] || 'Update {package} to {version}';\n    return template.replace('{package}', packageName).replace('{version}', version);\n}\n/**\r\n * Parse version string and extract version number\r\n * @param versionString Version string (may contain operators)\r\n * @param language Language context\r\n * @returns Clean version string\r\n */ function parseVersion(versionString, language) {\n    if (!versionString || versionString === '*') {\n        return '0.0.0';\n    }\n    // Remove common operators and prefixes\n    let clean = versionString.replace(/^[~^>=<!=]+/, '') // Remove operators\n    .replace(/^v/, '') // Remove v prefix\n    .trim();\n    // Handle special cases\n    if (clean === 'latest' || clean === '') {\n        return '0.0.0';\n    }\n    // Handle Python version specifiers\n    if (language === 'python') {\n        // Remove Python-specific operators\n        clean = clean.replace(/^[~=!<>]+/, '');\n    }\n    // Handle Go version suffixes\n    if (language === 'go') {\n        // Remove +incompatible, +incompatible.20210101, etc.\n        clean = clean.replace(/\\+.*$/, '');\n    }\n    // Handle Java version ranges\n    if (language === 'java') {\n        // Extract version from ranges like [1.0,2.0) or (1.0,2.0]\n        const rangeMatch = clean.match(/[\\[\\(]([^,]+),/);\n        if (rangeMatch) {\n            clean = rangeMatch[1];\n        }\n    }\n    return clean;\n}\n/**\r\n * Check if a version string is valid\r\n * @param versionString Version string\r\n * @param language Language context\r\n * @returns True if valid\r\n */ function isValidVersion(versionString, language) {\n    if (!versionString || versionString === '*') return false;\n    const clean = parseVersion(versionString, language);\n    // Basic version pattern validation\n    const versionPatterns = {\n        node: /^\\d+\\.\\d+\\.\\d+(-[a-zA-Z0-9.-]+)?(\\+[a-zA-Z0-9.-]+)?$/,\n        python: /^\\d+\\.\\d+(\\.\\d+)?([a-zA-Z0-9.-]+)?$/,\n        java: /^\\d+(\\.\\d+)*(-[a-zA-Z0-9.-]+)?$/,\n        go: /^v?\\d+\\.\\d+\\.\\d+(-[a-zA-Z0-9.-]+)?(\\+[a-zA-Z0-9.-]+)?$/,\n        dotnet: /^\\d+\\.\\d+(\\.\\d+)?(-[a-zA-Z0-9.-]+)?$/\n    };\n    const pattern = versionPatterns[language];\n    return pattern ? pattern.test(clean) : false;\n}\n/**\r\n * Normalize package name for comparison\r\n * @param packageName Package name\r\n * @param language Language context\r\n * @returns Normalized package name\r\n */ function normalizePackageName(packageName, language) {\n    let normalized = packageName.toLowerCase().trim();\n    // Handle scoped packages (Node.js)\n    if (language === 'node' && normalized.startsWith('@')) {\n        // Keep @scope/package format\n        return normalized;\n    }\n    // Handle Java group:artifact format\n    if (language === 'java' && normalized.includes(':')) {\n        return normalized;\n    }\n    // Handle Go modules\n    if (language === 'go') {\n        // Remove common prefixes\n        normalized = normalized.replace(/^github\\.com\\//, '');\n        normalized = normalized.replace(/^golang\\.org\\/x\\//, '');\n    }\n    // Handle .NET packages\n    if (language === 'dotnet') {\n        // Remove common prefixes\n        normalized = normalized.replace(/^microsoft\\./, '');\n        normalized = normalized.replace(/^system\\./, '');\n    }\n    return normalized;\n}\n/**\r\n * Check if a package is in the baseline rules\r\n * @param packageName Package name\r\n * @param language Language\r\n * @param rules Baseline rules\r\n * @returns True if package has baseline rules\r\n */ function hasBaselineRule(packageName, language, rules) {\n    const languageRules = rules.package_mins[language] || {};\n    const normalized = normalizePackageName(packageName, language);\n    // Check exact match first\n    if (languageRules[packageName]) return true;\n    if (languageRules[normalized]) return true;\n    // Check for partial matches (for scoped packages, etc.)\n    for (const [rulePackage, _] of Object.entries(languageRules)){\n        if (normalizePackageName(rulePackage, language) === normalized) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\r\n * Get baseline version for a package\r\n * @param packageName Package name\r\n * @param language Language\r\n * @param rules Baseline rules\r\n * @returns Baseline version or null\r\n */ function getBaselineVersion(packageName, language, rules) {\n    const languageRules = rules.package_mins[language] || {};\n    const normalized = normalizePackageName(packageName, language);\n    // Check exact match first\n    if (languageRules[packageName]) return languageRules[packageName];\n    if (languageRules[normalized]) return languageRules[normalized];\n    // Check for partial matches\n    for (const [rulePackage, version] of Object.entries(languageRules)){\n        if (normalizePackageName(rulePackage, language) === normalized) {\n            return version;\n        }\n    }\n    return null;\n}\n/**\r\n * Group dependencies by status\r\n * @param findings Dependency findings\r\n * @returns Grouped findings\r\n */ function groupDependenciesByStatus(findings) {\n    return {\n        ok: findings.filter((f)=>f.status === 'ok'),\n        affected: findings.filter((f)=>f.status === 'affected'),\n        unknown: findings.filter((f)=>f.status === 'unknown')\n    };\n}\n/**\r\n * Get dependency summary statistics\r\n * @param findings Dependency findings\r\n * @returns Summary statistics\r\n */ function getDependencySummary(findings) {\n    const total = findings.length;\n    const ok = findings.filter((f)=>f.status === 'ok').length;\n    const affected = findings.filter((f)=>f.status === 'affected').length;\n    const unknown = findings.filter((f)=>f.status === 'unknown').length;\n    return {\n        total,\n        ok,\n        affected,\n        unknown,\n        okPercentage: total > 0 ? ok / total * 100 : 0,\n        affectedPercentage: total > 0 ? affected / total * 100 : 0,\n        unknownPercentage: total > 0 ? unknown / total * 100 : 0\n    };\n}\n/**\r\n * Filter dependencies by language\r\n * @param findings Dependency findings\r\n * @param language Language to filter by\r\n * @returns Filtered findings\r\n */ function filterDependenciesByLanguage(findings, language) {\n    return findings.filter((f)=>f.lang === language);\n}\n/**\r\n * Sort dependencies by status and name\r\n * @param findings Dependency findings\r\n * @returns Sorted findings\r\n */ function sortDependencies(findings) {\n    const statusOrder = {\n        affected: 0,\n        unknown: 1,\n        ok: 2\n    };\n    return [\n        ...findings\n    ].sort((a, b)=>{\n        // First by status\n        const statusDiff = statusOrder[a.status] - statusOrder[b.status];\n        if (statusDiff !== 0) return statusDiff;\n        // Then by language\n        const langDiff = a.lang.localeCompare(b.lang);\n        if (langDiff !== 0) return langDiff;\n        // Finally by component name\n        return a.component.localeCompare(b.component);\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTztXQUFJcEQ7S0FBUyxDQUFDa0UsSUFBSSxDQUFDLENBQUNDLEdBQUdDO1FBQzVCLGtCQUFrQjtRQUNsQixNQUFNQyxhQUFhSixXQUFXLENBQUNFLEVBQUVuRCxNQUFNLENBQUMsR0FBR2lELFdBQVcsQ0FBQ0csRUFBRXBELE1BQU0sQ0FBQztRQUNoRSxJQUFJcUQsZUFBZSxHQUFHLE9BQU9BO1FBRTdCLG1CQUFtQjtRQUNuQixNQUFNQyxXQUFXSCxFQUFFdEQsSUFBSSxDQUFDMEQsYUFBYSxDQUFDSCxFQUFFdkQsSUFBSTtRQUM1QyxJQUFJeUQsYUFBYSxHQUFHLE9BQU9BO1FBRTNCLDRCQUE0QjtRQUM1QixPQUFPSCxFQUFFckQsU0FBUyxDQUFDeUQsYUFBYSxDQUFDSCxFQUFFdEQsU0FBUztJQUM5QztBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxkZXBzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExhbmd1YWdlLCBEZXBlbmRlbmN5RmluZGluZywgU3RhdHVzIH0gZnJvbSAnLi9iYXNlbGluZS50eXBlcyc7XHJcbmltcG9ydCB7IEJhc2VsaW5lUnVsZXMgfSBmcm9tICcuL2Jhc2VsaW5lLnR5cGVzJztcclxuaW1wb3J0IHsgY29tcGFyZVZlcnNpb25zIH0gZnJvbSAnLi9jb21wYXJlJztcclxuXHJcbi8qKlxyXG4gKiBBbmFseXplIGRlcGVuZGVuY2llcyBmcm9tIHByb2plY3QgbWFuaWZlc3RzXHJcbiAqIEBwYXJhbSBtYW5pZmVzdHMgQXJyYXkgb2YgcHJvamVjdCBtYW5pZmVzdHNcclxuICogQHBhcmFtIHJ1bGVzIEJhc2VsaW5lIHJ1bGVzXHJcbiAqIEByZXR1cm5zIEFycmF5IG9mIGRlcGVuZGVuY3kgZmluZGluZ3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhbmFseXplRGVwZW5kZW5jaWVzKFxyXG4gIG1hbmlmZXN0czogQXJyYXk8eyBsYW5ndWFnZTogTGFuZ3VhZ2U7IGZpbGU6IHN0cmluZzsgZGVwZW5kZW5jaWVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB9PixcclxuICBydWxlczogQmFzZWxpbmVSdWxlc1xyXG4pOiBEZXBlbmRlbmN5RmluZGluZ1tdIHtcclxuICBjb25zdCBmaW5kaW5nczogRGVwZW5kZW5jeUZpbmRpbmdbXSA9IFtdO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgbWFuaWZlc3Qgb2YgbWFuaWZlc3RzKSB7XHJcbiAgICBpZiAoIW1hbmlmZXN0LmRlcGVuZGVuY2llcykgY29udGludWU7XHJcbiAgICBcclxuICAgIGNvbnN0IGxhbmd1YWdlUnVsZXMgPSBydWxlcy5wYWNrYWdlX21pbnNbbWFuaWZlc3QubGFuZ3VhZ2VdIHx8IHt9O1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IFtwYWNrYWdlTmFtZSwgZm91bmRWZXJzaW9uXSBvZiBPYmplY3QuZW50cmllcyhtYW5pZmVzdC5kZXBlbmRlbmNpZXMpKSB7XHJcbiAgICAgIGNvbnN0IGJhc2VsaW5lVmVyc2lvbiA9IGxhbmd1YWdlUnVsZXNbcGFja2FnZU5hbWVdO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFiYXNlbGluZVZlcnNpb24pIHtcclxuICAgICAgICAvLyBObyBiYXNlbGluZSBydWxlIGZvciB0aGlzIHBhY2thZ2VcclxuICAgICAgICBmaW5kaW5ncy5wdXNoKHtcclxuICAgICAgICAgIGtpbmQ6ICdkZXBlbmRlbmN5JyxcclxuICAgICAgICAgIGxhbmc6IG1hbmlmZXN0Lmxhbmd1YWdlLFxyXG4gICAgICAgICAgY29tcG9uZW50OiBwYWNrYWdlTmFtZSxcclxuICAgICAgICAgIGZvdW5kVmVyc2lvbixcclxuICAgICAgICAgIGJhc2VsaW5lUmVxdWlyZWQ6IG51bGwsXHJcbiAgICAgICAgICBzdGF0dXM6ICd1bmtub3duJyxcclxuICAgICAgICAgIHJlYXNvbjogJ25vLWJhc2VsaW5lLXJ1bGUnLFxyXG4gICAgICAgICAgZmlsZTogbWFuaWZlc3QuZmlsZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQ29tcGFyZSB2ZXJzaW9uc1xyXG4gICAgICBjb25zdCBjb21wYXJpc29uID0gY29tcGFyZVZlcnNpb25zKGZvdW5kVmVyc2lvbiwgYmFzZWxpbmVWZXJzaW9uLCBtYW5pZmVzdC5sYW5ndWFnZSk7XHJcbiAgICAgIFxyXG4gICAgICBsZXQgc3RhdHVzOiBTdGF0dXM7XHJcbiAgICAgIGxldCByZWFzb246IHN0cmluZztcclxuICAgICAgXHJcbiAgICAgIHN3aXRjaCAoY29tcGFyaXNvbikge1xyXG4gICAgICAgIGNhc2UgJ2dyZWF0ZXInOlxyXG4gICAgICAgIGNhc2UgJ2VxdWFsJzpcclxuICAgICAgICAgIHN0YXR1cyA9ICdvayc7XHJcbiAgICAgICAgICByZWFzb24gPSAnbWVldHMtYmFzZWxpbmUnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbGVzcyc6XHJcbiAgICAgICAgICBzdGF0dXMgPSAnYWZmZWN0ZWQnO1xyXG4gICAgICAgICAgcmVhc29uID0gJ2JlbG93LWJhc2VsaW5lJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3Vua25vd24nOlxyXG4gICAgICAgICAgc3RhdHVzID0gJ3Vua25vd24nO1xyXG4gICAgICAgICAgcmVhc29uID0gJ3ZlcnNpb24tcGFyc2UtZXJyb3InO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHN0YXR1cyA9ICd1bmtub3duJztcclxuICAgICAgICAgIHJlYXNvbiA9ICd1bmtub3duLWNvbXBhcmlzb24nO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBmaW5kaW5ncy5wdXNoKHtcclxuICAgICAgICBraW5kOiAnZGVwZW5kZW5jeScsXHJcbiAgICAgICAgbGFuZzogbWFuaWZlc3QubGFuZ3VhZ2UsXHJcbiAgICAgICAgY29tcG9uZW50OiBwYWNrYWdlTmFtZSxcclxuICAgICAgICBmb3VuZFZlcnNpb24sXHJcbiAgICAgICAgYmFzZWxpbmVSZXF1aXJlZDogYmFzZWxpbmVWZXJzaW9uLFxyXG4gICAgICAgIHN0YXR1cyxcclxuICAgICAgICByZWFzb24sXHJcbiAgICAgICAgZmlsZTogbWFuaWZlc3QuZmlsZSxcclxuICAgICAgICBxdWlja0ZpeDogZ2V0RGVwZW5kZW5jeVF1aWNrRml4KHJ1bGVzLCBtYW5pZmVzdC5sYW5ndWFnZSwgcGFja2FnZU5hbWUsIGJhc2VsaW5lVmVyc2lvbiksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gZmluZGluZ3M7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgcXVpY2sgZml4IGZvciBkZXBlbmRlbmN5IHVwZ3JhZGVcclxuICogQHBhcmFtIHJ1bGVzIEJhc2VsaW5lIHJ1bGVzXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZVxyXG4gKiBAcGFyYW0gcGFja2FnZU5hbWUgUGFja2FnZSBuYW1lXHJcbiAqIEBwYXJhbSB2ZXJzaW9uIFJlcXVpcmVkIHZlcnNpb25cclxuICogQHJldHVybnMgUXVpY2sgZml4IHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeVF1aWNrRml4KFxyXG4gIHJ1bGVzOiBCYXNlbGluZVJ1bGVzLFxyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZSxcclxuICBwYWNrYWdlTmFtZTogc3RyaW5nLFxyXG4gIHZlcnNpb246IHN0cmluZ1xyXG4pOiBzdHJpbmcge1xyXG4gIGNvbnN0IHRlbXBsYXRlID0gcnVsZXMucXVpY2tfZml4ZXMuZGVwZW5kZW5jeV91cGdyYWRlW2xhbmd1YWdlXSB8fCAnVXBkYXRlIHtwYWNrYWdlfSB0byB7dmVyc2lvbn0nO1xyXG4gIFxyXG4gIHJldHVybiB0ZW1wbGF0ZVxyXG4gICAgLnJlcGxhY2UoJ3twYWNrYWdlfScsIHBhY2thZ2VOYW1lKVxyXG4gICAgLnJlcGxhY2UoJ3t2ZXJzaW9ufScsIHZlcnNpb24pO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgdmVyc2lvbiBzdHJpbmcgYW5kIGV4dHJhY3QgdmVyc2lvbiBudW1iZXJcclxuICogQHBhcmFtIHZlcnNpb25TdHJpbmcgVmVyc2lvbiBzdHJpbmcgKG1heSBjb250YWluIG9wZXJhdG9ycylcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgQ2xlYW4gdmVyc2lvbiBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVZlcnNpb24odmVyc2lvblN0cmluZzogc3RyaW5nLCBsYW5ndWFnZTogTGFuZ3VhZ2UpOiBzdHJpbmcge1xyXG4gIGlmICghdmVyc2lvblN0cmluZyB8fCB2ZXJzaW9uU3RyaW5nID09PSAnKicpIHtcclxuICAgIHJldHVybiAnMC4wLjAnO1xyXG4gIH1cclxuICBcclxuICAvLyBSZW1vdmUgY29tbW9uIG9wZXJhdG9ycyBhbmQgcHJlZml4ZXNcclxuICBsZXQgY2xlYW4gPSB2ZXJzaW9uU3RyaW5nXHJcbiAgICAucmVwbGFjZSgvXlt+Xj49PCE9XSsvLCAnJykgLy8gUmVtb3ZlIG9wZXJhdG9yc1xyXG4gICAgLnJlcGxhY2UoL152LywgJycpIC8vIFJlbW92ZSB2IHByZWZpeFxyXG4gICAgLnRyaW0oKTtcclxuICBcclxuICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlc1xyXG4gIGlmIChjbGVhbiA9PT0gJ2xhdGVzdCcgfHwgY2xlYW4gPT09ICcnKSB7XHJcbiAgICByZXR1cm4gJzAuMC4wJztcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIFB5dGhvbiB2ZXJzaW9uIHNwZWNpZmllcnNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdweXRob24nKSB7XHJcbiAgICAvLyBSZW1vdmUgUHl0aG9uLXNwZWNpZmljIG9wZXJhdG9yc1xyXG4gICAgY2xlYW4gPSBjbGVhbi5yZXBsYWNlKC9eW349ITw+XSsvLCAnJyk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBHbyB2ZXJzaW9uIHN1ZmZpeGVzXHJcbiAgaWYgKGxhbmd1YWdlID09PSAnZ28nKSB7XHJcbiAgICAvLyBSZW1vdmUgK2luY29tcGF0aWJsZSwgK2luY29tcGF0aWJsZS4yMDIxMDEwMSwgZXRjLlxyXG4gICAgY2xlYW4gPSBjbGVhbi5yZXBsYWNlKC9cXCsuKiQvLCAnJyk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBKYXZhIHZlcnNpb24gcmFuZ2VzXHJcbiAgaWYgKGxhbmd1YWdlID09PSAnamF2YScpIHtcclxuICAgIC8vIEV4dHJhY3QgdmVyc2lvbiBmcm9tIHJhbmdlcyBsaWtlIFsxLjAsMi4wKSBvciAoMS4wLDIuMF1cclxuICAgIGNvbnN0IHJhbmdlTWF0Y2ggPSBjbGVhbi5tYXRjaCgvW1xcW1xcKF0oW14sXSspLC8pO1xyXG4gICAgaWYgKHJhbmdlTWF0Y2gpIHtcclxuICAgICAgY2xlYW4gPSByYW5nZU1hdGNoWzFdO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gY2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZlcnNpb24gc3RyaW5nIGlzIHZhbGlkXHJcbiAqIEBwYXJhbSB2ZXJzaW9uU3RyaW5nIFZlcnNpb24gc3RyaW5nXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdmFsaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkVmVyc2lvbih2ZXJzaW9uU3RyaW5nOiBzdHJpbmcsIGxhbmd1YWdlOiBMYW5ndWFnZSk6IGJvb2xlYW4ge1xyXG4gIGlmICghdmVyc2lvblN0cmluZyB8fCB2ZXJzaW9uU3RyaW5nID09PSAnKicpIHJldHVybiBmYWxzZTtcclxuICBcclxuICBjb25zdCBjbGVhbiA9IHBhcnNlVmVyc2lvbih2ZXJzaW9uU3RyaW5nLCBsYW5ndWFnZSk7XHJcbiAgXHJcbiAgLy8gQmFzaWMgdmVyc2lvbiBwYXR0ZXJuIHZhbGlkYXRpb25cclxuICBjb25zdCB2ZXJzaW9uUGF0dGVybnMgPSB7XHJcbiAgICBub2RlOiAvXlxcZCtcXC5cXGQrXFwuXFxkKygtW2EtekEtWjAtOS4tXSspPyhcXCtbYS16QS1aMC05Li1dKyk/JC8sXHJcbiAgICBweXRob246IC9eXFxkK1xcLlxcZCsoXFwuXFxkKyk/KFthLXpBLVowLTkuLV0rKT8kLyxcclxuICAgIGphdmE6IC9eXFxkKyhcXC5cXGQrKSooLVthLXpBLVowLTkuLV0rKT8kLyxcclxuICAgIGdvOiAvXnY/XFxkK1xcLlxcZCtcXC5cXGQrKC1bYS16QS1aMC05Li1dKyk/KFxcK1thLXpBLVowLTkuLV0rKT8kLyxcclxuICAgIGRvdG5ldDogL15cXGQrXFwuXFxkKyhcXC5cXGQrKT8oLVthLXpBLVowLTkuLV0rKT8kLyxcclxuICB9O1xyXG4gIFxyXG4gIGNvbnN0IHBhdHRlcm4gPSB2ZXJzaW9uUGF0dGVybnNbbGFuZ3VhZ2VdO1xyXG4gIHJldHVybiBwYXR0ZXJuID8gcGF0dGVybi50ZXN0KGNsZWFuKSA6IGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIHBhY2thZ2UgbmFtZSBmb3IgY29tcGFyaXNvblxyXG4gKiBAcGFyYW0gcGFja2FnZU5hbWUgUGFja2FnZSBuYW1lXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgcGFja2FnZSBuYW1lXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUGFja2FnZU5hbWUocGFja2FnZU5hbWU6IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogc3RyaW5nIHtcclxuICBsZXQgbm9ybWFsaXplZCA9IHBhY2thZ2VOYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSBzY29wZWQgcGFja2FnZXMgKE5vZGUuanMpXHJcbiAgaWYgKGxhbmd1YWdlID09PSAnbm9kZScgJiYgbm9ybWFsaXplZC5zdGFydHNXaXRoKCdAJykpIHtcclxuICAgIC8vIEtlZXAgQHNjb3BlL3BhY2thZ2UgZm9ybWF0XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIEphdmEgZ3JvdXA6YXJ0aWZhY3QgZm9ybWF0XHJcbiAgaWYgKGxhbmd1YWdlID09PSAnamF2YScgJiYgbm9ybWFsaXplZC5pbmNsdWRlcygnOicpKSB7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIEdvIG1vZHVsZXNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdnbycpIHtcclxuICAgIC8vIFJlbW92ZSBjb21tb24gcHJlZml4ZXNcclxuICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLnJlcGxhY2UoL15naXRodWJcXC5jb21cXC8vLCAnJyk7XHJcbiAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9eZ29sYW5nXFwub3JnXFwveFxcLy8sICcnKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIC5ORVQgcGFja2FnZXNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdkb3RuZXQnKSB7XHJcbiAgICAvLyBSZW1vdmUgY29tbW9uIHByZWZpeGVzXHJcbiAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9ebWljcm9zb2Z0XFwuLywgJycpO1xyXG4gICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXnN5c3RlbVxcLi8sICcnKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHBhY2thZ2UgaXMgaW4gdGhlIGJhc2VsaW5lIHJ1bGVzXHJcbiAqIEBwYXJhbSBwYWNrYWdlTmFtZSBQYWNrYWdlIG5hbWVcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHBhY2thZ2UgaGFzIGJhc2VsaW5lIHJ1bGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzQmFzZWxpbmVSdWxlKFxyXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlLFxyXG4gIHJ1bGVzOiBCYXNlbGluZVJ1bGVzXHJcbik6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IGxhbmd1YWdlUnVsZXMgPSBydWxlcy5wYWNrYWdlX21pbnNbbGFuZ3VhZ2VdIHx8IHt9O1xyXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQYWNrYWdlTmFtZShwYWNrYWdlTmFtZSwgbGFuZ3VhZ2UpO1xyXG4gIFxyXG4gIC8vIENoZWNrIGV4YWN0IG1hdGNoIGZpcnN0XHJcbiAgaWYgKGxhbmd1YWdlUnVsZXNbcGFja2FnZU5hbWVdKSByZXR1cm4gdHJ1ZTtcclxuICBpZiAobGFuZ3VhZ2VSdWxlc1tub3JtYWxpemVkXSkgcmV0dXJuIHRydWU7XHJcbiAgXHJcbiAgLy8gQ2hlY2sgZm9yIHBhcnRpYWwgbWF0Y2hlcyAoZm9yIHNjb3BlZCBwYWNrYWdlcywgZXRjLilcclxuICBmb3IgKGNvbnN0IFtydWxlUGFja2FnZSwgX10gb2YgT2JqZWN0LmVudHJpZXMobGFuZ3VhZ2VSdWxlcykpIHtcclxuICAgIGlmIChub3JtYWxpemVQYWNrYWdlTmFtZShydWxlUGFja2FnZSwgbGFuZ3VhZ2UpID09PSBub3JtYWxpemVkKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYmFzZWxpbmUgdmVyc2lvbiBmb3IgYSBwYWNrYWdlXHJcbiAqIEBwYXJhbSBwYWNrYWdlTmFtZSBQYWNrYWdlIG5hbWVcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcmV0dXJucyBCYXNlbGluZSB2ZXJzaW9uIG9yIG51bGxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXNlbGluZVZlcnNpb24oXHJcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2UsXHJcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNcclxuKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgY29uc3QgbGFuZ3VhZ2VSdWxlcyA9IHJ1bGVzLnBhY2thZ2VfbWluc1tsYW5ndWFnZV0gfHwge307XHJcbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVBhY2thZ2VOYW1lKHBhY2thZ2VOYW1lLCBsYW5ndWFnZSk7XHJcbiAgXHJcbiAgLy8gQ2hlY2sgZXhhY3QgbWF0Y2ggZmlyc3RcclxuICBpZiAobGFuZ3VhZ2VSdWxlc1twYWNrYWdlTmFtZV0pIHJldHVybiBsYW5ndWFnZVJ1bGVzW3BhY2thZ2VOYW1lXTtcclxuICBpZiAobGFuZ3VhZ2VSdWxlc1tub3JtYWxpemVkXSkgcmV0dXJuIGxhbmd1YWdlUnVsZXNbbm9ybWFsaXplZF07XHJcbiAgXHJcbiAgLy8gQ2hlY2sgZm9yIHBhcnRpYWwgbWF0Y2hlc1xyXG4gIGZvciAoY29uc3QgW3J1bGVQYWNrYWdlLCB2ZXJzaW9uXSBvZiBPYmplY3QuZW50cmllcyhsYW5ndWFnZVJ1bGVzKSkge1xyXG4gICAgaWYgKG5vcm1hbGl6ZVBhY2thZ2VOYW1lKHJ1bGVQYWNrYWdlLCBsYW5ndWFnZSkgPT09IG5vcm1hbGl6ZWQpIHtcclxuICAgICAgcmV0dXJuIHZlcnNpb247XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogR3JvdXAgZGVwZW5kZW5jaWVzIGJ5IHN0YXR1c1xyXG4gKiBAcGFyYW0gZmluZGluZ3MgRGVwZW5kZW5jeSBmaW5kaW5nc1xyXG4gKiBAcmV0dXJucyBHcm91cGVkIGZpbmRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBEZXBlbmRlbmNpZXNCeVN0YXR1cyhmaW5kaW5nczogRGVwZW5kZW5jeUZpbmRpbmdbXSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBvazogZmluZGluZ3MuZmlsdGVyKGYgPT4gZi5zdGF0dXMgPT09ICdvaycpLFxyXG4gICAgYWZmZWN0ZWQ6IGZpbmRpbmdzLmZpbHRlcihmID0+IGYuc3RhdHVzID09PSAnYWZmZWN0ZWQnKSxcclxuICAgIHVua25vd246IGZpbmRpbmdzLmZpbHRlcihmID0+IGYuc3RhdHVzID09PSAndW5rbm93bicpLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZGVwZW5kZW5jeSBzdW1tYXJ5IHN0YXRpc3RpY3NcclxuICogQHBhcmFtIGZpbmRpbmdzIERlcGVuZGVuY3kgZmluZGluZ3NcclxuICogQHJldHVybnMgU3VtbWFyeSBzdGF0aXN0aWNzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeVN1bW1hcnkoZmluZGluZ3M6IERlcGVuZGVuY3lGaW5kaW5nW10pIHtcclxuICBjb25zdCB0b3RhbCA9IGZpbmRpbmdzLmxlbmd0aDtcclxuICBjb25zdCBvayA9IGZpbmRpbmdzLmZpbHRlcihmID0+IGYuc3RhdHVzID09PSAnb2snKS5sZW5ndGg7XHJcbiAgY29uc3QgYWZmZWN0ZWQgPSBmaW5kaW5ncy5maWx0ZXIoZiA9PiBmLnN0YXR1cyA9PT0gJ2FmZmVjdGVkJykubGVuZ3RoO1xyXG4gIGNvbnN0IHVua25vd24gPSBmaW5kaW5ncy5maWx0ZXIoZiA9PiBmLnN0YXR1cyA9PT0gJ3Vua25vd24nKS5sZW5ndGg7XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIHRvdGFsLFxyXG4gICAgb2ssXHJcbiAgICBhZmZlY3RlZCxcclxuICAgIHVua25vd24sXHJcbiAgICBva1BlcmNlbnRhZ2U6IHRvdGFsID4gMCA/IChvayAvIHRvdGFsKSAqIDEwMCA6IDAsXHJcbiAgICBhZmZlY3RlZFBlcmNlbnRhZ2U6IHRvdGFsID4gMCA/IChhZmZlY3RlZCAvIHRvdGFsKSAqIDEwMCA6IDAsXHJcbiAgICB1bmtub3duUGVyY2VudGFnZTogdG90YWwgPiAwID8gKHVua25vd24gLyB0b3RhbCkgKiAxMDAgOiAwLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaWx0ZXIgZGVwZW5kZW5jaWVzIGJ5IGxhbmd1YWdlXHJcbiAqIEBwYXJhbSBmaW5kaW5ncyBEZXBlbmRlbmN5IGZpbmRpbmdzXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSB0byBmaWx0ZXIgYnlcclxuICogQHJldHVybnMgRmlsdGVyZWQgZmluZGluZ3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJEZXBlbmRlbmNpZXNCeUxhbmd1YWdlKFxyXG4gIGZpbmRpbmdzOiBEZXBlbmRlbmN5RmluZGluZ1tdLFxyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxyXG4pOiBEZXBlbmRlbmN5RmluZGluZ1tdIHtcclxuICByZXR1cm4gZmluZGluZ3MuZmlsdGVyKGYgPT4gZi5sYW5nID09PSBsYW5ndWFnZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTb3J0IGRlcGVuZGVuY2llcyBieSBzdGF0dXMgYW5kIG5hbWVcclxuICogQHBhcmFtIGZpbmRpbmdzIERlcGVuZGVuY3kgZmluZGluZ3NcclxuICogQHJldHVybnMgU29ydGVkIGZpbmRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29ydERlcGVuZGVuY2llcyhmaW5kaW5nczogRGVwZW5kZW5jeUZpbmRpbmdbXSk6IERlcGVuZGVuY3lGaW5kaW5nW10ge1xyXG4gIGNvbnN0IHN0YXR1c09yZGVyID0geyBhZmZlY3RlZDogMCwgdW5rbm93bjogMSwgb2s6IDIgfTtcclxuICBcclxuICByZXR1cm4gWy4uLmZpbmRpbmdzXS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAvLyBGaXJzdCBieSBzdGF0dXNcclxuICAgIGNvbnN0IHN0YXR1c0RpZmYgPSBzdGF0dXNPcmRlclthLnN0YXR1c10gLSBzdGF0dXNPcmRlcltiLnN0YXR1c107XHJcbiAgICBpZiAoc3RhdHVzRGlmZiAhPT0gMCkgcmV0dXJuIHN0YXR1c0RpZmY7XHJcbiAgICBcclxuICAgIC8vIFRoZW4gYnkgbGFuZ3VhZ2VcclxuICAgIGNvbnN0IGxhbmdEaWZmID0gYS5sYW5nLmxvY2FsZUNvbXBhcmUoYi5sYW5nKTtcclxuICAgIGlmIChsYW5nRGlmZiAhPT0gMCkgcmV0dXJuIGxhbmdEaWZmO1xyXG4gICAgXHJcbiAgICAvLyBGaW5hbGx5IGJ5IGNvbXBvbmVudCBuYW1lXHJcbiAgICByZXR1cm4gYS5jb21wb25lbnQubG9jYWxlQ29tcGFyZShiLmNvbXBvbmVudCk7XHJcbiAgfSk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNvbXBhcmVWZXJzaW9ucyIsImFuYWx5emVEZXBlbmRlbmNpZXMiLCJtYW5pZmVzdHMiLCJydWxlcyIsImZpbmRpbmdzIiwibWFuaWZlc3QiLCJkZXBlbmRlbmNpZXMiLCJsYW5ndWFnZVJ1bGVzIiwicGFja2FnZV9taW5zIiwibGFuZ3VhZ2UiLCJwYWNrYWdlTmFtZSIsImZvdW5kVmVyc2lvbiIsIk9iamVjdCIsImVudHJpZXMiLCJiYXNlbGluZVZlcnNpb24iLCJwdXNoIiwia2luZCIsImxhbmciLCJjb21wb25lbnQiLCJiYXNlbGluZVJlcXVpcmVkIiwic3RhdHVzIiwicmVhc29uIiwiZmlsZSIsImNvbXBhcmlzb24iLCJxdWlja0ZpeCIsImdldERlcGVuZGVuY3lRdWlja0ZpeCIsInZlcnNpb24iLCJ0ZW1wbGF0ZSIsInF1aWNrX2ZpeGVzIiwiZGVwZW5kZW5jeV91cGdyYWRlIiwicmVwbGFjZSIsInBhcnNlVmVyc2lvbiIsInZlcnNpb25TdHJpbmciLCJjbGVhbiIsInRyaW0iLCJyYW5nZU1hdGNoIiwibWF0Y2giLCJpc1ZhbGlkVmVyc2lvbiIsInZlcnNpb25QYXR0ZXJucyIsIm5vZGUiLCJweXRob24iLCJqYXZhIiwiZ28iLCJkb3RuZXQiLCJwYXR0ZXJuIiwidGVzdCIsIm5vcm1hbGl6ZVBhY2thZ2VOYW1lIiwibm9ybWFsaXplZCIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwiaGFzQmFzZWxpbmVSdWxlIiwicnVsZVBhY2thZ2UiLCJfIiwiZ2V0QmFzZWxpbmVWZXJzaW9uIiwiZ3JvdXBEZXBlbmRlbmNpZXNCeVN0YXR1cyIsIm9rIiwiZmlsdGVyIiwiZiIsImFmZmVjdGVkIiwidW5rbm93biIsImdldERlcGVuZGVuY3lTdW1tYXJ5IiwidG90YWwiLCJsZW5ndGgiLCJva1BlcmNlbnRhZ2UiLCJhZmZlY3RlZFBlcmNlbnRhZ2UiLCJ1bmtub3duUGVyY2VudGFnZSIsImZpbHRlckRlcGVuZGVuY2llc0J5TGFuZ3VhZ2UiLCJzb3J0RGVwZW5kZW5jaWVzIiwic3RhdHVzT3JkZXIiLCJzb3J0IiwiYSIsImIiLCJzdGF0dXNEaWZmIiwibGFuZ0RpZmYiLCJsb2NhbGVDb21wYXJlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./lib/analysis/deps.ts\n");

/***/ }),

/***/ "(api-node)/./lib/analysis/detect.ts":
/*!********************************!*\
  !*** ./lib/analysis/detect.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectLanguagesFromFiles: () => (/* binding */ detectLanguagesFromFiles),\n/* harmony export */   detectProjectManifests: () => (/* binding */ detectProjectManifests),\n/* harmony export */   getManifestType: () => (/* binding */ getManifestType),\n/* harmony export */   getPrimaryLanguage: () => (/* binding */ getPrimaryLanguage),\n/* harmony export */   isManifestFile: () => (/* binding */ isManifestFile)\n/* harmony export */ });\n/**\r\n * Detect project languages and manifests from extracted files\r\n * @param files Array of extracted files\r\n * @returns Array of detected project manifests\r\n */ function detectProjectManifests(files) {\n    const manifests = [];\n    // Look for package.json (Node.js)\n    const packageJson = files.find((f)=>(f.path || f.name)?.endsWith('package.json'));\n    if (packageJson) {\n        try {\n            const pkg = JSON.parse(packageJson.content);\n            manifests.push({\n                language: 'node',\n                file: packageJson.path || packageJson.name,\n                dependencies: pkg.dependencies,\n                devDependencies: pkg.devDependencies,\n                peerDependencies: pkg.peerDependencies,\n                optionalDependencies: pkg.optionalDependencies\n            });\n        } catch (error) {\n            console.warn(`Failed to parse package.json: ${error}`);\n        }\n    }\n    // Look for requirements.txt (Python)\n    const requirementsTxt = files.find((f)=>(f.path || f.name)?.endsWith('requirements.txt'));\n    if (requirementsTxt) {\n        manifests.push({\n            language: 'python',\n            file: requirementsTxt.path || requirementsTxt.name,\n            dependencies: parseRequirementsTxt(requirementsTxt.content)\n        });\n    }\n    // Look for pyproject.toml (Python)\n    const pyprojectToml = files.find((f)=>(f.path || f.name)?.endsWith('pyproject.toml'));\n    if (pyprojectToml) {\n        try {\n            const deps = parsePyprojectToml(pyprojectToml.content);\n            if (deps) {\n                manifests.push({\n                    language: 'python',\n                    file: pyprojectToml.path || pyprojectToml.name,\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse pyproject.toml: ${error}`);\n        }\n    }\n    // Look for pom.xml (Java Maven)\n    const pomXml = files.find((f)=>(f.path || f.name)?.endsWith('pom.xml'));\n    if (pomXml) {\n        try {\n            const deps = parsePomXml(pomXml.content);\n            if (deps) {\n                manifests.push({\n                    language: 'java',\n                    file: pomXml.path || pomXml.name,\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse pom.xml: ${error}`);\n        }\n    }\n    // Look for build.gradle (Java Gradle)\n    const buildGradle = files.find((f)=>{\n        const path = f.path || f.name;\n        return path?.endsWith('build.gradle') || path?.endsWith('build.gradle.kts');\n    });\n    if (buildGradle) {\n        try {\n            const deps = parseBuildGradle(buildGradle.content);\n            if (deps) {\n                manifests.push({\n                    language: 'java',\n                    file: buildGradle.path || buildGradle.name,\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse build.gradle: ${error}`);\n        }\n    }\n    // Look for go.mod (Go)\n    const goMod = files.find((f)=>(f.path || f.name)?.endsWith('go.mod'));\n    if (goMod) {\n        try {\n            const deps = parseGoMod(goMod.content);\n            if (deps) {\n                manifests.push({\n                    language: 'go',\n                    file: goMod.path || goMod.name,\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse go.mod: ${error}`);\n        }\n    }\n    // Look for .csproj files (.NET)\n    const csprojFiles = files.filter((f)=>(f.path || f.name)?.endsWith('.csproj'));\n    for (const csproj of csprojFiles){\n        try {\n            const deps = parseCsproj(csproj.content);\n            if (deps) {\n                manifests.push({\n                    language: 'dotnet',\n                    file: csproj.path || csproj.name,\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse ${csproj.path || csproj.name}: ${error}`);\n        }\n    }\n    return manifests;\n}\n/**\r\n * Parse requirements.txt content\r\n * @param content requirements.txt content\r\n * @returns Dependencies object\r\n */ function parseRequirementsTxt(content) {\n    const deps = {};\n    const lines = content.split('\\n');\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (!trimmed || trimmed.startsWith('#')) continue;\n        // Handle various requirement formats\n        // package==1.0.0\n        // package>=1.0.0\n        // package~=1.0.0\n        // package\n        const match = trimmed.match(/^([a-zA-Z0-9_-]+)(.*)$/);\n        if (match) {\n            const [, name, version] = match;\n            deps[name] = version || '*';\n        }\n    }\n    return deps;\n}\n/**\r\n * Parse pyproject.toml content (basic parsing)\r\n * @param content pyproject.toml content\r\n * @returns Dependencies object or null\r\n */ function parsePyprojectToml(content) {\n    const deps = {};\n    // Simple TOML parsing for dependencies\n    const lines = content.split('\\n');\n    let inDependencies = false;\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (trimmed.startsWith('[tool.poetry.dependencies]') || trimmed.startsWith('[project.dependencies]') || trimmed.startsWith('[dependencies]')) {\n            inDependencies = true;\n            continue;\n        }\n        if (trimmed.startsWith('[') && inDependencies) {\n            break;\n        }\n        if (inDependencies && trimmed && !trimmed.startsWith('#')) {\n            const match = trimmed.match(/^([a-zA-Z0-9_-]+)\\s*=\\s*[\"']?([^\"']+)[\"']?/);\n            if (match) {\n                const [, name, version] = match;\n                deps[name] = version;\n            }\n        }\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse pom.xml content (basic XML parsing)\r\n * @param content pom.xml content\r\n * @returns Dependencies object or null\r\n */ function parsePomXml(content) {\n    const deps = {};\n    // Simple XML parsing for dependencies\n    const dependencyRegex = /<dependency>\\s*<groupId>([^<]+)<\\/groupId>\\s*<artifactId>([^<]+)<\\/artifactId>\\s*<version>([^<]+)<\\/version>/g;\n    let match;\n    while((match = dependencyRegex.exec(content)) !== null){\n        const [, groupId, artifactId, version] = match;\n        const fullName = `${groupId}:${artifactId}`;\n        deps[fullName] = version;\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse build.gradle content (basic parsing)\r\n * @param content build.gradle content\r\n * @returns Dependencies object or null\r\n */ function parseBuildGradle(content) {\n    const deps = {};\n    // Simple Gradle parsing for dependencies\n    const lines = content.split('\\n');\n    let inDependencies = false;\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (trimmed.includes('dependencies') && trimmed.includes('{')) {\n            inDependencies = true;\n            continue;\n        }\n        if (trimmed === '}' && inDependencies) {\n            break;\n        }\n        if (inDependencies && trimmed.includes('implementation') || trimmed.includes('compile')) {\n            // implementation 'group:artifact:version'\n            // implementation(\"group:artifact:version\")\n            const match = trimmed.match(/(?:implementation|compile)\\s*[(\"]?([^:)]+):([^:)]+):([^:)]+)/);\n            if (match) {\n                const [, group, artifact, version] = match;\n                const fullName = `${group}:${artifact}`;\n                deps[fullName] = version;\n            }\n        }\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse go.mod content\r\n * @param content go.mod content\r\n * @returns Dependencies object or null\r\n */ function parseGoMod(content) {\n    const deps = {};\n    const lines = content.split('\\n');\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (trimmed.startsWith('require')) {\n            continue;\n        }\n        if (trimmed.startsWith('require ')) {\n            // require module v1.0.0\n            const match = trimmed.match(/require\\s+([^\\s]+)\\s+([^\\s]+)/);\n            if (match) {\n                const [, module, version] = match;\n                deps[module] = version;\n            }\n        } else if (trimmed && !trimmed.startsWith('go ') && !trimmed.startsWith('module ') && !trimmed.startsWith('//')) {\n            // Module version line\n            const match = trimmed.match(/^([^\\s]+)\\s+([^\\s]+)/);\n            if (match) {\n                const [, module, version] = match;\n                deps[module] = version;\n            }\n        }\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse .csproj content (basic XML parsing)\r\n * @param content .csproj content\r\n * @returns Dependencies object or null\r\n */ function parseCsproj(content) {\n    const deps = {};\n    // Simple XML parsing for PackageReference\n    const packageRefRegex = /<PackageReference\\s+Include=\"([^\"]+)\"\\s+Version=\"([^\"]+)\"\\s*\\/?>/g;\n    let match;\n    while((match = packageRefRegex.exec(content)) !== null){\n        const [, packageName, version] = match;\n        deps[packageName] = version;\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Detect languages from file extensions\r\n * @param files Array of extracted files\r\n * @returns Array of detected languages\r\n */ function detectLanguagesFromFiles(files) {\n    const languageMap = {\n        '.js': 'node',\n        '.jsx': 'node',\n        '.ts': 'node',\n        '.tsx': 'node',\n        '.py': 'python',\n        '.java': 'java',\n        '.go': 'go',\n        '.cs': 'dotnet',\n        '.fs': 'dotnet',\n        '.vb': 'dotnet'\n    };\n    const detectedLanguages = new Set();\n    for (const file of files){\n        const filePath = file.path || file.name;\n        if (filePath) {\n            const ext = getFileExtension(filePath);\n            const language = languageMap[ext];\n            if (language) {\n                detectedLanguages.add(language);\n            }\n        }\n    }\n    return Array.from(detectedLanguages);\n}\n/**\r\n * Get file extension from path\r\n * @param filePath File path\r\n * @returns File extension with dot\r\n */ function getFileExtension(filePath) {\n    const lastDot = filePath.lastIndexOf('.');\n    if (lastDot === -1) return '';\n    return filePath.substring(lastDot);\n}\n/**\r\n * Get primary language from manifests\r\n * @param manifests Array of project manifests\r\n * @returns Primary language or null\r\n */ function getPrimaryLanguage(manifests) {\n    if (manifests.length === 0) return null;\n    // Priority order: node, python, java, go, dotnet\n    const priority = [\n        'node',\n        'python',\n        'java',\n        'go',\n        'dotnet'\n    ];\n    for (const lang of priority){\n        if (manifests.some((m)=>m.language === lang)) {\n            return lang;\n        }\n    }\n    return manifests[0].language;\n}\n/**\r\n * Check if a file is a manifest file\r\n * @param filePath File path\r\n * @returns True if it's a manifest file\r\n */ function isManifestFile(filePath) {\n    const manifestFiles = [\n        'package.json',\n        'requirements.txt',\n        'pyproject.toml',\n        'pom.xml',\n        'build.gradle',\n        'build.gradle.kts',\n        'go.mod',\n        '.csproj'\n    ];\n    return manifestFiles.some((manifest)=>filePath.endsWith(manifest));\n}\n/**\r\n * Get manifest file type from path\r\n * @param filePath File path\r\n * @returns Manifest type or null\r\n */ function getManifestType(filePath) {\n    if (filePath.endsWith('package.json')) {\n        return {\n            language: 'node',\n            type: 'package.json'\n        };\n    }\n    if (filePath.endsWith('requirements.txt')) {\n        return {\n            language: 'python',\n            type: 'requirements.txt'\n        };\n    }\n    if (filePath.endsWith('pyproject.toml')) {\n        return {\n            language: 'python',\n            type: 'pyproject.toml'\n        };\n    }\n    if (filePath.endsWith('pom.xml')) {\n        return {\n            language: 'java',\n            type: 'pom.xml'\n        };\n    }\n    if (filePath.endsWith('build.gradle') || filePath.endsWith('build.gradle.kts')) {\n        return {\n            language: 'java',\n            type: 'build.gradle'\n        };\n    }\n    if (filePath.endsWith('go.mod')) {\n        return {\n            language: 'go',\n            type: 'go.mod'\n        };\n    }\n    if (filePath.endsWith('.csproj')) {\n        return {\n            language: 'dotnet',\n            type: '.csproj'\n        };\n    }\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL2xpYi9hbmFseXNpcy9kZXRlY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0EsdUJBQXVCQyxLQUEwRDtJQUMvRixNQUFNQyxZQUErQixFQUFFO0lBRXZDLGtDQUFrQztJQUNsQyxNQUFNQyxjQUFjRixNQUFNRyxJQUFJLENBQUNDLENBQUFBLElBQU1BLENBQUFBLEVBQUVDLElBQUksSUFBSUQsRUFBRUUsSUFBSSxHQUFHQyxTQUFTO0lBQ2pFLElBQUlMLGFBQWE7UUFDZixJQUFJO1lBQ0YsTUFBTU0sTUFBTUMsS0FBS0MsS0FBSyxDQUFDUixZQUFZUyxPQUFPO1lBQzFDVixVQUFVVyxJQUFJLENBQUM7Z0JBQ2JDLFVBQVU7Z0JBQ1ZDLE1BQU1aLFlBQVlHLElBQUksSUFBSUgsWUFBWUksSUFBSTtnQkFDMUNTLGNBQWNQLElBQUlPLFlBQVk7Z0JBQzlCQyxpQkFBaUJSLElBQUlRLGVBQWU7Z0JBQ3BDQyxrQkFBa0JULElBQUlTLGdCQUFnQjtnQkFDdENDLHNCQUFzQlYsSUFBSVUsb0JBQW9CO1lBQ2hEO1FBQ0YsRUFBRSxPQUFPQyxPQUFPO1lBQ2RDLFFBQVFDLElBQUksQ0FBQyxDQUFDLDhCQUE4QixFQUFFRixPQUFPO1FBQ3ZEO0lBQ0Y7SUFFQSxxQ0FBcUM7SUFDckMsTUFBTUcsa0JBQWtCdEIsTUFBTUcsSUFBSSxDQUFDQyxDQUFBQSxJQUFNQSxDQUFBQSxFQUFFQyxJQUFJLElBQUlELEVBQUVFLElBQUksR0FBR0MsU0FBUztJQUNyRSxJQUFJZSxpQkFBaUI7UUFDbkJyQixVQUFVVyxJQUFJLENBQUM7WUFDYkMsVUFBVTtZQUNWQyxNQUFNUSxnQkFBZ0JqQixJQUFJLElBQUlpQixnQkFBZ0JoQixJQUFJO1lBQ2xEUyxjQUFjUSxxQkFBcUJELGdCQUFnQlgsT0FBTztRQUM1RDtJQUNGO0lBRUEsbUNBQW1DO0lBQ25DLE1BQU1hLGdCQUFnQnhCLE1BQU1HLElBQUksQ0FBQ0MsQ0FBQUEsSUFBTUEsQ0FBQUEsRUFBRUMsSUFBSSxJQUFJRCxFQUFFRSxJQUFJLEdBQUdDLFNBQVM7SUFDbkUsSUFBSWlCLGVBQWU7UUFDakIsSUFBSTtZQUNGLE1BQU1DLE9BQU9DLG1CQUFtQkYsY0FBY2IsT0FBTztZQUNyRCxJQUFJYyxNQUFNO2dCQUNSeEIsVUFBVVcsSUFBSSxDQUFDO29CQUNiQyxVQUFVO29CQUNWQyxNQUFNVSxjQUFjbkIsSUFBSSxJQUFJbUIsY0FBY2xCLElBQUk7b0JBQzlDUyxjQUFjVTtnQkFDaEI7WUFDRjtRQUNGLEVBQUUsT0FBT04sT0FBTztZQUNkQyxRQUFRQyxJQUFJLENBQUMsQ0FBQyxnQ0FBZ0MsRUFBRUYsT0FBTztRQUN6RDtJQUNGO0lBRUEsZ0NBQWdDO0lBQ2hDLE1BQU1RLFNBQVMzQixNQUFNRyxJQUFJLENBQUNDLENBQUFBLElBQU1BLENBQUFBLEVBQUVDLElBQUksSUFBSUQsRUFBRUUsSUFBSSxHQUFHQyxTQUFTO0lBQzVELElBQUlvQixRQUFRO1FBQ1YsSUFBSTtZQUNGLE1BQU1GLE9BQU9HLFlBQVlELE9BQU9oQixPQUFPO1lBQ3ZDLElBQUljLE1BQU07Z0JBQ1J4QixVQUFVVyxJQUFJLENBQUM7b0JBQ2JDLFVBQVU7b0JBQ1ZDLE1BQU1hLE9BQU90QixJQUFJLElBQUlzQixPQUFPckIsSUFBSTtvQkFDaENTLGNBQWNVO2dCQUNoQjtZQUNGO1FBQ0YsRUFBRSxPQUFPTixPQUFPO1lBQ2RDLFFBQVFDLElBQUksQ0FBQyxDQUFDLHlCQUF5QixFQUFFRixPQUFPO1FBQ2xEO0lBQ0Y7SUFFQSxzQ0FBc0M7SUFDdEMsTUFBTVUsY0FBYzdCLE1BQU1HLElBQUksQ0FBQ0MsQ0FBQUE7UUFDN0IsTUFBTUMsT0FBT0QsRUFBRUMsSUFBSSxJQUFJRCxFQUFFRSxJQUFJO1FBQzdCLE9BQU9ELE1BQU1FLFNBQVMsbUJBQW1CRixNQUFNRSxTQUFTO0lBQzFEO0lBQ0EsSUFBSXNCLGFBQWE7UUFDZixJQUFJO1lBQ0YsTUFBTUosT0FBT0ssaUJBQWlCRCxZQUFZbEIsT0FBTztZQUNqRCxJQUFJYyxNQUFNO2dCQUNSeEIsVUFBVVcsSUFBSSxDQUFDO29CQUNiQyxVQUFVO29CQUNWQyxNQUFNZSxZQUFZeEIsSUFBSSxJQUFJd0IsWUFBWXZCLElBQUk7b0JBQzFDUyxjQUFjVTtnQkFDaEI7WUFDRjtRQUNGLEVBQUUsT0FBT04sT0FBTztZQUNkQyxRQUFRQyxJQUFJLENBQUMsQ0FBQyw4QkFBOEIsRUFBRUYsT0FBTztRQUN2RDtJQUNGO0lBRUEsdUJBQXVCO0lBQ3ZCLE1BQU1ZLFFBQVEvQixNQUFNRyxJQUFJLENBQUNDLENBQUFBLElBQU1BLENBQUFBLEVBQUVDLElBQUksSUFBSUQsRUFBRUUsSUFBSSxHQUFHQyxTQUFTO0lBQzNELElBQUl3QixPQUFPO1FBQ1QsSUFBSTtZQUNGLE1BQU1OLE9BQU9PLFdBQVdELE1BQU1wQixPQUFPO1lBQ3JDLElBQUljLE1BQU07Z0JBQ1J4QixVQUFVVyxJQUFJLENBQUM7b0JBQ2JDLFVBQVU7b0JBQ1ZDLE1BQU1pQixNQUFNMUIsSUFBSSxJQUFJMEIsTUFBTXpCLElBQUk7b0JBQzlCUyxjQUFjVTtnQkFDaEI7WUFDRjtRQUNGLEVBQUUsT0FBT04sT0FBTztZQUNkQyxRQUFRQyxJQUFJLENBQUMsQ0FBQyx3QkFBd0IsRUFBRUYsT0FBTztRQUNqRDtJQUNGO0lBRUEsZ0NBQWdDO0lBQ2hDLE1BQU1jLGNBQWNqQyxNQUFNa0MsTUFBTSxDQUFDOUIsQ0FBQUEsSUFBTUEsQ0FBQUEsRUFBRUMsSUFBSSxJQUFJRCxFQUFFRSxJQUFJLEdBQUdDLFNBQVM7SUFDbkUsS0FBSyxNQUFNNEIsVUFBVUYsWUFBYTtRQUNoQyxJQUFJO1lBQ0YsTUFBTVIsT0FBT1csWUFBWUQsT0FBT3hCLE9BQU87WUFDdkMsSUFBSWMsTUFBTTtnQkFDUnhCLFVBQVVXLElBQUksQ0FBQztvQkFDYkMsVUFBVTtvQkFDVkMsTUFBTXFCLE9BQU85QixJQUFJLElBQUk4QixPQUFPN0IsSUFBSTtvQkFDaENTLGNBQWNVO2dCQUNoQjtZQUNGO1FBQ0YsRUFBRSxPQUFPTixPQUFPO1lBQ2RDLFFBQVFDLElBQUksQ0FBQyxDQUFDLGdCQUFnQixFQUFFYyxPQUFPOUIsSUFBSSxJQUFJOEIsT0FBTzdCLElBQUksQ0FBQyxFQUFFLEVBQUVhLE9BQU87UUFDeEU7SUFDRjtJQUVBLE9BQU9sQjtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNzQixxQkFBcUJaLE9BQWU7SUFDM0MsTUFBTWMsT0FBK0IsQ0FBQztJQUN0QyxNQUFNWSxRQUFRMUIsUUFBUTJCLEtBQUssQ0FBQztJQUU1QixLQUFLLE1BQU1DLFFBQVFGLE1BQU87UUFDeEIsTUFBTUcsVUFBVUQsS0FBS0UsSUFBSTtRQUN6QixJQUFJLENBQUNELFdBQVdBLFFBQVFFLFVBQVUsQ0FBQyxNQUFNO1FBRXpDLHFDQUFxQztRQUNyQyxpQkFBaUI7UUFDakIsaUJBQWlCO1FBQ2pCLGlCQUFpQjtRQUNqQixVQUFVO1FBQ1YsTUFBTUMsUUFBUUgsUUFBUUcsS0FBSyxDQUFDO1FBQzVCLElBQUlBLE9BQU87WUFDVCxNQUFNLEdBQUdyQyxNQUFNc0MsUUFBUSxHQUFHRDtZQUMxQmxCLElBQUksQ0FBQ25CLEtBQUssR0FBR3NDLFdBQVc7UUFDMUI7SUFDRjtJQUVBLE9BQU9uQjtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNDLG1CQUFtQmYsT0FBZTtJQUN6QyxNQUFNYyxPQUErQixDQUFDO0lBRXRDLHVDQUF1QztJQUN2QyxNQUFNWSxRQUFRMUIsUUFBUTJCLEtBQUssQ0FBQztJQUM1QixJQUFJTyxpQkFBaUI7SUFFckIsS0FBSyxNQUFNTixRQUFRRixNQUFPO1FBQ3hCLE1BQU1HLFVBQVVELEtBQUtFLElBQUk7UUFFekIsSUFBSUQsUUFBUUUsVUFBVSxDQUFDLGlDQUNuQkYsUUFBUUUsVUFBVSxDQUFDLDZCQUNuQkYsUUFBUUUsVUFBVSxDQUFDLG1CQUFtQjtZQUN4Q0csaUJBQWlCO1lBQ2pCO1FBQ0Y7UUFFQSxJQUFJTCxRQUFRRSxVQUFVLENBQUMsUUFBUUcsZ0JBQWdCO1lBQzdDO1FBQ0Y7UUFFQSxJQUFJQSxrQkFBa0JMLFdBQVcsQ0FBQ0EsUUFBUUUsVUFBVSxDQUFDLE1BQU07WUFDekQsTUFBTUMsUUFBUUgsUUFBUUcsS0FBSyxDQUFDO1lBQzVCLElBQUlBLE9BQU87Z0JBQ1QsTUFBTSxHQUFHckMsTUFBTXNDLFFBQVEsR0FBR0Q7Z0JBQzFCbEIsSUFBSSxDQUFDbkIsS0FBSyxHQUFHc0M7WUFDZjtRQUNGO0lBQ0Y7SUFFQSxPQUFPRSxPQUFPQyxJQUFJLENBQUN0QixNQUFNdUIsTUFBTSxHQUFHLElBQUl2QixPQUFPO0FBQy9DO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNHLFlBQVlqQixPQUFlO0lBQ2xDLE1BQU1jLE9BQStCLENBQUM7SUFFdEMsc0NBQXNDO0lBQ3RDLE1BQU13QixrQkFBa0I7SUFDeEIsSUFBSU47SUFFSixNQUFPLENBQUNBLFFBQVFNLGdCQUFnQkMsSUFBSSxDQUFDdkMsUUFBTyxNQUFPLEtBQU07UUFDdkQsTUFBTSxHQUFHd0MsU0FBU0MsWUFBWVIsUUFBUSxHQUFHRDtRQUN6QyxNQUFNVSxXQUFXLEdBQUdGLFFBQVEsQ0FBQyxFQUFFQyxZQUFZO1FBQzNDM0IsSUFBSSxDQUFDNEIsU0FBUyxHQUFHVDtJQUNuQjtJQUVBLE9BQU9FLE9BQU9DLElBQUksQ0FBQ3RCLE1BQU11QixNQUFNLEdBQUcsSUFBSXZCLE9BQU87QUFDL0M7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU0ssaUJBQWlCbkIsT0FBZTtJQUN2QyxNQUFNYyxPQUErQixDQUFDO0lBRXRDLHlDQUF5QztJQUN6QyxNQUFNWSxRQUFRMUIsUUFBUTJCLEtBQUssQ0FBQztJQUM1QixJQUFJTyxpQkFBaUI7SUFFckIsS0FBSyxNQUFNTixRQUFRRixNQUFPO1FBQ3hCLE1BQU1HLFVBQVVELEtBQUtFLElBQUk7UUFFekIsSUFBSUQsUUFBUWMsUUFBUSxDQUFDLG1CQUFtQmQsUUFBUWMsUUFBUSxDQUFDLE1BQU07WUFDN0RULGlCQUFpQjtZQUNqQjtRQUNGO1FBRUEsSUFBSUwsWUFBWSxPQUFPSyxnQkFBZ0I7WUFDckM7UUFDRjtRQUVBLElBQUlBLGtCQUFrQkwsUUFBUWMsUUFBUSxDQUFDLHFCQUFxQmQsUUFBUWMsUUFBUSxDQUFDLFlBQVk7WUFDdkYsMENBQTBDO1lBQzFDLDJDQUEyQztZQUMzQyxNQUFNWCxRQUFRSCxRQUFRRyxLQUFLLENBQUM7WUFDNUIsSUFBSUEsT0FBTztnQkFDVCxNQUFNLEdBQUdZLE9BQU9DLFVBQVVaLFFBQVEsR0FBR0Q7Z0JBQ3JDLE1BQU1VLFdBQVcsR0FBR0UsTUFBTSxDQUFDLEVBQUVDLFVBQVU7Z0JBQ3ZDL0IsSUFBSSxDQUFDNEIsU0FBUyxHQUFHVDtZQUNuQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPRSxPQUFPQyxJQUFJLENBQUN0QixNQUFNdUIsTUFBTSxHQUFHLElBQUl2QixPQUFPO0FBQy9DO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNPLFdBQVdyQixPQUFlO0lBQ2pDLE1BQU1jLE9BQStCLENBQUM7SUFDdEMsTUFBTVksUUFBUTFCLFFBQVEyQixLQUFLLENBQUM7SUFFNUIsS0FBSyxNQUFNQyxRQUFRRixNQUFPO1FBQ3hCLE1BQU1HLFVBQVVELEtBQUtFLElBQUk7UUFDekIsSUFBSUQsUUFBUUUsVUFBVSxDQUFDLFlBQVk7WUFJakM7UUFDRjtRQUVBLElBQUlGLFFBQVFFLFVBQVUsQ0FBQyxhQUFhO1lBQ2xDLHdCQUF3QjtZQUN4QixNQUFNQyxRQUFRSCxRQUFRRyxLQUFLLENBQUM7WUFDNUIsSUFBSUEsT0FBTztnQkFDVCxNQUFNLEdBQUdjLFFBQVFiLFFBQVEsR0FBR0Q7Z0JBQzVCbEIsSUFBSSxDQUFDZ0MsT0FBTyxHQUFHYjtZQUNqQjtRQUNGLE9BQU8sSUFBSUosV0FBVyxDQUFDQSxRQUFRRSxVQUFVLENBQUMsVUFBVSxDQUFDRixRQUFRRSxVQUFVLENBQUMsY0FBYyxDQUFDRixRQUFRRSxVQUFVLENBQUMsT0FBTztZQUMvRyxzQkFBc0I7WUFDdEIsTUFBTUMsUUFBUUgsUUFBUUcsS0FBSyxDQUFDO1lBQzVCLElBQUlBLE9BQU87Z0JBQ1QsTUFBTSxHQUFHYyxRQUFRYixRQUFRLEdBQUdEO2dCQUM1QmxCLElBQUksQ0FBQ2dDLE9BQU8sR0FBR2I7WUFDakI7UUFDRjtJQUNGO0lBRUEsT0FBT0UsT0FBT0MsSUFBSSxDQUFDdEIsTUFBTXVCLE1BQU0sR0FBRyxJQUFJdkIsT0FBTztBQUMvQztBQUVBOzs7O0NBSUMsR0FDRCxTQUFTVyxZQUFZekIsT0FBZTtJQUNsQyxNQUFNYyxPQUErQixDQUFDO0lBRXRDLDBDQUEwQztJQUMxQyxNQUFNaUMsa0JBQWtCO0lBQ3hCLElBQUlmO0lBRUosTUFBTyxDQUFDQSxRQUFRZSxnQkFBZ0JSLElBQUksQ0FBQ3ZDLFFBQU8sTUFBTyxLQUFNO1FBQ3ZELE1BQU0sR0FBR2dELGFBQWFmLFFBQVEsR0FBR0Q7UUFDakNsQixJQUFJLENBQUNrQyxZQUFZLEdBQUdmO0lBQ3RCO0lBRUEsT0FBT0UsT0FBT0MsSUFBSSxDQUFDdEIsTUFBTXVCLE1BQU0sR0FBRyxJQUFJdkIsT0FBTztBQUMvQztBQUVBOzs7O0NBSUMsR0FDTSxTQUFTbUMseUJBQXlCNUQsS0FBeUM7SUFDaEYsTUFBTTZELGNBQXdDO1FBQzVDLE9BQU87UUFDUCxRQUFRO1FBQ1IsT0FBTztRQUNQLFFBQVE7UUFDUixPQUFPO1FBQ1AsU0FBUztRQUNULE9BQU87UUFDUCxPQUFPO1FBQ1AsT0FBTztRQUNQLE9BQU87SUFDVDtJQUVBLE1BQU1DLG9CQUFvQixJQUFJQztJQUU5QixLQUFLLE1BQU1qRCxRQUFRZCxNQUFPO1FBQ3hCLE1BQU1nRSxXQUFXbEQsS0FBS1QsSUFBSSxJQUFJUyxLQUFLUixJQUFJO1FBQ3ZDLElBQUkwRCxVQUFVO1lBQ1osTUFBTUMsTUFBTUMsaUJBQWlCRjtZQUM3QixNQUFNbkQsV0FBV2dELFdBQVcsQ0FBQ0ksSUFBSTtZQUNqQyxJQUFJcEQsVUFBVTtnQkFDWmlELGtCQUFrQkssR0FBRyxDQUFDdEQ7WUFDeEI7UUFDRjtJQUNGO0lBRUEsT0FBT3VELE1BQU1DLElBQUksQ0FBQ1A7QUFDcEI7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU0ksaUJBQWlCRixRQUFnQjtJQUN4QyxNQUFNTSxVQUFVTixTQUFTTyxXQUFXLENBQUM7SUFDckMsSUFBSUQsWUFBWSxDQUFDLEdBQUcsT0FBTztJQUMzQixPQUFPTixTQUFTUSxTQUFTLENBQUNGO0FBQzVCO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNHLG1CQUFtQnhFLFNBQTRCO0lBQzdELElBQUlBLFVBQVUrQyxNQUFNLEtBQUssR0FBRyxPQUFPO0lBRW5DLGlEQUFpRDtJQUNqRCxNQUFNMEIsV0FBdUI7UUFBQztRQUFRO1FBQVU7UUFBUTtRQUFNO0tBQVM7SUFFdkUsS0FBSyxNQUFNQyxRQUFRRCxTQUFVO1FBQzNCLElBQUl6RSxVQUFVMkUsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFaEUsUUFBUSxLQUFLOEQsT0FBTztZQUM1QyxPQUFPQTtRQUNUO0lBQ0Y7SUFFQSxPQUFPMUUsU0FBUyxDQUFDLEVBQUUsQ0FBQ1ksUUFBUTtBQUM5QjtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTaUUsZUFBZWQsUUFBZ0I7SUFDN0MsTUFBTWUsZ0JBQWdCO1FBQ3BCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUVELE9BQU9BLGNBQWNILElBQUksQ0FBQ0ksQ0FBQUEsV0FBWWhCLFNBQVN6RCxRQUFRLENBQUN5RTtBQUMxRDtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTQyxnQkFBZ0JqQixRQUFnQjtJQUM5QyxJQUFJQSxTQUFTekQsUUFBUSxDQUFDLGlCQUFpQjtRQUNyQyxPQUFPO1lBQUVNLFVBQVU7WUFBUXFFLE1BQU07UUFBZTtJQUNsRDtJQUNBLElBQUlsQixTQUFTekQsUUFBUSxDQUFDLHFCQUFxQjtRQUN6QyxPQUFPO1lBQUVNLFVBQVU7WUFBVXFFLE1BQU07UUFBbUI7SUFDeEQ7SUFDQSxJQUFJbEIsU0FBU3pELFFBQVEsQ0FBQyxtQkFBbUI7UUFDdkMsT0FBTztZQUFFTSxVQUFVO1lBQVVxRSxNQUFNO1FBQWlCO0lBQ3REO0lBQ0EsSUFBSWxCLFNBQVN6RCxRQUFRLENBQUMsWUFBWTtRQUNoQyxPQUFPO1lBQUVNLFVBQVU7WUFBUXFFLE1BQU07UUFBVTtJQUM3QztJQUNBLElBQUlsQixTQUFTekQsUUFBUSxDQUFDLG1CQUFtQnlELFNBQVN6RCxRQUFRLENBQUMscUJBQXFCO1FBQzlFLE9BQU87WUFBRU0sVUFBVTtZQUFRcUUsTUFBTTtRQUFlO0lBQ2xEO0lBQ0EsSUFBSWxCLFNBQVN6RCxRQUFRLENBQUMsV0FBVztRQUMvQixPQUFPO1lBQUVNLFVBQVU7WUFBTXFFLE1BQU07UUFBUztJQUMxQztJQUNBLElBQUlsQixTQUFTekQsUUFBUSxDQUFDLFlBQVk7UUFDaEMsT0FBTztZQUFFTSxVQUFVO1lBQVVxRSxNQUFNO1FBQVU7SUFDL0M7SUFFQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcYW5hbHlzaXNcXGRldGVjdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5ndWFnZSwgUHJvamVjdE1hbmlmZXN0IH0gZnJvbSAnLi9iYXNlbGluZS50eXBlcyc7XHJcblxyXG4vKipcclxuICogRGV0ZWN0IHByb2plY3QgbGFuZ3VhZ2VzIGFuZCBtYW5pZmVzdHMgZnJvbSBleHRyYWN0ZWQgZmlsZXNcclxuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBkZXRlY3RlZCBwcm9qZWN0IG1hbmlmZXN0c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdFByb2plY3RNYW5pZmVzdHMoZmlsZXM6IHsgcGF0aD86IHN0cmluZzsgbmFtZT86IHN0cmluZzsgY29udGVudDogc3RyaW5nIH1bXSk6IFByb2plY3RNYW5pZmVzdFtdIHtcclxuICBjb25zdCBtYW5pZmVzdHM6IFByb2plY3RNYW5pZmVzdFtdID0gW107XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgcGFja2FnZS5qc29uIChOb2RlLmpzKVxyXG4gIGNvbnN0IHBhY2thZ2VKc29uID0gZmlsZXMuZmluZChmID0+IChmLnBhdGggfHwgZi5uYW1lKT8uZW5kc1dpdGgoJ3BhY2thZ2UuanNvbicpKTtcclxuICBpZiAocGFja2FnZUpzb24pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBrZyA9IEpTT04ucGFyc2UocGFja2FnZUpzb24uY29udGVudCk7XHJcbiAgICAgIG1hbmlmZXN0cy5wdXNoKHtcclxuICAgICAgICBsYW5ndWFnZTogJ25vZGUnLFxyXG4gICAgICAgIGZpbGU6IHBhY2thZ2VKc29uLnBhdGggfHwgcGFja2FnZUpzb24ubmFtZSxcclxuICAgICAgICBkZXBlbmRlbmNpZXM6IHBrZy5kZXBlbmRlbmNpZXMsXHJcbiAgICAgICAgZGV2RGVwZW5kZW5jaWVzOiBwa2cuZGV2RGVwZW5kZW5jaWVzLFxyXG4gICAgICAgIHBlZXJEZXBlbmRlbmNpZXM6IHBrZy5wZWVyRGVwZW5kZW5jaWVzLFxyXG4gICAgICAgIG9wdGlvbmFsRGVwZW5kZW5jaWVzOiBwa2cub3B0aW9uYWxEZXBlbmRlbmNpZXMsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gcGFyc2UgcGFja2FnZS5qc29uOiAke2Vycm9yfWApO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyBMb29rIGZvciByZXF1aXJlbWVudHMudHh0IChQeXRob24pXHJcbiAgY29uc3QgcmVxdWlyZW1lbnRzVHh0ID0gZmlsZXMuZmluZChmID0+IChmLnBhdGggfHwgZi5uYW1lKT8uZW5kc1dpdGgoJ3JlcXVpcmVtZW50cy50eHQnKSk7XHJcbiAgaWYgKHJlcXVpcmVtZW50c1R4dCkge1xyXG4gICAgbWFuaWZlc3RzLnB1c2goe1xyXG4gICAgICBsYW5ndWFnZTogJ3B5dGhvbicsXHJcbiAgICAgIGZpbGU6IHJlcXVpcmVtZW50c1R4dC5wYXRoIHx8IHJlcXVpcmVtZW50c1R4dC5uYW1lLFxyXG4gICAgICBkZXBlbmRlbmNpZXM6IHBhcnNlUmVxdWlyZW1lbnRzVHh0KHJlcXVpcmVtZW50c1R4dC5jb250ZW50KSxcclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICAvLyBMb29rIGZvciBweXByb2plY3QudG9tbCAoUHl0aG9uKVxyXG4gIGNvbnN0IHB5cHJvamVjdFRvbWwgPSBmaWxlcy5maW5kKGYgPT4gKGYucGF0aCB8fCBmLm5hbWUpPy5lbmRzV2l0aCgncHlwcm9qZWN0LnRvbWwnKSk7XHJcbiAgaWYgKHB5cHJvamVjdFRvbWwpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRlcHMgPSBwYXJzZVB5cHJvamVjdFRvbWwocHlwcm9qZWN0VG9tbC5jb250ZW50KTtcclxuICAgICAgaWYgKGRlcHMpIHtcclxuICAgICAgICBtYW5pZmVzdHMucHVzaCh7XHJcbiAgICAgICAgICBsYW5ndWFnZTogJ3B5dGhvbicsXHJcbiAgICAgICAgICBmaWxlOiBweXByb2plY3RUb21sLnBhdGggfHwgcHlwcm9qZWN0VG9tbC5uYW1lLFxyXG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBkZXBzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBwYXJzZSBweXByb2plY3QudG9tbDogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgcG9tLnhtbCAoSmF2YSBNYXZlbilcclxuICBjb25zdCBwb21YbWwgPSBmaWxlcy5maW5kKGYgPT4gKGYucGF0aCB8fCBmLm5hbWUpPy5lbmRzV2l0aCgncG9tLnhtbCcpKTtcclxuICBpZiAocG9tWG1sKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkZXBzID0gcGFyc2VQb21YbWwocG9tWG1sLmNvbnRlbnQpO1xyXG4gICAgICBpZiAoZGVwcykge1xyXG4gICAgICAgIG1hbmlmZXN0cy5wdXNoKHtcclxuICAgICAgICAgIGxhbmd1YWdlOiAnamF2YScsXHJcbiAgICAgICAgICBmaWxlOiBwb21YbWwucGF0aCB8fCBwb21YbWwubmFtZSxcclxuICAgICAgICAgIGRlcGVuZGVuY2llczogZGVwcyxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gcGFyc2UgcG9tLnhtbDogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgYnVpbGQuZ3JhZGxlIChKYXZhIEdyYWRsZSlcclxuICBjb25zdCBidWlsZEdyYWRsZSA9IGZpbGVzLmZpbmQoZiA9PiB7XHJcbiAgICBjb25zdCBwYXRoID0gZi5wYXRoIHx8IGYubmFtZTtcclxuICAgIHJldHVybiBwYXRoPy5lbmRzV2l0aCgnYnVpbGQuZ3JhZGxlJykgfHwgcGF0aD8uZW5kc1dpdGgoJ2J1aWxkLmdyYWRsZS5rdHMnKTtcclxuICB9KTtcclxuICBpZiAoYnVpbGRHcmFkbGUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRlcHMgPSBwYXJzZUJ1aWxkR3JhZGxlKGJ1aWxkR3JhZGxlLmNvbnRlbnQpO1xyXG4gICAgICBpZiAoZGVwcykge1xyXG4gICAgICAgIG1hbmlmZXN0cy5wdXNoKHtcclxuICAgICAgICAgIGxhbmd1YWdlOiAnamF2YScsXHJcbiAgICAgICAgICBmaWxlOiBidWlsZEdyYWRsZS5wYXRoIHx8IGJ1aWxkR3JhZGxlLm5hbWUsXHJcbiAgICAgICAgICBkZXBlbmRlbmNpZXM6IGRlcHMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHBhcnNlIGJ1aWxkLmdyYWRsZTogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgZ28ubW9kIChHbylcclxuICBjb25zdCBnb01vZCA9IGZpbGVzLmZpbmQoZiA9PiAoZi5wYXRoIHx8IGYubmFtZSk/LmVuZHNXaXRoKCdnby5tb2QnKSk7XHJcbiAgaWYgKGdvTW9kKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkZXBzID0gcGFyc2VHb01vZChnb01vZC5jb250ZW50KTtcclxuICAgICAgaWYgKGRlcHMpIHtcclxuICAgICAgICBtYW5pZmVzdHMucHVzaCh7XHJcbiAgICAgICAgICBsYW5ndWFnZTogJ2dvJyxcclxuICAgICAgICAgIGZpbGU6IGdvTW9kLnBhdGggfHwgZ29Nb2QubmFtZSxcclxuICAgICAgICAgIGRlcGVuZGVuY2llczogZGVwcyxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gcGFyc2UgZ28ubW9kOiAke2Vycm9yfWApO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyBMb29rIGZvciAuY3Nwcm9qIGZpbGVzICguTkVUKVxyXG4gIGNvbnN0IGNzcHJvakZpbGVzID0gZmlsZXMuZmlsdGVyKGYgPT4gKGYucGF0aCB8fCBmLm5hbWUpPy5lbmRzV2l0aCgnLmNzcHJvaicpKTtcclxuICBmb3IgKGNvbnN0IGNzcHJvaiBvZiBjc3Byb2pGaWxlcykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGVwcyA9IHBhcnNlQ3Nwcm9qKGNzcHJvai5jb250ZW50KTtcclxuICAgICAgaWYgKGRlcHMpIHtcclxuICAgICAgICBtYW5pZmVzdHMucHVzaCh7XHJcbiAgICAgICAgICBsYW5ndWFnZTogJ2RvdG5ldCcsXHJcbiAgICAgICAgICBmaWxlOiBjc3Byb2oucGF0aCB8fCBjc3Byb2oubmFtZSxcclxuICAgICAgICAgIGRlcGVuZGVuY2llczogZGVwcyxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gcGFyc2UgJHtjc3Byb2oucGF0aCB8fCBjc3Byb2oubmFtZX06ICR7ZXJyb3J9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBtYW5pZmVzdHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSByZXF1aXJlbWVudHMudHh0IGNvbnRlbnRcclxuICogQHBhcmFtIGNvbnRlbnQgcmVxdWlyZW1lbnRzLnR4dCBjb250ZW50XHJcbiAqIEByZXR1cm5zIERlcGVuZGVuY2llcyBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlUmVxdWlyZW1lbnRzVHh0KGNvbnRlbnQ6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xyXG4gIGNvbnN0IGRlcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcclxuICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xyXG4gICAgY29uc3QgdHJpbW1lZCA9IGxpbmUudHJpbSgpO1xyXG4gICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQuc3RhcnRzV2l0aCgnIycpKSBjb250aW51ZTtcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIHZhcmlvdXMgcmVxdWlyZW1lbnQgZm9ybWF0c1xyXG4gICAgLy8gcGFja2FnZT09MS4wLjBcclxuICAgIC8vIHBhY2thZ2U+PTEuMC4wXHJcbiAgICAvLyBwYWNrYWdlfj0xLjAuMFxyXG4gICAgLy8gcGFja2FnZVxyXG4gICAgY29uc3QgbWF0Y2ggPSB0cmltbWVkLm1hdGNoKC9eKFthLXpBLVowLTlfLV0rKSguKikkLyk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgY29uc3QgWywgbmFtZSwgdmVyc2lvbl0gPSBtYXRjaDtcclxuICAgICAgZGVwc1tuYW1lXSA9IHZlcnNpb24gfHwgJyonO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gZGVwcztcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHB5cHJvamVjdC50b21sIGNvbnRlbnQgKGJhc2ljIHBhcnNpbmcpXHJcbiAqIEBwYXJhbSBjb250ZW50IHB5cHJvamVjdC50b21sIGNvbnRlbnRcclxuICogQHJldHVybnMgRGVwZW5kZW5jaWVzIG9iamVjdCBvciBudWxsXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVB5cHJvamVjdFRvbWwoY29udGVudDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IG51bGwge1xyXG4gIGNvbnN0IGRlcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcclxuICBcclxuICAvLyBTaW1wbGUgVE9NTCBwYXJzaW5nIGZvciBkZXBlbmRlbmNpZXNcclxuICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xyXG4gIGxldCBpbkRlcGVuZGVuY2llcyA9IGZhbHNlO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xyXG4gICAgY29uc3QgdHJpbW1lZCA9IGxpbmUudHJpbSgpO1xyXG4gICAgXHJcbiAgICBpZiAodHJpbW1lZC5zdGFydHNXaXRoKCdbdG9vbC5wb2V0cnkuZGVwZW5kZW5jaWVzXScpIHx8IFxyXG4gICAgICAgIHRyaW1tZWQuc3RhcnRzV2l0aCgnW3Byb2plY3QuZGVwZW5kZW5jaWVzXScpIHx8XHJcbiAgICAgICAgdHJpbW1lZC5zdGFydHNXaXRoKCdbZGVwZW5kZW5jaWVzXScpKSB7XHJcbiAgICAgIGluRGVwZW5kZW5jaWVzID0gdHJ1ZTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoJ1snKSAmJiBpbkRlcGVuZGVuY2llcykge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKGluRGVwZW5kZW5jaWVzICYmIHRyaW1tZWQgJiYgIXRyaW1tZWQuc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaCgvXihbYS16QS1aMC05Xy1dKylcXHMqPVxccypbXCInXT8oW15cIiddKylbXCInXT8vKTtcclxuICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgY29uc3QgWywgbmFtZSwgdmVyc2lvbl0gPSBtYXRjaDtcclxuICAgICAgICBkZXBzW25hbWVdID0gdmVyc2lvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gT2JqZWN0LmtleXMoZGVwcykubGVuZ3RoID4gMCA/IGRlcHMgOiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgcG9tLnhtbCBjb250ZW50IChiYXNpYyBYTUwgcGFyc2luZylcclxuICogQHBhcmFtIGNvbnRlbnQgcG9tLnhtbCBjb250ZW50XHJcbiAqIEByZXR1cm5zIERlcGVuZGVuY2llcyBvYmplY3Qgb3IgbnVsbFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VQb21YbWwoY29udGVudDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IG51bGwge1xyXG4gIGNvbnN0IGRlcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcclxuICBcclxuICAvLyBTaW1wbGUgWE1MIHBhcnNpbmcgZm9yIGRlcGVuZGVuY2llc1xyXG4gIGNvbnN0IGRlcGVuZGVuY3lSZWdleCA9IC88ZGVwZW5kZW5jeT5cXHMqPGdyb3VwSWQ+KFtePF0rKTxcXC9ncm91cElkPlxccyo8YXJ0aWZhY3RJZD4oW148XSspPFxcL2FydGlmYWN0SWQ+XFxzKjx2ZXJzaW9uPihbXjxdKyk8XFwvdmVyc2lvbj4vZztcclxuICBsZXQgbWF0Y2g7XHJcbiAgXHJcbiAgd2hpbGUgKChtYXRjaCA9IGRlcGVuZGVuY3lSZWdleC5leGVjKGNvbnRlbnQpKSAhPT0gbnVsbCkge1xyXG4gICAgY29uc3QgWywgZ3JvdXBJZCwgYXJ0aWZhY3RJZCwgdmVyc2lvbl0gPSBtYXRjaDtcclxuICAgIGNvbnN0IGZ1bGxOYW1lID0gYCR7Z3JvdXBJZH06JHthcnRpZmFjdElkfWA7XHJcbiAgICBkZXBzW2Z1bGxOYW1lXSA9IHZlcnNpb247XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBPYmplY3Qua2V5cyhkZXBzKS5sZW5ndGggPiAwID8gZGVwcyA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBidWlsZC5ncmFkbGUgY29udGVudCAoYmFzaWMgcGFyc2luZylcclxuICogQHBhcmFtIGNvbnRlbnQgYnVpbGQuZ3JhZGxlIGNvbnRlbnRcclxuICogQHJldHVybnMgRGVwZW5kZW5jaWVzIG9iamVjdCBvciBudWxsXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUJ1aWxkR3JhZGxlKGNvbnRlbnQ6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBudWxsIHtcclxuICBjb25zdCBkZXBzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XHJcbiAgXHJcbiAgLy8gU2ltcGxlIEdyYWRsZSBwYXJzaW5nIGZvciBkZXBlbmRlbmNpZXNcclxuICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xyXG4gIGxldCBpbkRlcGVuZGVuY2llcyA9IGZhbHNlO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xyXG4gICAgY29uc3QgdHJpbW1lZCA9IGxpbmUudHJpbSgpO1xyXG4gICAgXHJcbiAgICBpZiAodHJpbW1lZC5pbmNsdWRlcygnZGVwZW5kZW5jaWVzJykgJiYgdHJpbW1lZC5pbmNsdWRlcygneycpKSB7XHJcbiAgICAgIGluRGVwZW5kZW5jaWVzID0gdHJ1ZTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0cmltbWVkID09PSAnfScgJiYgaW5EZXBlbmRlbmNpZXMpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChpbkRlcGVuZGVuY2llcyAmJiB0cmltbWVkLmluY2x1ZGVzKCdpbXBsZW1lbnRhdGlvbicpIHx8IHRyaW1tZWQuaW5jbHVkZXMoJ2NvbXBpbGUnKSkge1xyXG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiAnZ3JvdXA6YXJ0aWZhY3Q6dmVyc2lvbidcclxuICAgICAgLy8gaW1wbGVtZW50YXRpb24oXCJncm91cDphcnRpZmFjdDp2ZXJzaW9uXCIpXHJcbiAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaCgvKD86aW1wbGVtZW50YXRpb258Y29tcGlsZSlcXHMqWyhcIl0/KFteOildKyk6KFteOildKyk6KFteOildKykvKTtcclxuICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgY29uc3QgWywgZ3JvdXAsIGFydGlmYWN0LCB2ZXJzaW9uXSA9IG1hdGNoO1xyXG4gICAgICAgIGNvbnN0IGZ1bGxOYW1lID0gYCR7Z3JvdXB9OiR7YXJ0aWZhY3R9YDtcclxuICAgICAgICBkZXBzW2Z1bGxOYW1lXSA9IHZlcnNpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRlcHMpLmxlbmd0aCA+IDAgPyBkZXBzIDogbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIGdvLm1vZCBjb250ZW50XHJcbiAqIEBwYXJhbSBjb250ZW50IGdvLm1vZCBjb250ZW50XHJcbiAqIEByZXR1cm5zIERlcGVuZGVuY2llcyBvYmplY3Qgb3IgbnVsbFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VHb01vZChjb250ZW50OiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbCB7XHJcbiAgY29uc3QgZGVwczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xyXG4gIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XHJcbiAgXHJcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XHJcbiAgICBpZiAodHJpbW1lZC5zdGFydHNXaXRoKCdyZXF1aXJlJykpIHtcclxuICAgICAgLy8gcmVxdWlyZSAoXHJcbiAgICAgIC8vICAgbW9kdWxlIHYxLjAuMFxyXG4gICAgICAvLyApXHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodHJpbW1lZC5zdGFydHNXaXRoKCdyZXF1aXJlICcpKSB7XHJcbiAgICAgIC8vIHJlcXVpcmUgbW9kdWxlIHYxLjAuMFxyXG4gICAgICBjb25zdCBtYXRjaCA9IHRyaW1tZWQubWF0Y2goL3JlcXVpcmVcXHMrKFteXFxzXSspXFxzKyhbXlxcc10rKS8pO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBbLCBtb2R1bGUsIHZlcnNpb25dID0gbWF0Y2g7XHJcbiAgICAgICAgZGVwc1ttb2R1bGVdID0gdmVyc2lvbjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0cmltbWVkICYmICF0cmltbWVkLnN0YXJ0c1dpdGgoJ2dvICcpICYmICF0cmltbWVkLnN0YXJ0c1dpdGgoJ21vZHVsZSAnKSAmJiAhdHJpbW1lZC5zdGFydHNXaXRoKCcvLycpKSB7XHJcbiAgICAgIC8vIE1vZHVsZSB2ZXJzaW9uIGxpbmVcclxuICAgICAgY29uc3QgbWF0Y2ggPSB0cmltbWVkLm1hdGNoKC9eKFteXFxzXSspXFxzKyhbXlxcc10rKS8pO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBbLCBtb2R1bGUsIHZlcnNpb25dID0gbWF0Y2g7XHJcbiAgICAgICAgZGVwc1ttb2R1bGVdID0gdmVyc2lvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gT2JqZWN0LmtleXMoZGVwcykubGVuZ3RoID4gMCA/IGRlcHMgOiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgLmNzcHJvaiBjb250ZW50IChiYXNpYyBYTUwgcGFyc2luZylcclxuICogQHBhcmFtIGNvbnRlbnQgLmNzcHJvaiBjb250ZW50XHJcbiAqIEByZXR1cm5zIERlcGVuZGVuY2llcyBvYmplY3Qgb3IgbnVsbFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VDc3Byb2ooY29udGVudDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IG51bGwge1xyXG4gIGNvbnN0IGRlcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcclxuICBcclxuICAvLyBTaW1wbGUgWE1MIHBhcnNpbmcgZm9yIFBhY2thZ2VSZWZlcmVuY2VcclxuICBjb25zdCBwYWNrYWdlUmVmUmVnZXggPSAvPFBhY2thZ2VSZWZlcmVuY2VcXHMrSW5jbHVkZT1cIihbXlwiXSspXCJcXHMrVmVyc2lvbj1cIihbXlwiXSspXCJcXHMqXFwvPz4vZztcclxuICBsZXQgbWF0Y2g7XHJcbiAgXHJcbiAgd2hpbGUgKChtYXRjaCA9IHBhY2thZ2VSZWZSZWdleC5leGVjKGNvbnRlbnQpKSAhPT0gbnVsbCkge1xyXG4gICAgY29uc3QgWywgcGFja2FnZU5hbWUsIHZlcnNpb25dID0gbWF0Y2g7XHJcbiAgICBkZXBzW3BhY2thZ2VOYW1lXSA9IHZlcnNpb247XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBPYmplY3Qua2V5cyhkZXBzKS5sZW5ndGggPiAwID8gZGVwcyA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlY3QgbGFuZ3VhZ2VzIGZyb20gZmlsZSBleHRlbnNpb25zXHJcbiAqIEBwYXJhbSBmaWxlcyBBcnJheSBvZiBleHRyYWN0ZWQgZmlsZXNcclxuICogQHJldHVybnMgQXJyYXkgb2YgZGV0ZWN0ZWQgbGFuZ3VhZ2VzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0TGFuZ3VhZ2VzRnJvbUZpbGVzKGZpbGVzOiB7IHBhdGg/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmcgfVtdKTogTGFuZ3VhZ2VbXSB7XHJcbiAgY29uc3QgbGFuZ3VhZ2VNYXA6IFJlY29yZDxzdHJpbmcsIExhbmd1YWdlPiA9IHtcclxuICAgICcuanMnOiAnbm9kZScsXHJcbiAgICAnLmpzeCc6ICdub2RlJyxcclxuICAgICcudHMnOiAnbm9kZScsXHJcbiAgICAnLnRzeCc6ICdub2RlJyxcclxuICAgICcucHknOiAncHl0aG9uJyxcclxuICAgICcuamF2YSc6ICdqYXZhJyxcclxuICAgICcuZ28nOiAnZ28nLFxyXG4gICAgJy5jcyc6ICdkb3RuZXQnLFxyXG4gICAgJy5mcyc6ICdkb3RuZXQnLFxyXG4gICAgJy52Yic6ICdkb3RuZXQnLFxyXG4gIH07XHJcbiAgXHJcbiAgY29uc3QgZGV0ZWN0ZWRMYW5ndWFnZXMgPSBuZXcgU2V0PExhbmd1YWdlPigpO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGggfHwgZmlsZS5uYW1lO1xyXG4gICAgaWYgKGZpbGVQYXRoKSB7XHJcbiAgICAgIGNvbnN0IGV4dCA9IGdldEZpbGVFeHRlbnNpb24oZmlsZVBhdGgpO1xyXG4gICAgICBjb25zdCBsYW5ndWFnZSA9IGxhbmd1YWdlTWFwW2V4dF07XHJcbiAgICAgIGlmIChsYW5ndWFnZSkge1xyXG4gICAgICAgIGRldGVjdGVkTGFuZ3VhZ2VzLmFkZChsYW5ndWFnZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIEFycmF5LmZyb20oZGV0ZWN0ZWRMYW5ndWFnZXMpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGZpbGUgZXh0ZW5zaW9uIGZyb20gcGF0aFxyXG4gKiBAcGFyYW0gZmlsZVBhdGggRmlsZSBwYXRoXHJcbiAqIEByZXR1cm5zIEZpbGUgZXh0ZW5zaW9uIHdpdGggZG90XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGaWxlRXh0ZW5zaW9uKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGxhc3REb3QgPSBmaWxlUGF0aC5sYXN0SW5kZXhPZignLicpO1xyXG4gIGlmIChsYXN0RG90ID09PSAtMSkgcmV0dXJuICcnO1xyXG4gIHJldHVybiBmaWxlUGF0aC5zdWJzdHJpbmcobGFzdERvdCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgcHJpbWFyeSBsYW5ndWFnZSBmcm9tIG1hbmlmZXN0c1xyXG4gKiBAcGFyYW0gbWFuaWZlc3RzIEFycmF5IG9mIHByb2plY3QgbWFuaWZlc3RzXHJcbiAqIEByZXR1cm5zIFByaW1hcnkgbGFuZ3VhZ2Ugb3IgbnVsbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFByaW1hcnlMYW5ndWFnZShtYW5pZmVzdHM6IFByb2plY3RNYW5pZmVzdFtdKTogTGFuZ3VhZ2UgfCBudWxsIHtcclxuICBpZiAobWFuaWZlc3RzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XHJcbiAgXHJcbiAgLy8gUHJpb3JpdHkgb3JkZXI6IG5vZGUsIHB5dGhvbiwgamF2YSwgZ28sIGRvdG5ldFxyXG4gIGNvbnN0IHByaW9yaXR5OiBMYW5ndWFnZVtdID0gWydub2RlJywgJ3B5dGhvbicsICdqYXZhJywgJ2dvJywgJ2RvdG5ldCddO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgbGFuZyBvZiBwcmlvcml0eSkge1xyXG4gICAgaWYgKG1hbmlmZXN0cy5zb21lKG0gPT4gbS5sYW5ndWFnZSA9PT0gbGFuZykpIHtcclxuICAgICAgcmV0dXJuIGxhbmc7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBtYW5pZmVzdHNbMF0ubGFuZ3VhZ2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGZpbGUgaXMgYSBtYW5pZmVzdCBmaWxlXHJcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcclxuICogQHJldHVybnMgVHJ1ZSBpZiBpdCdzIGEgbWFuaWZlc3QgZmlsZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTWFuaWZlc3RGaWxlKGZpbGVQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICBjb25zdCBtYW5pZmVzdEZpbGVzID0gW1xyXG4gICAgJ3BhY2thZ2UuanNvbicsXHJcbiAgICAncmVxdWlyZW1lbnRzLnR4dCcsXHJcbiAgICAncHlwcm9qZWN0LnRvbWwnLFxyXG4gICAgJ3BvbS54bWwnLFxyXG4gICAgJ2J1aWxkLmdyYWRsZScsXHJcbiAgICAnYnVpbGQuZ3JhZGxlLmt0cycsXHJcbiAgICAnZ28ubW9kJyxcclxuICAgICcuY3Nwcm9qJyxcclxuICBdO1xyXG4gIFxyXG4gIHJldHVybiBtYW5pZmVzdEZpbGVzLnNvbWUobWFuaWZlc3QgPT4gZmlsZVBhdGguZW5kc1dpdGgobWFuaWZlc3QpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBtYW5pZmVzdCBmaWxlIHR5cGUgZnJvbSBwYXRoXHJcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcclxuICogQHJldHVybnMgTWFuaWZlc3QgdHlwZSBvciBudWxsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFuaWZlc3RUeXBlKGZpbGVQYXRoOiBzdHJpbmcpOiB7IGxhbmd1YWdlOiBMYW5ndWFnZTsgdHlwZTogc3RyaW5nIH0gfCBudWxsIHtcclxuICBpZiAoZmlsZVBhdGguZW5kc1dpdGgoJ3BhY2thZ2UuanNvbicpKSB7XHJcbiAgICByZXR1cm4geyBsYW5ndWFnZTogJ25vZGUnLCB0eXBlOiAncGFja2FnZS5qc29uJyB9O1xyXG4gIH1cclxuICBpZiAoZmlsZVBhdGguZW5kc1dpdGgoJ3JlcXVpcmVtZW50cy50eHQnKSkge1xyXG4gICAgcmV0dXJuIHsgbGFuZ3VhZ2U6ICdweXRob24nLCB0eXBlOiAncmVxdWlyZW1lbnRzLnR4dCcgfTtcclxuICB9XHJcbiAgaWYgKGZpbGVQYXRoLmVuZHNXaXRoKCdweXByb2plY3QudG9tbCcpKSB7XHJcbiAgICByZXR1cm4geyBsYW5ndWFnZTogJ3B5dGhvbicsIHR5cGU6ICdweXByb2plY3QudG9tbCcgfTtcclxuICB9XHJcbiAgaWYgKGZpbGVQYXRoLmVuZHNXaXRoKCdwb20ueG1sJykpIHtcclxuICAgIHJldHVybiB7IGxhbmd1YWdlOiAnamF2YScsIHR5cGU6ICdwb20ueG1sJyB9O1xyXG4gIH1cclxuICBpZiAoZmlsZVBhdGguZW5kc1dpdGgoJ2J1aWxkLmdyYWRsZScpIHx8IGZpbGVQYXRoLmVuZHNXaXRoKCdidWlsZC5ncmFkbGUua3RzJykpIHtcclxuICAgIHJldHVybiB7IGxhbmd1YWdlOiAnamF2YScsIHR5cGU6ICdidWlsZC5ncmFkbGUnIH07XHJcbiAgfVxyXG4gIGlmIChmaWxlUGF0aC5lbmRzV2l0aCgnZ28ubW9kJykpIHtcclxuICAgIHJldHVybiB7IGxhbmd1YWdlOiAnZ28nLCB0eXBlOiAnZ28ubW9kJyB9O1xyXG4gIH1cclxuICBpZiAoZmlsZVBhdGguZW5kc1dpdGgoJy5jc3Byb2onKSkge1xyXG4gICAgcmV0dXJuIHsgbGFuZ3VhZ2U6ICdkb3RuZXQnLCB0eXBlOiAnLmNzcHJvaicgfTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuIl0sIm5hbWVzIjpbImRldGVjdFByb2plY3RNYW5pZmVzdHMiLCJmaWxlcyIsIm1hbmlmZXN0cyIsInBhY2thZ2VKc29uIiwiZmluZCIsImYiLCJwYXRoIiwibmFtZSIsImVuZHNXaXRoIiwicGtnIiwiSlNPTiIsInBhcnNlIiwiY29udGVudCIsInB1c2giLCJsYW5ndWFnZSIsImZpbGUiLCJkZXBlbmRlbmNpZXMiLCJkZXZEZXBlbmRlbmNpZXMiLCJwZWVyRGVwZW5kZW5jaWVzIiwib3B0aW9uYWxEZXBlbmRlbmNpZXMiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwicmVxdWlyZW1lbnRzVHh0IiwicGFyc2VSZXF1aXJlbWVudHNUeHQiLCJweXByb2plY3RUb21sIiwiZGVwcyIsInBhcnNlUHlwcm9qZWN0VG9tbCIsInBvbVhtbCIsInBhcnNlUG9tWG1sIiwiYnVpbGRHcmFkbGUiLCJwYXJzZUJ1aWxkR3JhZGxlIiwiZ29Nb2QiLCJwYXJzZUdvTW9kIiwiY3Nwcm9qRmlsZXMiLCJmaWx0ZXIiLCJjc3Byb2oiLCJwYXJzZUNzcHJvaiIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwidHJpbW1lZCIsInRyaW0iLCJzdGFydHNXaXRoIiwibWF0Y2giLCJ2ZXJzaW9uIiwiaW5EZXBlbmRlbmNpZXMiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZGVwZW5kZW5jeVJlZ2V4IiwiZXhlYyIsImdyb3VwSWQiLCJhcnRpZmFjdElkIiwiZnVsbE5hbWUiLCJpbmNsdWRlcyIsImdyb3VwIiwiYXJ0aWZhY3QiLCJtb2R1bGUiLCJwYWNrYWdlUmVmUmVnZXgiLCJwYWNrYWdlTmFtZSIsImRldGVjdExhbmd1YWdlc0Zyb21GaWxlcyIsImxhbmd1YWdlTWFwIiwiZGV0ZWN0ZWRMYW5ndWFnZXMiLCJTZXQiLCJmaWxlUGF0aCIsImV4dCIsImdldEZpbGVFeHRlbnNpb24iLCJhZGQiLCJBcnJheSIsImZyb20iLCJsYXN0RG90IiwibGFzdEluZGV4T2YiLCJzdWJzdHJpbmciLCJnZXRQcmltYXJ5TGFuZ3VhZ2UiLCJwcmlvcml0eSIsImxhbmciLCJzb21lIiwibSIsImlzTWFuaWZlc3RGaWxlIiwibWFuaWZlc3RGaWxlcyIsIm1hbmlmZXN0IiwiZ2V0TWFuaWZlc3RUeXBlIiwidHlwZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./lib/analysis/detect.ts\n");

/***/ }),

/***/ "(api-node)/./lib/analysis/run.ts":
/*!*****************************!*\
  !*** ./lib/analysis/run.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkAnalysisFeasibility: () => (/* binding */ checkAnalysisFeasibility),\n/* harmony export */   estimateAnalysisTime: () => (/* binding */ estimateAnalysisTime),\n/* harmony export */   getAnalysisProgress: () => (/* binding */ getAnalysisProgress),\n/* harmony export */   runAnalysisOnFiles: () => (/* binding */ runAnalysisOnFiles),\n/* harmony export */   runBaselineAnalysis: () => (/* binding */ runBaselineAnalysis),\n/* harmony export */   validateAnalysisOptions: () => (/* binding */ validateAnalysisOptions)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _baseline_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./baseline.loader */ \"(api-node)/./lib/analysis/baseline.loader.ts\");\n/* harmony import */ var _detect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detect */ \"(api-node)/./lib/analysis/detect.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deps */ \"(api-node)/./lib/analysis/deps.ts\");\n/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scan */ \"(api-node)/./lib/analysis/scan.ts\");\n/* harmony import */ var _files_unzip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../files/unzip */ \"(api-node)/./lib/files/unzip.ts\");\n/* harmony import */ var _files_single_file__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../files/single-file */ \"(api-node)/./lib/files/single-file.ts\");\n/* harmony import */ var _files_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../files/store */ \"(api-node)/./lib/files/store.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_baseline_loader__WEBPACK_IMPORTED_MODULE_1__, _scan__WEBPACK_IMPORTED_MODULE_4__]);\n([_baseline_loader__WEBPACK_IMPORTED_MODULE_1__, _scan__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n/**\r\n * Run complete baseline analysis on a ZIP file\r\n * @param zipPath Path to ZIP file\r\n * @param options Analysis options\r\n * @returns Analysis result with report and artifacts\r\n */ async function analyzeWithGroq(files, projectType, dependencies) {\n    const results = [];\n    // Skip Groq analysis if no GROQ_API_KEY is available\n    if (!process.env.GROQ_API_KEY) {\n        console.log('Skipping Groq analysis: GROQ_API_KEY not configured');\n        return results;\n    }\n    // Analyze up to 5 key files to avoid rate limits\n    const keyFiles = files.filter((file)=>{\n        const fileName = file.name || file.path || 'unknown';\n        const ext = fileName.split('.').pop()?.toLowerCase();\n        return [\n            'js',\n            'ts',\n            'jsx',\n            'tsx',\n            'css',\n            'html',\n            'vue',\n            'svelte',\n            'py',\n            'java',\n            'go',\n            'cs'\n        ].includes(ext || '');\n    }).slice(0, 5);\n    for (const file of keyFiles){\n        try {\n            // Use absolute URL for server-side fetch\n            const baseUrl = process.env.PUBLIC_URL || 'http://localhost:3000';\n            const response = await fetch(`${baseUrl}/api/analyze/groq`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    code: file.content,\n                    filename: file.name || file.path || 'unknown',\n                    projectType,\n                    dependencies\n                })\n            });\n            if (response.ok) {\n                const result = await response.json();\n                results.push(result);\n            } else {\n                console.error(`Groq analysis failed for ${file.name || file.path}: ${response.status} ${response.statusText}`);\n            }\n        } catch (error) {\n            console.error(`Groq analysis failed for ${file.name || file.path}:`, error);\n        }\n    }\n    return results;\n}\nasync function runBaselineAnalysis(filePath, options = {}) {\n    const { maxFiles = 50000, maxFileSize = 2 * 1024 * 1024, allowedExtensions = [\n        '.py',\n        '.js',\n        '.ts',\n        '.tsx',\n        '.jsx',\n        '.java',\n        '.go',\n        '.cs',\n        '.fs',\n        '.vb'\n    ], ignorePaths = [\n        '/node_modules/',\n        '/.venv/',\n        '/venv/',\n        '/dist/',\n        '/build/',\n        '/.git/',\n        '/.next/'\n    ], storeResults = true, publicUrl = 'http://localhost:3000' } = options;\n    const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomUUID)();\n    const startTime = Date.now();\n    try {\n        // Load baseline rules\n        const rules = (0,_baseline_loader__WEBPACK_IMPORTED_MODULE_1__.loadBaselineRules)();\n        // Determine if file is ZIP or single file\n        const isZipFile = filePath.toLowerCase().endsWith('.zip');\n        let extractResult;\n        if (isZipFile) {\n            // Extract ZIP file\n            extractResult = await (0,_files_unzip__WEBPACK_IMPORTED_MODULE_5__.extractZipToMemory)(filePath, {\n                maxFiles,\n                maxFileSize,\n                allowedExtensions,\n                ignorePaths\n            });\n            if (extractResult.errors.length > 0) {\n                console.warn('Extraction warnings:', extractResult.errors);\n            }\n        } else {\n            // Process single file\n            const fs = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n            const content = fs.readFileSync(filePath, 'utf8');\n            if (!(0,_files_single_file__WEBPACK_IMPORTED_MODULE_6__.shouldAnalyzeFile)(filePath)) {\n                throw new Error(`File type not supported for analysis: ${filePath}`);\n            }\n            extractResult = (0,_files_single_file__WEBPACK_IMPORTED_MODULE_6__.processSingleFile)(filePath, content, maxFileSize);\n        }\n        // Detect project manifests and languages\n        const manifests = (0,_detect__WEBPACK_IMPORTED_MODULE_2__.detectProjectManifests)(extractResult.files);\n        const detectedLanguages = (0,_detect__WEBPACK_IMPORTED_MODULE_2__.detectLanguagesFromFiles)(extractResult.files);\n        // Create analysis context\n        const context = {\n            rules,\n            extractedFiles: extractResult.files,\n            manifests,\n            detectedLanguages\n        };\n        // Run analysis\n        const findings = await runAnalysis(context);\n        // Generate summary\n        const summary = generateSummary(findings, detectedLanguages);\n        // Run Groq AI analysis\n        const groqResults = await analyzeWithGroq(extractResult.files, detectedLanguages.join(', '), context.manifests.flatMap((m)=>Object.keys(m.dependencies || {})));\n        // Create report\n        const report = {\n            findings,\n            summary,\n            metadata: {\n                analysisId,\n                timestamp: new Date().toISOString(),\n                projectName: getProjectName(filePath),\n                detectedLanguages,\n                totalFiles: extractResult.totalFiles,\n                scannedFiles: extractResult.files.length,\n                skippedFiles: extractResult.skippedFiles,\n                groqAnalysis: groqResults\n            }\n        };\n        // Store results if requested\n        let artifacts;\n        if (storeResults) {\n            artifacts = (0,_files_store__WEBPACK_IMPORTED_MODULE_7__.storeAnalysisResults)(report, {\n                publicUrl\n            });\n        }\n        const endTime = Date.now();\n        console.log(`Analysis completed in ${endTime - startTime}ms`);\n        return {\n            report,\n            artifacts\n        };\n    } catch (error) {\n        console.error('Analysis failed:', error);\n        throw new Error(`Analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\r\n * Run analysis on extracted files and manifests\r\n * @param context Analysis context\r\n * @returns Array of findings\r\n */ async function runAnalysis(context) {\n    const findings = [];\n    // Analyze dependencies\n    const dependencyFindings = (0,_deps__WEBPACK_IMPORTED_MODULE_3__.analyzeDependencies)(context.manifests, context.rules);\n    findings.push(...dependencyFindings);\n    // Scan source files for deprecated patterns\n    const patternFindings = (0,_scan__WEBPACK_IMPORTED_MODULE_4__.scanSourceFiles)(context.extractedFiles, context.rules);\n    findings.push(...patternFindings);\n    return findings;\n}\n/**\r\n * Generate summary from findings\r\n * @param findings Array of findings\r\n * @param detectedLanguages Array of detected languages\r\n * @returns Report summary\r\n */ function generateSummary(findings, detectedLanguages) {\n    const summary = {\n        ok: 0,\n        affected: 0,\n        unknown: 0,\n        byLanguage: {}\n    };\n    // Initialize language summaries\n    for (const language of detectedLanguages){\n        summary.byLanguage[language] = {\n            ok: 0,\n            affected: 0,\n            unknown: 0\n        };\n    }\n    // Count findings by status and language\n    for (const finding of findings){\n        if (finding.kind === 'dependency') {\n            summary[finding.status]++;\n            if (summary.byLanguage[finding.lang]) {\n                summary.byLanguage[finding.lang][finding.status]++;\n            }\n        } else if (finding.kind === 'pattern') {\n            summary.affected++;\n            if (summary.byLanguage[finding.lang]) {\n                summary.byLanguage[finding.lang].affected++;\n            }\n        }\n    }\n    return summary;\n}\n/**\r\n * Get project name from ZIP path\r\n * @param zipPath ZIP file path\r\n * @returns Project name\r\n */ function getProjectName(zipPath) {\n    const pathParts = zipPath.split('/');\n    const fileName = pathParts[pathParts.length - 1];\n    return fileName.replace(/\\.zip$/i, '');\n}\n/**\r\n * Run analysis on extracted files (for testing)\r\n * @param files Array of extracted files\r\n * @param manifests Array of project manifests\r\n * @param rules Baseline rules\r\n * @returns Analysis result\r\n */ async function runAnalysisOnFiles(files, manifests, rules) {\n    const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomUUID)();\n    const detectedLanguages = (0,_detect__WEBPACK_IMPORTED_MODULE_2__.detectLanguagesFromFiles)(files);\n    const context = {\n        rules,\n        extractedFiles: files,\n        manifests,\n        detectedLanguages\n    };\n    const findings = await runAnalysis(context);\n    const summary = generateSummary(findings, detectedLanguages);\n    const report = {\n        findings,\n        summary,\n        metadata: {\n            analysisId,\n            timestamp: new Date().toISOString(),\n            projectName: 'test-project',\n            detectedLanguages,\n            totalFiles: files.length,\n            scannedFiles: files.length,\n            skippedFiles: 0\n        }\n    };\n    return {\n        report\n    };\n}\n/**\r\n * Validate analysis options\r\n * @param options Analysis options\r\n * @returns Validated options\r\n */ function validateAnalysisOptions(options) {\n    return {\n        maxFiles: Math.min(options.maxFiles || 50000, 100000),\n        maxFileSize: Math.min(options.maxFileSize || 2 * 1024 * 1024, 10 * 1024 * 1024),\n        allowedExtensions: options.allowedExtensions || [\n            '.py',\n            '.js',\n            '.ts',\n            '.tsx',\n            '.jsx',\n            '.java',\n            '.go',\n            '.cs',\n            '.fs',\n            '.vb'\n        ],\n        ignorePaths: options.ignorePaths || [\n            '/node_modules/',\n            '/.venv/',\n            '/venv/',\n            '/dist/',\n            '/build/',\n            '/.git/',\n            '/.next/'\n        ],\n        storeResults: options.storeResults !== false,\n        publicUrl: options.publicUrl || 'http://localhost:3000'\n    };\n}\n/**\r\n * Get analysis progress (for long-running analyses)\r\n * @param context Analysis context\r\n * @param currentStep Current step\r\n * @param totalSteps Total steps\r\n * @returns Progress information\r\n */ function getAnalysisProgress(context, currentStep, totalSteps) {\n    const steps = [\n        'Loading baseline rules',\n        'Extracting ZIP file',\n        'Detecting project manifests',\n        'Analyzing dependencies',\n        'Scanning source files',\n        'Generating report'\n    ];\n    const step = steps[currentStep] || 'Unknown';\n    const progress = currentStep / totalSteps * 100;\n    let details = '';\n    if (currentStep === 1) {\n        details = `Extracted ${context.extractedFiles.length} files`;\n    } else if (currentStep === 2) {\n        details = `Found ${context.manifests.length} manifests, ${context.detectedLanguages.length} languages`;\n    } else if (currentStep === 3) {\n        details = `Analyzing ${context.manifests.length} dependency manifests`;\n    } else if (currentStep === 4) {\n        details = `Scanning ${context.extractedFiles.length} source files`;\n    }\n    return {\n        step,\n        progress,\n        details\n    };\n}\n/**\r\n * Estimate analysis time\r\n * @param fileCount Number of files\r\n * @param manifestCount Number of manifests\r\n * @returns Estimated time in milliseconds\r\n */ function estimateAnalysisTime(fileCount, manifestCount) {\n    // Base time: 1 second\n    let estimated = 1000;\n    // Add time for file processing: 10ms per file\n    estimated += fileCount * 10;\n    // Add time for manifest processing: 50ms per manifest\n    estimated += manifestCount * 50;\n    // Add time for pattern scanning: 5ms per file\n    estimated += fileCount * 5;\n    return Math.min(estimated, 30000); // Cap at 30 seconds\n}\n/**\r\n * Check if analysis is feasible\r\n * @param fileCount Number of files\r\n * @param totalSize Total size in bytes\r\n * @returns Feasibility check result\r\n */ function checkAnalysisFeasibility(fileCount, totalSize) {\n    const warnings = [];\n    let feasible = true;\n    // Check file count\n    if (fileCount > 50000) {\n        feasible = false;\n        warnings.push(`Too many files: ${fileCount} (limit: 50,000)`);\n    } else if (fileCount > 10000) {\n        warnings.push(`Large number of files: ${fileCount} (analysis may take longer)`);\n    }\n    // Check total size\n    if (totalSize > 100 * 1024 * 1024) {\n        feasible = false;\n        warnings.push(`Archive too large: ${Math.round(totalSize / 1024 / 1024)}MB (limit: 100MB)`);\n    } else if (totalSize > 50 * 1024 * 1024) {\n        warnings.push(`Large archive: ${Math.round(totalSize / 1024 / 1024)}MB (analysis may take longer)`);\n    }\n    const estimatedTime = estimateAnalysisTime(fileCount, Math.min(fileCount / 100, 50));\n    return {\n        feasible,\n        warnings,\n        estimatedTime\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OEUsVUFBVSxnQkFBZ0IsQ0FBQztJQUM5RCxPQUFPLElBQUlBLFlBQVksT0FBTztRQUM1QkssU0FBU25GLElBQUksQ0FBQyxDQUFDLHVCQUF1QixFQUFFOEUsVUFBVSwyQkFBMkIsQ0FBQztJQUNoRjtJQUVBLG1CQUFtQjtJQUNuQixJQUFJSSxZQUFZLE1BQU0sT0FBTyxNQUFNO1FBQ2pDRSxXQUFXO1FBQ1hELFNBQVNuRixJQUFJLENBQUMsQ0FBQyxtQkFBbUIsRUFBRW9FLEtBQUtpQixLQUFLLENBQUNILFlBQVksT0FBTyxNQUFNLGlCQUFpQixDQUFDO0lBQzVGLE9BQU8sSUFBSUEsWUFBWSxLQUFLLE9BQU8sTUFBTTtRQUN2Q0MsU0FBU25GLElBQUksQ0FBQyxDQUFDLGVBQWUsRUFBRW9FLEtBQUtpQixLQUFLLENBQUNILFlBQVksT0FBTyxNQUFNLDZCQUE2QixDQUFDO0lBQ3BHO0lBRUEsTUFBTUksZ0JBQWdCVCxxQkFBcUJDLFdBQVdWLEtBQUtDLEdBQUcsQ0FBQ1MsWUFBWSxLQUFLO0lBRWhGLE9BQU87UUFDTE07UUFDQUQ7UUFDQUc7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxydW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmFuZG9tVVVJRCB9IGZyb20gJ2NyeXB0byc7XHJcbmltcG9ydCB7IGxvYWRCYXNlbGluZVJ1bGVzIH0gZnJvbSAnLi9iYXNlbGluZS5sb2FkZXInO1xyXG5pbXBvcnQgeyBkZXRlY3RQcm9qZWN0TWFuaWZlc3RzLCBkZXRlY3RMYW5ndWFnZXNGcm9tRmlsZXMgfSBmcm9tICcuL2RldGVjdCc7XHJcbmltcG9ydCB7IGFuYWx5emVEZXBlbmRlbmNpZXMgfSBmcm9tICcuL2RlcHMnO1xyXG5pbXBvcnQgeyBzY2FuU291cmNlRmlsZXMgfSBmcm9tICcuL3NjYW4nO1xyXG5pbXBvcnQgeyBleHRyYWN0WmlwVG9NZW1vcnkgfSBmcm9tICcuLi9maWxlcy91bnppcCc7XHJcbmltcG9ydCB7IHByb2Nlc3NTaW5nbGVGaWxlLCBkZXRlY3RGaWxlVHlwZSwgc2hvdWxkQW5hbHl6ZUZpbGUgfSBmcm9tICcuLi9maWxlcy9zaW5nbGUtZmlsZSc7XHJcbmltcG9ydCB7IHN0b3JlQW5hbHlzaXNSZXN1bHRzIH0gZnJvbSAnLi4vZmlsZXMvc3RvcmUnO1xyXG5pbXBvcnQge1xyXG4gIFJlcG9ydCxcclxuICBGaW5kaW5nLFxyXG4gIExhbmd1YWdlLFxyXG4gIFJlcG9ydFN1bW1hcnksXHJcbiAgTGFuZ3VhZ2VTdW1tYXJ5LFxyXG4gIEFuYWx5c2lzQ29udGV4dCxcclxuICBFeHRyYWN0ZWRGaWxlLFxyXG4gIFByb2plY3RNYW5pZmVzdFxyXG59IGZyb20gJy4vYmFzZWxpbmUudHlwZXMnO1xyXG5cclxuaW50ZXJmYWNlIEdyb3FBbmFseXNpc1Jlc3VsdCB7XHJcbiAgYW5hbHlzaXM6IHN0cmluZztcclxuICBmaWxlbmFtZTogc3RyaW5nO1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5c2lzT3B0aW9ucyB7XHJcbiAgbWF4RmlsZXM/OiBudW1iZXI7XHJcbiAgbWF4RmlsZVNpemU/OiBudW1iZXI7XHJcbiAgYWxsb3dlZEV4dGVuc2lvbnM/OiBzdHJpbmdbXTtcclxuICBpZ25vcmVQYXRocz86IHN0cmluZ1tdO1xyXG4gIHN0b3JlUmVzdWx0cz86IGJvb2xlYW47XHJcbiAgcHVibGljVXJsPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5c2lzUmVzdWx0IHtcclxuICByZXBvcnQ6IFJlcG9ydDtcclxuICBhcnRpZmFjdHM/OiB7XHJcbiAgICBqc29uVXJsOiBzdHJpbmc7XHJcbiAgICBjc3ZVcmw6IHN0cmluZztcclxuICAgIGFuYWx5c2lzSWQ6IHN0cmluZztcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogUnVuIGNvbXBsZXRlIGJhc2VsaW5lIGFuYWx5c2lzIG9uIGEgWklQIGZpbGVcclxuICogQHBhcmFtIHppcFBhdGggUGF0aCB0byBaSVAgZmlsZVxyXG4gKiBAcGFyYW0gb3B0aW9ucyBBbmFseXNpcyBvcHRpb25zXHJcbiAqIEByZXR1cm5zIEFuYWx5c2lzIHJlc3VsdCB3aXRoIHJlcG9ydCBhbmQgYXJ0aWZhY3RzXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBhbmFseXplV2l0aEdyb3EoXHJcbiAgZmlsZXM6IEV4dHJhY3RlZEZpbGVbXSxcclxuICBwcm9qZWN0VHlwZTogc3RyaW5nLFxyXG4gIGRlcGVuZGVuY2llczogc3RyaW5nW11cclxuKTogUHJvbWlzZTxHcm9xQW5hbHlzaXNSZXN1bHRbXT4ge1xyXG4gIGNvbnN0IHJlc3VsdHM6IEdyb3FBbmFseXNpc1Jlc3VsdFtdID0gW107XHJcbiAgXHJcbiAgLy8gU2tpcCBHcm9xIGFuYWx5c2lzIGlmIG5vIEdST1FfQVBJX0tFWSBpcyBhdmFpbGFibGVcclxuICBpZiAoIXByb2Nlc3MuZW52LkdST1FfQVBJX0tFWSkge1xyXG4gICAgY29uc29sZS5sb2coJ1NraXBwaW5nIEdyb3EgYW5hbHlzaXM6IEdST1FfQVBJX0tFWSBub3QgY29uZmlndXJlZCcpO1xyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEFuYWx5emUgdXAgdG8gNSBrZXkgZmlsZXMgdG8gYXZvaWQgcmF0ZSBsaW1pdHNcclxuICBjb25zdCBrZXlGaWxlcyA9IGZpbGVzXHJcbiAgICAuZmlsdGVyKGZpbGUgPT4ge1xyXG4gICAgICBjb25zdCBmaWxlTmFtZSA9IGZpbGUubmFtZSB8fCBmaWxlLnBhdGggfHwgJ3Vua25vd24nO1xyXG4gICAgICBjb25zdCBleHQgPSBmaWxlTmFtZS5zcGxpdCgnLicpLnBvcCgpPy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICByZXR1cm4gWydqcycsICd0cycsICdqc3gnLCAndHN4JywgJ2NzcycsICdodG1sJywgJ3Z1ZScsICdzdmVsdGUnLCAncHknLCAnamF2YScsICdnbycsICdjcyddLmluY2x1ZGVzKGV4dCB8fCAnJyk7XHJcbiAgICB9KVxyXG4gICAgLnNsaWNlKDAsIDUpO1xyXG5cclxuICBmb3IgKGNvbnN0IGZpbGUgb2Yga2V5RmlsZXMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFVzZSBhYnNvbHV0ZSBVUkwgZm9yIHNlcnZlci1zaWRlIGZldGNoXHJcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSBwcm9jZXNzLmVudi5QVUJMSUNfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2Jhc2VVcmx9L2FwaS9hbmFseXplL2dyb3FgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIGNvZGU6IGZpbGUuY29udGVudCxcclxuICAgICAgICAgIGZpbGVuYW1lOiBmaWxlLm5hbWUgfHwgZmlsZS5wYXRoIHx8ICd1bmtub3duJyxcclxuICAgICAgICAgIHByb2plY3RUeXBlLFxyXG4gICAgICAgICAgZGVwZW5kZW5jaWVzXHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgR3JvcSBhbmFseXNpcyBmYWlsZWQgZm9yICR7ZmlsZS5uYW1lIHx8IGZpbGUucGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEdyb3EgYW5hbHlzaXMgZmFpbGVkIGZvciAke2ZpbGUubmFtZSB8fCBmaWxlLnBhdGh9OmAsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuQmFzZWxpbmVBbmFseXNpcyhcclxuICBmaWxlUGF0aDogc3RyaW5nLFxyXG4gIG9wdGlvbnM6IEFuYWx5c2lzT3B0aW9ucyA9IHt9XHJcbik6IFByb21pc2U8QW5hbHlzaXNSZXN1bHQ+IHtcclxuICBjb25zdCB7XHJcbiAgICBtYXhGaWxlcyA9IDUwMDAwLFxyXG4gICAgbWF4RmlsZVNpemUgPSAyICogMTAyNCAqIDEwMjQsIC8vIDJNQlxyXG4gICAgYWxsb3dlZEV4dGVuc2lvbnMgPSBbJy5weScsICcuanMnLCAnLnRzJywgJy50c3gnLCAnLmpzeCcsICcuamF2YScsICcuZ28nLCAnLmNzJywgJy5mcycsICcudmInXSxcclxuICAgIGlnbm9yZVBhdGhzID0gWycvbm9kZV9tb2R1bGVzLycsICcvLnZlbnYvJywgJy92ZW52LycsICcvZGlzdC8nLCAnL2J1aWxkLycsICcvLmdpdC8nLCAnLy5uZXh0LyddLFxyXG4gICAgc3RvcmVSZXN1bHRzID0gdHJ1ZSxcclxuICAgIHB1YmxpY1VybCA9ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnLFxyXG4gIH0gPSBvcHRpb25zO1xyXG5cclxuICBjb25zdCBhbmFseXNpc0lkID0gcmFuZG9tVVVJRCgpO1xyXG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBMb2FkIGJhc2VsaW5lIHJ1bGVzXHJcbiAgICBjb25zdCBydWxlcyA9IGxvYWRCYXNlbGluZVJ1bGVzKCk7XHJcbiAgICBcclxuICAgIC8vIERldGVybWluZSBpZiBmaWxlIGlzIFpJUCBvciBzaW5nbGUgZmlsZVxyXG4gICAgY29uc3QgaXNaaXBGaWxlID0gZmlsZVBhdGgudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLnppcCcpO1xyXG4gICAgbGV0IGV4dHJhY3RSZXN1bHQ7XHJcbiAgICBcclxuICAgIGlmIChpc1ppcEZpbGUpIHtcclxuICAgICAgLy8gRXh0cmFjdCBaSVAgZmlsZVxyXG4gICAgICBleHRyYWN0UmVzdWx0ID0gYXdhaXQgZXh0cmFjdFppcFRvTWVtb3J5KGZpbGVQYXRoLCB7XHJcbiAgICAgICAgbWF4RmlsZXMsXHJcbiAgICAgICAgbWF4RmlsZVNpemUsXHJcbiAgICAgICAgYWxsb3dlZEV4dGVuc2lvbnMsXHJcbiAgICAgICAgaWdub3JlUGF0aHMsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGV4dHJhY3RSZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0V4dHJhY3Rpb24gd2FybmluZ3M6JywgZXh0cmFjdFJlc3VsdC5lcnJvcnMpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBQcm9jZXNzIHNpbmdsZSBmaWxlXHJcbiAgICAgIGNvbnN0IGZzID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFzaG91bGRBbmFseXplRmlsZShmaWxlUGF0aCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgdHlwZSBub3Qgc3VwcG9ydGVkIGZvciBhbmFseXNpczogJHtmaWxlUGF0aH1gKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgZXh0cmFjdFJlc3VsdCA9IHByb2Nlc3NTaW5nbGVGaWxlKGZpbGVQYXRoLCBjb250ZW50LCBtYXhGaWxlU2l6ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZWN0IHByb2plY3QgbWFuaWZlc3RzIGFuZCBsYW5ndWFnZXNcclxuICAgIGNvbnN0IG1hbmlmZXN0cyA9IGRldGVjdFByb2plY3RNYW5pZmVzdHMoZXh0cmFjdFJlc3VsdC5maWxlcyk7XHJcbiAgICBjb25zdCBkZXRlY3RlZExhbmd1YWdlcyA9IGRldGVjdExhbmd1YWdlc0Zyb21GaWxlcyhleHRyYWN0UmVzdWx0LmZpbGVzKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGFuYWx5c2lzIGNvbnRleHRcclxuICAgIGNvbnN0IGNvbnRleHQ6IEFuYWx5c2lzQ29udGV4dCA9IHtcclxuICAgICAgcnVsZXMsXHJcbiAgICAgIGV4dHJhY3RlZEZpbGVzOiBleHRyYWN0UmVzdWx0LmZpbGVzLFxyXG4gICAgICBtYW5pZmVzdHMsXHJcbiAgICAgIGRldGVjdGVkTGFuZ3VhZ2VzLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSdW4gYW5hbHlzaXNcclxuICAgIGNvbnN0IGZpbmRpbmdzID0gYXdhaXQgcnVuQW5hbHlzaXMoY29udGV4dCk7XHJcbiAgICBcclxuICAgIC8vIEdlbmVyYXRlIHN1bW1hcnlcclxuICAgIGNvbnN0IHN1bW1hcnkgPSBnZW5lcmF0ZVN1bW1hcnkoZmluZGluZ3MsIGRldGVjdGVkTGFuZ3VhZ2VzKTtcclxuICAgIFxyXG4gICAgLy8gUnVuIEdyb3EgQUkgYW5hbHlzaXNcclxuICAgIGNvbnN0IGdyb3FSZXN1bHRzID0gYXdhaXQgYW5hbHl6ZVdpdGhHcm9xKFxyXG4gICAgICBleHRyYWN0UmVzdWx0LmZpbGVzLFxyXG4gICAgICBkZXRlY3RlZExhbmd1YWdlcy5qb2luKCcsICcpLFxyXG4gICAgICBjb250ZXh0Lm1hbmlmZXN0cy5mbGF0TWFwKG0gPT4gT2JqZWN0LmtleXMobS5kZXBlbmRlbmNpZXMgfHwge30pKVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIHJlcG9ydFxyXG4gICAgY29uc3QgcmVwb3J0OiBSZXBvcnQgPSB7XHJcbiAgICAgIGZpbmRpbmdzLFxyXG4gICAgICBzdW1tYXJ5LFxyXG4gICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgIGFuYWx5c2lzSWQsXHJcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgcHJvamVjdE5hbWU6IGdldFByb2plY3ROYW1lKGZpbGVQYXRoKSxcclxuICAgICAgICBkZXRlY3RlZExhbmd1YWdlcyxcclxuICAgICAgICB0b3RhbEZpbGVzOiBleHRyYWN0UmVzdWx0LnRvdGFsRmlsZXMsXHJcbiAgICAgICAgc2Nhbm5lZEZpbGVzOiBleHRyYWN0UmVzdWx0LmZpbGVzLmxlbmd0aCxcclxuICAgICAgICBza2lwcGVkRmlsZXM6IGV4dHJhY3RSZXN1bHQuc2tpcHBlZEZpbGVzLFxyXG4gICAgICAgIGdyb3FBbmFseXNpczogZ3JvcVJlc3VsdHMsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN0b3JlIHJlc3VsdHMgaWYgcmVxdWVzdGVkXHJcbiAgICBsZXQgYXJ0aWZhY3RzO1xyXG4gICAgaWYgKHN0b3JlUmVzdWx0cykge1xyXG4gICAgICBhcnRpZmFjdHMgPSBzdG9yZUFuYWx5c2lzUmVzdWx0cyhyZXBvcnQsIHsgcHVibGljVXJsIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc29sZS5sb2coYEFuYWx5c2lzIGNvbXBsZXRlZCBpbiAke2VuZFRpbWUgLSBzdGFydFRpbWV9bXNgKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXBvcnQsXHJcbiAgICAgIGFydGlmYWN0cyxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FuYWx5c2lzIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFuYWx5c2lzIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW4gYW5hbHlzaXMgb24gZXh0cmFjdGVkIGZpbGVzIGFuZCBtYW5pZmVzdHNcclxuICogQHBhcmFtIGNvbnRleHQgQW5hbHlzaXMgY29udGV4dFxyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBmaW5kaW5nc1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcnVuQW5hbHlzaXMoY29udGV4dDogQW5hbHlzaXNDb250ZXh0KTogUHJvbWlzZTxGaW5kaW5nW10+IHtcclxuICBjb25zdCBmaW5kaW5nczogRmluZGluZ1tdID0gW107XHJcblxyXG4gIC8vIEFuYWx5emUgZGVwZW5kZW5jaWVzXHJcbiAgY29uc3QgZGVwZW5kZW5jeUZpbmRpbmdzID0gYW5hbHl6ZURlcGVuZGVuY2llcyhjb250ZXh0Lm1hbmlmZXN0cywgY29udGV4dC5ydWxlcyk7XHJcbiAgZmluZGluZ3MucHVzaCguLi5kZXBlbmRlbmN5RmluZGluZ3MpO1xyXG5cclxuICAvLyBTY2FuIHNvdXJjZSBmaWxlcyBmb3IgZGVwcmVjYXRlZCBwYXR0ZXJuc1xyXG4gIGNvbnN0IHBhdHRlcm5GaW5kaW5ncyA9IHNjYW5Tb3VyY2VGaWxlcyhjb250ZXh0LmV4dHJhY3RlZEZpbGVzLCBjb250ZXh0LnJ1bGVzKTtcclxuICBmaW5kaW5ncy5wdXNoKC4uLnBhdHRlcm5GaW5kaW5ncyk7XHJcblxyXG4gIHJldHVybiBmaW5kaW5ncztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHN1bW1hcnkgZnJvbSBmaW5kaW5nc1xyXG4gKiBAcGFyYW0gZmluZGluZ3MgQXJyYXkgb2YgZmluZGluZ3NcclxuICogQHBhcmFtIGRldGVjdGVkTGFuZ3VhZ2VzIEFycmF5IG9mIGRldGVjdGVkIGxhbmd1YWdlc1xyXG4gKiBAcmV0dXJucyBSZXBvcnQgc3VtbWFyeVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVTdW1tYXJ5KGZpbmRpbmdzOiBGaW5kaW5nW10sIGRldGVjdGVkTGFuZ3VhZ2VzOiBMYW5ndWFnZVtdKTogUmVwb3J0U3VtbWFyeSB7XHJcbiAgY29uc3Qgc3VtbWFyeTogUmVwb3J0U3VtbWFyeSA9IHtcclxuICAgIG9rOiAwLFxyXG4gICAgYWZmZWN0ZWQ6IDAsXHJcbiAgICB1bmtub3duOiAwLFxyXG4gICAgYnlMYW5ndWFnZToge30sXHJcbiAgfTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBsYW5ndWFnZSBzdW1tYXJpZXNcclxuICBmb3IgKGNvbnN0IGxhbmd1YWdlIG9mIGRldGVjdGVkTGFuZ3VhZ2VzKSB7XHJcbiAgICBzdW1tYXJ5LmJ5TGFuZ3VhZ2VbbGFuZ3VhZ2VdID0ge1xyXG4gICAgICBvazogMCxcclxuICAgICAgYWZmZWN0ZWQ6IDAsXHJcbiAgICAgIHVua25vd246IDAsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gQ291bnQgZmluZGluZ3MgYnkgc3RhdHVzIGFuZCBsYW5ndWFnZVxyXG4gIGZvciAoY29uc3QgZmluZGluZyBvZiBmaW5kaW5ncykge1xyXG4gICAgaWYgKGZpbmRpbmcua2luZCA9PT0gJ2RlcGVuZGVuY3knKSB7XHJcbiAgICAgIHN1bW1hcnlbZmluZGluZy5zdGF0dXNdKys7XHJcbiAgICAgIGlmIChzdW1tYXJ5LmJ5TGFuZ3VhZ2VbZmluZGluZy5sYW5nXSkge1xyXG4gICAgICAgIHN1bW1hcnkuYnlMYW5ndWFnZVtmaW5kaW5nLmxhbmddW2ZpbmRpbmcuc3RhdHVzXSsrO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGZpbmRpbmcua2luZCA9PT0gJ3BhdHRlcm4nKSB7XHJcbiAgICAgIHN1bW1hcnkuYWZmZWN0ZWQrKztcclxuICAgICAgaWYgKHN1bW1hcnkuYnlMYW5ndWFnZVtmaW5kaW5nLmxhbmddKSB7XHJcbiAgICAgICAgc3VtbWFyeS5ieUxhbmd1YWdlW2ZpbmRpbmcubGFuZ10uYWZmZWN0ZWQrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN1bW1hcnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgcHJvamVjdCBuYW1lIGZyb20gWklQIHBhdGhcclxuICogQHBhcmFtIHppcFBhdGggWklQIGZpbGUgcGF0aFxyXG4gKiBAcmV0dXJucyBQcm9qZWN0IG5hbWVcclxuICovXHJcbmZ1bmN0aW9uIGdldFByb2plY3ROYW1lKHppcFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgcGF0aFBhcnRzID0gemlwUGF0aC5zcGxpdCgnLycpO1xyXG4gIGNvbnN0IGZpbGVOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXTtcclxuICByZXR1cm4gZmlsZU5hbWUucmVwbGFjZSgvXFwuemlwJC9pLCAnJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW4gYW5hbHlzaXMgb24gZXh0cmFjdGVkIGZpbGVzIChmb3IgdGVzdGluZylcclxuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xyXG4gKiBAcGFyYW0gbWFuaWZlc3RzIEFycmF5IG9mIHByb2plY3QgbWFuaWZlc3RzXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcmV0dXJucyBBbmFseXNpcyByZXN1bHRcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5BbmFseXNpc09uRmlsZXMoXHJcbiAgZmlsZXM6IEV4dHJhY3RlZEZpbGVbXSxcclxuICBtYW5pZmVzdHM6IFByb2plY3RNYW5pZmVzdFtdLFxyXG4gIHJ1bGVzOiBhbnlcclxuKTogUHJvbWlzZTxBbmFseXNpc1Jlc3VsdD4ge1xyXG4gIGNvbnN0IGFuYWx5c2lzSWQgPSByYW5kb21VVUlEKCk7XHJcbiAgY29uc3QgZGV0ZWN0ZWRMYW5ndWFnZXMgPSBkZXRlY3RMYW5ndWFnZXNGcm9tRmlsZXMoZmlsZXMpO1xyXG4gIFxyXG4gIGNvbnN0IGNvbnRleHQ6IEFuYWx5c2lzQ29udGV4dCA9IHtcclxuICAgIHJ1bGVzLFxyXG4gICAgZXh0cmFjdGVkRmlsZXM6IGZpbGVzLFxyXG4gICAgbWFuaWZlc3RzLFxyXG4gICAgZGV0ZWN0ZWRMYW5ndWFnZXMsXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZmluZGluZ3MgPSBhd2FpdCBydW5BbmFseXNpcyhjb250ZXh0KTtcclxuICBjb25zdCBzdW1tYXJ5ID0gZ2VuZXJhdGVTdW1tYXJ5KGZpbmRpbmdzLCBkZXRlY3RlZExhbmd1YWdlcyk7XHJcbiAgXHJcbiAgY29uc3QgcmVwb3J0OiBSZXBvcnQgPSB7XHJcbiAgICBmaW5kaW5ncyxcclxuICAgIHN1bW1hcnksXHJcbiAgICBtZXRhZGF0YToge1xyXG4gICAgICBhbmFseXNpc0lkLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgcHJvamVjdE5hbWU6ICd0ZXN0LXByb2plY3QnLFxyXG4gICAgICBkZXRlY3RlZExhbmd1YWdlcyxcclxuICAgICAgdG90YWxGaWxlczogZmlsZXMubGVuZ3RoLFxyXG4gICAgICBzY2FubmVkRmlsZXM6IGZpbGVzLmxlbmd0aCxcclxuICAgICAgc2tpcHBlZEZpbGVzOiAwLFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICByZXR1cm4geyByZXBvcnQgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIGFuYWx5c2lzIG9wdGlvbnNcclxuICogQHBhcmFtIG9wdGlvbnMgQW5hbHlzaXMgb3B0aW9uc1xyXG4gKiBAcmV0dXJucyBWYWxpZGF0ZWQgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQW5hbHlzaXNPcHRpb25zKG9wdGlvbnM6IEFuYWx5c2lzT3B0aW9ucyk6IEFuYWx5c2lzT3B0aW9ucyB7XHJcbiAgcmV0dXJuIHtcclxuICAgIG1heEZpbGVzOiBNYXRoLm1pbihvcHRpb25zLm1heEZpbGVzIHx8IDUwMDAwLCAxMDAwMDApLCAvLyBDYXAgYXQgMTAwa1xyXG4gICAgbWF4RmlsZVNpemU6IE1hdGgubWluKG9wdGlvbnMubWF4RmlsZVNpemUgfHwgMiAqIDEwMjQgKiAxMDI0LCAxMCAqIDEwMjQgKiAxMDI0KSwgLy8gQ2FwIGF0IDEwTUJcclxuICAgIGFsbG93ZWRFeHRlbnNpb25zOiBvcHRpb25zLmFsbG93ZWRFeHRlbnNpb25zIHx8IFsnLnB5JywgJy5qcycsICcudHMnLCAnLnRzeCcsICcuanN4JywgJy5qYXZhJywgJy5nbycsICcuY3MnLCAnLmZzJywgJy52YiddLFxyXG4gICAgaWdub3JlUGF0aHM6IG9wdGlvbnMuaWdub3JlUGF0aHMgfHwgWycvbm9kZV9tb2R1bGVzLycsICcvLnZlbnYvJywgJy92ZW52LycsICcvZGlzdC8nLCAnL2J1aWxkLycsICcvLmdpdC8nLCAnLy5uZXh0LyddLFxyXG4gICAgc3RvcmVSZXN1bHRzOiBvcHRpb25zLnN0b3JlUmVzdWx0cyAhPT0gZmFsc2UsXHJcbiAgICBwdWJsaWNVcmw6IG9wdGlvbnMucHVibGljVXJsIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYW5hbHlzaXMgcHJvZ3Jlc3MgKGZvciBsb25nLXJ1bm5pbmcgYW5hbHlzZXMpXHJcbiAqIEBwYXJhbSBjb250ZXh0IEFuYWx5c2lzIGNvbnRleHRcclxuICogQHBhcmFtIGN1cnJlbnRTdGVwIEN1cnJlbnQgc3RlcFxyXG4gKiBAcGFyYW0gdG90YWxTdGVwcyBUb3RhbCBzdGVwc1xyXG4gKiBAcmV0dXJucyBQcm9ncmVzcyBpbmZvcm1hdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuYWx5c2lzUHJvZ3Jlc3MoXHJcbiAgY29udGV4dDogQW5hbHlzaXNDb250ZXh0LFxyXG4gIGN1cnJlbnRTdGVwOiBudW1iZXIsXHJcbiAgdG90YWxTdGVwczogbnVtYmVyXHJcbik6IHtcclxuICBzdGVwOiBzdHJpbmc7XHJcbiAgcHJvZ3Jlc3M6IG51bWJlcjtcclxuICBkZXRhaWxzOiBzdHJpbmc7XHJcbn0ge1xyXG4gIGNvbnN0IHN0ZXBzID0gW1xyXG4gICAgJ0xvYWRpbmcgYmFzZWxpbmUgcnVsZXMnLFxyXG4gICAgJ0V4dHJhY3RpbmcgWklQIGZpbGUnLFxyXG4gICAgJ0RldGVjdGluZyBwcm9qZWN0IG1hbmlmZXN0cycsXHJcbiAgICAnQW5hbHl6aW5nIGRlcGVuZGVuY2llcycsXHJcbiAgICAnU2Nhbm5pbmcgc291cmNlIGZpbGVzJyxcclxuICAgICdHZW5lcmF0aW5nIHJlcG9ydCcsXHJcbiAgXTtcclxuXHJcbiAgY29uc3Qgc3RlcCA9IHN0ZXBzW2N1cnJlbnRTdGVwXSB8fCAnVW5rbm93bic7XHJcbiAgY29uc3QgcHJvZ3Jlc3MgPSAoY3VycmVudFN0ZXAgLyB0b3RhbFN0ZXBzKSAqIDEwMDtcclxuICBcclxuICBsZXQgZGV0YWlscyA9ICcnO1xyXG4gIGlmIChjdXJyZW50U3RlcCA9PT0gMSkge1xyXG4gICAgZGV0YWlscyA9IGBFeHRyYWN0ZWQgJHtjb250ZXh0LmV4dHJhY3RlZEZpbGVzLmxlbmd0aH0gZmlsZXNgO1xyXG4gIH0gZWxzZSBpZiAoY3VycmVudFN0ZXAgPT09IDIpIHtcclxuICAgIGRldGFpbHMgPSBgRm91bmQgJHtjb250ZXh0Lm1hbmlmZXN0cy5sZW5ndGh9IG1hbmlmZXN0cywgJHtjb250ZXh0LmRldGVjdGVkTGFuZ3VhZ2VzLmxlbmd0aH0gbGFuZ3VhZ2VzYDtcclxuICB9IGVsc2UgaWYgKGN1cnJlbnRTdGVwID09PSAzKSB7XHJcbiAgICBkZXRhaWxzID0gYEFuYWx5emluZyAke2NvbnRleHQubWFuaWZlc3RzLmxlbmd0aH0gZGVwZW5kZW5jeSBtYW5pZmVzdHNgO1xyXG4gIH0gZWxzZSBpZiAoY3VycmVudFN0ZXAgPT09IDQpIHtcclxuICAgIGRldGFpbHMgPSBgU2Nhbm5pbmcgJHtjb250ZXh0LmV4dHJhY3RlZEZpbGVzLmxlbmd0aH0gc291cmNlIGZpbGVzYDtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzdGVwLFxyXG4gICAgcHJvZ3Jlc3MsXHJcbiAgICBkZXRhaWxzLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFc3RpbWF0ZSBhbmFseXNpcyB0aW1lXHJcbiAqIEBwYXJhbSBmaWxlQ291bnQgTnVtYmVyIG9mIGZpbGVzXHJcbiAqIEBwYXJhbSBtYW5pZmVzdENvdW50IE51bWJlciBvZiBtYW5pZmVzdHNcclxuICogQHJldHVybnMgRXN0aW1hdGVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXN0aW1hdGVBbmFseXNpc1RpbWUoZmlsZUNvdW50OiBudW1iZXIsIG1hbmlmZXN0Q291bnQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgLy8gQmFzZSB0aW1lOiAxIHNlY29uZFxyXG4gIGxldCBlc3RpbWF0ZWQgPSAxMDAwO1xyXG4gIFxyXG4gIC8vIEFkZCB0aW1lIGZvciBmaWxlIHByb2Nlc3Npbmc6IDEwbXMgcGVyIGZpbGVcclxuICBlc3RpbWF0ZWQgKz0gZmlsZUNvdW50ICogMTA7XHJcbiAgXHJcbiAgLy8gQWRkIHRpbWUgZm9yIG1hbmlmZXN0IHByb2Nlc3Npbmc6IDUwbXMgcGVyIG1hbmlmZXN0XHJcbiAgZXN0aW1hdGVkICs9IG1hbmlmZXN0Q291bnQgKiA1MDtcclxuICBcclxuICAvLyBBZGQgdGltZSBmb3IgcGF0dGVybiBzY2FubmluZzogNW1zIHBlciBmaWxlXHJcbiAgZXN0aW1hdGVkICs9IGZpbGVDb3VudCAqIDU7XHJcbiAgXHJcbiAgcmV0dXJuIE1hdGgubWluKGVzdGltYXRlZCwgMzAwMDApOyAvLyBDYXAgYXQgMzAgc2Vjb25kc1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYW5hbHlzaXMgaXMgZmVhc2libGVcclxuICogQHBhcmFtIGZpbGVDb3VudCBOdW1iZXIgb2YgZmlsZXNcclxuICogQHBhcmFtIHRvdGFsU2l6ZSBUb3RhbCBzaXplIGluIGJ5dGVzXHJcbiAqIEByZXR1cm5zIEZlYXNpYmlsaXR5IGNoZWNrIHJlc3VsdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrQW5hbHlzaXNGZWFzaWJpbGl0eShcclxuICBmaWxlQ291bnQ6IG51bWJlcixcclxuICB0b3RhbFNpemU6IG51bWJlclxyXG4pOiB7XHJcbiAgZmVhc2libGU6IGJvb2xlYW47XHJcbiAgd2FybmluZ3M6IHN0cmluZ1tdO1xyXG4gIGVzdGltYXRlZFRpbWU6IG51bWJlcjtcclxufSB7XHJcbiAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XHJcbiAgbGV0IGZlYXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgLy8gQ2hlY2sgZmlsZSBjb3VudFxyXG4gIGlmIChmaWxlQ291bnQgPiA1MDAwMCkge1xyXG4gICAgZmVhc2libGUgPSBmYWxzZTtcclxuICAgIHdhcm5pbmdzLnB1c2goYFRvbyBtYW55IGZpbGVzOiAke2ZpbGVDb3VudH0gKGxpbWl0OiA1MCwwMDApYCk7XHJcbiAgfSBlbHNlIGlmIChmaWxlQ291bnQgPiAxMDAwMCkge1xyXG4gICAgd2FybmluZ3MucHVzaChgTGFyZ2UgbnVtYmVyIG9mIGZpbGVzOiAke2ZpbGVDb3VudH0gKGFuYWx5c2lzIG1heSB0YWtlIGxvbmdlcilgKTtcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIHRvdGFsIHNpemVcclxuICBpZiAodG90YWxTaXplID4gMTAwICogMTAyNCAqIDEwMjQpIHsgLy8gMTAwTUJcclxuICAgIGZlYXNpYmxlID0gZmFsc2U7XHJcbiAgICB3YXJuaW5ncy5wdXNoKGBBcmNoaXZlIHRvbyBsYXJnZTogJHtNYXRoLnJvdW5kKHRvdGFsU2l6ZSAvIDEwMjQgLyAxMDI0KX1NQiAobGltaXQ6IDEwME1CKWApO1xyXG4gIH0gZWxzZSBpZiAodG90YWxTaXplID4gNTAgKiAxMDI0ICogMTAyNCkgeyAvLyA1ME1CXHJcbiAgICB3YXJuaW5ncy5wdXNoKGBMYXJnZSBhcmNoaXZlOiAke01hdGgucm91bmQodG90YWxTaXplIC8gMTAyNCAvIDEwMjQpfU1CIChhbmFseXNpcyBtYXkgdGFrZSBsb25nZXIpYCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBlc3RpbWF0ZWRUaW1lID0gZXN0aW1hdGVBbmFseXNpc1RpbWUoZmlsZUNvdW50LCBNYXRoLm1pbihmaWxlQ291bnQgLyAxMDAsIDUwKSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBmZWFzaWJsZSxcclxuICAgIHdhcm5pbmdzLFxyXG4gICAgZXN0aW1hdGVkVGltZSxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJyYW5kb21VVUlEIiwibG9hZEJhc2VsaW5lUnVsZXMiLCJkZXRlY3RQcm9qZWN0TWFuaWZlc3RzIiwiZGV0ZWN0TGFuZ3VhZ2VzRnJvbUZpbGVzIiwiYW5hbHl6ZURlcGVuZGVuY2llcyIsInNjYW5Tb3VyY2VGaWxlcyIsImV4dHJhY3RaaXBUb01lbW9yeSIsInByb2Nlc3NTaW5nbGVGaWxlIiwic2hvdWxkQW5hbHl6ZUZpbGUiLCJzdG9yZUFuYWx5c2lzUmVzdWx0cyIsImFuYWx5emVXaXRoR3JvcSIsImZpbGVzIiwicHJvamVjdFR5cGUiLCJkZXBlbmRlbmNpZXMiLCJyZXN1bHRzIiwicHJvY2VzcyIsImVudiIsIkdST1FfQVBJX0tFWSIsImNvbnNvbGUiLCJsb2ciLCJrZXlGaWxlcyIsImZpbHRlciIsImZpbGUiLCJmaWxlTmFtZSIsIm5hbWUiLCJwYXRoIiwiZXh0Iiwic3BsaXQiLCJwb3AiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic2xpY2UiLCJiYXNlVXJsIiwiUFVCTElDX1VSTCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb2RlIiwiY29udGVudCIsImZpbGVuYW1lIiwib2siLCJyZXN1bHQiLCJqc29uIiwicHVzaCIsImVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInJ1bkJhc2VsaW5lQW5hbHlzaXMiLCJmaWxlUGF0aCIsIm9wdGlvbnMiLCJtYXhGaWxlcyIsIm1heEZpbGVTaXplIiwiYWxsb3dlZEV4dGVuc2lvbnMiLCJpZ25vcmVQYXRocyIsInN0b3JlUmVzdWx0cyIsInB1YmxpY1VybCIsImFuYWx5c2lzSWQiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwicnVsZXMiLCJpc1ppcEZpbGUiLCJlbmRzV2l0aCIsImV4dHJhY3RSZXN1bHQiLCJlcnJvcnMiLCJsZW5ndGgiLCJ3YXJuIiwiZnMiLCJyZWFkRmlsZVN5bmMiLCJFcnJvciIsIm1hbmlmZXN0cyIsImRldGVjdGVkTGFuZ3VhZ2VzIiwiY29udGV4dCIsImV4dHJhY3RlZEZpbGVzIiwiZmluZGluZ3MiLCJydW5BbmFseXNpcyIsInN1bW1hcnkiLCJnZW5lcmF0ZVN1bW1hcnkiLCJncm9xUmVzdWx0cyIsImpvaW4iLCJmbGF0TWFwIiwibSIsIk9iamVjdCIsImtleXMiLCJyZXBvcnQiLCJtZXRhZGF0YSIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwicHJvamVjdE5hbWUiLCJnZXRQcm9qZWN0TmFtZSIsInRvdGFsRmlsZXMiLCJzY2FubmVkRmlsZXMiLCJza2lwcGVkRmlsZXMiLCJncm9xQW5hbHlzaXMiLCJhcnRpZmFjdHMiLCJlbmRUaW1lIiwibWVzc2FnZSIsImRlcGVuZGVuY3lGaW5kaW5ncyIsInBhdHRlcm5GaW5kaW5ncyIsImFmZmVjdGVkIiwidW5rbm93biIsImJ5TGFuZ3VhZ2UiLCJsYW5ndWFnZSIsImZpbmRpbmciLCJraW5kIiwibGFuZyIsInppcFBhdGgiLCJwYXRoUGFydHMiLCJyZXBsYWNlIiwicnVuQW5hbHlzaXNPbkZpbGVzIiwidmFsaWRhdGVBbmFseXNpc09wdGlvbnMiLCJNYXRoIiwibWluIiwiZ2V0QW5hbHlzaXNQcm9ncmVzcyIsImN1cnJlbnRTdGVwIiwidG90YWxTdGVwcyIsInN0ZXBzIiwic3RlcCIsInByb2dyZXNzIiwiZGV0YWlscyIsImVzdGltYXRlQW5hbHlzaXNUaW1lIiwiZmlsZUNvdW50IiwibWFuaWZlc3RDb3VudCIsImVzdGltYXRlZCIsImNoZWNrQW5hbHlzaXNGZWFzaWJpbGl0eSIsInRvdGFsU2l6ZSIsIndhcm5pbmdzIiwiZmVhc2libGUiLCJyb3VuZCIsImVzdGltYXRlZFRpbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./lib/analysis/run.ts\n");

/***/ }),

/***/ "(api-node)/./lib/analysis/scan.ts":
/*!******************************!*\
  !*** ./lib/analysis/scan.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fileHasDeprecatedPatterns: () => (/* binding */ fileHasDeprecatedPatterns),\n/* harmony export */   filterPatternFindingsByFile: () => (/* binding */ filterPatternFindingsByFile),\n/* harmony export */   filterPatternFindingsByLanguage: () => (/* binding */ filterPatternFindingsByLanguage),\n/* harmony export */   getDeprecatedPatternLines: () => (/* binding */ getDeprecatedPatternLines),\n/* harmony export */   getFilesWithDeprecatedPatterns: () => (/* binding */ getFilesWithDeprecatedPatterns),\n/* harmony export */   getMostCommonPatterns: () => (/* binding */ getMostCommonPatterns),\n/* harmony export */   getPatternFrequency: () => (/* binding */ getPatternFrequency),\n/* harmony export */   getPatternQuickFix: () => (/* binding */ getPatternQuickFix),\n/* harmony export */   getPatternSummary: () => (/* binding */ getPatternSummary),\n/* harmony export */   getUniquePatterns: () => (/* binding */ getUniquePatterns),\n/* harmony export */   groupPatternFindingsByFile: () => (/* binding */ groupPatternFindingsByFile),\n/* harmony export */   groupPatternFindingsByLanguage: () => (/* binding */ groupPatternFindingsByLanguage),\n/* harmony export */   scanSourceFiles: () => (/* binding */ scanSourceFiles),\n/* harmony export */   sortPatternFindings: () => (/* binding */ sortPatternFindings)\n/* harmony export */ });\n/* harmony import */ var _baseline_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./baseline.loader */ \"(api-node)/./lib/analysis/baseline.loader.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_baseline_loader__WEBPACK_IMPORTED_MODULE_0__]);\n_baseline_loader__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\r\n * Scan source files for deprecated patterns\r\n * @param files Array of extracted files\r\n * @param rules Baseline rules\r\n * @returns Array of pattern findings\r\n */ function scanSourceFiles(files, rules) {\n    const findings = [];\n    for (const file of files){\n        // Skip files that are too large\n        if (file.size > rules.max_file_size) {\n            console.warn(`Skipping large file: ${file.path || file.name} (${file.size} bytes)`);\n            continue;\n        }\n        // Skip ignored paths\n        const filePath = file.path || file.name;\n        if ((0,_baseline_loader__WEBPACK_IMPORTED_MODULE_0__.shouldIgnorePath)(rules, filePath)) {\n            continue;\n        }\n        // Skip files that shouldn't be scanned\n        const extension = getFileExtension(filePath);\n        if (!(0,_baseline_loader__WEBPACK_IMPORTED_MODULE_0__.shouldScanFile)(rules, extension)) {\n            continue;\n        }\n        // Detect language from file extension\n        const language = detectLanguageFromExtension(extension);\n        if (!language) {\n            continue;\n        }\n        // Get deprecated patterns for this language\n        const patterns = rules.deprecated_patterns[language] || [];\n        if (patterns.length === 0) {\n            continue;\n        }\n        // Scan file content\n        const fileFindings = scanFileContent(file, language, patterns, rules);\n        findings.push(...fileFindings);\n    }\n    return findings;\n}\n/**\r\n * Scan a single file for deprecated patterns\r\n * @param file File to scan\r\n * @param language Language of the file\r\n * @param patterns Deprecated patterns to look for\r\n * @param rules Baseline rules\r\n * @returns Array of pattern findings\r\n */ function scanFileContent(file, language, patterns, rules) {\n    const findings = [];\n    const lines = file.content.split('\\n');\n    for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n        const line = lines[lineIndex];\n        const lineNumber = lineIndex + 1;\n        // Skip empty lines and comments\n        if (isCommentLine(line, language) || line.trim() === '') {\n            continue;\n        }\n        // Check each pattern\n        for (const pattern of patterns){\n            try {\n                const regex = new RegExp(pattern.pattern, 'g');\n                let match;\n                while((match = regex.exec(line)) !== null){\n                    // Avoid infinite loops with zero-length matches\n                    if (match.index === regex.lastIndex) {\n                        regex.lastIndex++;\n                    }\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: file.path || file.name || 'unknown',\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'deprecated-api',\n                        issue: pattern.message,\n                        pattern: pattern.pattern,\n                        quickFix: pattern.alternative\n                    });\n                }\n            } catch (error) {\n                console.warn(`Invalid regex pattern: ${pattern.pattern} - ${error}`);\n            }\n        }\n    }\n    return findings;\n}\n/**\r\n * Get file extension from path\r\n * @param filePath File path\r\n * @returns File extension with dot\r\n */ function getFileExtension(filePath) {\n    const lastDot = filePath.lastIndexOf('.');\n    if (lastDot === -1) return '';\n    return filePath.substring(lastDot);\n}\n/**\r\n * Detect language from file extension\r\n * @param extension File extension\r\n * @returns Language or null\r\n */ function detectLanguageFromExtension(extension) {\n    const languageMap = {\n        '.js': 'node',\n        '.jsx': 'node',\n        '.ts': 'node',\n        '.tsx': 'node',\n        '.py': 'python',\n        '.java': 'java',\n        '.go': 'go',\n        '.cs': 'dotnet',\n        '.fs': 'dotnet',\n        '.vb': 'dotnet'\n    };\n    return languageMap[extension] || null;\n}\n/**\r\n * Check if a line is a comment\r\n * @param line Line content\r\n * @param language Language context\r\n * @returns True if comment line\r\n */ function isCommentLine(line, language) {\n    const trimmed = line.trim();\n    switch(language){\n        case 'node':\n        case 'java':\n        case 'go':\n        case 'dotnet':\n            return trimmed.startsWith('//') || trimmed.startsWith('/*') || trimmed.startsWith('*');\n        case 'python':\n            return trimmed.startsWith('#');\n        default:\n            return false;\n    }\n}\n/**\r\n * Get quick fix for pattern replacement\r\n * @param rules Baseline rules\r\n * @param language Language\r\n * @param pattern Pattern to replace\r\n * @returns Quick fix suggestion or undefined\r\n */ function getPatternQuickFix(rules, language, pattern) {\n    return rules.quick_fixes.pattern_replacement[language]?.[pattern];\n}\n/**\r\n * Group pattern findings by file\r\n * @param findings Pattern findings\r\n * @returns Grouped findings by file\r\n */ function groupPatternFindingsByFile(findings) {\n    const grouped = {};\n    for (const finding of findings){\n        if (!grouped[finding.file]) {\n            grouped[finding.file] = [];\n        }\n        grouped[finding.file].push(finding);\n    }\n    return grouped;\n}\n/**\r\n * Group pattern findings by language\r\n * @param findings Pattern findings\r\n * @returns Grouped findings by language\r\n */ function groupPatternFindingsByLanguage(findings) {\n    const grouped = {};\n    for (const finding of findings){\n        if (!grouped[finding.lang]) {\n            grouped[finding.lang] = [];\n        }\n        grouped[finding.lang].push(finding);\n    }\n    return grouped;\n}\n/**\r\n * Get pattern summary statistics\r\n * @param findings Pattern findings\r\n * @returns Summary statistics\r\n */ function getPatternSummary(findings) {\n    const total = findings.length;\n    const byLanguage = groupPatternFindingsByLanguage(findings);\n    const byFile = groupPatternFindingsByFile(findings);\n    return {\n        total,\n        affectedFiles: Object.keys(byFile).length,\n        byLanguage: Object.fromEntries(Object.entries(byLanguage).map(([lang, findings])=>[\n                lang,\n                {\n                    count: findings.length,\n                    files: new Set(findings.map((f)=>f.file)).size\n                }\n            ]))\n    };\n}\n/**\r\n * Filter pattern findings by language\r\n * @param findings Pattern findings\r\n * @param language Language to filter by\r\n * @returns Filtered findings\r\n */ function filterPatternFindingsByLanguage(findings, language) {\n    return findings.filter((f)=>f.lang === language);\n}\n/**\r\n * Filter pattern findings by file\r\n * @param findings Pattern findings\r\n * @param filePath File path to filter by\r\n * @returns Filtered findings\r\n */ function filterPatternFindingsByFile(findings, filePath) {\n    return findings.filter((f)=>f.file === filePath);\n}\n/**\r\n * Sort pattern findings by file and line\r\n * @param findings Pattern findings\r\n * @returns Sorted findings\r\n */ function sortPatternFindings(findings) {\n    return [\n        ...findings\n    ].sort((a, b)=>{\n        // First by file path\n        const fileDiff = a.file.localeCompare(b.file);\n        if (fileDiff !== 0) return fileDiff;\n        // Then by line number\n        return a.line - b.line;\n    });\n}\n/**\r\n * Get unique patterns found\r\n * @param findings Pattern findings\r\n * @returns Array of unique patterns\r\n */ function getUniquePatterns(findings) {\n    const patterns = new Set();\n    for (const finding of findings){\n        patterns.add(finding.pattern);\n    }\n    return Array.from(patterns);\n}\n/**\r\n * Get pattern frequency\r\n * @param findings Pattern findings\r\n * @returns Pattern frequency map\r\n */ function getPatternFrequency(findings) {\n    const frequency = {};\n    for (const finding of findings){\n        frequency[finding.pattern] = (frequency[finding.pattern] || 0) + 1;\n    }\n    return frequency;\n}\n/**\r\n * Get most common patterns\r\n * @param findings Pattern findings\r\n * @param limit Maximum number of patterns to return\r\n * @returns Array of most common patterns\r\n */ function getMostCommonPatterns(findings, limit = 10) {\n    const frequency = getPatternFrequency(findings);\n    return Object.entries(frequency).map(([pattern, count])=>({\n            pattern,\n            count\n        })).sort((a, b)=>b.count - a.count).slice(0, limit);\n}\n/**\r\n * Check if a file contains any deprecated patterns\r\n * @param filePath File path\r\n * @param findings Pattern findings\r\n * @returns True if file has deprecated patterns\r\n */ function fileHasDeprecatedPatterns(filePath, findings) {\n    return findings.some((f)=>f.file === filePath);\n}\n/**\r\n * Get files with deprecated patterns\r\n * @param findings Pattern findings\r\n * @returns Array of file paths\r\n */ function getFilesWithDeprecatedPatterns(findings) {\n    const files = new Set();\n    for (const finding of findings){\n        files.add(finding.file);\n    }\n    return Array.from(files);\n}\n/**\r\n * Get line numbers with deprecated patterns for a file\r\n * @param filePath File path\r\n * @param findings Pattern findings\r\n * @returns Array of line numbers\r\n */ function getDeprecatedPatternLines(filePath, findings) {\n    return findings.filter((f)=>f.file === filePath).map((f)=>f.line).sort((a, b)=>a - b);\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTyxDQUFDbUIsV0FDbkJsQixHQUFHLENBQUMsQ0FBQyxDQUFDdEMsU0FBU3VDLE1BQU0sR0FBTTtZQUFFdkM7WUFBU3VDO1FBQU0sSUFDNUNPLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFVCxLQUFLLEdBQUdRLEVBQUVSLEtBQUssRUFDaENvQixLQUFLLENBQUMsR0FBR0Q7QUFDZDtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU0UsMEJBQ2QvRSxRQUFnQixFQUNoQlIsUUFBMEI7SUFFMUIsT0FBT0EsU0FBU3dGLElBQUksQ0FBQ3BCLENBQUFBLElBQUtBLEVBQUVuRSxJQUFJLEtBQUtPO0FBQ3ZDO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNpRiwrQkFBK0J6RixRQUEwQjtJQUN2RSxNQUFNRixRQUFRLElBQUlxRTtJQUVsQixLQUFLLE1BQU1iLFdBQVd0RCxTQUFVO1FBQzlCRixNQUFNaUYsR0FBRyxDQUFDekIsUUFBUXJELElBQUk7SUFDeEI7SUFFQSxPQUFPK0UsTUFBTUMsSUFBSSxDQUFDbkY7QUFDcEI7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVM0RiwwQkFDZGxGLFFBQWdCLEVBQ2hCUixRQUEwQjtJQUUxQixPQUFPQSxTQUNKc0UsTUFBTSxDQUFDRixDQUFBQSxJQUFLQSxFQUFFbkUsSUFBSSxLQUFLTyxVQUN2QnlELEdBQUcsQ0FBQ0csQ0FBQUEsSUFBS0EsRUFBRTdDLElBQUksRUFDZmtELElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQztBQUN4QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxDa2hhZGFyXFxEb3dubG9hZHNcXEFJX0Jhc2VsaW5lX01hcFxcbGliXFxhbmFseXNpc1xcc2Nhbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5ndWFnZSwgUGF0dGVybkZpbmRpbmcsIEJhc2VsaW5lUnVsZXMgfSBmcm9tICcuL2Jhc2VsaW5lLnR5cGVzJztcclxuaW1wb3J0IHsgc2hvdWxkU2NhbkZpbGUsIHNob3VsZElnbm9yZVBhdGggfSBmcm9tICcuL2Jhc2VsaW5lLmxvYWRlcic7XHJcblxyXG4vKipcclxuICogU2NhbiBzb3VyY2UgZmlsZXMgZm9yIGRlcHJlY2F0ZWQgcGF0dGVybnNcclxuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xyXG4gKiBAcGFyYW0gcnVsZXMgQmFzZWxpbmUgcnVsZXNcclxuICogQHJldHVybnMgQXJyYXkgb2YgcGF0dGVybiBmaW5kaW5nc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNjYW5Tb3VyY2VGaWxlcyhcclxuICBmaWxlczogQXJyYXk8eyBwYXRoPzogc3RyaW5nOyBuYW1lPzogc3RyaW5nOyBjb250ZW50OiBzdHJpbmc7IHNpemU6IG51bWJlciB9PixcclxuICBydWxlczogQmFzZWxpbmVSdWxlc1xyXG4pOiBQYXR0ZXJuRmluZGluZ1tdIHtcclxuICBjb25zdCBmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSA9IFtdO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xyXG4gICAgLy8gU2tpcCBmaWxlcyB0aGF0IGFyZSB0b28gbGFyZ2VcclxuICAgIGlmIChmaWxlLnNpemUgPiBydWxlcy5tYXhfZmlsZV9zaXplKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgbGFyZ2UgZmlsZTogJHtmaWxlLnBhdGggfHwgZmlsZS5uYW1lfSAoJHtmaWxlLnNpemV9IGJ5dGVzKWApO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gU2tpcCBpZ25vcmVkIHBhdGhzXHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aCB8fCBmaWxlLm5hbWU7XHJcbiAgICBpZiAoc2hvdWxkSWdub3JlUGF0aChydWxlcywgZmlsZVBhdGgpKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTa2lwIGZpbGVzIHRoYXQgc2hvdWxkbid0IGJlIHNjYW5uZWRcclxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGdldEZpbGVFeHRlbnNpb24oZmlsZVBhdGgpO1xyXG4gICAgaWYgKCFzaG91bGRTY2FuRmlsZShydWxlcywgZXh0ZW5zaW9uKSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRGV0ZWN0IGxhbmd1YWdlIGZyb20gZmlsZSBleHRlbnNpb25cclxuICAgIGNvbnN0IGxhbmd1YWdlID0gZGV0ZWN0TGFuZ3VhZ2VGcm9tRXh0ZW5zaW9uKGV4dGVuc2lvbik7XHJcbiAgICBpZiAoIWxhbmd1YWdlKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBHZXQgZGVwcmVjYXRlZCBwYXR0ZXJucyBmb3IgdGhpcyBsYW5ndWFnZVxyXG4gICAgY29uc3QgcGF0dGVybnMgPSBydWxlcy5kZXByZWNhdGVkX3BhdHRlcm5zW2xhbmd1YWdlXSB8fCBbXTtcclxuICAgIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNjYW4gZmlsZSBjb250ZW50XHJcbiAgICBjb25zdCBmaWxlRmluZGluZ3MgPSBzY2FuRmlsZUNvbnRlbnQoZmlsZSwgbGFuZ3VhZ2UsIHBhdHRlcm5zLCBydWxlcyk7XHJcbiAgICBmaW5kaW5ncy5wdXNoKC4uLmZpbGVGaW5kaW5ncyk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBmaW5kaW5ncztcclxufVxyXG5cclxuLyoqXHJcbiAqIFNjYW4gYSBzaW5nbGUgZmlsZSBmb3IgZGVwcmVjYXRlZCBwYXR0ZXJuc1xyXG4gKiBAcGFyYW0gZmlsZSBGaWxlIHRvIHNjYW5cclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIG9mIHRoZSBmaWxlXHJcbiAqIEBwYXJhbSBwYXR0ZXJucyBEZXByZWNhdGVkIHBhdHRlcm5zIHRvIGxvb2sgZm9yXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBwYXR0ZXJuIGZpbmRpbmdzXHJcbiAqL1xyXG5mdW5jdGlvbiBzY2FuRmlsZUNvbnRlbnQoXHJcbiAgZmlsZTogeyBwYXRoPzogc3RyaW5nOyBuYW1lPzogc3RyaW5nOyBjb250ZW50OiBzdHJpbmcgfSxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2UsXHJcbiAgcGF0dGVybnM6IEFycmF5PHsgcGF0dGVybjogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmc7IGFsdGVybmF0aXZlOiBzdHJpbmcgfT4sXHJcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNcclxuKTogUGF0dGVybkZpbmRpbmdbXSB7XHJcbiAgY29uc3QgZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10gPSBbXTtcclxuICBjb25zdCBsaW5lcyA9IGZpbGUuY29udGVudC5zcGxpdCgnXFxuJyk7XHJcbiAgXHJcbiAgZm9yIChsZXQgbGluZUluZGV4ID0gMDsgbGluZUluZGV4IDwgbGluZXMubGVuZ3RoOyBsaW5lSW5kZXgrKykge1xyXG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2xpbmVJbmRleF07XHJcbiAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcclxuICAgIFxyXG4gICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBhbmQgY29tbWVudHNcclxuICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGVhY2ggcGF0dGVyblxyXG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4ucGF0dGVybiwgJ2cnKTtcclxuICAgICAgICBsZXQgbWF0Y2g7XHJcbiAgICAgICAgXHJcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMobGluZSkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAvLyBBdm9pZCBpbmZpbml0ZSBsb29wcyB3aXRoIHplcm8tbGVuZ3RoIG1hdGNoZXNcclxuICAgICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gcmVnZXgubGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCsrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcclxuICAgICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxyXG4gICAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcclxuICAgICAgICAgICAgZmlsZTogZmlsZS5wYXRoIHx8IGZpbGUubmFtZSB8fCAndW5rbm93bicsXHJcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcclxuICAgICAgICAgICAgcmVhc29uOiAnZGVwcmVjYXRlZC1hcGknLFxyXG4gICAgICAgICAgICBpc3N1ZTogcGF0dGVybi5tZXNzYWdlLFxyXG4gICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLnBhdHRlcm4sXHJcbiAgICAgICAgICAgIHF1aWNrRml4OiBwYXR0ZXJuLmFsdGVybmF0aXZlLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCByZWdleCBwYXR0ZXJuOiAke3BhdHRlcm4ucGF0dGVybn0gLSAke2Vycm9yfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBmaW5kaW5ncztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBmaWxlIGV4dGVuc2lvbiBmcm9tIHBhdGhcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aFxyXG4gKiBAcmV0dXJucyBGaWxlIGV4dGVuc2lvbiB3aXRoIGRvdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBsYXN0RG90ID0gZmlsZVBhdGgubGFzdEluZGV4T2YoJy4nKTtcclxuICBpZiAobGFzdERvdCA9PT0gLTEpIHJldHVybiAnJztcclxuICByZXR1cm4gZmlsZVBhdGguc3Vic3RyaW5nKGxhc3REb3QpO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZWN0IGxhbmd1YWdlIGZyb20gZmlsZSBleHRlbnNpb25cclxuICogQHBhcmFtIGV4dGVuc2lvbiBGaWxlIGV4dGVuc2lvblxyXG4gKiBAcmV0dXJucyBMYW5ndWFnZSBvciBudWxsXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uOiBzdHJpbmcpOiBMYW5ndWFnZSB8IG51bGwge1xyXG4gIGNvbnN0IGxhbmd1YWdlTWFwOiBSZWNvcmQ8c3RyaW5nLCBMYW5ndWFnZT4gPSB7XHJcbiAgICAnLmpzJzogJ25vZGUnLFxyXG4gICAgJy5qc3gnOiAnbm9kZScsXHJcbiAgICAnLnRzJzogJ25vZGUnLFxyXG4gICAgJy50c3gnOiAnbm9kZScsXHJcbiAgICAnLnB5JzogJ3B5dGhvbicsXHJcbiAgICAnLmphdmEnOiAnamF2YScsXHJcbiAgICAnLmdvJzogJ2dvJyxcclxuICAgICcuY3MnOiAnZG90bmV0JyxcclxuICAgICcuZnMnOiAnZG90bmV0JyxcclxuICAgICcudmInOiAnZG90bmV0JyxcclxuICB9O1xyXG4gIFxyXG4gIHJldHVybiBsYW5ndWFnZU1hcFtleHRlbnNpb25dIHx8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGxpbmUgaXMgYSBjb21tZW50XHJcbiAqIEBwYXJhbSBsaW5lIExpbmUgY29udGVudFxyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGNvbW1lbnQgbGluZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNDb21tZW50TGluZShsaW5lOiBzdHJpbmcsIGxhbmd1YWdlOiBMYW5ndWFnZSk6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcclxuICBcclxuICBzd2l0Y2ggKGxhbmd1YWdlKSB7XHJcbiAgICBjYXNlICdub2RlJzpcclxuICAgIGNhc2UgJ2phdmEnOlxyXG4gICAgY2FzZSAnZ28nOlxyXG4gICAgY2FzZSAnZG90bmV0JzpcclxuICAgICAgcmV0dXJuIHRyaW1tZWQuc3RhcnRzV2l0aCgnLy8nKSB8fCB0cmltbWVkLnN0YXJ0c1dpdGgoJy8qJykgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCcqJyk7XHJcbiAgICBcclxuICAgIGNhc2UgJ3B5dGhvbic6XHJcbiAgICAgIHJldHVybiB0cmltbWVkLnN0YXJ0c1dpdGgoJyMnKTtcclxuICAgIFxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBxdWljayBmaXggZm9yIHBhdHRlcm4gcmVwbGFjZW1lbnRcclxuICogQHBhcmFtIHJ1bGVzIEJhc2VsaW5lIHJ1bGVzXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZVxyXG4gKiBAcGFyYW0gcGF0dGVybiBQYXR0ZXJuIHRvIHJlcGxhY2VcclxuICogQHJldHVybnMgUXVpY2sgZml4IHN1Z2dlc3Rpb24gb3IgdW5kZWZpbmVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0dGVyblF1aWNrRml4KFxyXG4gIHJ1bGVzOiBCYXNlbGluZVJ1bGVzLFxyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZSxcclxuICBwYXR0ZXJuOiBzdHJpbmdcclxuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICByZXR1cm4gcnVsZXMucXVpY2tfZml4ZXMucGF0dGVybl9yZXBsYWNlbWVudFtsYW5ndWFnZV0/LltwYXR0ZXJuXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdyb3VwIHBhdHRlcm4gZmluZGluZ3MgYnkgZmlsZVxyXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xyXG4gKiBAcmV0dXJucyBHcm91cGVkIGZpbmRpbmdzIGJ5IGZpbGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBncm91cFBhdHRlcm5GaW5kaW5nc0J5RmlsZShmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSk6IFJlY29yZDxzdHJpbmcsIFBhdHRlcm5GaW5kaW5nW10+IHtcclxuICBjb25zdCBncm91cGVkOiBSZWNvcmQ8c3RyaW5nLCBQYXR0ZXJuRmluZGluZ1tdPiA9IHt9O1xyXG4gIFxyXG4gIGZvciAoY29uc3QgZmluZGluZyBvZiBmaW5kaW5ncykge1xyXG4gICAgaWYgKCFncm91cGVkW2ZpbmRpbmcuZmlsZV0pIHtcclxuICAgICAgZ3JvdXBlZFtmaW5kaW5nLmZpbGVdID0gW107XHJcbiAgICB9XHJcbiAgICBncm91cGVkW2ZpbmRpbmcuZmlsZV0ucHVzaChmaW5kaW5nKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGdyb3VwZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHcm91cCBwYXR0ZXJuIGZpbmRpbmdzIGJ5IGxhbmd1YWdlXHJcbiAqIEBwYXJhbSBmaW5kaW5ncyBQYXR0ZXJuIGZpbmRpbmdzXHJcbiAqIEByZXR1cm5zIEdyb3VwZWQgZmluZGluZ3MgYnkgbGFuZ3VhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBncm91cFBhdHRlcm5GaW5kaW5nc0J5TGFuZ3VhZ2UoZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10pOiBSZWNvcmQ8TGFuZ3VhZ2UsIFBhdHRlcm5GaW5kaW5nW10+IHtcclxuICBjb25zdCBncm91cGVkOiBSZWNvcmQ8TGFuZ3VhZ2UsIFBhdHRlcm5GaW5kaW5nW10+ID0ge307XHJcbiAgXHJcbiAgZm9yIChjb25zdCBmaW5kaW5nIG9mIGZpbmRpbmdzKSB7XHJcbiAgICBpZiAoIWdyb3VwZWRbZmluZGluZy5sYW5nXSkge1xyXG4gICAgICBncm91cGVkW2ZpbmRpbmcubGFuZ10gPSBbXTtcclxuICAgIH1cclxuICAgIGdyb3VwZWRbZmluZGluZy5sYW5nXS5wdXNoKGZpbmRpbmcpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gZ3JvdXBlZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBwYXR0ZXJuIHN1bW1hcnkgc3RhdGlzdGljc1xyXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xyXG4gKiBAcmV0dXJucyBTdW1tYXJ5IHN0YXRpc3RpY3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXR0ZXJuU3VtbWFyeShmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSkge1xyXG4gIGNvbnN0IHRvdGFsID0gZmluZGluZ3MubGVuZ3RoO1xyXG4gIGNvbnN0IGJ5TGFuZ3VhZ2UgPSBncm91cFBhdHRlcm5GaW5kaW5nc0J5TGFuZ3VhZ2UoZmluZGluZ3MpO1xyXG4gIGNvbnN0IGJ5RmlsZSA9IGdyb3VwUGF0dGVybkZpbmRpbmdzQnlGaWxlKGZpbmRpbmdzKTtcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgdG90YWwsXHJcbiAgICBhZmZlY3RlZEZpbGVzOiBPYmplY3Qua2V5cyhieUZpbGUpLmxlbmd0aCxcclxuICAgIGJ5TGFuZ3VhZ2U6IE9iamVjdC5mcm9tRW50cmllcyhcclxuICAgICAgT2JqZWN0LmVudHJpZXMoYnlMYW5ndWFnZSkubWFwKChbbGFuZywgZmluZGluZ3NdKSA9PiBbXHJcbiAgICAgICAgbGFuZyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBjb3VudDogZmluZGluZ3MubGVuZ3RoLFxyXG4gICAgICAgICAgZmlsZXM6IG5ldyBTZXQoZmluZGluZ3MubWFwKGYgPT4gZi5maWxlKSkuc2l6ZSxcclxuICAgICAgICB9LFxyXG4gICAgICBdKVxyXG4gICAgKSxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogRmlsdGVyIHBhdHRlcm4gZmluZGluZ3MgYnkgbGFuZ3VhZ2VcclxuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIHRvIGZpbHRlciBieVxyXG4gKiBAcmV0dXJucyBGaWx0ZXJlZCBmaW5kaW5nc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclBhdHRlcm5GaW5kaW5nc0J5TGFuZ3VhZ2UoXHJcbiAgZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10sXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IFBhdHRlcm5GaW5kaW5nW10ge1xyXG4gIHJldHVybiBmaW5kaW5ncy5maWx0ZXIoZiA9PiBmLmxhbmcgPT09IGxhbmd1YWdlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbHRlciBwYXR0ZXJuIGZpbmRpbmdzIGJ5IGZpbGVcclxuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aCB0byBmaWx0ZXIgYnlcclxuICogQHJldHVybnMgRmlsdGVyZWQgZmluZGluZ3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJQYXR0ZXJuRmluZGluZ3NCeUZpbGUoXHJcbiAgZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10sXHJcbiAgZmlsZVBhdGg6IHN0cmluZ1xyXG4pOiBQYXR0ZXJuRmluZGluZ1tdIHtcclxuICByZXR1cm4gZmluZGluZ3MuZmlsdGVyKGYgPT4gZi5maWxlID09PSBmaWxlUGF0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTb3J0IHBhdHRlcm4gZmluZGluZ3MgYnkgZmlsZSBhbmQgbGluZVxyXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xyXG4gKiBAcmV0dXJucyBTb3J0ZWQgZmluZGluZ3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzb3J0UGF0dGVybkZpbmRpbmdzKGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdKTogUGF0dGVybkZpbmRpbmdbXSB7XHJcbiAgcmV0dXJuIFsuLi5maW5kaW5nc10uc29ydCgoYSwgYikgPT4ge1xyXG4gICAgLy8gRmlyc3QgYnkgZmlsZSBwYXRoXHJcbiAgICBjb25zdCBmaWxlRGlmZiA9IGEuZmlsZS5sb2NhbGVDb21wYXJlKGIuZmlsZSk7XHJcbiAgICBpZiAoZmlsZURpZmYgIT09IDApIHJldHVybiBmaWxlRGlmZjtcclxuICAgIFxyXG4gICAgLy8gVGhlbiBieSBsaW5lIG51bWJlclxyXG4gICAgcmV0dXJuIGEubGluZSAtIGIubGluZTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB1bmlxdWUgcGF0dGVybnMgZm91bmRcclxuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcclxuICogQHJldHVybnMgQXJyYXkgb2YgdW5pcXVlIHBhdHRlcm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pcXVlUGF0dGVybnMoZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10pOiBzdHJpbmdbXSB7XHJcbiAgY29uc3QgcGF0dGVybnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICBcclxuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgZmluZGluZ3MpIHtcclxuICAgIHBhdHRlcm5zLmFkZChmaW5kaW5nLnBhdHRlcm4pO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gQXJyYXkuZnJvbShwYXR0ZXJucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgcGF0dGVybiBmcmVxdWVuY3lcclxuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcclxuICogQHJldHVybnMgUGF0dGVybiBmcmVxdWVuY3kgbWFwXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0dGVybkZyZXF1ZW5jeShmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xyXG4gIGNvbnN0IGZyZXF1ZW5jeTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gIFxyXG4gIGZvciAoY29uc3QgZmluZGluZyBvZiBmaW5kaW5ncykge1xyXG4gICAgZnJlcXVlbmN5W2ZpbmRpbmcucGF0dGVybl0gPSAoZnJlcXVlbmN5W2ZpbmRpbmcucGF0dGVybl0gfHwgMCkgKyAxO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gZnJlcXVlbmN5O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IG1vc3QgY29tbW9uIHBhdHRlcm5zXHJcbiAqIEBwYXJhbSBmaW5kaW5ncyBQYXR0ZXJuIGZpbmRpbmdzXHJcbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBwYXR0ZXJucyB0byByZXR1cm5cclxuICogQHJldHVybnMgQXJyYXkgb2YgbW9zdCBjb21tb24gcGF0dGVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb3N0Q29tbW9uUGF0dGVybnMoXHJcbiAgZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10sXHJcbiAgbGltaXQ6IG51bWJlciA9IDEwXHJcbik6IEFycmF5PHsgcGF0dGVybjogc3RyaW5nOyBjb3VudDogbnVtYmVyIH0+IHtcclxuICBjb25zdCBmcmVxdWVuY3kgPSBnZXRQYXR0ZXJuRnJlcXVlbmN5KGZpbmRpbmdzKTtcclxuICBcclxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZnJlcXVlbmN5KVxyXG4gICAgLm1hcCgoW3BhdHRlcm4sIGNvdW50XSkgPT4gKHsgcGF0dGVybiwgY291bnQgfSkpXHJcbiAgICAuc29ydCgoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnQpXHJcbiAgICAuc2xpY2UoMCwgbGltaXQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYSBmaWxlIGNvbnRhaW5zIGFueSBkZXByZWNhdGVkIHBhdHRlcm5zXHJcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcclxuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcclxuICogQHJldHVybnMgVHJ1ZSBpZiBmaWxlIGhhcyBkZXByZWNhdGVkIHBhdHRlcm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmlsZUhhc0RlcHJlY2F0ZWRQYXR0ZXJucyhcclxuICBmaWxlUGF0aDogc3RyaW5nLFxyXG4gIGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdXHJcbik6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBmaW5kaW5ncy5zb21lKGYgPT4gZi5maWxlID09PSBmaWxlUGF0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZmlsZXMgd2l0aCBkZXByZWNhdGVkIHBhdHRlcm5zXHJcbiAqIEBwYXJhbSBmaW5kaW5ncyBQYXR0ZXJuIGZpbmRpbmdzXHJcbiAqIEByZXR1cm5zIEFycmF5IG9mIGZpbGUgcGF0aHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlc1dpdGhEZXByZWNhdGVkUGF0dGVybnMoZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10pOiBzdHJpbmdbXSB7XHJcbiAgY29uc3QgZmlsZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICBcclxuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgZmluZGluZ3MpIHtcclxuICAgIGZpbGVzLmFkZChmaW5kaW5nLmZpbGUpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gQXJyYXkuZnJvbShmaWxlcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgbGluZSBudW1iZXJzIHdpdGggZGVwcmVjYXRlZCBwYXR0ZXJucyBmb3IgYSBmaWxlXHJcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcclxuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcclxuICogQHJldHVybnMgQXJyYXkgb2YgbGluZSBudW1iZXJzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwcmVjYXRlZFBhdHRlcm5MaW5lcyhcclxuICBmaWxlUGF0aDogc3RyaW5nLFxyXG4gIGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdXHJcbik6IG51bWJlcltdIHtcclxuICByZXR1cm4gZmluZGluZ3NcclxuICAgIC5maWx0ZXIoZiA9PiBmLmZpbGUgPT09IGZpbGVQYXRoKVxyXG4gICAgLm1hcChmID0+IGYubGluZSlcclxuICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbn1cclxuIl0sIm5hbWVzIjpbInNob3VsZFNjYW5GaWxlIiwic2hvdWxkSWdub3JlUGF0aCIsInNjYW5Tb3VyY2VGaWxlcyIsImZpbGVzIiwicnVsZXMiLCJmaW5kaW5ncyIsImZpbGUiLCJzaXplIiwibWF4X2ZpbGVfc2l6ZSIsImNvbnNvbGUiLCJ3YXJuIiwicGF0aCIsIm5hbWUiLCJmaWxlUGF0aCIsImV4dGVuc2lvbiIsImdldEZpbGVFeHRlbnNpb24iLCJsYW5ndWFnZSIsImRldGVjdExhbmd1YWdlRnJvbUV4dGVuc2lvbiIsInBhdHRlcm5zIiwiZGVwcmVjYXRlZF9wYXR0ZXJucyIsImxlbmd0aCIsImZpbGVGaW5kaW5ncyIsInNjYW5GaWxlQ29udGVudCIsInB1c2giLCJsaW5lcyIsImNvbnRlbnQiLCJzcGxpdCIsImxpbmVJbmRleCIsImxpbmUiLCJsaW5lTnVtYmVyIiwiaXNDb21tZW50TGluZSIsInRyaW0iLCJwYXR0ZXJuIiwicmVnZXgiLCJSZWdFeHAiLCJtYXRjaCIsImV4ZWMiLCJpbmRleCIsImxhc3RJbmRleCIsImtpbmQiLCJsYW5nIiwic3RhdHVzIiwicmVhc29uIiwiaXNzdWUiLCJtZXNzYWdlIiwicXVpY2tGaXgiLCJhbHRlcm5hdGl2ZSIsImVycm9yIiwibGFzdERvdCIsImxhc3RJbmRleE9mIiwic3Vic3RyaW5nIiwibGFuZ3VhZ2VNYXAiLCJ0cmltbWVkIiwic3RhcnRzV2l0aCIsImdldFBhdHRlcm5RdWlja0ZpeCIsInF1aWNrX2ZpeGVzIiwicGF0dGVybl9yZXBsYWNlbWVudCIsImdyb3VwUGF0dGVybkZpbmRpbmdzQnlGaWxlIiwiZ3JvdXBlZCIsImZpbmRpbmciLCJncm91cFBhdHRlcm5GaW5kaW5nc0J5TGFuZ3VhZ2UiLCJnZXRQYXR0ZXJuU3VtbWFyeSIsInRvdGFsIiwiYnlMYW5ndWFnZSIsImJ5RmlsZSIsImFmZmVjdGVkRmlsZXMiLCJPYmplY3QiLCJrZXlzIiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwiY291bnQiLCJTZXQiLCJmIiwiZmlsdGVyUGF0dGVybkZpbmRpbmdzQnlMYW5ndWFnZSIsImZpbHRlciIsImZpbHRlclBhdHRlcm5GaW5kaW5nc0J5RmlsZSIsInNvcnRQYXR0ZXJuRmluZGluZ3MiLCJzb3J0IiwiYSIsImIiLCJmaWxlRGlmZiIsImxvY2FsZUNvbXBhcmUiLCJnZXRVbmlxdWVQYXR0ZXJucyIsImFkZCIsIkFycmF5IiwiZnJvbSIsImdldFBhdHRlcm5GcmVxdWVuY3kiLCJmcmVxdWVuY3kiLCJnZXRNb3N0Q29tbW9uUGF0dGVybnMiLCJsaW1pdCIsInNsaWNlIiwiZmlsZUhhc0RlcHJlY2F0ZWRQYXR0ZXJucyIsInNvbWUiLCJnZXRGaWxlc1dpdGhEZXByZWNhdGVkUGF0dGVybnMiLCJnZXREZXByZWNhdGVkUGF0dGVybkxpbmVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./lib/analysis/scan.ts\n");

/***/ }),

/***/ "(api-node)/./lib/files/single-file.ts":
/*!**********************************!*\
  !*** ./lib/files/single-file.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectFileType: () => (/* binding */ detectFileType),\n/* harmony export */   processSingleFile: () => (/* binding */ processSingleFile),\n/* harmony export */   shouldAnalyzeFile: () => (/* binding */ shouldAnalyzeFile)\n/* harmony export */ });\n/**\r\n * Process a single file for analysis\r\n * @param filePath Path to the file\r\n * @param content File content\r\n * @param maxFileSize Maximum file size in bytes\r\n * @returns Single file result\r\n */ function processSingleFile(filePath, content, maxFileSize = 2 * 1024 * 1024 // 2MB\n) {\n    // Check file size\n    const fileSize = Buffer.byteLength(content, 'utf8');\n    if (fileSize > maxFileSize) {\n        return {\n            files: [],\n            totalFiles: 1,\n            skippedFiles: 1\n        };\n    }\n    // Create extracted file object\n    const extractedFile = {\n        name: filePath,\n        content: content,\n        size: fileSize\n    };\n    return {\n        files: [\n            extractedFile\n        ],\n        totalFiles: 1,\n        skippedFiles: 0\n    };\n}\n/**\r\n * Detect file type from extension\r\n * @param filename File name\r\n * @returns File type category\r\n */ function detectFileType(filename) {\n    const ext = filename.split('.').pop()?.toLowerCase();\n    const typeMap = {\n        // Web files\n        'js': 'javascript',\n        'jsx': 'javascript',\n        'ts': 'typescript',\n        'tsx': 'typescript',\n        'html': 'html',\n        'htm': 'html',\n        'css': 'css',\n        'scss': 'css',\n        'sass': 'css',\n        'less': 'css',\n        // Python\n        'py': 'python',\n        'pyw': 'python',\n        // Java\n        'java': 'java',\n        'kt': 'kotlin',\n        'scala': 'scala',\n        // C/C++\n        'c': 'c',\n        'cpp': 'cpp',\n        'cc': 'cpp',\n        'cxx': 'cpp',\n        'h': 'c',\n        'hpp': 'cpp',\n        // C#\n        'cs': 'csharp',\n        'fs': 'fsharp',\n        'vb': 'vbnet',\n        // Go\n        'go': 'go',\n        // Rust\n        'rs': 'rust',\n        // PHP\n        'php': 'php',\n        // Ruby\n        'rb': 'ruby',\n        // Swift\n        'swift': 'swift',\n        // Configuration files\n        'json': 'json',\n        'yaml': 'yaml',\n        'yml': 'yaml',\n        'xml': 'xml',\n        'toml': 'toml',\n        'ini': 'ini',\n        'cfg': 'config',\n        'conf': 'config',\n        // Documentation\n        'md': 'markdown',\n        'txt': 'text',\n        'rst': 'restructuredtext',\n        // Shell scripts\n        'sh': 'shell',\n        'bash': 'shell',\n        'zsh': 'shell',\n        'fish': 'shell',\n        'ps1': 'powershell',\n        'bat': 'batch',\n        'cmd': 'batch',\n        // SQL\n        'sql': 'sql',\n        // Docker\n        'dockerfile': 'dockerfile',\n        'dockerignore': 'dockerignore',\n        // Git\n        'gitignore': 'gitignore',\n        'gitattributes': 'gitattributes',\n        // Package managers\n        'package.json': 'package.json',\n        'requirements.txt': 'requirements.txt',\n        'pom.xml': 'pom.xml',\n        'build.gradle': 'gradle',\n        'go.mod': 'go.mod',\n        'cargo.toml': 'cargo.toml',\n        'composer.json': 'composer.json',\n        'gemfile': 'gemfile',\n        'podfile': 'podfile',\n        'pubspec.yaml': 'pubspec.yaml'\n    };\n    return typeMap[ext || ''] || 'unknown';\n}\n/**\r\n * Check if file should be analyzed\r\n * @param filename File name\r\n * @returns Whether file should be analyzed\r\n */ function shouldAnalyzeFile(filename) {\n    const ext = filename.split('.').pop()?.toLowerCase();\n    // Skip binary files (but allow ZIP for project archives)\n    const binaryExtensions = [\n        'exe',\n        'dll',\n        'so',\n        'dylib',\n        'bin',\n        'dat',\n        'db',\n        'sqlite',\n        'jpg',\n        'jpeg',\n        'png',\n        'gif',\n        'bmp',\n        'svg',\n        'ico',\n        'webp',\n        'mp3',\n        'mp4',\n        'avi',\n        'mov',\n        'wav',\n        'flac',\n        'ogg',\n        'rar',\n        '7z',\n        'tar',\n        'gz',\n        'bz2',\n        'xz',\n        'pdf',\n        'doc',\n        'docx',\n        'xls',\n        'xlsx',\n        'ppt',\n        'pptx',\n        'woff',\n        'woff2',\n        'ttf',\n        'otf',\n        'eot'\n    ];\n    if (binaryExtensions.includes(ext || '')) {\n        return false;\n    }\n    // Skip very large files (over 1MB for single file analysis)\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxPQUFPO0lBQ1Q7SUFFQSw0REFBNEQ7SUFDNUQsT0FBTztBQUNUIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGZpbGVzXFxzaW5nbGUtZmlsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRyYWN0ZWRGaWxlIH0gZnJvbSAnLi4vYW5hbHlzaXMvYmFzZWxpbmUudHlwZXMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTaW5nbGVGaWxlUmVzdWx0IHtcclxuICBmaWxlczogRXh0cmFjdGVkRmlsZVtdO1xyXG4gIHRvdGFsRmlsZXM6IG51bWJlcjtcclxuICBza2lwcGVkRmlsZXM6IG51bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3MgYSBzaW5nbGUgZmlsZSBmb3IgYW5hbHlzaXNcclxuICogQHBhcmFtIGZpbGVQYXRoIFBhdGggdG8gdGhlIGZpbGVcclxuICogQHBhcmFtIGNvbnRlbnQgRmlsZSBjb250ZW50XHJcbiAqIEBwYXJhbSBtYXhGaWxlU2l6ZSBNYXhpbXVtIGZpbGUgc2l6ZSBpbiBieXRlc1xyXG4gKiBAcmV0dXJucyBTaW5nbGUgZmlsZSByZXN1bHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzU2luZ2xlRmlsZShcclxuICBmaWxlUGF0aDogc3RyaW5nLFxyXG4gIGNvbnRlbnQ6IHN0cmluZyxcclxuICBtYXhGaWxlU2l6ZTogbnVtYmVyID0gMiAqIDEwMjQgKiAxMDI0IC8vIDJNQlxyXG4pOiBTaW5nbGVGaWxlUmVzdWx0IHtcclxuICAvLyBDaGVjayBmaWxlIHNpemVcclxuICBjb25zdCBmaWxlU2l6ZSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNvbnRlbnQsICd1dGY4Jyk7XHJcbiAgaWYgKGZpbGVTaXplID4gbWF4RmlsZVNpemUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGZpbGVzOiBbXSxcclxuICAgICAgdG90YWxGaWxlczogMSxcclxuICAgICAgc2tpcHBlZEZpbGVzOiAxXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIGV4dHJhY3RlZCBmaWxlIG9iamVjdFxyXG4gIGNvbnN0IGV4dHJhY3RlZEZpbGU6IEV4dHJhY3RlZEZpbGUgPSB7XHJcbiAgICBuYW1lOiBmaWxlUGF0aCxcclxuICAgIGNvbnRlbnQ6IGNvbnRlbnQsXHJcbiAgICBzaXplOiBmaWxlU2l6ZVxyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBmaWxlczogW2V4dHJhY3RlZEZpbGVdLFxyXG4gICAgdG90YWxGaWxlczogMSxcclxuICAgIHNraXBwZWRGaWxlczogMFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlY3QgZmlsZSB0eXBlIGZyb20gZXh0ZW5zaW9uXHJcbiAqIEBwYXJhbSBmaWxlbmFtZSBGaWxlIG5hbWVcclxuICogQHJldHVybnMgRmlsZSB0eXBlIGNhdGVnb3J5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0RmlsZVR5cGUoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgZXh0ID0gZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKT8udG9Mb3dlckNhc2UoKTtcclxuICBcclxuICBjb25zdCB0eXBlTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgLy8gV2ViIGZpbGVzXHJcbiAgICAnanMnOiAnamF2YXNjcmlwdCcsXHJcbiAgICAnanN4JzogJ2phdmFzY3JpcHQnLFxyXG4gICAgJ3RzJzogJ3R5cGVzY3JpcHQnLFxyXG4gICAgJ3RzeCc6ICd0eXBlc2NyaXB0JyxcclxuICAgICdodG1sJzogJ2h0bWwnLFxyXG4gICAgJ2h0bSc6ICdodG1sJyxcclxuICAgICdjc3MnOiAnY3NzJyxcclxuICAgICdzY3NzJzogJ2NzcycsXHJcbiAgICAnc2Fzcyc6ICdjc3MnLFxyXG4gICAgJ2xlc3MnOiAnY3NzJyxcclxuICAgIFxyXG4gICAgLy8gUHl0aG9uXHJcbiAgICAncHknOiAncHl0aG9uJyxcclxuICAgICdweXcnOiAncHl0aG9uJyxcclxuICAgIFxyXG4gICAgLy8gSmF2YVxyXG4gICAgJ2phdmEnOiAnamF2YScsXHJcbiAgICAna3QnOiAna290bGluJyxcclxuICAgICdzY2FsYSc6ICdzY2FsYScsXHJcbiAgICBcclxuICAgIC8vIEMvQysrXHJcbiAgICAnYyc6ICdjJyxcclxuICAgICdjcHAnOiAnY3BwJyxcclxuICAgICdjYyc6ICdjcHAnLFxyXG4gICAgJ2N4eCc6ICdjcHAnLFxyXG4gICAgJ2gnOiAnYycsXHJcbiAgICAnaHBwJzogJ2NwcCcsXHJcbiAgICBcclxuICAgIC8vIEMjXHJcbiAgICAnY3MnOiAnY3NoYXJwJyxcclxuICAgICdmcyc6ICdmc2hhcnAnLFxyXG4gICAgJ3ZiJzogJ3ZibmV0JyxcclxuICAgIFxyXG4gICAgLy8gR29cclxuICAgICdnbyc6ICdnbycsXHJcbiAgICBcclxuICAgIC8vIFJ1c3RcclxuICAgICdycyc6ICdydXN0JyxcclxuICAgIFxyXG4gICAgLy8gUEhQXHJcbiAgICAncGhwJzogJ3BocCcsXHJcbiAgICBcclxuICAgIC8vIFJ1YnlcclxuICAgICdyYic6ICdydWJ5JyxcclxuICAgIFxyXG4gICAgLy8gU3dpZnRcclxuICAgICdzd2lmdCc6ICdzd2lmdCcsXHJcbiAgICBcclxuICAgIC8vIENvbmZpZ3VyYXRpb24gZmlsZXNcclxuICAgICdqc29uJzogJ2pzb24nLFxyXG4gICAgJ3lhbWwnOiAneWFtbCcsXHJcbiAgICAneW1sJzogJ3lhbWwnLFxyXG4gICAgJ3htbCc6ICd4bWwnLFxyXG4gICAgJ3RvbWwnOiAndG9tbCcsXHJcbiAgICAnaW5pJzogJ2luaScsXHJcbiAgICAnY2ZnJzogJ2NvbmZpZycsXHJcbiAgICAnY29uZic6ICdjb25maWcnLFxyXG4gICAgXHJcbiAgICAvLyBEb2N1bWVudGF0aW9uXHJcbiAgICAnbWQnOiAnbWFya2Rvd24nLFxyXG4gICAgJ3R4dCc6ICd0ZXh0JyxcclxuICAgICdyc3QnOiAncmVzdHJ1Y3R1cmVkdGV4dCcsXHJcbiAgICBcclxuICAgIC8vIFNoZWxsIHNjcmlwdHNcclxuICAgICdzaCc6ICdzaGVsbCcsXHJcbiAgICAnYmFzaCc6ICdzaGVsbCcsXHJcbiAgICAnenNoJzogJ3NoZWxsJyxcclxuICAgICdmaXNoJzogJ3NoZWxsJyxcclxuICAgICdwczEnOiAncG93ZXJzaGVsbCcsXHJcbiAgICAnYmF0JzogJ2JhdGNoJyxcclxuICAgICdjbWQnOiAnYmF0Y2gnLFxyXG4gICAgXHJcbiAgICAvLyBTUUxcclxuICAgICdzcWwnOiAnc3FsJyxcclxuICAgIFxyXG4gICAgLy8gRG9ja2VyXHJcbiAgICAnZG9ja2VyZmlsZSc6ICdkb2NrZXJmaWxlJyxcclxuICAgICdkb2NrZXJpZ25vcmUnOiAnZG9ja2VyaWdub3JlJyxcclxuICAgIFxyXG4gICAgLy8gR2l0XHJcbiAgICAnZ2l0aWdub3JlJzogJ2dpdGlnbm9yZScsXHJcbiAgICAnZ2l0YXR0cmlidXRlcyc6ICdnaXRhdHRyaWJ1dGVzJyxcclxuICAgIFxyXG4gICAgLy8gUGFja2FnZSBtYW5hZ2Vyc1xyXG4gICAgJ3BhY2thZ2UuanNvbic6ICdwYWNrYWdlLmpzb24nLFxyXG4gICAgJ3JlcXVpcmVtZW50cy50eHQnOiAncmVxdWlyZW1lbnRzLnR4dCcsXHJcbiAgICAncG9tLnhtbCc6ICdwb20ueG1sJyxcclxuICAgICdidWlsZC5ncmFkbGUnOiAnZ3JhZGxlJyxcclxuICAgICdnby5tb2QnOiAnZ28ubW9kJyxcclxuICAgICdjYXJnby50b21sJzogJ2NhcmdvLnRvbWwnLFxyXG4gICAgJ2NvbXBvc2VyLmpzb24nOiAnY29tcG9zZXIuanNvbicsXHJcbiAgICAnZ2VtZmlsZSc6ICdnZW1maWxlJyxcclxuICAgICdwb2RmaWxlJzogJ3BvZGZpbGUnLFxyXG4gICAgJ3B1YnNwZWMueWFtbCc6ICdwdWJzcGVjLnlhbWwnXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHR5cGVNYXBbZXh0IHx8ICcnXSB8fCAndW5rbm93bic7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBmaWxlIHNob3VsZCBiZSBhbmFseXplZFxyXG4gKiBAcGFyYW0gZmlsZW5hbWUgRmlsZSBuYW1lXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgZmlsZSBzaG91bGQgYmUgYW5hbHl6ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRBbmFseXplRmlsZShmaWxlbmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgZXh0ID0gZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKT8udG9Mb3dlckNhc2UoKTtcclxuICBcclxuICAvLyBTa2lwIGJpbmFyeSBmaWxlcyAoYnV0IGFsbG93IFpJUCBmb3IgcHJvamVjdCBhcmNoaXZlcylcclxuICBjb25zdCBiaW5hcnlFeHRlbnNpb25zID0gW1xyXG4gICAgJ2V4ZScsICdkbGwnLCAnc28nLCAnZHlsaWInLCAnYmluJywgJ2RhdCcsICdkYicsICdzcWxpdGUnLFxyXG4gICAgJ2pwZycsICdqcGVnJywgJ3BuZycsICdnaWYnLCAnYm1wJywgJ3N2ZycsICdpY28nLCAnd2VicCcsXHJcbiAgICAnbXAzJywgJ21wNCcsICdhdmknLCAnbW92JywgJ3dhdicsICdmbGFjJywgJ29nZycsXHJcbiAgICAncmFyJywgJzd6JywgJ3RhcicsICdneicsICdiejInLCAneHonLFxyXG4gICAgJ3BkZicsICdkb2MnLCAnZG9jeCcsICd4bHMnLCAneGxzeCcsICdwcHQnLCAncHB0eCcsXHJcbiAgICAnd29mZicsICd3b2ZmMicsICd0dGYnLCAnb3RmJywgJ2VvdCdcclxuICBdO1xyXG4gIFxyXG4gIGlmIChiaW5hcnlFeHRlbnNpb25zLmluY2x1ZGVzKGV4dCB8fCAnJykpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgXHJcbiAgLy8gU2tpcCB2ZXJ5IGxhcmdlIGZpbGVzIChvdmVyIDFNQiBmb3Igc2luZ2xlIGZpbGUgYW5hbHlzaXMpXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuIl0sIm5hbWVzIjpbInByb2Nlc3NTaW5nbGVGaWxlIiwiZmlsZVBhdGgiLCJjb250ZW50IiwibWF4RmlsZVNpemUiLCJmaWxlU2l6ZSIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJmaWxlcyIsInRvdGFsRmlsZXMiLCJza2lwcGVkRmlsZXMiLCJleHRyYWN0ZWRGaWxlIiwibmFtZSIsInNpemUiLCJkZXRlY3RGaWxlVHlwZSIsImZpbGVuYW1lIiwiZXh0Iiwic3BsaXQiLCJwb3AiLCJ0b0xvd2VyQ2FzZSIsInR5cGVNYXAiLCJzaG91bGRBbmFseXplRmlsZSIsImJpbmFyeUV4dGVuc2lvbnMiLCJpbmNsdWRlcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./lib/files/single-file.ts\n");

/***/ }),

/***/ "(api-node)/./lib/files/store.ts":
/*!****************************!*\
  !*** ./lib/files/store.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analysisExists: () => (/* binding */ analysisExists),\n/* harmony export */   cleanupOldAnalyses: () => (/* binding */ cleanupOldAnalyses),\n/* harmony export */   deleteAnalysis: () => (/* binding */ deleteAnalysis),\n/* harmony export */   getAnalysisMetadata: () => (/* binding */ getAnalysisMetadata),\n/* harmony export */   getStorageStats: () => (/* binding */ getStorageStats),\n/* harmony export */   getStoredAnalysis: () => (/* binding */ getStoredAnalysis),\n/* harmony export */   listStoredAnalyses: () => (/* binding */ listStoredAnalyses),\n/* harmony export */   storeAnalysisResults: () => (/* binding */ storeAnalysisResults)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! papaparse */ \"papaparse\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n/**\r\n * Store analysis results and return public URLs\r\n * @param report Analysis report\r\n * @param options Storage options\r\n * @returns Stored artifacts with public URLs\r\n */ function storeAnalysisResults(report, options = {}) {\n    const { baseDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis'), publicUrl = 'http://localhost:3000', ttl = 24 * 60 * 60 * 1000 } = options;\n    const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_2__.randomUUID)();\n    // Ensure base directory exists\n    if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(baseDir)) {\n        (0,fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync)(baseDir, {\n            recursive: true\n        });\n    }\n    // Create analysis directory\n    const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n    if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir)) {\n        (0,fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync)(analysisDir, {\n            recursive: true\n        });\n    }\n    // Store JSON report\n    const jsonPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(analysisDir, 'report.json');\n    (0,fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync)(jsonPath, JSON.stringify(report, null, 2));\n    // Store CSV report\n    const csvPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(analysisDir, 'report.csv');\n    const csvContent = generateCSV(report);\n    (0,fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync)(csvPath, csvContent);\n    // Schedule cleanup\n    scheduleCleanup(analysisDir, ttl);\n    return {\n        jsonUrl: `${publicUrl}/api/analyze/${analysisId}?format=json`,\n        csvUrl: `${publicUrl}/api/analyze/${analysisId}?format=csv`,\n        analysisId\n    };\n}\n/**\r\n * Generate CSV content from report\r\n * @param report Analysis report\r\n * @returns CSV content\r\n */ function generateCSV(report) {\n    const rows = [];\n    for (const finding of report.findings){\n        if (finding.kind === 'dependency') {\n            rows.push({\n                Kind: 'Dependency',\n                Language: finding.lang,\n                Component: finding.component,\n                File: finding.file,\n                Line: '',\n                Status: finding.status,\n                Reason: finding.reason,\n                'Quick Fix': finding.quickFix || '',\n                'Found Version': finding.foundVersion || '',\n                'Required Version': finding.baselineRequired || ''\n            });\n        } else if (finding.kind === 'pattern') {\n            rows.push({\n                Kind: 'Pattern',\n                Language: finding.lang,\n                Component: '',\n                File: finding.file,\n                Line: finding.line.toString(),\n                Status: finding.status,\n                Reason: finding.issue,\n                'Quick Fix': finding.quickFix || '',\n                'Found Version': '',\n                'Required Version': ''\n            });\n        }\n    }\n    return papaparse__WEBPACK_IMPORTED_MODULE_3___default().unparse(rows);\n}\n/**\r\n * Schedule cleanup of analysis files\r\n * @param analysisDir Analysis directory path\r\n * @param ttl Time to live in milliseconds\r\n */ function scheduleCleanup(analysisDir, ttl) {\n    setTimeout(()=>{\n        try {\n            if ((0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir)) {\n                // Remove directory and all contents\n                const { rmSync } = __webpack_require__(/*! fs */ \"fs\");\n                rmSync(analysisDir, {\n                    recursive: true,\n                    force: true\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to cleanup analysis directory ${analysisDir}: ${error}`);\n        }\n    }, ttl);\n}\n/**\r\n * Get stored analysis report\r\n * @param analysisId Analysis ID\r\n * @param format Format (json or csv)\r\n * @param baseDir Base directory for storage\r\n * @returns Report content or null if not found\r\n */ function getStoredAnalysis(analysisId, format = 'json', baseDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    try {\n        const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n        const filePath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(analysisDir, `report.${format}`);\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(filePath)) {\n            return null;\n        }\n        const content = (__webpack_require__(/*! fs */ \"fs\").readFileSync)(filePath, 'utf8');\n        return content;\n    } catch (error) {\n        console.warn(`Failed to read stored analysis ${analysisId}: ${error}`);\n        return null;\n    }\n}\n/**\r\n * Check if analysis exists\r\n * @param analysisId Analysis ID\r\n * @param baseDir Base directory for storage\r\n * @returns True if analysis exists\r\n */ function analysisExists(analysisId, baseDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n    return (0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir);\n}\n/**\r\n * Clean up old analysis files\r\n * @param baseDir Base directory for storage\r\n * @param maxAge Maximum age in milliseconds\r\n * @returns Number of cleaned up analyses\r\n */ function cleanupOldAnalyses(baseDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis'), maxAge = 24 * 60 * 60 * 1000 // 24 hours\n) {\n    let cleanedCount = 0;\n    try {\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(baseDir)) {\n            return 0;\n        }\n        const { readdirSync, statSync, rmSync } = __webpack_require__(/*! fs */ \"fs\");\n        const entries = readdirSync(baseDir, {\n            withFileTypes: true\n        });\n        for (const entry of entries){\n            if (entry.isDirectory()) {\n                const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, entry.name);\n                const stats = statSync(analysisDir);\n                const age = Date.now() - stats.mtime.getTime();\n                if (age > maxAge) {\n                    try {\n                        rmSync(analysisDir, {\n                            recursive: true,\n                            force: true\n                        });\n                        cleanedCount++;\n                    } catch (error) {\n                        console.warn(`Failed to cleanup ${analysisDir}: ${error}`);\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        console.warn(`Failed to cleanup old analyses: ${error}`);\n    }\n    return cleanedCount;\n}\n/**\r\n * Get analysis metadata\r\n * @param analysisId Analysis ID\r\n * @param baseDir Base directory for storage\r\n * @returns Analysis metadata or null\r\n */ function getAnalysisMetadata(analysisId, baseDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    try {\n        const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir)) {\n            return null;\n        }\n        const { statSync } = __webpack_require__(/*! fs */ \"fs\");\n        const stats = statSync(analysisDir);\n        return {\n            createdAt: stats.birthtime,\n            size: stats.size\n        };\n    } catch (error) {\n        console.warn(`Failed to get metadata for ${analysisId}: ${error}`);\n        return null;\n    }\n}\n/**\r\n * List all stored analyses\r\n * @param baseDir Base directory for storage\r\n * @returns Array of analysis IDs\r\n */ function listStoredAnalyses(baseDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    try {\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(baseDir)) {\n            return [];\n        }\n        const { readdirSync } = __webpack_require__(/*! fs */ \"fs\");\n        const entries = readdirSync(baseDir, {\n            withFileTypes: true\n        });\n        return entries.filter((entry)=>entry.isDirectory()).map((entry)=>entry.name);\n    } catch (error) {\n        console.warn(`Failed to list stored analyses: ${error}`);\n        return [];\n    }\n}\n/**\r\n * Delete specific analysis\r\n * @param analysisId Analysis ID\r\n * @param baseDir Base directory for storage\r\n * @returns True if deleted successfully\r\n */ function deleteAnalysis(analysisId, baseDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    try {\n        const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir)) {\n            return false;\n        }\n        const { rmSync } = __webpack_require__(/*! fs */ \"fs\");\n        rmSync(analysisDir, {\n            recursive: true,\n            force: true\n        });\n        return true;\n    } catch (error) {\n        console.warn(`Failed to delete analysis ${analysisId}: ${error}`);\n        return false;\n    }\n}\n/**\r\n * Get storage statistics\r\n * @param baseDir Base directory for storage\r\n * @returns Storage statistics\r\n */ function getStorageStats(baseDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    try {\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(baseDir)) {\n            return {\n                totalAnalyses: 0,\n                totalSize: 0,\n                oldestAnalysis: null,\n                newestAnalysis: null\n            };\n        }\n        const { readdirSync, statSync } = __webpack_require__(/*! fs */ \"fs\");\n        const entries = readdirSync(baseDir, {\n            withFileTypes: true\n        });\n        const analyses = entries.filter((entry)=>entry.isDirectory());\n        let totalSize = 0;\n        let oldestDate = null;\n        let newestDate = null;\n        for (const analysis of analyses){\n            const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysis.name);\n            const stats = statSync(analysisDir);\n            totalSize += stats.size;\n            if (!oldestDate || stats.birthtime < oldestDate) {\n                oldestDate = stats.birthtime;\n            }\n            if (!newestDate || stats.birthtime > newestDate) {\n                newestDate = stats.birthtime;\n            }\n        }\n        return {\n            totalAnalyses: analyses.length,\n            totalSize,\n            oldestAnalysis: oldestDate,\n            newestAnalysis: newestDate\n        };\n    } catch (error) {\n        console.warn(`Failed to get storage stats: ${error}`);\n        return {\n            totalAnalyses: 0,\n            totalSize: 0,\n            oldestAnalysis: null,\n            newestAnalysis: null\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0JHO1lBQ2hCRixnQkFBZ0JHO1FBQ2xCO0lBQ0YsRUFBRSxPQUFPeEMsT0FBTztRQUNkQyxRQUFRQyxJQUFJLENBQUMsQ0FBQyw2QkFBNkIsRUFBRUYsT0FBTztRQUNwRCxPQUFPO1lBQ0xrQyxlQUFlO1lBQ2ZDLFdBQVc7WUFDWEMsZ0JBQWdCO1lBQ2hCQyxnQkFBZ0I7UUFDbEI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGZpbGVzXFxzdG9yZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3cml0ZUZpbGVTeW5jLCBta2RpclN5bmMsIGV4aXN0c1N5bmMsIHVubGlua1N5bmMgfSBmcm9tICdmcyc7XHJcbmltcG9ydCB7IGpvaW4sIGRpcm5hbWUgfSBmcm9tICdwYXRoJztcclxuaW1wb3J0IHsgcmFuZG9tVVVJRCB9IGZyb20gJ2NyeXB0byc7XHJcbmltcG9ydCBQYXBhIGZyb20gJ3BhcGFwYXJzZSc7XHJcbmltcG9ydCB7IFJlcG9ydCwgRmluZGluZywgQ1NWUm93IH0gZnJvbSAnLi4vYW5hbHlzaXMvYmFzZWxpbmUudHlwZXMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdG9yZWRBcnRpZmFjdHMge1xyXG4gIGpzb25Vcmw6IHN0cmluZztcclxuICBjc3ZVcmw6IHN0cmluZztcclxuICBhbmFseXNpc0lkOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmFnZU9wdGlvbnMge1xyXG4gIGJhc2VEaXI/OiBzdHJpbmc7XHJcbiAgcHVibGljVXJsPzogc3RyaW5nO1xyXG4gIHR0bD86IG51bWJlcjsgLy8gVGltZSB0byBsaXZlIGluIG1pbGxpc2Vjb25kc1xyXG59XHJcblxyXG4vKipcclxuICogU3RvcmUgYW5hbHlzaXMgcmVzdWx0cyBhbmQgcmV0dXJuIHB1YmxpYyBVUkxzXHJcbiAqIEBwYXJhbSByZXBvcnQgQW5hbHlzaXMgcmVwb3J0XHJcbiAqIEBwYXJhbSBvcHRpb25zIFN0b3JhZ2Ugb3B0aW9uc1xyXG4gKiBAcmV0dXJucyBTdG9yZWQgYXJ0aWZhY3RzIHdpdGggcHVibGljIFVSTHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9yZUFuYWx5c2lzUmVzdWx0cyhcclxuICByZXBvcnQ6IFJlcG9ydCxcclxuICBvcHRpb25zOiBTdG9yYWdlT3B0aW9ucyA9IHt9XHJcbik6IFN0b3JlZEFydGlmYWN0cyB7XHJcbiAgY29uc3Qge1xyXG4gICAgYmFzZURpciA9IGpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdhbmFseXNpcycpLFxyXG4gICAgcHVibGljVXJsID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcsXHJcbiAgICB0dGwgPSAyNCAqIDYwICogNjAgKiAxMDAwLCAvLyAyNCBob3Vyc1xyXG4gIH0gPSBvcHRpb25zO1xyXG5cclxuICBjb25zdCBhbmFseXNpc0lkID0gcmFuZG9tVVVJRCgpO1xyXG4gIFxyXG4gIC8vIEVuc3VyZSBiYXNlIGRpcmVjdG9yeSBleGlzdHNcclxuICBpZiAoIWV4aXN0c1N5bmMoYmFzZURpcikpIHtcclxuICAgIG1rZGlyU3luYyhiYXNlRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBhbmFseXNpcyBkaXJlY3RvcnlcclxuICBjb25zdCBhbmFseXNpc0RpciA9IGpvaW4oYmFzZURpciwgYW5hbHlzaXNJZCk7XHJcbiAgaWYgKCFleGlzdHNTeW5jKGFuYWx5c2lzRGlyKSkge1xyXG4gICAgbWtkaXJTeW5jKGFuYWx5c2lzRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcclxuICB9XHJcblxyXG4gIC8vIFN0b3JlIEpTT04gcmVwb3J0XHJcbiAgY29uc3QganNvblBhdGggPSBqb2luKGFuYWx5c2lzRGlyLCAncmVwb3J0Lmpzb24nKTtcclxuICB3cml0ZUZpbGVTeW5jKGpzb25QYXRoLCBKU09OLnN0cmluZ2lmeShyZXBvcnQsIG51bGwsIDIpKTtcclxuXHJcbiAgLy8gU3RvcmUgQ1NWIHJlcG9ydFxyXG4gIGNvbnN0IGNzdlBhdGggPSBqb2luKGFuYWx5c2lzRGlyLCAncmVwb3J0LmNzdicpO1xyXG4gIGNvbnN0IGNzdkNvbnRlbnQgPSBnZW5lcmF0ZUNTVihyZXBvcnQpO1xyXG4gIHdyaXRlRmlsZVN5bmMoY3N2UGF0aCwgY3N2Q29udGVudCk7XHJcblxyXG4gIC8vIFNjaGVkdWxlIGNsZWFudXBcclxuICBzY2hlZHVsZUNsZWFudXAoYW5hbHlzaXNEaXIsIHR0bCk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBqc29uVXJsOiBgJHtwdWJsaWNVcmx9L2FwaS9hbmFseXplLyR7YW5hbHlzaXNJZH0/Zm9ybWF0PWpzb25gLFxyXG4gICAgY3N2VXJsOiBgJHtwdWJsaWNVcmx9L2FwaS9hbmFseXplLyR7YW5hbHlzaXNJZH0/Zm9ybWF0PWNzdmAsXHJcbiAgICBhbmFseXNpc0lkLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBDU1YgY29udGVudCBmcm9tIHJlcG9ydFxyXG4gKiBAcGFyYW0gcmVwb3J0IEFuYWx5c2lzIHJlcG9ydFxyXG4gKiBAcmV0dXJucyBDU1YgY29udGVudFxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVDU1YocmVwb3J0OiBSZXBvcnQpOiBzdHJpbmcge1xyXG4gIGNvbnN0IHJvd3M6IENTVlJvd1tdID0gW107XHJcblxyXG4gIGZvciAoY29uc3QgZmluZGluZyBvZiByZXBvcnQuZmluZGluZ3MpIHtcclxuICAgIGlmIChmaW5kaW5nLmtpbmQgPT09ICdkZXBlbmRlbmN5Jykge1xyXG4gICAgICByb3dzLnB1c2goe1xyXG4gICAgICAgIEtpbmQ6ICdEZXBlbmRlbmN5JyxcclxuICAgICAgICBMYW5ndWFnZTogZmluZGluZy5sYW5nLFxyXG4gICAgICAgIENvbXBvbmVudDogZmluZGluZy5jb21wb25lbnQsXHJcbiAgICAgICAgRmlsZTogZmluZGluZy5maWxlLFxyXG4gICAgICAgIExpbmU6ICcnLFxyXG4gICAgICAgIFN0YXR1czogZmluZGluZy5zdGF0dXMsXHJcbiAgICAgICAgUmVhc29uOiBmaW5kaW5nLnJlYXNvbixcclxuICAgICAgICAnUXVpY2sgRml4JzogZmluZGluZy5xdWlja0ZpeCB8fCAnJyxcclxuICAgICAgICAnRm91bmQgVmVyc2lvbic6IGZpbmRpbmcuZm91bmRWZXJzaW9uIHx8ICcnLFxyXG4gICAgICAgICdSZXF1aXJlZCBWZXJzaW9uJzogZmluZGluZy5iYXNlbGluZVJlcXVpcmVkIHx8ICcnLFxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAoZmluZGluZy5raW5kID09PSAncGF0dGVybicpIHtcclxuICAgICAgcm93cy5wdXNoKHtcclxuICAgICAgICBLaW5kOiAnUGF0dGVybicsXHJcbiAgICAgICAgTGFuZ3VhZ2U6IGZpbmRpbmcubGFuZyxcclxuICAgICAgICBDb21wb25lbnQ6ICcnLFxyXG4gICAgICAgIEZpbGU6IGZpbmRpbmcuZmlsZSxcclxuICAgICAgICBMaW5lOiBmaW5kaW5nLmxpbmUudG9TdHJpbmcoKSxcclxuICAgICAgICBTdGF0dXM6IGZpbmRpbmcuc3RhdHVzLFxyXG4gICAgICAgIFJlYXNvbjogZmluZGluZy5pc3N1ZSxcclxuICAgICAgICAnUXVpY2sgRml4JzogZmluZGluZy5xdWlja0ZpeCB8fCAnJyxcclxuICAgICAgICAnRm91bmQgVmVyc2lvbic6ICcnLFxyXG4gICAgICAgICdSZXF1aXJlZCBWZXJzaW9uJzogJycsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFBhcGEudW5wYXJzZShyb3dzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNjaGVkdWxlIGNsZWFudXAgb2YgYW5hbHlzaXMgZmlsZXNcclxuICogQHBhcmFtIGFuYWx5c2lzRGlyIEFuYWx5c2lzIGRpcmVjdG9yeSBwYXRoXHJcbiAqIEBwYXJhbSB0dGwgVGltZSB0byBsaXZlIGluIG1pbGxpc2Vjb25kc1xyXG4gKi9cclxuZnVuY3Rpb24gc2NoZWR1bGVDbGVhbnVwKGFuYWx5c2lzRGlyOiBzdHJpbmcsIHR0bDogbnVtYmVyKTogdm9pZCB7XHJcbiAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoZXhpc3RzU3luYyhhbmFseXNpc0RpcikpIHtcclxuICAgICAgICAvLyBSZW1vdmUgZGlyZWN0b3J5IGFuZCBhbGwgY29udGVudHNcclxuICAgICAgICBjb25zdCB7IHJtU3luYyB9ID0gcmVxdWlyZSgnZnMnKTtcclxuICAgICAgICBybVN5bmMoYW5hbHlzaXNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY2xlYW51cCBhbmFseXNpcyBkaXJlY3RvcnkgJHthbmFseXNpc0Rpcn06ICR7ZXJyb3J9YCk7XHJcbiAgICB9XHJcbiAgfSwgdHRsKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBzdG9yZWQgYW5hbHlzaXMgcmVwb3J0XHJcbiAqIEBwYXJhbSBhbmFseXNpc0lkIEFuYWx5c2lzIElEXHJcbiAqIEBwYXJhbSBmb3JtYXQgRm9ybWF0IChqc29uIG9yIGNzdilcclxuICogQHBhcmFtIGJhc2VEaXIgQmFzZSBkaXJlY3RvcnkgZm9yIHN0b3JhZ2VcclxuICogQHJldHVybnMgUmVwb3J0IGNvbnRlbnQgb3IgbnVsbCBpZiBub3QgZm91bmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9yZWRBbmFseXNpcyhcclxuICBhbmFseXNpc0lkOiBzdHJpbmcsXHJcbiAgZm9ybWF0OiAnanNvbicgfCAnY3N2JyA9ICdqc29uJyxcclxuICBiYXNlRGlyOiBzdHJpbmcgPSBqb2luKHByb2Nlc3MuY3dkKCksICd0bXAnLCAnYW5hbHlzaXMnKVxyXG4pOiBzdHJpbmcgfCBudWxsIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgYW5hbHlzaXNEaXIgPSBqb2luKGJhc2VEaXIsIGFuYWx5c2lzSWQpO1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSBqb2luKGFuYWx5c2lzRGlyLCBgcmVwb3J0LiR7Zm9ybWF0fWApO1xyXG4gICAgXHJcbiAgICBpZiAoIWV4aXN0c1N5bmMoZmlsZVBhdGgpKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbnRlbnQgPSByZXF1aXJlKCdmcycpLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byByZWFkIHN0b3JlZCBhbmFseXNpcyAke2FuYWx5c2lzSWR9OiAke2Vycm9yfWApO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYW5hbHlzaXMgZXhpc3RzXHJcbiAqIEBwYXJhbSBhbmFseXNpc0lkIEFuYWx5c2lzIElEXHJcbiAqIEBwYXJhbSBiYXNlRGlyIEJhc2UgZGlyZWN0b3J5IGZvciBzdG9yYWdlXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgYW5hbHlzaXMgZXhpc3RzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYW5hbHlzaXNFeGlzdHMoXHJcbiAgYW5hbHlzaXNJZDogc3RyaW5nLFxyXG4gIGJhc2VEaXI6IHN0cmluZyA9IGpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdhbmFseXNpcycpXHJcbik6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IGFuYWx5c2lzRGlyID0gam9pbihiYXNlRGlyLCBhbmFseXNpc0lkKTtcclxuICByZXR1cm4gZXhpc3RzU3luYyhhbmFseXNpc0Rpcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhbiB1cCBvbGQgYW5hbHlzaXMgZmlsZXNcclxuICogQHBhcmFtIGJhc2VEaXIgQmFzZSBkaXJlY3RvcnkgZm9yIHN0b3JhZ2VcclxuICogQHBhcmFtIG1heEFnZSBNYXhpbXVtIGFnZSBpbiBtaWxsaXNlY29uZHNcclxuICogQHJldHVybnMgTnVtYmVyIG9mIGNsZWFuZWQgdXAgYW5hbHlzZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwT2xkQW5hbHlzZXMoXHJcbiAgYmFzZURpcjogc3RyaW5nID0gam9pbihwcm9jZXNzLmN3ZCgpLCAndG1wJywgJ2FuYWx5c2lzJyksXHJcbiAgbWF4QWdlOiBudW1iZXIgPSAyNCAqIDYwICogNjAgKiAxMDAwIC8vIDI0IGhvdXJzXHJcbik6IG51bWJlciB7XHJcbiAgbGV0IGNsZWFuZWRDb3VudCA9IDA7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBpZiAoIWV4aXN0c1N5bmMoYmFzZURpcikpIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyByZWFkZGlyU3luYywgc3RhdFN5bmMsIHJtU3luYyB9ID0gcmVxdWlyZSgnZnMnKTtcclxuICAgIGNvbnN0IGVudHJpZXMgPSByZWFkZGlyU3luYyhiYXNlRGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSgpKSB7XHJcbiAgICAgICAgY29uc3QgYW5hbHlzaXNEaXIgPSBqb2luKGJhc2VEaXIsIGVudHJ5Lm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0gc3RhdFN5bmMoYW5hbHlzaXNEaXIpO1xyXG4gICAgICAgIGNvbnN0IGFnZSA9IERhdGUubm93KCkgLSBzdGF0cy5tdGltZS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgIGlmIChhZ2UgPiBtYXhBZ2UpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJtU3luYyhhbmFseXNpc0RpciwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBjbGVhbmVkQ291bnQrKztcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGNsZWFudXAgJHthbmFseXNpc0Rpcn06ICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGNsZWFudXAgb2xkIGFuYWx5c2VzOiAke2Vycm9yfWApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNsZWFuZWRDb3VudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhbmFseXNpcyBtZXRhZGF0YVxyXG4gKiBAcGFyYW0gYW5hbHlzaXNJZCBBbmFseXNpcyBJRFxyXG4gKiBAcGFyYW0gYmFzZURpciBCYXNlIGRpcmVjdG9yeSBmb3Igc3RvcmFnZVxyXG4gKiBAcmV0dXJucyBBbmFseXNpcyBtZXRhZGF0YSBvciBudWxsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW5hbHlzaXNNZXRhZGF0YShcclxuICBhbmFseXNpc0lkOiBzdHJpbmcsXHJcbiAgYmFzZURpcjogc3RyaW5nID0gam9pbihwcm9jZXNzLmN3ZCgpLCAndG1wJywgJ2FuYWx5c2lzJylcclxuKTogeyBjcmVhdGVkQXQ6IERhdGU7IHNpemU6IG51bWJlciB9IHwgbnVsbCB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGFuYWx5c2lzRGlyID0gam9pbihiYXNlRGlyLCBhbmFseXNpc0lkKTtcclxuICAgIFxyXG4gICAgaWYgKCFleGlzdHNTeW5jKGFuYWx5c2lzRGlyKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHN0YXRTeW5jIH0gPSByZXF1aXJlKCdmcycpO1xyXG4gICAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhhbmFseXNpc0Rpcik7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY3JlYXRlZEF0OiBzdGF0cy5iaXJ0aHRpbWUsXHJcbiAgICAgIHNpemU6IHN0YXRzLnNpemUsXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBnZXQgbWV0YWRhdGEgZm9yICR7YW5hbHlzaXNJZH06ICR7ZXJyb3J9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0IGFsbCBzdG9yZWQgYW5hbHlzZXNcclxuICogQHBhcmFtIGJhc2VEaXIgQmFzZSBkaXJlY3RvcnkgZm9yIHN0b3JhZ2VcclxuICogQHJldHVybnMgQXJyYXkgb2YgYW5hbHlzaXMgSURzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbGlzdFN0b3JlZEFuYWx5c2VzKFxyXG4gIGJhc2VEaXI6IHN0cmluZyA9IGpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdhbmFseXNpcycpXHJcbik6IHN0cmluZ1tdIHtcclxuICB0cnkge1xyXG4gICAgaWYgKCFleGlzdHNTeW5jKGJhc2VEaXIpKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHJlYWRkaXJTeW5jIH0gPSByZXF1aXJlKCdmcycpO1xyXG4gICAgY29uc3QgZW50cmllcyA9IHJlYWRkaXJTeW5jKGJhc2VEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcclxuXHJcbiAgICByZXR1cm4gZW50cmllc1xyXG4gICAgICAuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LmlzRGlyZWN0b3J5KCkpXHJcbiAgICAgIC5tYXAoZW50cnkgPT4gZW50cnkubmFtZSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGxpc3Qgc3RvcmVkIGFuYWx5c2VzOiAke2Vycm9yfWApO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERlbGV0ZSBzcGVjaWZpYyBhbmFseXNpc1xyXG4gKiBAcGFyYW0gYW5hbHlzaXNJZCBBbmFseXNpcyBJRFxyXG4gKiBAcGFyYW0gYmFzZURpciBCYXNlIGRpcmVjdG9yeSBmb3Igc3RvcmFnZVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlQW5hbHlzaXMoXHJcbiAgYW5hbHlzaXNJZDogc3RyaW5nLFxyXG4gIGJhc2VEaXI6IHN0cmluZyA9IGpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdhbmFseXNpcycpXHJcbik6IGJvb2xlYW4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBhbmFseXNpc0RpciA9IGpvaW4oYmFzZURpciwgYW5hbHlzaXNJZCk7XHJcbiAgICBcclxuICAgIGlmICghZXhpc3RzU3luYyhhbmFseXNpc0RpcikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgcm1TeW5jIH0gPSByZXF1aXJlKCdmcycpO1xyXG4gICAgcm1TeW5jKGFuYWx5c2lzRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZGVsZXRlIGFuYWx5c2lzICR7YW5hbHlzaXNJZH06ICR7ZXJyb3J9YCk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHN0b3JhZ2Ugc3RhdGlzdGljc1xyXG4gKiBAcGFyYW0gYmFzZURpciBCYXNlIGRpcmVjdG9yeSBmb3Igc3RvcmFnZVxyXG4gKiBAcmV0dXJucyBTdG9yYWdlIHN0YXRpc3RpY3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHMoXHJcbiAgYmFzZURpcjogc3RyaW5nID0gam9pbihwcm9jZXNzLmN3ZCgpLCAndG1wJywgJ2FuYWx5c2lzJylcclxuKToge1xyXG4gIHRvdGFsQW5hbHlzZXM6IG51bWJlcjtcclxuICB0b3RhbFNpemU6IG51bWJlcjtcclxuICBvbGRlc3RBbmFseXNpczogRGF0ZSB8IG51bGw7XHJcbiAgbmV3ZXN0QW5hbHlzaXM6IERhdGUgfCBudWxsO1xyXG59IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCFleGlzdHNTeW5jKGJhc2VEaXIpKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG90YWxBbmFseXNlczogMCxcclxuICAgICAgICB0b3RhbFNpemU6IDAsXHJcbiAgICAgICAgb2xkZXN0QW5hbHlzaXM6IG51bGwsXHJcbiAgICAgICAgbmV3ZXN0QW5hbHlzaXM6IG51bGwsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyByZWFkZGlyU3luYywgc3RhdFN5bmMgfSA9IHJlcXVpcmUoJ2ZzJyk7XHJcbiAgICBjb25zdCBlbnRyaWVzID0gcmVhZGRpclN5bmMoYmFzZURpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xyXG4gICAgY29uc3QgYW5hbHlzZXMgPSBlbnRyaWVzLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5pc0RpcmVjdG9yeSgpKTtcclxuXHJcbiAgICBsZXQgdG90YWxTaXplID0gMDtcclxuICAgIGxldCBvbGRlc3REYXRlOiBEYXRlIHwgbnVsbCA9IG51bGw7XHJcbiAgICBsZXQgbmV3ZXN0RGF0ZTogRGF0ZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIGZvciAoY29uc3QgYW5hbHlzaXMgb2YgYW5hbHlzZXMpIHtcclxuICAgICAgY29uc3QgYW5hbHlzaXNEaXIgPSBqb2luKGJhc2VEaXIsIGFuYWx5c2lzLm5hbWUpO1xyXG4gICAgICBjb25zdCBzdGF0cyA9IHN0YXRTeW5jKGFuYWx5c2lzRGlyKTtcclxuICAgICAgXHJcbiAgICAgIHRvdGFsU2l6ZSArPSBzdGF0cy5zaXplO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFvbGRlc3REYXRlIHx8IHN0YXRzLmJpcnRodGltZSA8IG9sZGVzdERhdGUpIHtcclxuICAgICAgICBvbGRlc3REYXRlID0gc3RhdHMuYmlydGh0aW1lO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIW5ld2VzdERhdGUgfHwgc3RhdHMuYmlydGh0aW1lID4gbmV3ZXN0RGF0ZSkge1xyXG4gICAgICAgIG5ld2VzdERhdGUgPSBzdGF0cy5iaXJ0aHRpbWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbEFuYWx5c2VzOiBhbmFseXNlcy5sZW5ndGgsXHJcbiAgICAgIHRvdGFsU2l6ZSxcclxuICAgICAgb2xkZXN0QW5hbHlzaXM6IG9sZGVzdERhdGUsXHJcbiAgICAgIG5ld2VzdEFuYWx5c2lzOiBuZXdlc3REYXRlLFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZ2V0IHN0b3JhZ2Ugc3RhdHM6ICR7ZXJyb3J9YCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbEFuYWx5c2VzOiAwLFxyXG4gICAgICB0b3RhbFNpemU6IDAsXHJcbiAgICAgIG9sZGVzdEFuYWx5c2lzOiBudWxsLFxyXG4gICAgICBuZXdlc3RBbmFseXNpczogbnVsbCxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ3cml0ZUZpbGVTeW5jIiwibWtkaXJTeW5jIiwiZXhpc3RzU3luYyIsImpvaW4iLCJyYW5kb21VVUlEIiwiUGFwYSIsInN0b3JlQW5hbHlzaXNSZXN1bHRzIiwicmVwb3J0Iiwib3B0aW9ucyIsImJhc2VEaXIiLCJwcm9jZXNzIiwiY3dkIiwicHVibGljVXJsIiwidHRsIiwiYW5hbHlzaXNJZCIsInJlY3Vyc2l2ZSIsImFuYWx5c2lzRGlyIiwianNvblBhdGgiLCJKU09OIiwic3RyaW5naWZ5IiwiY3N2UGF0aCIsImNzdkNvbnRlbnQiLCJnZW5lcmF0ZUNTViIsInNjaGVkdWxlQ2xlYW51cCIsImpzb25VcmwiLCJjc3ZVcmwiLCJyb3dzIiwiZmluZGluZyIsImZpbmRpbmdzIiwia2luZCIsInB1c2giLCJLaW5kIiwiTGFuZ3VhZ2UiLCJsYW5nIiwiQ29tcG9uZW50IiwiY29tcG9uZW50IiwiRmlsZSIsImZpbGUiLCJMaW5lIiwiU3RhdHVzIiwic3RhdHVzIiwiUmVhc29uIiwicmVhc29uIiwicXVpY2tGaXgiLCJmb3VuZFZlcnNpb24iLCJiYXNlbGluZVJlcXVpcmVkIiwibGluZSIsInRvU3RyaW5nIiwiaXNzdWUiLCJ1bnBhcnNlIiwic2V0VGltZW91dCIsInJtU3luYyIsInJlcXVpcmUiLCJmb3JjZSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJnZXRTdG9yZWRBbmFseXNpcyIsImZvcm1hdCIsImZpbGVQYXRoIiwiY29udGVudCIsInJlYWRGaWxlU3luYyIsImFuYWx5c2lzRXhpc3RzIiwiY2xlYW51cE9sZEFuYWx5c2VzIiwibWF4QWdlIiwiY2xlYW5lZENvdW50IiwicmVhZGRpclN5bmMiLCJzdGF0U3luYyIsImVudHJpZXMiLCJ3aXRoRmlsZVR5cGVzIiwiZW50cnkiLCJpc0RpcmVjdG9yeSIsIm5hbWUiLCJzdGF0cyIsImFnZSIsIkRhdGUiLCJub3ciLCJtdGltZSIsImdldFRpbWUiLCJnZXRBbmFseXNpc01ldGFkYXRhIiwiY3JlYXRlZEF0IiwiYmlydGh0aW1lIiwic2l6ZSIsImxpc3RTdG9yZWRBbmFseXNlcyIsImZpbHRlciIsIm1hcCIsImRlbGV0ZUFuYWx5c2lzIiwiZ2V0U3RvcmFnZVN0YXRzIiwidG90YWxBbmFseXNlcyIsInRvdGFsU2l6ZSIsIm9sZGVzdEFuYWx5c2lzIiwibmV3ZXN0QW5hbHlzaXMiLCJhbmFseXNlcyIsIm9sZGVzdERhdGUiLCJuZXdlc3REYXRlIiwiYW5hbHlzaXMiLCJsZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./lib/files/store.ts\n");

/***/ }),

/***/ "(api-node)/./lib/files/unzip.ts":
/*!****************************!*\
  !*** ./lib/files/unzip.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractZip: () => (/* binding */ extractZip),\n/* harmony export */   extractZipToMemory: () => (/* binding */ extractZipToMemory),\n/* harmony export */   getZipInfo: () => (/* binding */ getZipInfo),\n/* harmony export */   validateZip: () => (/* binding */ validateZip)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var stream_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream/promises */ \"stream/promises\");\n/* harmony import */ var stream_promises__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(stream_promises__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var unzipper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unzipper */ \"unzipper\");\n/* harmony import */ var unzipper__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(unzipper__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n/**\r\n * Securely extract ZIP file contents\r\n * @param zipPath Path to ZIP file\r\n * @param extractPath Path to extract to\r\n * @param options Extraction options\r\n * @returns Extraction result\r\n */ async function extractZip(zipPath, extractPath, options = {}) {\n    const { maxFiles = 50000, maxFileSize = 10 * 1024 * 1024, allowedExtensions = [\n        '.py',\n        '.js',\n        '.ts',\n        '.tsx',\n        '.jsx',\n        '.java',\n        '.go',\n        '.cs',\n        '.fs',\n        '.vb'\n    ], ignorePaths = [\n        '/node_modules/',\n        '/.venv/',\n        '/venv/',\n        '/dist/',\n        '/build/',\n        '/.git/',\n        '/.next/'\n    ] } = options;\n    const files = [];\n    const errors = [];\n    let totalFiles = 0;\n    let skippedFiles = 0;\n    try {\n        // Create extract directory\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(extractPath)) {\n            (0,fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync)(extractPath, {\n                recursive: true\n            });\n        }\n        // Open ZIP file\n        const zip = unzipper__WEBPACK_IMPORTED_MODULE_3___default().Open.file(zipPath);\n        const directory = await zip;\n        // Process each entry\n        for (const entry of directory.files){\n            totalFiles++;\n            // Check file count limit\n            if (totalFiles > maxFiles) {\n                errors.push(`Too many files in archive (limit: ${maxFiles})`);\n                break;\n            }\n            // Skip directories\n            if (entry.type === 'Directory') {\n                continue;\n            }\n            // Validate file path\n            const filePath = (0,path__WEBPACK_IMPORTED_MODULE_1__.normalize)(entry.path);\n            if (!isValidPath(filePath, extractPath)) {\n                errors.push(`Invalid file path: ${filePath}`);\n                skippedFiles++;\n                continue;\n            }\n            // Check if path should be ignored\n            if (shouldIgnorePath(filePath, ignorePaths)) {\n                skippedFiles++;\n                continue;\n            }\n            // Check file extension\n            const extension = getFileExtension(filePath);\n            if (allowedExtensions.length > 0 && !allowedExtensions.includes(extension)) {\n                skippedFiles++;\n                continue;\n            }\n            // Check file size\n            if (entry.uncompressedSize > maxFileSize) {\n                errors.push(`File too large: ${filePath} (${entry.uncompressedSize} bytes)`);\n                skippedFiles++;\n                continue;\n            }\n            try {\n                // Extract file\n                const fullPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(extractPath, filePath);\n                const dir = (0,path__WEBPACK_IMPORTED_MODULE_1__.dirname)(fullPath);\n                if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(dir)) {\n                    (0,fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync)(dir, {\n                        recursive: true\n                    });\n                }\n                await (0,stream_promises__WEBPACK_IMPORTED_MODULE_2__.pipeline)(entry.stream(), (0,fs__WEBPACK_IMPORTED_MODULE_0__.createWriteStream)(fullPath));\n                // Read file content for analysis\n                const content = await readFileContent(fullPath);\n                if (content !== null) {\n                    files.push({\n                        path: filePath,\n                        content,\n                        size: content.length,\n                        language: detectLanguageFromExtension(extension)\n                    });\n                }\n            } catch (error) {\n                errors.push(`Failed to extract ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n                skippedFiles++;\n            }\n        }\n    } catch (error) {\n        errors.push(`Failed to open ZIP file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n    return {\n        files,\n        totalFiles,\n        skippedFiles,\n        errors\n    };\n}\n/**\r\n * Validate file path for security\r\n * @param filePath File path\r\n * @param extractPath Base extraction path\r\n * @returns True if path is valid\r\n */ function isValidPath(filePath, extractPath) {\n    try {\n        // Normalize path\n        const normalized = (0,path__WEBPACK_IMPORTED_MODULE_1__.normalize)(filePath);\n        // Check for path traversal\n        if (normalized.includes('..') || normalized.startsWith('/')) {\n            return false;\n        }\n        // Check if path is within extract directory\n        const fullPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.resolve)(extractPath, normalized);\n        const basePath = (0,path__WEBPACK_IMPORTED_MODULE_1__.resolve)(extractPath);\n        return fullPath.startsWith(basePath);\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Check if path should be ignored\r\n * @param filePath File path\r\n * @param ignorePaths Array of paths to ignore\r\n * @returns True if should be ignored\r\n */ function shouldIgnorePath(filePath, ignorePaths) {\n    return ignorePaths.some((ignorePath)=>filePath.includes(ignorePath) || filePath.startsWith(ignorePath));\n}\n/**\r\n * Get file extension from path\r\n * @param filePath File path\r\n * @returns File extension with dot\r\n */ function getFileExtension(filePath) {\n    const lastDot = filePath.lastIndexOf('.');\n    if (lastDot === -1) return '';\n    return filePath.substring(lastDot);\n}\n/**\r\n * Detect language from file extension\r\n * @param extension File extension\r\n * @returns Language or undefined\r\n */ function detectLanguageFromExtension(extension) {\n    const languageMap = {\n        '.js': 'node',\n        '.jsx': 'node',\n        '.ts': 'node',\n        '.tsx': 'node',\n        '.py': 'python',\n        '.java': 'java',\n        '.go': 'go',\n        '.cs': 'dotnet',\n        '.fs': 'dotnet',\n        '.vb': 'dotnet'\n    };\n    return languageMap[extension];\n}\n/**\r\n * Read file content safely\r\n * @param filePath File path\r\n * @returns File content or null if error\r\n */ async function readFileContent(filePath) {\n    try {\n        const stats = (0,fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(filePath);\n        // Skip very large files\n        if (stats.size > 2 * 1024 * 1024) {\n            return null;\n        }\n        // Read file content\n        const content = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23)).then((fs)=>fs.promises.readFile(filePath, 'utf8'));\n        return content;\n    } catch (error) {\n        console.warn(`Failed to read file ${filePath}: ${error}`);\n        return null;\n    }\n}\n/**\r\n * Extract ZIP to memory (for small archives)\r\n * @param zipPath Path to ZIP file\r\n * @param options Extraction options\r\n * @returns Extraction result\r\n */ async function extractZipToMemory(zipPath, options = {}) {\n    const { maxFiles = 50000, maxFileSize = 2 * 1024 * 1024, allowedExtensions = [\n        '.py',\n        '.js',\n        '.ts',\n        '.tsx',\n        '.jsx',\n        '.java',\n        '.go',\n        '.cs',\n        '.fs',\n        '.vb'\n    ], ignorePaths = [\n        '/node_modules/',\n        '/.venv/',\n        '/venv/',\n        '/dist/',\n        '/build/',\n        '/.git/',\n        '/.next/'\n    ] } = options;\n    const files = [];\n    const errors = [];\n    let totalFiles = 0;\n    let skippedFiles = 0;\n    try {\n        // Open ZIP file\n        const zip = unzipper__WEBPACK_IMPORTED_MODULE_3___default().Open.file(zipPath);\n        const directory = await zip;\n        // Process each entry\n        for (const entry of directory.files){\n            totalFiles++;\n            // Check file count limit\n            if (totalFiles > maxFiles) {\n                errors.push(`Too many files in archive (limit: ${maxFiles})`);\n                break;\n            }\n            // Skip directories\n            if (entry.type === 'Directory') {\n                continue;\n            }\n            // Validate file path\n            const filePath = (0,path__WEBPACK_IMPORTED_MODULE_1__.normalize)(entry.path);\n            if (!isValidPath(filePath, '/')) {\n                errors.push(`Invalid file path: ${filePath}`);\n                skippedFiles++;\n                continue;\n            }\n            // Check if path should be ignored\n            if (shouldIgnorePath(filePath, ignorePaths)) {\n                skippedFiles++;\n                continue;\n            }\n            // Check file extension\n            const extension = getFileExtension(filePath);\n            if (allowedExtensions.length > 0 && !allowedExtensions.includes(extension)) {\n                skippedFiles++;\n                continue;\n            }\n            // Check file size\n            if (entry.uncompressedSize > maxFileSize) {\n                errors.push(`File too large: ${filePath} (${entry.uncompressedSize} bytes)`);\n                skippedFiles++;\n                continue;\n            }\n            try {\n                // Read file content\n                const content = await entry.buffer();\n                const contentString = content.toString('utf8');\n                files.push({\n                    path: filePath,\n                    content: contentString,\n                    size: contentString.length,\n                    language: detectLanguageFromExtension(extension)\n                });\n            } catch (error) {\n                errors.push(`Failed to read ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n                skippedFiles++;\n            }\n        }\n    } catch (error) {\n        errors.push(`Failed to open ZIP file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n    return {\n        files,\n        totalFiles,\n        skippedFiles,\n        errors\n    };\n}\n/**\r\n * Get ZIP file information\r\n * @param zipPath Path to ZIP file\r\n * @returns ZIP file info\r\n */ async function getZipInfo(zipPath) {\n    try {\n        const zip = unzipper__WEBPACK_IMPORTED_MODULE_3___default().Open.file(zipPath);\n        const directory = await zip;\n        let totalSize = 0;\n        let compressedSize = 0;\n        const files = [];\n        for (const entry of directory.files){\n            if (entry.type !== 'Directory') {\n                totalSize += entry.uncompressedSize;\n                compressedSize += entry.compressedSize;\n                files.push({\n                    path: entry.path,\n                    size: entry.uncompressedSize,\n                    compressedSize: entry.compressedSize\n                });\n            }\n        }\n        return {\n            totalFiles: files.length,\n            totalSize,\n            compressedSize,\n            files\n        };\n    } catch (error) {\n        throw new Error(`Failed to read ZIP info: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\r\n * Validate ZIP file\r\n * @param zipPath Path to ZIP file\r\n * @returns True if valid ZIP\r\n */ async function validateZip(zipPath) {\n    try {\n        const zip = unzipper__WEBPACK_IMPORTED_MODULE_3___default().Open.file(zipPath);\n        await zip;\n        return true;\n    } catch  {\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2QsTUFBTSxJQUFJQyxNQUFNLENBQUMseUJBQXlCLEVBQUVELGlCQUFpQkMsUUFBUUQsTUFBTUUsT0FBTyxHQUFHLGlCQUFpQjtJQUN4RztBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNNLGVBQWV3QixZQUFZOUQsT0FBZTtJQUMvQyxJQUFJO1FBQ0YsTUFBTVksTUFBTWQsb0RBQWEsQ0FBQ2dCLElBQUksQ0FBQ2Q7UUFDL0IsTUFBTVk7UUFDTixPQUFPO0lBQ1QsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcZmlsZXNcXHVuemlwLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVJlYWRTdHJlYW0sIGNyZWF0ZVdyaXRlU3RyZWFtLCBta2RpclN5bmMsIHN0YXRTeW5jLCBleGlzdHNTeW5jIH0gZnJvbSAnZnMnO1xyXG5pbXBvcnQgeyBqb2luLCBkaXJuYW1lLCByZXNvbHZlLCBub3JtYWxpemUgfSBmcm9tICdwYXRoJztcclxuaW1wb3J0IHsgcGlwZWxpbmUgfSBmcm9tICdzdHJlYW0vcHJvbWlzZXMnO1xyXG5pbXBvcnQgdW56aXBwZXIgZnJvbSAndW56aXBwZXInO1xyXG5pbXBvcnQgeyBFeHRyYWN0ZWRGaWxlIH0gZnJvbSAnLi4vYW5hbHlzaXMvYmFzZWxpbmUudHlwZXMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVbnppcE9wdGlvbnMge1xyXG4gIG1heEZpbGVzPzogbnVtYmVyO1xyXG4gIG1heEZpbGVTaXplPzogbnVtYmVyO1xyXG4gIGFsbG93ZWRFeHRlbnNpb25zPzogc3RyaW5nW107XHJcbiAgaWdub3JlUGF0aHM/OiBzdHJpbmdbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVbnppcFJlc3VsdCB7XHJcbiAgZmlsZXM6IEV4dHJhY3RlZEZpbGVbXTtcclxuICB0b3RhbEZpbGVzOiBudW1iZXI7XHJcbiAgc2tpcHBlZEZpbGVzOiBudW1iZXI7XHJcbiAgZXJyb3JzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlY3VyZWx5IGV4dHJhY3QgWklQIGZpbGUgY29udGVudHNcclxuICogQHBhcmFtIHppcFBhdGggUGF0aCB0byBaSVAgZmlsZVxyXG4gKiBAcGFyYW0gZXh0cmFjdFBhdGggUGF0aCB0byBleHRyYWN0IHRvXHJcbiAqIEBwYXJhbSBvcHRpb25zIEV4dHJhY3Rpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyBFeHRyYWN0aW9uIHJlc3VsdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RaaXAoXHJcbiAgemlwUGF0aDogc3RyaW5nLFxyXG4gIGV4dHJhY3RQYXRoOiBzdHJpbmcsXHJcbiAgb3B0aW9uczogVW56aXBPcHRpb25zID0ge31cclxuKTogUHJvbWlzZTxVbnppcFJlc3VsdD4ge1xyXG4gIGNvbnN0IHtcclxuICAgIG1heEZpbGVzID0gNTAwMDAsXHJcbiAgICBtYXhGaWxlU2l6ZSA9IDEwICogMTAyNCAqIDEwMjQsIC8vIDEwTUJcclxuICAgIGFsbG93ZWRFeHRlbnNpb25zID0gWycucHknLCAnLmpzJywgJy50cycsICcudHN4JywgJy5qc3gnLCAnLmphdmEnLCAnLmdvJywgJy5jcycsICcuZnMnLCAnLnZiJ10sXHJcbiAgICBpZ25vcmVQYXRocyA9IFsnL25vZGVfbW9kdWxlcy8nLCAnLy52ZW52LycsICcvdmVudi8nLCAnL2Rpc3QvJywgJy9idWlsZC8nLCAnLy5naXQvJywgJy8ubmV4dC8nXVxyXG4gIH0gPSBvcHRpb25zO1xyXG5cclxuICBjb25zdCBmaWxlczogRXh0cmFjdGVkRmlsZVtdID0gW107XHJcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGxldCB0b3RhbEZpbGVzID0gMDtcclxuICBsZXQgc2tpcHBlZEZpbGVzID0gMDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIENyZWF0ZSBleHRyYWN0IGRpcmVjdG9yeVxyXG4gICAgaWYgKCFleGlzdHNTeW5jKGV4dHJhY3RQYXRoKSkge1xyXG4gICAgICBta2RpclN5bmMoZXh0cmFjdFBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9wZW4gWklQIGZpbGVcclxuICAgIGNvbnN0IHppcCA9IHVuemlwcGVyLk9wZW4uZmlsZSh6aXBQYXRoKTtcclxuICAgIGNvbnN0IGRpcmVjdG9yeSA9IGF3YWl0IHppcDtcclxuXHJcbiAgICAvLyBQcm9jZXNzIGVhY2ggZW50cnlcclxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZGlyZWN0b3J5LmZpbGVzKSB7XHJcbiAgICAgIHRvdGFsRmlsZXMrKztcclxuXHJcbiAgICAgIC8vIENoZWNrIGZpbGUgY291bnQgbGltaXRcclxuICAgICAgaWYgKHRvdGFsRmlsZXMgPiBtYXhGaWxlcykge1xyXG4gICAgICAgIGVycm9ycy5wdXNoKGBUb28gbWFueSBmaWxlcyBpbiBhcmNoaXZlIChsaW1pdDogJHttYXhGaWxlc30pYCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNraXAgZGlyZWN0b3JpZXNcclxuICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdEaXJlY3RvcnknKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFZhbGlkYXRlIGZpbGUgcGF0aFxyXG4gICAgICBjb25zdCBmaWxlUGF0aCA9IG5vcm1hbGl6ZShlbnRyeS5wYXRoKTtcclxuICAgICAgaWYgKCFpc1ZhbGlkUGF0aChmaWxlUGF0aCwgZXh0cmFjdFBhdGgpKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYEludmFsaWQgZmlsZSBwYXRoOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICAgIHNraXBwZWRGaWxlcysrO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBwYXRoIHNob3VsZCBiZSBpZ25vcmVkXHJcbiAgICAgIGlmIChzaG91bGRJZ25vcmVQYXRoKGZpbGVQYXRoLCBpZ25vcmVQYXRocykpIHtcclxuICAgICAgICBza2lwcGVkRmlsZXMrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZmlsZSBleHRlbnNpb25cclxuICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XHJcbiAgICAgIGlmIChhbGxvd2VkRXh0ZW5zaW9ucy5sZW5ndGggPiAwICYmICFhbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhleHRlbnNpb24pKSB7XHJcbiAgICAgICAgc2tpcHBlZEZpbGVzKys7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZpbGUgc2l6ZVxyXG4gICAgICBpZiAoZW50cnkudW5jb21wcmVzc2VkU2l6ZSA+IG1heEZpbGVTaXplKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYEZpbGUgdG9vIGxhcmdlOiAke2ZpbGVQYXRofSAoJHtlbnRyeS51bmNvbXByZXNzZWRTaXplfSBieXRlcylgKTtcclxuICAgICAgICBza2lwcGVkRmlsZXMrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBFeHRyYWN0IGZpbGVcclxuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IGpvaW4oZXh0cmFjdFBhdGgsIGZpbGVQYXRoKTtcclxuICAgICAgICBjb25zdCBkaXIgPSBkaXJuYW1lKGZ1bGxQYXRoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWV4aXN0c1N5bmMoZGlyKSkge1xyXG4gICAgICAgICAgbWtkaXJTeW5jKGRpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhd2FpdCBwaXBlbGluZShcclxuICAgICAgICAgIGVudHJ5LnN0cmVhbSgpLFxyXG4gICAgICAgICAgY3JlYXRlV3JpdGVTdHJlYW0oZnVsbFBhdGgpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gUmVhZCBmaWxlIGNvbnRlbnQgZm9yIGFuYWx5c2lzXHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlYWRGaWxlQ29udGVudChmdWxsUGF0aCk7XHJcbiAgICAgICAgaWYgKGNvbnRlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgIGZpbGVzLnB1c2goe1xyXG4gICAgICAgICAgICBwYXRoOiBmaWxlUGF0aCxcclxuICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgc2l6ZTogY29udGVudC5sZW5ndGgsXHJcbiAgICAgICAgICAgIGxhbmd1YWdlOiBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBlcnJvcnMucHVzaChgRmFpbGVkIHRvIGV4dHJhY3QgJHtmaWxlUGF0aH06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgICAgICAgc2tpcHBlZEZpbGVzKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgZXJyb3JzLnB1c2goYEZhaWxlZCB0byBvcGVuIFpJUCBmaWxlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGZpbGVzLFxyXG4gICAgdG90YWxGaWxlcyxcclxuICAgIHNraXBwZWRGaWxlcyxcclxuICAgIGVycm9ycyxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgZmlsZSBwYXRoIGZvciBzZWN1cml0eVxyXG4gKiBAcGFyYW0gZmlsZVBhdGggRmlsZSBwYXRoXHJcbiAqIEBwYXJhbSBleHRyYWN0UGF0aCBCYXNlIGV4dHJhY3Rpb24gcGF0aFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHBhdGggaXMgdmFsaWRcclxuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRQYXRoKGZpbGVQYXRoOiBzdHJpbmcsIGV4dHJhY3RQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICB0cnkge1xyXG4gICAgLy8gTm9ybWFsaXplIHBhdGhcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemUoZmlsZVBhdGgpO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBmb3IgcGF0aCB0cmF2ZXJzYWxcclxuICAgIGlmIChub3JtYWxpemVkLmluY2x1ZGVzKCcuLicpIHx8IG5vcm1hbGl6ZWQuc3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgcGF0aCBpcyB3aXRoaW4gZXh0cmFjdCBkaXJlY3RvcnlcclxuICAgIGNvbnN0IGZ1bGxQYXRoID0gcmVzb2x2ZShleHRyYWN0UGF0aCwgbm9ybWFsaXplZCk7XHJcbiAgICBjb25zdCBiYXNlUGF0aCA9IHJlc29sdmUoZXh0cmFjdFBhdGgpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZnVsbFBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgcGF0aCBzaG91bGQgYmUgaWdub3JlZFxyXG4gKiBAcGFyYW0gZmlsZVBhdGggRmlsZSBwYXRoXHJcbiAqIEBwYXJhbSBpZ25vcmVQYXRocyBBcnJheSBvZiBwYXRocyB0byBpZ25vcmVcclxuICogQHJldHVybnMgVHJ1ZSBpZiBzaG91bGQgYmUgaWdub3JlZFxyXG4gKi9cclxuZnVuY3Rpb24gc2hvdWxkSWdub3JlUGF0aChmaWxlUGF0aDogc3RyaW5nLCBpZ25vcmVQYXRoczogc3RyaW5nW10pOiBib29sZWFuIHtcclxuICByZXR1cm4gaWdub3JlUGF0aHMuc29tZShpZ25vcmVQYXRoID0+IFxyXG4gICAgZmlsZVBhdGguaW5jbHVkZXMoaWdub3JlUGF0aCkgfHwgZmlsZVBhdGguc3RhcnRzV2l0aChpZ25vcmVQYXRoKVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZmlsZSBleHRlbnNpb24gZnJvbSBwYXRoXHJcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcclxuICogQHJldHVybnMgRmlsZSBleHRlbnNpb24gd2l0aCBkb3RcclxuICovXHJcbmZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgbGFzdERvdCA9IGZpbGVQYXRoLmxhc3RJbmRleE9mKCcuJyk7XHJcbiAgaWYgKGxhc3REb3QgPT09IC0xKSByZXR1cm4gJyc7XHJcbiAgcmV0dXJuIGZpbGVQYXRoLnN1YnN0cmluZyhsYXN0RG90KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVjdCBsYW5ndWFnZSBmcm9tIGZpbGUgZXh0ZW5zaW9uXHJcbiAqIEBwYXJhbSBleHRlbnNpb24gRmlsZSBleHRlbnNpb25cclxuICogQHJldHVybnMgTGFuZ3VhZ2Ugb3IgdW5kZWZpbmVkXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uOiBzdHJpbmcpOiAncHl0aG9uJyB8ICdub2RlJyB8ICdqYXZhJyB8ICdnbycgfCAnZG90bmV0JyB8IHVuZGVmaW5lZCB7XHJcbiAgY29uc3QgbGFuZ3VhZ2VNYXA6IFJlY29yZDxzdHJpbmcsICdweXRob24nIHwgJ25vZGUnIHwgJ2phdmEnIHwgJ2dvJyB8ICdkb3RuZXQnPiA9IHtcclxuICAgICcuanMnOiAnbm9kZScsXHJcbiAgICAnLmpzeCc6ICdub2RlJyxcclxuICAgICcudHMnOiAnbm9kZScsXHJcbiAgICAnLnRzeCc6ICdub2RlJyxcclxuICAgICcucHknOiAncHl0aG9uJyxcclxuICAgICcuamF2YSc6ICdqYXZhJyxcclxuICAgICcuZ28nOiAnZ28nLFxyXG4gICAgJy5jcyc6ICdkb3RuZXQnLFxyXG4gICAgJy5mcyc6ICdkb3RuZXQnLFxyXG4gICAgJy52Yic6ICdkb3RuZXQnLFxyXG4gIH07XHJcbiAgXHJcbiAgcmV0dXJuIGxhbmd1YWdlTWFwW2V4dGVuc2lvbl07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWFkIGZpbGUgY29udGVudCBzYWZlbHlcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aFxyXG4gKiBAcmV0dXJucyBGaWxlIGNvbnRlbnQgb3IgbnVsbCBpZiBlcnJvclxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGVDb250ZW50KGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhmaWxlUGF0aCk7XHJcbiAgICBcclxuICAgIC8vIFNraXAgdmVyeSBsYXJnZSBmaWxlc1xyXG4gICAgaWYgKHN0YXRzLnNpemUgPiAyICogMTAyNCAqIDEwMjQpIHsgLy8gMk1CXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBSZWFkIGZpbGUgY29udGVudFxyXG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IGltcG9ydCgnZnMnKS50aGVuKGZzID0+IGZzLnByb21pc2VzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpKTtcclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byByZWFkIGZpbGUgJHtmaWxlUGF0aH06ICR7ZXJyb3J9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IFpJUCB0byBtZW1vcnkgKGZvciBzbWFsbCBhcmNoaXZlcylcclxuICogQHBhcmFtIHppcFBhdGggUGF0aCB0byBaSVAgZmlsZVxyXG4gKiBAcGFyYW0gb3B0aW9ucyBFeHRyYWN0aW9uIG9wdGlvbnNcclxuICogQHJldHVybnMgRXh0cmFjdGlvbiByZXN1bHRcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHRyYWN0WmlwVG9NZW1vcnkoXHJcbiAgemlwUGF0aDogc3RyaW5nLFxyXG4gIG9wdGlvbnM6IFVuemlwT3B0aW9ucyA9IHt9XHJcbik6IFByb21pc2U8VW56aXBSZXN1bHQ+IHtcclxuICBjb25zdCB7XHJcbiAgICBtYXhGaWxlcyA9IDUwMDAwLFxyXG4gICAgbWF4RmlsZVNpemUgPSAyICogMTAyNCAqIDEwMjQsIC8vIDJNQlxyXG4gICAgYWxsb3dlZEV4dGVuc2lvbnMgPSBbJy5weScsICcuanMnLCAnLnRzJywgJy50c3gnLCAnLmpzeCcsICcuamF2YScsICcuZ28nLCAnLmNzJywgJy5mcycsICcudmInXSxcclxuICAgIGlnbm9yZVBhdGhzID0gWycvbm9kZV9tb2R1bGVzLycsICcvLnZlbnYvJywgJy92ZW52LycsICcvZGlzdC8nLCAnL2J1aWxkLycsICcvLmdpdC8nLCAnLy5uZXh0LyddXHJcbiAgfSA9IG9wdGlvbnM7XHJcblxyXG4gIGNvbnN0IGZpbGVzOiBFeHRyYWN0ZWRGaWxlW10gPSBbXTtcclxuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XHJcbiAgbGV0IHRvdGFsRmlsZXMgPSAwO1xyXG4gIGxldCBza2lwcGVkRmlsZXMgPSAwO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gT3BlbiBaSVAgZmlsZVxyXG4gICAgY29uc3QgemlwID0gdW56aXBwZXIuT3Blbi5maWxlKHppcFBhdGgpO1xyXG4gICAgY29uc3QgZGlyZWN0b3J5ID0gYXdhaXQgemlwO1xyXG5cclxuICAgIC8vIFByb2Nlc3MgZWFjaCBlbnRyeVxyXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBkaXJlY3RvcnkuZmlsZXMpIHtcclxuICAgICAgdG90YWxGaWxlcysrO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgZmlsZSBjb3VudCBsaW1pdFxyXG4gICAgICBpZiAodG90YWxGaWxlcyA+IG1heEZpbGVzKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYFRvbyBtYW55IGZpbGVzIGluIGFyY2hpdmUgKGxpbWl0OiAke21heEZpbGVzfSlgKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2tpcCBkaXJlY3Rvcmllc1xyXG4gICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ0RpcmVjdG9yeScpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVmFsaWRhdGUgZmlsZSBwYXRoXHJcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gbm9ybWFsaXplKGVudHJ5LnBhdGgpO1xyXG4gICAgICBpZiAoIWlzVmFsaWRQYXRoKGZpbGVQYXRoLCAnLycpKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYEludmFsaWQgZmlsZSBwYXRoOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICAgIHNraXBwZWRGaWxlcysrO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBwYXRoIHNob3VsZCBiZSBpZ25vcmVkXHJcbiAgICAgIGlmIChzaG91bGRJZ25vcmVQYXRoKGZpbGVQYXRoLCBpZ25vcmVQYXRocykpIHtcclxuICAgICAgICBza2lwcGVkRmlsZXMrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZmlsZSBleHRlbnNpb25cclxuICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XHJcbiAgICAgIGlmIChhbGxvd2VkRXh0ZW5zaW9ucy5sZW5ndGggPiAwICYmICFhbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhleHRlbnNpb24pKSB7XHJcbiAgICAgICAgc2tpcHBlZEZpbGVzKys7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZpbGUgc2l6ZVxyXG4gICAgICBpZiAoZW50cnkudW5jb21wcmVzc2VkU2l6ZSA+IG1heEZpbGVTaXplKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYEZpbGUgdG9vIGxhcmdlOiAke2ZpbGVQYXRofSAoJHtlbnRyeS51bmNvbXByZXNzZWRTaXplfSBieXRlcylgKTtcclxuICAgICAgICBza2lwcGVkRmlsZXMrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBSZWFkIGZpbGUgY29udGVudFxyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBlbnRyeS5idWZmZXIoKTtcclxuICAgICAgICBjb25zdCBjb250ZW50U3RyaW5nID0gY29udGVudC50b1N0cmluZygndXRmOCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZpbGVzLnB1c2goe1xyXG4gICAgICAgICAgcGF0aDogZmlsZVBhdGgsXHJcbiAgICAgICAgICBjb250ZW50OiBjb250ZW50U3RyaW5nLFxyXG4gICAgICAgICAgc2l6ZTogY29udGVudFN0cmluZy5sZW5ndGgsXHJcbiAgICAgICAgICBsYW5ndWFnZTogZGV0ZWN0TGFuZ3VhZ2VGcm9tRXh0ZW5zaW9uKGV4dGVuc2lvbiksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYEZhaWxlZCB0byByZWFkICR7ZmlsZVBhdGh9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gICAgICAgIHNraXBwZWRGaWxlcysrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGVycm9ycy5wdXNoKGBGYWlsZWQgdG8gb3BlbiBaSVAgZmlsZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBmaWxlcyxcclxuICAgIHRvdGFsRmlsZXMsXHJcbiAgICBza2lwcGVkRmlsZXMsXHJcbiAgICBlcnJvcnMsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBaSVAgZmlsZSBpbmZvcm1hdGlvblxyXG4gKiBAcGFyYW0gemlwUGF0aCBQYXRoIHRvIFpJUCBmaWxlXHJcbiAqIEByZXR1cm5zIFpJUCBmaWxlIGluZm9cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRaaXBJbmZvKHppcFBhdGg6IHN0cmluZyk6IFByb21pc2U8e1xyXG4gIHRvdGFsRmlsZXM6IG51bWJlcjtcclxuICB0b3RhbFNpemU6IG51bWJlcjtcclxuICBjb21wcmVzc2VkU2l6ZTogbnVtYmVyO1xyXG4gIGZpbGVzOiBBcnJheTx7IHBhdGg6IHN0cmluZzsgc2l6ZTogbnVtYmVyOyBjb21wcmVzc2VkU2l6ZTogbnVtYmVyIH0+O1xyXG59PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHppcCA9IHVuemlwcGVyLk9wZW4uZmlsZSh6aXBQYXRoKTtcclxuICAgIGNvbnN0IGRpcmVjdG9yeSA9IGF3YWl0IHppcDtcclxuICAgIFxyXG4gICAgbGV0IHRvdGFsU2l6ZSA9IDA7XHJcbiAgICBsZXQgY29tcHJlc3NlZFNpemUgPSAwO1xyXG4gICAgY29uc3QgZmlsZXM6IEFycmF5PHsgcGF0aDogc3RyaW5nOyBzaXplOiBudW1iZXI7IGNvbXByZXNzZWRTaXplOiBudW1iZXIgfT4gPSBbXTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBkaXJlY3RvcnkuZmlsZXMpIHtcclxuICAgICAgaWYgKGVudHJ5LnR5cGUgIT09ICdEaXJlY3RvcnknKSB7XHJcbiAgICAgICAgdG90YWxTaXplICs9IGVudHJ5LnVuY29tcHJlc3NlZFNpemU7XHJcbiAgICAgICAgY29tcHJlc3NlZFNpemUgKz0gZW50cnkuY29tcHJlc3NlZFNpemU7XHJcbiAgICAgICAgZmlsZXMucHVzaCh7XHJcbiAgICAgICAgICBwYXRoOiBlbnRyeS5wYXRoLFxyXG4gICAgICAgICAgc2l6ZTogZW50cnkudW5jb21wcmVzc2VkU2l6ZSxcclxuICAgICAgICAgIGNvbXByZXNzZWRTaXplOiBlbnRyeS5jb21wcmVzc2VkU2l6ZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbEZpbGVzOiBmaWxlcy5sZW5ndGgsXHJcbiAgICAgIHRvdGFsU2l6ZSxcclxuICAgICAgY29tcHJlc3NlZFNpemUsXHJcbiAgICAgIGZpbGVzLFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVhZCBaSVAgaW5mbzogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBaSVAgZmlsZVxyXG4gKiBAcGFyYW0gemlwUGF0aCBQYXRoIHRvIFpJUCBmaWxlXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdmFsaWQgWklQXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVaaXAoemlwUGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHppcCA9IHVuemlwcGVyLk9wZW4uZmlsZSh6aXBQYXRoKTtcclxuICAgIGF3YWl0IHppcDtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiY3JlYXRlV3JpdGVTdHJlYW0iLCJta2RpclN5bmMiLCJzdGF0U3luYyIsImV4aXN0c1N5bmMiLCJqb2luIiwiZGlybmFtZSIsInJlc29sdmUiLCJub3JtYWxpemUiLCJwaXBlbGluZSIsInVuemlwcGVyIiwiZXh0cmFjdFppcCIsInppcFBhdGgiLCJleHRyYWN0UGF0aCIsIm9wdGlvbnMiLCJtYXhGaWxlcyIsIm1heEZpbGVTaXplIiwiYWxsb3dlZEV4dGVuc2lvbnMiLCJpZ25vcmVQYXRocyIsImZpbGVzIiwiZXJyb3JzIiwidG90YWxGaWxlcyIsInNraXBwZWRGaWxlcyIsInJlY3Vyc2l2ZSIsInppcCIsIk9wZW4iLCJmaWxlIiwiZGlyZWN0b3J5IiwiZW50cnkiLCJwdXNoIiwidHlwZSIsImZpbGVQYXRoIiwicGF0aCIsImlzVmFsaWRQYXRoIiwic2hvdWxkSWdub3JlUGF0aCIsImV4dGVuc2lvbiIsImdldEZpbGVFeHRlbnNpb24iLCJsZW5ndGgiLCJpbmNsdWRlcyIsInVuY29tcHJlc3NlZFNpemUiLCJmdWxsUGF0aCIsImRpciIsInN0cmVhbSIsImNvbnRlbnQiLCJyZWFkRmlsZUNvbnRlbnQiLCJzaXplIiwibGFuZ3VhZ2UiLCJkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24iLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsIm5vcm1hbGl6ZWQiLCJzdGFydHNXaXRoIiwiYmFzZVBhdGgiLCJzb21lIiwiaWdub3JlUGF0aCIsImxhc3REb3QiLCJsYXN0SW5kZXhPZiIsInN1YnN0cmluZyIsImxhbmd1YWdlTWFwIiwic3RhdHMiLCJ0aGVuIiwiZnMiLCJwcm9taXNlcyIsInJlYWRGaWxlIiwiY29uc29sZSIsIndhcm4iLCJleHRyYWN0WmlwVG9NZW1vcnkiLCJidWZmZXIiLCJjb250ZW50U3RyaW5nIiwidG9TdHJpbmciLCJnZXRaaXBJbmZvIiwidG90YWxTaXplIiwiY29tcHJlc3NlZFNpemUiLCJ2YWxpZGF0ZVppcCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./lib/files/unzip.ts\n");

/***/ }),

/***/ "(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Canalyze.ts&middlewareConfigBase64=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Canalyze.ts&middlewareConfigBase64=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   handler: () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/api-utils */ \"(api-node)/./node_modules/next/dist/server/api-utils/index.js\");\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api-node)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api-node)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api-node)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pages\\api\\analyze.ts */ \"(api-node)/./pages/api/analyze.ts\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(api-node)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(api-node)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_4__]);\n_pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n// Import the userland code.\n\n\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_4__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_4__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/analyze\",\n        pathname: \"/api/analyze\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_4__,\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || ''\n});\nasync function handler(req, res, ctx) {\n    let srcPage = \"/api/analyze\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {}\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return;\n    }\n    const { query, params, prerenderManifest, routerServerContext } = prepareResult;\n    try {\n        const method = req.method || 'GET';\n        const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.getTracer)();\n        const activeSpan = tracer.getActiveScopeSpan();\n        const onRequestError = routeModule.instrumentationOnRequestError.bind(routeModule);\n        const invokeRouteModule = async (span)=>routeModule.render(req, res, {\n                query: {\n                    ...query,\n                    ...params\n                },\n                params,\n                allowedRevalidateHeaderKeys: [],\n                multiZoneDraftMode: Boolean(false),\n                trustHostHeader: false,\n                // TODO: get this from from runtime env so manifest\n                // doesn't need to load\n                previewProps: prerenderManifest.preview,\n                propagateError: false,\n                dev: routeModule.isDev,\n                page: \"/api/analyze\",\n                internalRevalidate: routerServerContext == null ? void 0 : routerServerContext.revalidate,\n                onError: (...args)=>onRequestError(req, ...args)\n            }).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await invokeRouteModule(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, invokeRouteModule));\n        }\n    } catch (err) {\n        // we re-throw in dev to show the error overlay\n        if (routeModule.isDev) {\n            throw err;\n        }\n        // this is technically an invariant as error handling\n        // should be done inside of api-resolver onError\n        (0,next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__.sendError)(res, 500, 'Internal Server Error');\n    } finally{\n        // We don't allow any waitUntil work in pages API routes currently\n        // so if callback is present return with resolved promise since no\n        // pending work\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n    }\n}\n\n//# sourceMappingURL=pages-api.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtcm91dGUtbG9hZGVyL2luZGV4LmpzP2tpbmQ9UEFHRVNfQVBJJnBhZ2U9JTJGYXBpJTJGYW5hbHl6ZSZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnBhZ2VzJTVDYXBpJTVDYW5hbHl6ZS50cyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDQztBQUN1QztBQUNyQztBQUMxRDtBQUNxRDtBQUNtQjtBQUNGO0FBQ3RFO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyxrREFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMsa0RBQVE7QUFDcEM7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixhQUFhLE9BQW9DLElBQUksQ0FBRTtBQUN2RCx3QkFBd0IsTUFBdUM7QUFDL0QsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFCLEVBQUUsRUFFMUI7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQXdEO0FBQ3BFO0FBQ0E7QUFDQSx1QkFBdUIsNEVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNkNBQTZDLEVBQTZDO0FBQzFGLDRDQUE0QyxLQUF3QztBQUNwRixpQ0FBaUMsS0FBb0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdGQUFjO0FBQy9FLCtEQUErRCx5Q0FBeUM7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUSxFQUFFLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxrQkFBa0I7QUFDbEIsdUNBQXVDLFFBQVEsRUFBRSxRQUFRO0FBQ3pEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZFQUE2RSxnRkFBYztBQUMzRixpQ0FBaUMsUUFBUSxFQUFFLFFBQVE7QUFDbkQsMEJBQTBCLHVFQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUVBQVM7QUFDakIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlbmRFcnJvciB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2FwaS11dGlsc1wiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgaG9pc3QgfSBmcm9tIFwibmV4dC9kaXN0L2J1aWxkL3RlbXBsYXRlcy9oZWxwZXJzXCI7XG4vLyBJbXBvcnQgdGhlIHVzZXJsYW5kIGNvZGUuXG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiLi9wYWdlc1xcXFxhcGlcXFxcYW5hbHl6ZS50c1wiO1xuaW1wb3J0IHsgZ2V0VHJhY2VyLCBTcGFuS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS90cmFjZXJcIjtcbmltcG9ydCB7IEJhc2VTZXJ2ZXJTcGFuIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL2NvbnN0YW50c1wiO1xuLy8gUmUtZXhwb3J0IHRoZSBoYW5kbGVyIChzaG91bGQgYmUgdGhlIGRlZmF1bHQgZXhwb3J0KS5cbmV4cG9ydCBkZWZhdWx0IGhvaXN0KHVzZXJsYW5kLCAnZGVmYXVsdCcpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgJ2NvbmZpZycpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9hbmFseXplXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvYW5hbHl6ZVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6ICcnLFxuICAgICAgICBmaWxlbmFtZTogJydcbiAgICB9LFxuICAgIHVzZXJsYW5kLFxuICAgIGRpc3REaXI6IHByb2Nlc3MuZW52Ll9fTkVYVF9SRUxBVElWRV9ESVNUX0RJUiB8fCAnJyxcbiAgICByZWxhdGl2ZVByb2plY3REaXI6IHByb2Nlc3MuZW52Ll9fTkVYVF9SRUxBVElWRV9QUk9KRUNUX0RJUiB8fCAnJ1xufSk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcywgY3R4KSB7XG4gICAgbGV0IHNyY1BhZ2UgPSBcIi9hcGkvYW5hbHl6ZVwiO1xuICAgIC8vIHR1cmJvcGFjayBkb2Vzbid0IG5vcm1hbGl6ZSBgL2luZGV4YCBpbiB0aGUgcGFnZSBuYW1lXG4gICAgLy8gc28gd2UgbmVlZCB0byB0byBwcm9jZXNzIGR5bmFtaWMgcm91dGVzIHByb3Blcmx5XG4gICAgLy8gVE9ETzogZml4IHR1cmJvcGFjayBwcm92aWRpbmcgZGlmZmVyaW5nIHZhbHVlIGZyb20gd2VicGFja1xuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgc3JjUGFnZSA9IHNyY1BhZ2UucmVwbGFjZSgvXFwvaW5kZXgkLywgJycpIHx8ICcvJztcbiAgICB9XG4gICAgY29uc3QgcHJlcGFyZVJlc3VsdCA9IGF3YWl0IHJvdXRlTW9kdWxlLnByZXBhcmUocmVxLCByZXMsIHtcbiAgICAgICAgc3JjUGFnZVxuICAgIH0pO1xuICAgIGlmICghcHJlcGFyZVJlc3VsdCkge1xuICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQwMDtcbiAgICAgICAgcmVzLmVuZCgnQmFkIFJlcXVlc3QnKTtcbiAgICAgICAgY3R4LndhaXRVbnRpbCA9PSBudWxsID8gdm9pZCAwIDogY3R4LndhaXRVbnRpbC5jYWxsKGN0eCwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgcXVlcnksIHBhcmFtcywgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQgfSA9IHByZXBhcmVSZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZCB8fCAnR0VUJztcbiAgICAgICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgICAgIGNvbnN0IG9uUmVxdWVzdEVycm9yID0gcm91dGVNb2R1bGUuaW5zdHJ1bWVudGF0aW9uT25SZXF1ZXN0RXJyb3IuYmluZChyb3V0ZU1vZHVsZSk7XG4gICAgICAgIGNvbnN0IGludm9rZVJvdXRlTW9kdWxlID0gYXN5bmMgKHNwYW4pPT5yb3V0ZU1vZHVsZS5yZW5kZXIocmVxLCByZXMsIHtcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgYWxsb3dlZFJldmFsaWRhdGVIZWFkZXJLZXlzOiBwcm9jZXNzLmVudi5fX05FWFRfQUxMT1dFRF9SRVZBTElEQVRFX0hFQURFUlMsXG4gICAgICAgICAgICAgICAgbXVsdGlab25lRHJhZnRNb2RlOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9NVUxUSV9aT05FX0RSQUZUX01PREUpLFxuICAgICAgICAgICAgICAgIHRydXN0SG9zdEhlYWRlcjogcHJvY2Vzcy5lbnYuX19ORVhUX1RSVVNUX0hPU1RfSEVBREVSLFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGdldCB0aGlzIGZyb20gZnJvbSBydW50aW1lIGVudiBzbyBtYW5pZmVzdFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbmVlZCB0byBsb2FkXG4gICAgICAgICAgICAgICAgcHJldmlld1Byb3BzOiBwcmVyZW5kZXJNYW5pZmVzdC5wcmV2aWV3LFxuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZXY6IHJvdXRlTW9kdWxlLmlzRGV2LFxuICAgICAgICAgICAgICAgIHBhZ2U6IFwiL2FwaS9hbmFseXplXCIsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxSZXZhbGlkYXRlOiByb3V0ZXJTZXJ2ZXJDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXJTZXJ2ZXJDb250ZXh0LnJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgb25FcnJvcjogKC4uLmFyZ3MpPT5vblJlcXVlc3RFcnJvcihyZXEsIC4uLmFyZ3MpXG4gICAgICAgICAgICB9KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnZva2VSb3V0ZU1vZHVsZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBpbnZva2VSb3V0ZU1vZHVsZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHdlIHJlLXRocm93IGluIGRldiB0byBzaG93IHRoZSBlcnJvciBvdmVybGF5XG4gICAgICAgIGlmIChyb3V0ZU1vZHVsZS5pc0Rldikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYW4gaW52YXJpYW50IGFzIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIC8vIHNob3VsZCBiZSBkb25lIGluc2lkZSBvZiBhcGktcmVzb2x2ZXIgb25FcnJvclxuICAgICAgICBzZW5kRXJyb3IocmVzLCA1MDAsICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InKTtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIC8vIFdlIGRvbid0IGFsbG93IGFueSB3YWl0VW50aWwgd29yayBpbiBwYWdlcyBBUEkgcm91dGVzIGN1cnJlbnRseVxuICAgICAgICAvLyBzbyBpZiBjYWxsYmFjayBpcyBwcmVzZW50IHJldHVybiB3aXRoIHJlc29sdmVkIHByb21pc2Ugc2luY2Ugbm9cbiAgICAgICAgLy8gcGVuZGluZyB3b3JrXG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Canalyze.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api-node)/./pages/api/analyze.ts":
/*!******************************!*\
  !*** ./pages/api/analyze.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var formidable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! formidable */ \"formidable\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/analysis/run */ \"(api-node)/./lib/analysis/run.ts\");\n/* harmony import */ var _lib_files_unzip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/files/unzip */ \"(api-node)/./lib/files/unzip.ts\");\n/* harmony import */ var _lib_files_single_file__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/files/single-file */ \"(api-node)/./lib/files/single-file.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([formidable__WEBPACK_IMPORTED_MODULE_0__, _lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__]);\n([formidable__WEBPACK_IMPORTED_MODULE_0__, _lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\nconst config = {\n    api: {\n        bodyParser: false\n    }\n};\nasync function handler(req, res) {\n    console.log('Analyze API called with method:', req.method);\n    if (req.method !== 'POST') {\n        return res.status(405).json({\n            error: 'Method not allowed'\n        });\n    }\n    let tempPath;\n    try {\n        // Parse form data\n        const form = (0,formidable__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            maxFileSize: 200 * 1024 * 1024,\n            filter: ({ mimetype, originalFilename })=>{\n                // Accept all file types\n                console.log('Filter check:', {\n                    mimetype,\n                    originalFilename\n                });\n                return true;\n            }\n        });\n        console.log('Parsing form data...');\n        const [fields, files] = await form.parse(req);\n        console.log('Parsed fields:', Object.keys(fields));\n        console.log('Parsed files:', Object.keys(files));\n        console.log('Files object:', files);\n        const file = Array.isArray(files.file) ? files.file[0] : files.file;\n        if (!file) {\n            console.error('No file found in request. Available files:', Object.keys(files));\n            return res.status(400).json({\n                error: 'No file provided',\n                debug: {\n                    fieldsKeys: Object.keys(fields),\n                    filesKeys: Object.keys(files),\n                    filesContent: files\n                }\n            });\n        }\n        console.log('File found:', {\n            originalFilename: file.originalFilename,\n            mimetype: file.mimetype,\n            size: file.size,\n            filepath: file.filepath\n        });\n        // Create temporary directory\n        const tempDir = path__WEBPACK_IMPORTED_MODULE_2___default().join(process.cwd(), 'tmp', 'analyzer');\n        await fs__WEBPACK_IMPORTED_MODULE_1__.promises.mkdir(tempDir, {\n            recursive: true\n        });\n        // Save uploaded file\n        const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_3__.randomUUID)();\n        const originalName = file.originalFilename || 'uploaded-file';\n        tempPath = path__WEBPACK_IMPORTED_MODULE_2___default().join(tempDir, `${analysisId}-${originalName}`);\n        console.log('Copying file from', file.filepath, 'to', tempPath);\n        await fs__WEBPACK_IMPORTED_MODULE_1__.promises.copyFile(file.filepath, tempPath);\n        console.log('File copied successfully');\n        try {\n            // Check if file should be analyzed\n            if (!(0,_lib_files_single_file__WEBPACK_IMPORTED_MODULE_6__.shouldAnalyzeFile)(originalName)) {\n                return res.status(400).json({\n                    error: 'File type not supported for analysis',\n                    details: {\n                        filename: originalName\n                    }\n                });\n            }\n            // Check file size\n            const stats = await fs__WEBPACK_IMPORTED_MODULE_1__.promises.stat(tempPath);\n            if (stats.size > 200 * 1024 * 1024) {\n                return res.status(400).json({\n                    error: 'File too large',\n                    details: {\n                        size: stats.size,\n                        maxSize: 200 * 1024 * 1024\n                    }\n                });\n            }\n            // For ZIP files, validate and get info\n            let feasibility = {\n                feasible: true,\n                warnings: [],\n                estimatedTime: '1-2 minutes'\n            };\n            if (originalName.toLowerCase().endsWith('.zip')) {\n                const isValidZip = await (0,_lib_files_unzip__WEBPACK_IMPORTED_MODULE_5__.validateZip)(tempPath);\n                if (!isValidZip) {\n                    return res.status(400).json({\n                        error: 'Invalid ZIP file'\n                    });\n                }\n                const zipInfo = await (0,_lib_files_unzip__WEBPACK_IMPORTED_MODULE_5__.getZipInfo)(tempPath);\n                feasibility = (0,_lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__.checkAnalysisFeasibility)(zipInfo.totalFiles, zipInfo.totalSize);\n                if (!feasibility.feasible) {\n                    return res.status(400).json({\n                        error: 'Analysis not feasible',\n                        warnings: feasibility.warnings,\n                        details: {\n                            totalFiles: zipInfo.totalFiles,\n                            totalSize: zipInfo.totalSize,\n                            estimatedTime: feasibility.estimatedTime\n                        }\n                    });\n                }\n            }\n            // Run analysis\n            console.log('Starting analysis for:', originalName);\n            const analysisOptions = (0,_lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__.validateAnalysisOptions)({\n                maxFiles: 50000,\n                maxFileSize: 2 * 1024 * 1024,\n                storeResults: true,\n                publicUrl: process.env.PUBLIC_URL || 'http://localhost:3000'\n            });\n            console.log('Analysis options:', analysisOptions);\n            const result = await (0,_lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__.runBaselineAnalysis)(tempPath, analysisOptions);\n            console.log('Analysis completed successfully');\n            if (!result.artifacts) {\n                throw new Error('Failed to store analysis results');\n            }\n            // Create response\n            const response = {\n                analysisId: result.artifacts.analysisId,\n                summary: result.report.summary,\n                artifacts: {\n                    jsonUrl: result.artifacts.jsonUrl,\n                    csvUrl: result.artifacts.csvUrl\n                },\n                report: result.report\n            };\n            return res.status(200).json(response);\n        } finally{\n            // Clean up temporary file\n            try {\n                await fs__WEBPACK_IMPORTED_MODULE_1__.promises.unlink(tempPath);\n            } catch (error) {\n                console.warn(`Failed to cleanup temp file ${tempPath}: ${error}`);\n            }\n        }\n    } catch (error) {\n        console.error('Analysis API error:', error);\n        // Clean up temporary file on error\n        try {\n            if (typeof tempPath !== 'undefined') {\n                await fs__WEBPACK_IMPORTED_MODULE_1__.promises.unlink(tempPath);\n            }\n        } catch (cleanupError) {\n            console.warn(`Failed to cleanup temp file on error: ${cleanupError}`);\n        }\n        return res.status(500).json({\n            error: 'Analysis failed',\n            message: error instanceof Error ? error.message : 'Unknown error',\n            details: error instanceof Error ? error.stack : undefined\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c0MsRUFBRUMsY0FBYztRQUN0RTtRQUVBLE9BQU9uRSxJQUFJSSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQzFCQyxPQUFPO1lBQ1A4RCxTQUFTOUQsaUJBQWlCcUQsUUFBUXJELE1BQU04RCxPQUFPLEdBQUc7WUFDbERoQyxTQUFTOUIsaUJBQWlCcUQsUUFBUXJELE1BQU0rRCxLQUFLLEdBQUdDO1FBQ2xEO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxDa2hhZGFyXFxEb3dubG9hZHNcXEFJX0Jhc2VsaW5lX01hcFxccGFnZXNcXGFwaVxcYW5hbHl6ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XHJcbmltcG9ydCBmb3JtaWRhYmxlIGZyb20gJ2Zvcm1pZGFibGUnO1xyXG5pbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7IHJhbmRvbVVVSUQgfSBmcm9tICdjcnlwdG8nO1xyXG5pbXBvcnQgeyBydW5CYXNlbGluZUFuYWx5c2lzLCB2YWxpZGF0ZUFuYWx5c2lzT3B0aW9ucywgY2hlY2tBbmFseXNpc0ZlYXNpYmlsaXR5IH0gZnJvbSAnLi4vLi4vbGliL2FuYWx5c2lzL3J1bic7XHJcbmltcG9ydCB7IHZhbGlkYXRlWmlwLCBnZXRaaXBJbmZvIH0gZnJvbSAnLi4vLi4vbGliL2ZpbGVzL3VuemlwJztcclxuaW1wb3J0IHsgc2hvdWxkQW5hbHl6ZUZpbGUgfSBmcm9tICcuLi8uLi9saWIvZmlsZXMvc2luZ2xlLWZpbGUnO1xyXG5pbXBvcnQgeyBBbmFseXplUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9saWIvYW5hbHlzaXMvYmFzZWxpbmUudHlwZXMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcclxuICBhcGk6IHtcclxuICAgIGJvZHlQYXJzZXI6IGZhbHNlLFxyXG4gIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcTogTmV4dEFwaVJlcXVlc3QsIHJlczogTmV4dEFwaVJlc3BvbnNlKSB7XHJcbiAgY29uc29sZS5sb2coJ0FuYWx5emUgQVBJIGNhbGxlZCB3aXRoIG1ldGhvZDonLCByZXEubWV0aG9kKTtcclxuICBcclxuICBpZiAocmVxLm1ldGhvZCAhPT0gJ1BPU1QnKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBlcnJvcjogJ01ldGhvZCBub3QgYWxsb3dlZCcgfSk7XHJcbiAgfVxyXG5cclxuICBsZXQgdGVtcFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIFBhcnNlIGZvcm0gZGF0YVxyXG4gICAgY29uc3QgZm9ybSA9IGZvcm1pZGFibGUoe1xyXG4gICAgICBtYXhGaWxlU2l6ZTogMjAwICogMTAyNCAqIDEwMjQsIC8vIDIwME1CXHJcbiAgICAgIGZpbHRlcjogKHsgbWltZXR5cGUsIG9yaWdpbmFsRmlsZW5hbWUgfSkgPT4ge1xyXG4gICAgICAgIC8vIEFjY2VwdCBhbGwgZmlsZSB0eXBlc1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdGaWx0ZXIgY2hlY2s6JywgeyBtaW1ldHlwZSwgb3JpZ2luYWxGaWxlbmFtZSB9KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdQYXJzaW5nIGZvcm0gZGF0YS4uLicpO1xyXG4gICAgY29uc3QgW2ZpZWxkcywgZmlsZXNdID0gYXdhaXQgZm9ybS5wYXJzZShyZXEpO1xyXG4gICAgY29uc29sZS5sb2coJ1BhcnNlZCBmaWVsZHM6JywgT2JqZWN0LmtleXMoZmllbGRzKSk7XHJcbiAgICBjb25zb2xlLmxvZygnUGFyc2VkIGZpbGVzOicsIE9iamVjdC5rZXlzKGZpbGVzKSk7XHJcbiAgICBjb25zb2xlLmxvZygnRmlsZXMgb2JqZWN0OicsIGZpbGVzKTtcclxuICAgIFxyXG4gICAgY29uc3QgZmlsZSA9IEFycmF5LmlzQXJyYXkoZmlsZXMuZmlsZSkgPyBmaWxlcy5maWxlWzBdIDogZmlsZXMuZmlsZTtcclxuXHJcbiAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTm8gZmlsZSBmb3VuZCBpbiByZXF1ZXN0LiBBdmFpbGFibGUgZmlsZXM6JywgT2JqZWN0LmtleXMoZmlsZXMpKTtcclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgXHJcbiAgICAgICAgZXJyb3I6ICdObyBmaWxlIHByb3ZpZGVkJyxcclxuICAgICAgICBkZWJ1Zzoge1xyXG4gICAgICAgICAgZmllbGRzS2V5czogT2JqZWN0LmtleXMoZmllbGRzKSxcclxuICAgICAgICAgIGZpbGVzS2V5czogT2JqZWN0LmtleXMoZmlsZXMpLFxyXG4gICAgICAgICAgZmlsZXNDb250ZW50OiBmaWxlc1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coJ0ZpbGUgZm91bmQ6Jywge1xyXG4gICAgICBvcmlnaW5hbEZpbGVuYW1lOiBmaWxlLm9yaWdpbmFsRmlsZW5hbWUsXHJcbiAgICAgIG1pbWV0eXBlOiBmaWxlLm1pbWV0eXBlLFxyXG4gICAgICBzaXplOiBmaWxlLnNpemUsXHJcbiAgICAgIGZpbGVwYXRoOiBmaWxlLmZpbGVwYXRoXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGVtcG9yYXJ5IGRpcmVjdG9yeVxyXG4gICAgY29uc3QgdGVtcERpciA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAndG1wJywgJ2FuYWx5emVyJyk7XHJcbiAgICBhd2FpdCBmcy5ta2Rpcih0ZW1wRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAvLyBTYXZlIHVwbG9hZGVkIGZpbGVcclxuICAgIGNvbnN0IGFuYWx5c2lzSWQgPSByYW5kb21VVUlEKCk7XHJcbiAgICBjb25zdCBvcmlnaW5hbE5hbWUgPSBmaWxlLm9yaWdpbmFsRmlsZW5hbWUgfHwgJ3VwbG9hZGVkLWZpbGUnO1xyXG4gICAgdGVtcFBhdGggPSBwYXRoLmpvaW4odGVtcERpciwgYCR7YW5hbHlzaXNJZH0tJHtvcmlnaW5hbE5hbWV9YCk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdDb3B5aW5nIGZpbGUgZnJvbScsIGZpbGUuZmlsZXBhdGgsICd0bycsIHRlbXBQYXRoKTtcclxuICAgIGF3YWl0IGZzLmNvcHlGaWxlKGZpbGUuZmlsZXBhdGgsIHRlbXBQYXRoKTtcclxuICAgIGNvbnNvbGUubG9nKCdGaWxlIGNvcGllZCBzdWNjZXNzZnVsbHknKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDaGVjayBpZiBmaWxlIHNob3VsZCBiZSBhbmFseXplZFxyXG4gICAgICBpZiAoIXNob3VsZEFuYWx5emVGaWxlKG9yaWdpbmFsTmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBcclxuICAgICAgICAgIGVycm9yOiAnRmlsZSB0eXBlIG5vdCBzdXBwb3J0ZWQgZm9yIGFuYWx5c2lzJyxcclxuICAgICAgICAgIGRldGFpbHM6IHsgZmlsZW5hbWU6IG9yaWdpbmFsTmFtZSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZpbGUgc2l6ZVxyXG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnN0YXQodGVtcFBhdGgpO1xyXG4gICAgICBpZiAoc3RhdHMuc2l6ZSA+IDIwMCAqIDEwMjQgKiAxMDI0KSB7IC8vIDIwME1CIGxpbWl0XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgXHJcbiAgICAgICAgICBlcnJvcjogJ0ZpbGUgdG9vIGxhcmdlJyxcclxuICAgICAgICAgIGRldGFpbHM6IHsgXHJcbiAgICAgICAgICAgIHNpemU6IHN0YXRzLnNpemUsXHJcbiAgICAgICAgICAgIG1heFNpemU6IDIwMCAqIDEwMjQgKiAxMDI0XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZvciBaSVAgZmlsZXMsIHZhbGlkYXRlIGFuZCBnZXQgaW5mb1xyXG4gICAgICBsZXQgZmVhc2liaWxpdHkgPSB7IGZlYXNpYmxlOiB0cnVlLCB3YXJuaW5nczogW10sIGVzdGltYXRlZFRpbWU6ICcxLTIgbWludXRlcycgfTtcclxuICAgICAgaWYgKG9yaWdpbmFsTmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuemlwJykpIHtcclxuICAgICAgICBjb25zdCBpc1ZhbGlkWmlwID0gYXdhaXQgdmFsaWRhdGVaaXAodGVtcFBhdGgpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZFppcCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdJbnZhbGlkIFpJUCBmaWxlJyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHppcEluZm8gPSBhd2FpdCBnZXRaaXBJbmZvKHRlbXBQYXRoKTtcclxuICAgICAgICBmZWFzaWJpbGl0eSA9IGNoZWNrQW5hbHlzaXNGZWFzaWJpbGl0eSh6aXBJbmZvLnRvdGFsRmlsZXMsIHppcEluZm8udG90YWxTaXplKTtcclxuICAgICAgICBpZiAoIWZlYXNpYmlsaXR5LmZlYXNpYmxlKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBcclxuICAgICAgICAgICAgZXJyb3I6ICdBbmFseXNpcyBub3QgZmVhc2libGUnLFxyXG4gICAgICAgICAgICB3YXJuaW5nczogZmVhc2liaWxpdHkud2FybmluZ3MsXHJcbiAgICAgICAgICAgIGRldGFpbHM6IHtcclxuICAgICAgICAgICAgICB0b3RhbEZpbGVzOiB6aXBJbmZvLnRvdGFsRmlsZXMsXHJcbiAgICAgICAgICAgICAgdG90YWxTaXplOiB6aXBJbmZvLnRvdGFsU2l6ZSxcclxuICAgICAgICAgICAgICBlc3RpbWF0ZWRUaW1lOiBmZWFzaWJpbGl0eS5lc3RpbWF0ZWRUaW1lLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJ1biBhbmFseXNpc1xyXG4gICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgYW5hbHlzaXMgZm9yOicsIG9yaWdpbmFsTmFtZSk7XHJcbiAgICAgIGNvbnN0IGFuYWx5c2lzT3B0aW9ucyA9IHZhbGlkYXRlQW5hbHlzaXNPcHRpb25zKHtcclxuICAgICAgICBtYXhGaWxlczogNTAwMDAsXHJcbiAgICAgICAgbWF4RmlsZVNpemU6IDIgKiAxMDI0ICogMTAyNCwgLy8gMk1CXHJcbiAgICAgICAgc3RvcmVSZXN1bHRzOiB0cnVlLFxyXG4gICAgICAgIHB1YmxpY1VybDogcHJvY2Vzcy5lbnYuUFVCTElDX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnQW5hbHlzaXMgb3B0aW9uczonLCBhbmFseXNpc09wdGlvbnMpO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBydW5CYXNlbGluZUFuYWx5c2lzKHRlbXBQYXRoLCBhbmFseXNpc09wdGlvbnMpO1xyXG4gICAgICBjb25zb2xlLmxvZygnQW5hbHlzaXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseScpO1xyXG5cclxuICAgICAgaWYgKCFyZXN1bHQuYXJ0aWZhY3RzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc3RvcmUgYW5hbHlzaXMgcmVzdWx0cycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDcmVhdGUgcmVzcG9uc2VcclxuICAgICAgY29uc3QgcmVzcG9uc2U6IEFuYWx5emVSZXNwb25zZSA9IHtcclxuICAgICAgICBhbmFseXNpc0lkOiByZXN1bHQuYXJ0aWZhY3RzLmFuYWx5c2lzSWQsXHJcbiAgICAgICAgc3VtbWFyeTogcmVzdWx0LnJlcG9ydC5zdW1tYXJ5LFxyXG4gICAgICAgIGFydGlmYWN0czoge1xyXG4gICAgICAgICAganNvblVybDogcmVzdWx0LmFydGlmYWN0cy5qc29uVXJsLFxyXG4gICAgICAgICAgY3N2VXJsOiByZXN1bHQuYXJ0aWZhY3RzLmNzdlVybCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcG9ydDogcmVzdWx0LnJlcG9ydCwgLy8gSW5jbHVkZSBmdWxsIHJlcG9ydCBmb3IgR3JvcSBhbmFseXNpc1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHJlc3BvbnNlKTtcclxuXHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAvLyBDbGVhbiB1cCB0ZW1wb3JhcnkgZmlsZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IGZzLnVubGluayh0ZW1wUGF0aCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY2xlYW51cCB0ZW1wIGZpbGUgJHt0ZW1wUGF0aH06ICR7ZXJyb3J9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FuYWx5c2lzIEFQSSBlcnJvcjonLCBlcnJvcik7XHJcbiAgICBcclxuICAgIC8vIENsZWFuIHVwIHRlbXBvcmFyeSBmaWxlIG9uIGVycm9yXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodHlwZW9mIHRlbXBQYXRoICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGF3YWl0IGZzLnVubGluayh0ZW1wUGF0aCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBjbGVhbnVwIHRlbXAgZmlsZSBvbiBlcnJvcjogJHtjbGVhbnVwRXJyb3J9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IFxyXG4gICAgICBlcnJvcjogJ0FuYWx5c2lzIGZhaWxlZCcsXHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxyXG4gICAgICBkZXRhaWxzOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWRcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiZm9ybWlkYWJsZSIsInByb21pc2VzIiwiZnMiLCJwYXRoIiwicmFuZG9tVVVJRCIsInJ1bkJhc2VsaW5lQW5hbHlzaXMiLCJ2YWxpZGF0ZUFuYWx5c2lzT3B0aW9ucyIsImNoZWNrQW5hbHlzaXNGZWFzaWJpbGl0eSIsInZhbGlkYXRlWmlwIiwiZ2V0WmlwSW5mbyIsInNob3VsZEFuYWx5emVGaWxlIiwiY29uZmlnIiwiYXBpIiwiYm9keVBhcnNlciIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJjb25zb2xlIiwibG9nIiwibWV0aG9kIiwic3RhdHVzIiwianNvbiIsImVycm9yIiwidGVtcFBhdGgiLCJmb3JtIiwibWF4RmlsZVNpemUiLCJmaWx0ZXIiLCJtaW1ldHlwZSIsIm9yaWdpbmFsRmlsZW5hbWUiLCJmaWVsZHMiLCJmaWxlcyIsInBhcnNlIiwiT2JqZWN0Iiwia2V5cyIsImZpbGUiLCJBcnJheSIsImlzQXJyYXkiLCJkZWJ1ZyIsImZpZWxkc0tleXMiLCJmaWxlc0tleXMiLCJmaWxlc0NvbnRlbnQiLCJzaXplIiwiZmlsZXBhdGgiLCJ0ZW1wRGlyIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJta2RpciIsInJlY3Vyc2l2ZSIsImFuYWx5c2lzSWQiLCJvcmlnaW5hbE5hbWUiLCJjb3B5RmlsZSIsImRldGFpbHMiLCJmaWxlbmFtZSIsInN0YXRzIiwic3RhdCIsIm1heFNpemUiLCJmZWFzaWJpbGl0eSIsImZlYXNpYmxlIiwid2FybmluZ3MiLCJlc3RpbWF0ZWRUaW1lIiwidG9Mb3dlckNhc2UiLCJlbmRzV2l0aCIsImlzVmFsaWRaaXAiLCJ6aXBJbmZvIiwidG90YWxGaWxlcyIsInRvdGFsU2l6ZSIsImFuYWx5c2lzT3B0aW9ucyIsIm1heEZpbGVzIiwic3RvcmVSZXN1bHRzIiwicHVibGljVXJsIiwiZW52IiwiUFVCTElDX1VSTCIsInJlc3VsdCIsImFydGlmYWN0cyIsIkVycm9yIiwicmVzcG9uc2UiLCJzdW1tYXJ5IiwicmVwb3J0IiwianNvblVybCIsImNzdlVybCIsInVubGluayIsIndhcm4iLCJjbGVhbnVwRXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJ1bmRlZmluZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/analyze.ts\n");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "formidable":
/*!*****************************!*\
  !*** external "formidable" ***!
  \*****************************/
/***/ ((module) => {

module.exports = import("formidable");;

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "papaparse":
/*!****************************!*\
  !*** external "papaparse" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("papaparse");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "semver":
/*!*************************!*\
  !*** external "semver" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("semver");

/***/ }),

/***/ "stream/promises":
/*!**********************************!*\
  !*** external "stream/promises" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("stream/promises");

/***/ }),

/***/ "unzipper":
/*!***************************!*\
  !*** external "unzipper" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("unzipper");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "yaml":
/*!***********************!*\
  !*** external "yaml" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("yaml");

/***/ }),

/***/ "zod":
/*!**********************!*\
  !*** external "zod" ***!
  \**********************/
/***/ ((module) => {

module.exports = import("zod");;

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Canalyze.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();