/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/analyze/route";
exports.ids = ["app/api/analyze/route"];
exports.modules = {

/***/ "(rsc)/./app/api/analyze/route.ts":
/*!**********************************!*\
  !*** ./app/api/analyze/route.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../lib/analysis/run */ \"(rsc)/./lib/analysis/run.ts\");\n/* harmony import */ var _lib_files_single_file__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../lib/files/single-file */ \"(rsc)/./lib/files/single-file.ts\");\n\n\n\n\n\n// ZIP imports removed as per new requirements\n\nconst runtime = \"nodejs\";\nconst dynamic = \"force-dynamic\";\nasync function POST(request) {\n    console.log('Analyze API called with method: POST');\n    let tempPath;\n    try {\n        // Parse form data using Next.js built-in FormData\n        const formData = await request.formData();\n        const file = formData.get('file');\n        if (!file) {\n            console.error('No file found in request');\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'No file provided'\n            }, {\n                status: 400\n            });\n        }\n        console.log('File found:', {\n            name: file.name,\n            type: file.type,\n            size: file.size\n        });\n        // Create temporary directory - use /tmp for Vercel serverless\n        const tempDir = process.env.VERCEL ? '/tmp/analyzer' : path__WEBPACK_IMPORTED_MODULE_2___default().join(process.cwd(), 'tmp', 'analyzer');\n        await fs__WEBPACK_IMPORTED_MODULE_1__.promises.mkdir(tempDir, {\n            recursive: true\n        });\n        // Save uploaded file\n        const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_3__.randomUUID)();\n        const originalName = file.name || 'uploaded-file';\n        tempPath = path__WEBPACK_IMPORTED_MODULE_2___default().join(tempDir, `${analysisId}-${originalName}`);\n        // Convert File to Buffer and write to disk\n        const bytes = await file.arrayBuffer();\n        const buffer = Buffer.from(bytes);\n        await fs__WEBPACK_IMPORTED_MODULE_1__.promises.writeFile(tempPath, buffer);\n        console.log('File saved successfully');\n        try {\n            // Check if file should be analyzed (early exit for unsupported types)\n            if (!(0,_lib_files_single_file__WEBPACK_IMPORTED_MODULE_5__.shouldAnalyzeFile)(originalName)) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: 'File type not supported for analysis',\n                    details: {\n                        filename: originalName\n                    }\n                }, {\n                    status: 400\n                });\n            }\n            // Check file size\n            const stats = await fs__WEBPACK_IMPORTED_MODULE_1__.promises.stat(tempPath);\n            if (stats.size > 200 * 1024 * 1024) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: 'File too large',\n                    details: {\n                        size: stats.size,\n                        maxSize: 200 * 1024 * 1024\n                    }\n                }, {\n                    status: 400\n                });\n            }\n            // Run analysis\n            console.log('Starting analysis for:', originalName);\n            const analysisOptions = (0,_lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__.validateAnalysisOptions)({\n                maxFiles: 50000,\n                maxFileSize: 2 * 1024 * 1024,\n                allowedExtensions: [\n                    '.html',\n                    '.htm',\n                    '.css',\n                    '.js',\n                    '.mjs',\n                    '.ts',\n                    '.svg',\n                    '.wasm',\n                    '.json',\n                    '.webmanifest'\n                ],\n                storeResults: true,\n                publicUrl: process.env.PUBLIC_URL || 'http://localhost:3000'\n            });\n            console.log('Analysis options:', analysisOptions);\n            const result = await (0,_lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__.runBaselineAnalysis)(tempPath, analysisOptions);\n            console.log('Analysis completed successfully');\n            if (!result.artifacts) {\n                throw new Error('Failed to store analysis results');\n            }\n            // Create response\n            const response = {\n                analysisId: result.artifacts.analysisId,\n                summary: result.report.summary,\n                artifacts: {\n                    jsonUrl: result.artifacts.jsonUrl,\n                    csvUrl: result.artifacts.csvUrl\n                },\n                report: result.report\n            };\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(response);\n        } finally{\n            // Clean up temporary file\n            try {\n                await fs__WEBPACK_IMPORTED_MODULE_1__.promises.unlink(tempPath);\n            } catch (error) {\n                console.warn(`Failed to cleanup temp file ${tempPath}: ${error}`);\n            }\n        }\n    } catch (error) {\n        console.error('Analysis API error:', error);\n        // Clean up temporary file on error\n        try {\n            if (typeof tempPath !== 'undefined') {\n                await fs__WEBPACK_IMPORTED_MODULE_1__.promises.unlink(tempPath);\n            }\n        } catch (cleanupError) {\n            console.warn(`Failed to cleanup temp file on error: ${cleanupError}`);\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: 'Analysis failed',\n            message: error instanceof Error ? error.message : 'Unknown error',\n            details: error instanceof Error ? error.stack : undefined\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxhcHBcXGFwaVxcYW5hbHl6ZVxccm91dGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IHByb21pc2VzIGFzIGZzIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyByYW5kb21VVUlEIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IHJ1bkJhc2VsaW5lQW5hbHlzaXMsIHZhbGlkYXRlQW5hbHlzaXNPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vbGliL2FuYWx5c2lzL3J1bic7XG4vLyBaSVAgaW1wb3J0cyByZW1vdmVkIGFzIHBlciBuZXcgcmVxdWlyZW1lbnRzXG5pbXBvcnQgeyBzaG91bGRBbmFseXplRmlsZSB9IGZyb20gJy4uLy4uLy4uL2xpYi9maWxlcy9zaW5nbGUtZmlsZSc7XG5pbXBvcnQgeyBBbmFseXplUmVzcG9uc2UgfSBmcm9tICcuLi8uLi8uLi9saWIvYW5hbHlzaXMvYmFzZWxpbmUudHlwZXMnO1xuXG5leHBvcnQgY29uc3QgcnVudGltZSA9IFwibm9kZWpzXCI7XG5leHBvcnQgY29uc3QgZHluYW1pYyA9IFwiZm9yY2UtZHluYW1pY1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICBjb25zb2xlLmxvZygnQW5hbHl6ZSBBUEkgY2FsbGVkIHdpdGggbWV0aG9kOiBQT1NUJyk7XG4gIFxuICBsZXQgdGVtcFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIC8vIFBhcnNlIGZvcm0gZGF0YSB1c2luZyBOZXh0LmpzIGJ1aWx0LWluIEZvcm1EYXRhXG4gICAgY29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XG4gICAgY29uc3QgZmlsZSA9IGZvcm1EYXRhLmdldCgnZmlsZScpIGFzIEZpbGU7XG5cbiAgICBpZiAoIWZpbGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGZpbGUgZm91bmQgaW4gcmVxdWVzdCcpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgXG4gICAgICAgIGVycm9yOiAnTm8gZmlsZSBwcm92aWRlZCdcbiAgICAgIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0ZpbGUgZm91bmQ6Jywge1xuICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgc2l6ZTogZmlsZS5zaXplXG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgdGVtcG9yYXJ5IGRpcmVjdG9yeSAtIHVzZSAvdG1wIGZvciBWZXJjZWwgc2VydmVybGVzc1xuICAgIGNvbnN0IHRlbXBEaXIgPSBwcm9jZXNzLmVudi5WRVJDRUwgPyAnL3RtcC9hbmFseXplcicgOiBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdhbmFseXplcicpO1xuICAgIGF3YWl0IGZzLm1rZGlyKHRlbXBEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuXG4gICAgLy8gU2F2ZSB1cGxvYWRlZCBmaWxlXG4gICAgY29uc3QgYW5hbHlzaXNJZCA9IHJhbmRvbVVVSUQoKTtcbiAgICBjb25zdCBvcmlnaW5hbE5hbWUgPSBmaWxlLm5hbWUgfHwgJ3VwbG9hZGVkLWZpbGUnO1xuICAgIHRlbXBQYXRoID0gcGF0aC5qb2luKHRlbXBEaXIsIGAke2FuYWx5c2lzSWR9LSR7b3JpZ2luYWxOYW1lfWApO1xuICAgIFxuICAgIC8vIENvbnZlcnQgRmlsZSB0byBCdWZmZXIgYW5kIHdyaXRlIHRvIGRpc2tcbiAgICBjb25zdCBieXRlcyA9IGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShieXRlcyk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHRlbXBQYXRoLCBidWZmZXIpO1xuICAgIGNvbnNvbGUubG9nKCdGaWxlIHNhdmVkIHN1Y2Nlc3NmdWxseScpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIGZpbGUgc2hvdWxkIGJlIGFuYWx5emVkIChlYXJseSBleGl0IGZvciB1bnN1cHBvcnRlZCB0eXBlcylcbiAgICAgIGlmICghc2hvdWxkQW5hbHl6ZUZpbGUob3JpZ2luYWxOYW1lKSkge1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBcbiAgICAgICAgICBlcnJvcjogJ0ZpbGUgdHlwZSBub3Qgc3VwcG9ydGVkIGZvciBhbmFseXNpcycsXG4gICAgICAgICAgZGV0YWlsczogeyBmaWxlbmFtZTogb3JpZ2luYWxOYW1lIH1cbiAgICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZmlsZSBzaXplXG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnN0YXQodGVtcFBhdGgpO1xuICAgICAgaWYgKHN0YXRzLnNpemUgPiAyMDAgKiAxMDI0ICogMTAyNCkgeyAvLyAyMDBNQiBsaW1pdFxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBcbiAgICAgICAgICBlcnJvcjogJ0ZpbGUgdG9vIGxhcmdlJyxcbiAgICAgICAgICBkZXRhaWxzOiB7IFxuICAgICAgICAgICAgc2l6ZTogc3RhdHMuc2l6ZSxcbiAgICAgICAgICAgIG1heFNpemU6IDIwMCAqIDEwMjQgKiAxMDI0XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7IHN0YXR1czogNDAwIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBSdW4gYW5hbHlzaXNcbiAgICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBhbmFseXNpcyBmb3I6Jywgb3JpZ2luYWxOYW1lKTtcbiAgICAgIGNvbnN0IGFuYWx5c2lzT3B0aW9ucyA9IHZhbGlkYXRlQW5hbHlzaXNPcHRpb25zKHtcbiAgICAgICAgbWF4RmlsZXM6IDUwMDAwLFxuICAgICAgICBtYXhGaWxlU2l6ZTogMiAqIDEwMjQgKiAxMDI0LCAvLyAyTUJcbiAgICAgICAgYWxsb3dlZEV4dGVuc2lvbnM6IFsnLmh0bWwnLCAnLmh0bScsICcuY3NzJywgJy5qcycsICcubWpzJywgJy50cycsICcuc3ZnJywgJy53YXNtJywgJy5qc29uJywgJy53ZWJtYW5pZmVzdCddLFxuICAgICAgICBzdG9yZVJlc3VsdHM6IHRydWUsXG4gICAgICAgIHB1YmxpY1VybDogcHJvY2Vzcy5lbnYuUFVCTElDX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygnQW5hbHlzaXMgb3B0aW9uczonLCBhbmFseXNpc09wdGlvbnMpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnVuQmFzZWxpbmVBbmFseXNpcyh0ZW1wUGF0aCwgYW5hbHlzaXNPcHRpb25zKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBbmFseXNpcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICAgIGlmICghcmVzdWx0LmFydGlmYWN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSBhbmFseXNpcyByZXN1bHRzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2U6IEFuYWx5emVSZXNwb25zZSA9IHtcbiAgICAgICAgYW5hbHlzaXNJZDogcmVzdWx0LmFydGlmYWN0cy5hbmFseXNpc0lkLFxuICAgICAgICBzdW1tYXJ5OiByZXN1bHQucmVwb3J0LnN1bW1hcnksXG4gICAgICAgIGFydGlmYWN0czoge1xuICAgICAgICAgIGpzb25Vcmw6IHJlc3VsdC5hcnRpZmFjdHMuanNvblVybCxcbiAgICAgICAgICBjc3ZVcmw6IHJlc3VsdC5hcnRpZmFjdHMuY3N2VXJsLFxuICAgICAgICB9LFxuICAgICAgICByZXBvcnQ6IHJlc3VsdC5yZXBvcnQsIC8vIEluY2x1ZGUgZnVsbCByZXBvcnQgZm9yIEdyb3EgYW5hbHlzaXNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihyZXNwb25zZSk7XG5cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gQ2xlYW4gdXAgdGVtcG9yYXJ5IGZpbGVcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZzLnVubGluayh0ZW1wUGF0aCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBjbGVhbnVwIHRlbXAgZmlsZSAke3RlbXBQYXRofTogJHtlcnJvcn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdBbmFseXNpcyBBUEkgZXJyb3I6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIHRlbXBvcmFyeSBmaWxlIG9uIGVycm9yXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcFBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGF3YWl0IGZzLnVubGluayh0ZW1wUGF0aCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoY2xlYW51cEVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBjbGVhbnVwIHRlbXAgZmlsZSBvbiBlcnJvcjogJHtjbGVhbnVwRXJyb3J9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgZXJyb3I6ICdBbmFseXNpcyBmYWlsZWQnLFxuICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICBkZXRhaWxzOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWRcbiAgICB9LCB7IHN0YXR1czogNTAwIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwicHJvbWlzZXMiLCJmcyIsInBhdGgiLCJyYW5kb21VVUlEIiwicnVuQmFzZWxpbmVBbmFseXNpcyIsInZhbGlkYXRlQW5hbHlzaXNPcHRpb25zIiwic2hvdWxkQW5hbHl6ZUZpbGUiLCJydW50aW1lIiwiZHluYW1pYyIsIlBPU1QiLCJyZXF1ZXN0IiwiY29uc29sZSIsImxvZyIsInRlbXBQYXRoIiwiZm9ybURhdGEiLCJmaWxlIiwiZ2V0IiwiZXJyb3IiLCJqc29uIiwic3RhdHVzIiwibmFtZSIsInR5cGUiLCJzaXplIiwidGVtcERpciIsInByb2Nlc3MiLCJlbnYiLCJWRVJDRUwiLCJqb2luIiwiY3dkIiwibWtkaXIiLCJyZWN1cnNpdmUiLCJhbmFseXNpc0lkIiwib3JpZ2luYWxOYW1lIiwiYnl0ZXMiLCJhcnJheUJ1ZmZlciIsImJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJ3cml0ZUZpbGUiLCJkZXRhaWxzIiwiZmlsZW5hbWUiLCJzdGF0cyIsInN0YXQiLCJtYXhTaXplIiwiYW5hbHlzaXNPcHRpb25zIiwibWF4RmlsZXMiLCJtYXhGaWxlU2l6ZSIsImFsbG93ZWRFeHRlbnNpb25zIiwic3RvcmVSZXN1bHRzIiwicHVibGljVXJsIiwiUFVCTElDX1VSTCIsInJlc3VsdCIsImFydGlmYWN0cyIsIkVycm9yIiwicmVzcG9uc2UiLCJzdW1tYXJ5IiwicmVwb3J0IiwianNvblVybCIsImNzdlVybCIsInVubGluayIsIndhcm4iLCJjbGVhbnVwRXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJ1bmRlZmluZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/analyze/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/baseline.loader.ts":
/*!*****************************************!*\
  !*** ./lib/analysis/baseline.loader.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearRulesCache: () => (/* binding */ clearRulesCache),\n/* harmony export */   getCachedBaselineRules: () => (/* binding */ getCachedBaselineRules),\n/* harmony export */   getDefaultBaselineRules: () => (/* binding */ getDefaultBaselineRules),\n/* harmony export */   getDependencyUpgradeTemplate: () => (/* binding */ getDependencyUpgradeTemplate),\n/* harmony export */   getLanguageRules: () => (/* binding */ getLanguageRules),\n/* harmony export */   getPatternQuickFix: () => (/* binding */ getPatternQuickFix),\n/* harmony export */   isRulesCacheValid: () => (/* binding */ isRulesCacheValid),\n/* harmony export */   loadBaselineRules: () => (/* binding */ loadBaselineRules),\n/* harmony export */   loadBaselineRulesWithFallback: () => (/* binding */ loadBaselineRulesWithFallback),\n/* harmony export */   shouldIgnorePath: () => (/* binding */ shouldIgnorePath),\n/* harmony export */   shouldScanFile: () => (/* binding */ shouldScanFile),\n/* harmony export */   validateRulesStructure: () => (/* binding */ validateRulesStructure)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yaml */ \"(rsc)/./node_modules/yaml/dist/index.js\");\n/* harmony import */ var _baseline_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./baseline.types */ \"(rsc)/./lib/analysis/baseline.types.ts\");\n// readFileSync imported dynamically\n\n\n\n// Use process.cwd() for Node.js environment\n// Cache for loaded rules\nlet rulesCache = null;\nlet rulesCacheTimestamp = 0;\n/**\r\n * Load baseline rules from YAML configuration file\r\n * @param configPath Optional path to config file, defaults to config/baseline.rules.yaml\r\n * @returns Parsed and validated baseline rules\r\n */ async function loadBaselineRules(configPath) {\n    const defaultPath = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(process.cwd(), 'config', 'baseline.rules.yaml');\n    const path = configPath || defaultPath;\n    try {\n        // Check if we have cached rules and they're still valid\n        const { statSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const stats = statSync(path);\n        const mtime = stats.mtime.getTime();\n        if (rulesCache && mtime <= rulesCacheTimestamp) {\n            return rulesCache;\n        }\n        // Read and parse YAML file\n        const { readFileSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const yamlContent = readFileSync(path, 'utf8');\n        const rawRules = yaml__WEBPACK_IMPORTED_MODULE_1__.parse(yamlContent);\n        // Validate and parse rules\n        const rules = (0,_baseline_types__WEBPACK_IMPORTED_MODULE_2__.validateBaselineRules)(rawRules);\n        // Update cache\n        rulesCache = rules;\n        rulesCacheTimestamp = mtime;\n        return rules;\n    } catch (error) {\n        throw new Error(`Failed to load baseline rules from ${path}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\r\n * Get cached baseline rules without file system access\r\n * @returns Cached rules or throws if not loaded\r\n */ function getCachedBaselineRules() {\n    if (!rulesCache) {\n        throw new Error('Baseline rules not loaded. Call loadBaselineRules() first.');\n    }\n    return rulesCache;\n}\n/**\r\n * Clear the rules cache (useful for testing)\r\n */ function clearRulesCache() {\n    rulesCache = null;\n    rulesCacheTimestamp = 0;\n}\n/**\r\n * Check if rules are cached and up to date\r\n * @param configPath Optional path to config file\r\n * @returns True if cached rules are valid\r\n */ async function isRulesCacheValid(configPath) {\n    if (!rulesCache) return false;\n    try {\n        const defaultPath = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(process.cwd(), 'config', 'baseline.rules.yaml');\n        const path = configPath || defaultPath;\n        const { statSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const stats = statSync(path);\n        const mtime = stats.mtime.getTime();\n        return mtime <= rulesCacheTimestamp;\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Get default baseline rules (fallback if file loading fails)\r\n * @returns Minimal default rules\r\n */ function getDefaultBaselineRules() {\n    return {\n        language_runtimes: {\n            node: '>=18.0.0',\n            python: '>=3.10.0',\n            java: '>=17.0.0',\n            go: '>=1.21.0',\n            dotnet: '>=6.0.0'\n        },\n        package_mins: {\n            node: {\n                react: '>=18.0.0',\n                next: '>=13.0.0',\n                express: '>=4.18.0'\n            },\n            python: {\n                numpy: '>=1.22.0',\n                pandas: '>=1.4.0',\n                torch: '>=2.0.0'\n            },\n            java: {},\n            go: {},\n            dotnet: {}\n        },\n        deprecated_patterns: {\n            node: [\n                {\n                    pattern: 'fs\\\\.exists\\\\(',\n                    message: 'fs.exists() is deprecated, use fs.access() or fs.stat()',\n                    alternative: 'Use fs.access() or fs.promises.access()'\n                }\n            ],\n            python: [\n                {\n                    pattern: 'numpy\\\\.asscalar',\n                    message: 'numpy.asscalar is deprecated, use item() instead',\n                    alternative: 'Use numpy.item() or direct array indexing'\n                }\n            ],\n            java: [],\n            go: [],\n            dotnet: []\n        },\n        scan_file_exts: [\n            '.py',\n            '.js',\n            '.ts',\n            '.tsx',\n            '.jsx',\n            '.java',\n            '.go',\n            '.cs'\n        ],\n        ignore_paths: [\n            '/node_modules/',\n            '/.venv/',\n            '/venv/',\n            '/dist/',\n            '/build/',\n            '/.git/'\n        ],\n        max_file_size: 2097152,\n        max_files: 50000,\n        quick_fixes: {\n            dependency_upgrade: {\n                node: 'npm install {package}@{version}',\n                python: 'pip install \\'{package}>={version}\\'',\n                java: 'Update {package} to version {version} in pom.xml or build.gradle',\n                go: 'go get {package}@{version}',\n                dotnet: 'dotnet add package {package} --version {version}'\n            },\n            pattern_replacement: {\n                node: {\n                    'fs.exists(': 'Use fs.access() or fs.promises.access()'\n                },\n                python: {\n                    'numpy.asscalar': 'Use .item() method instead'\n                },\n                java: {},\n                go: {},\n                dotnet: {}\n            }\n        }\n    };\n}\n/**\r\n * Load baseline rules with fallback to defaults\r\n * @param configPath Optional path to config file\r\n * @returns Baseline rules (loaded or default)\r\n */ async function loadBaselineRulesWithFallback(configPath) {\n    try {\n        return await loadBaselineRules(configPath);\n    } catch (error) {\n        console.warn(`Failed to load baseline rules: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        console.warn('Using default baseline rules');\n        return getDefaultBaselineRules();\n    }\n}\n/**\r\n * Validate that a rules object has all required fields\r\n * @param rules Rules object to validate\r\n * @returns True if valid\r\n */ async function validateRulesStructure(rules) {\n    try {\n        (0,_baseline_types__WEBPACK_IMPORTED_MODULE_2__.validateBaselineRules)(rules);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Get rules for a specific language\r\n * @param rules Baseline rules\r\n * @param language Language to get rules for\r\n * @returns Rules specific to the language\r\n */ function getLanguageRules(rules, language) {\n    return {\n        packageMins: rules.package_mins[language] || {},\n        deprecatedPatterns: rules.deprecated_patterns[language] || [],\n        runtime: rules.language_runtimes[language]\n    };\n}\n/**\r\n * Check if a file extension should be scanned\r\n * @param rules Baseline rules\r\n * @param extension File extension (with or without dot)\r\n * @returns True if should be scanned\r\n */ function shouldScanFile(rules, extension) {\n    const ext = extension.startsWith('.') ? extension : `.${extension}`;\n    return rules.scan_file_exts.includes(ext);\n}\n/**\r\n * Check if a path should be ignored\r\n * @param rules Baseline rules\r\n * @param filePath File path to check\r\n * @returns True if should be ignored\r\n */ function shouldIgnorePath(rules, filePath) {\n    if (!filePath || !rules.ignore_paths) {\n        return false;\n    }\n    return rules.ignore_paths.some((ignorePath)=>filePath.includes(ignorePath) || filePath.startsWith(ignorePath));\n}\n/**\r\n * Get quick fix template for dependency upgrade\r\n * @param rules Baseline rules\r\n * @param language Language\r\n * @returns Template string\r\n */ function getDependencyUpgradeTemplate(rules, language) {\n    return rules.quick_fixes.dependency_upgrade[language] || 'Update {package} to {version}';\n}\n/**\r\n * Get quick fix for pattern replacement\r\n * @param rules Baseline rules\r\n * @param language Language\r\n * @param pattern Pattern to replace\r\n * @returns Quick fix suggestion or undefined\r\n */ function getPatternQuickFix(rules, language, pattern) {\n    return rules.quick_fixes.pattern_replacement[language]?.[pattern];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvYW5hbHlzaXMvYmFzZWxpbmUubG9hZGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvQ0FBb0M7QUFDUjtBQUNKO0FBQ2dEO0FBRXhFLDRDQUE0QztBQUU1Qyx5QkFBeUI7QUFDekIsSUFBSUcsYUFBbUM7QUFDdkMsSUFBSUMsc0JBQThCO0FBRWxDOzs7O0NBSUMsR0FDTSxlQUFlQyxrQkFBa0JDLFVBQW1CO0lBQ3pELE1BQU1DLGNBQWNQLDBDQUFJQSxDQUFDUSxRQUFRQyxHQUFHLElBQUksVUFBVTtJQUNsRCxNQUFNQyxPQUFPSixjQUFjQztJQUUzQixJQUFJO1FBQ0Ysd0RBQXdEO1FBQ3hELE1BQU0sRUFBRUksUUFBUSxFQUFFLEdBQUcsTUFBTSwwR0FBWTtRQUN2QyxNQUFNQyxRQUFRRCxTQUFTRDtRQUN2QixNQUFNRyxRQUFRRCxNQUFNQyxLQUFLLENBQUNDLE9BQU87UUFFakMsSUFBSVgsY0FBY1UsU0FBU1QscUJBQXFCO1lBQzlDLE9BQU9EO1FBQ1Q7UUFFQSwyQkFBMkI7UUFDM0IsTUFBTSxFQUFFWSxZQUFZLEVBQUUsR0FBRyxNQUFNLDBHQUFZO1FBQzNDLE1BQU1DLGNBQWNELGFBQWFMLE1BQU07UUFDdkMsTUFBTU8sV0FBV2hCLHVDQUFVLENBQUNlO1FBRTVCLDJCQUEyQjtRQUMzQixNQUFNRyxRQUFRakIsc0VBQXFCQSxDQUFDZTtRQUVwQyxlQUFlO1FBQ2ZkLGFBQWFnQjtRQUNiZixzQkFBc0JTO1FBRXRCLE9BQU9NO0lBQ1QsRUFBRSxPQUFPQyxPQUFPO1FBQ2QsTUFBTSxJQUFJQyxNQUFNLENBQUMsbUNBQW1DLEVBQUVYLEtBQUssRUFBRSxFQUFFVSxpQkFBaUJDLFFBQVFELE1BQU1FLE9BQU8sR0FBRyxpQkFBaUI7SUFDM0g7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDO0lBQ2QsSUFBSSxDQUFDcEIsWUFBWTtRQUNmLE1BQU0sSUFBSWtCLE1BQU07SUFDbEI7SUFDQSxPQUFPbEI7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU3FCO0lBQ2RyQixhQUFhO0lBQ2JDLHNCQUFzQjtBQUN4QjtBQUVBOzs7O0NBSUMsR0FDTSxlQUFlcUIsa0JBQWtCbkIsVUFBbUI7SUFDekQsSUFBSSxDQUFDSCxZQUFZLE9BQU87SUFFeEIsSUFBSTtRQUNGLE1BQU1JLGNBQWNQLDBDQUFJQSxDQUFDUSxRQUFRQyxHQUFHLElBQUksVUFBVTtRQUNsRCxNQUFNQyxPQUFPSixjQUFjQztRQUMzQixNQUFNLEVBQUVJLFFBQVEsRUFBRSxHQUFHLE1BQU0sMEdBQVk7UUFDdkMsTUFBTUMsUUFBUUQsU0FBU0Q7UUFDdkIsTUFBTUcsUUFBUUQsTUFBTUMsS0FBSyxDQUFDQyxPQUFPO1FBRWpDLE9BQU9ELFNBQVNUO0lBQ2xCLEVBQUUsT0FBTTtRQUNOLE9BQU87SUFDVDtBQUNGO0FBRUE7OztDQUdDLEdBQ00sU0FBU3NCO0lBQ2QsT0FBTztRQUNMQyxtQkFBbUI7WUFDakJDLE1BQU07WUFDTkMsUUFBUTtZQUNSQyxNQUFNO1lBQ05DLElBQUk7WUFDSkMsUUFBUTtRQUNWO1FBQ0FDLGNBQWM7WUFDWkwsTUFBTTtnQkFDSk0sT0FBTztnQkFDUEMsTUFBTTtnQkFDTkMsU0FBUztZQUNYO1lBQ0FQLFFBQVE7Z0JBQ05RLE9BQU87Z0JBQ1BDLFFBQVE7Z0JBQ1JDLE9BQU87WUFDVDtZQUNBVCxNQUFNLENBQUM7WUFDUEMsSUFBSSxDQUFDO1lBQ0xDLFFBQVEsQ0FBQztRQUNYO1FBQ0FRLHFCQUFxQjtZQUNuQlosTUFBTTtnQkFDSjtvQkFDRWEsU0FBUztvQkFDVG5CLFNBQVM7b0JBQ1RvQixhQUFhO2dCQUNmO2FBQ0Q7WUFDRGIsUUFBUTtnQkFDTjtvQkFDRVksU0FBUztvQkFDVG5CLFNBQVM7b0JBQ1RvQixhQUFhO2dCQUNmO2FBQ0Q7WUFDRFosTUFBTSxFQUFFO1lBQ1JDLElBQUksRUFBRTtZQUNOQyxRQUFRLEVBQUU7UUFDWjtRQUNBVyxnQkFBZ0I7WUFBQztZQUFPO1lBQU87WUFBTztZQUFRO1lBQVE7WUFBUztZQUFPO1NBQU07UUFDNUVDLGNBQWM7WUFBQztZQUFrQjtZQUFXO1lBQVU7WUFBVTtZQUFXO1NBQVM7UUFDcEZDLGVBQWU7UUFDZkMsV0FBVztRQUNYQyxhQUFhO1lBQ1hDLG9CQUFvQjtnQkFDbEJwQixNQUFNO2dCQUNOQyxRQUFRO2dCQUNSQyxNQUFNO2dCQUNOQyxJQUFJO2dCQUNKQyxRQUFRO1lBQ1Y7WUFDQWlCLHFCQUFxQjtnQkFDbkJyQixNQUFNO29CQUNKLGNBQWM7Z0JBQ2hCO2dCQUNBQyxRQUFRO29CQUNOLGtCQUFrQjtnQkFDcEI7Z0JBQ0FDLE1BQU0sQ0FBQztnQkFDUEMsSUFBSSxDQUFDO2dCQUNMQyxRQUFRLENBQUM7WUFDWDtRQUNGO0lBQ0Y7QUFDRjtBQUVBOzs7O0NBSUMsR0FDTSxlQUFla0IsOEJBQThCNUMsVUFBbUI7SUFDckUsSUFBSTtRQUNGLE9BQU8sTUFBTUQsa0JBQWtCQztJQUNqQyxFQUFFLE9BQU9jLE9BQU87UUFDZCtCLFFBQVFDLElBQUksQ0FBQyxDQUFDLCtCQUErQixFQUFFaEMsaUJBQWlCQyxRQUFRRCxNQUFNRSxPQUFPLEdBQUcsaUJBQWlCO1FBQ3pHNkIsUUFBUUMsSUFBSSxDQUFDO1FBQ2IsT0FBTzFCO0lBQ1Q7QUFDRjtBQUVBOzs7O0NBSUMsR0FDTSxlQUFlMkIsdUJBQXVCbEMsS0FBYztJQUN6RCxJQUFJO1FBQ0ZqQixzRUFBcUJBLENBQUNpQjtRQUN0QixPQUFPO0lBQ1QsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNtQyxpQkFBaUJuQyxLQUFvQixFQUFFb0MsUUFBNkM7SUFDbEcsT0FBTztRQUNMQyxhQUFhckMsTUFBTWMsWUFBWSxDQUFDc0IsU0FBUyxJQUFJLENBQUM7UUFDOUNFLG9CQUFvQnRDLE1BQU1xQixtQkFBbUIsQ0FBQ2UsU0FBUyxJQUFJLEVBQUU7UUFDN0RHLFNBQVN2QyxNQUFNUSxpQkFBaUIsQ0FBQzRCLFNBQVM7SUFDNUM7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU0ksZUFBZXhDLEtBQW9CLEVBQUV5QyxTQUFpQjtJQUNwRSxNQUFNQyxNQUFNRCxVQUFVRSxVQUFVLENBQUMsT0FBT0YsWUFBWSxDQUFDLENBQUMsRUFBRUEsV0FBVztJQUNuRSxPQUFPekMsTUFBTXdCLGNBQWMsQ0FBQ29CLFFBQVEsQ0FBQ0Y7QUFDdkM7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNHLGlCQUFpQjdDLEtBQW9CLEVBQUU4QyxRQUFnQjtJQUNyRSxJQUFJLENBQUNBLFlBQVksQ0FBQzlDLE1BQU15QixZQUFZLEVBQUU7UUFDcEMsT0FBTztJQUNUO0lBQ0EsT0FBT3pCLE1BQU15QixZQUFZLENBQUNzQixJQUFJLENBQUNDLENBQUFBLGFBQzdCRixTQUFTRixRQUFRLENBQUNJLGVBQWVGLFNBQVNILFVBQVUsQ0FBQ0s7QUFFekQ7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNDLDZCQUE2QmpELEtBQW9CLEVBQUVvQyxRQUFrRTtJQUNuSSxPQUFPcEMsTUFBTTRCLFdBQVcsQ0FBQ0Msa0JBQWtCLENBQUNPLFNBQVMsSUFBSTtBQUMzRDtBQUVBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNjLG1CQUNkbEQsS0FBb0IsRUFDcEJvQyxRQUFtRSxFQUNuRWQsT0FBZTtJQUVmLE9BQU90QixNQUFNNEIsV0FBVyxDQUFDRSxtQkFBbUIsQ0FBQ00sU0FBUyxFQUFFLENBQUNkLFFBQVE7QUFDbkUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcYW5hbHlzaXNcXGJhc2VsaW5lLmxvYWRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZWFkRmlsZVN5bmMgaW1wb3J0ZWQgZHluYW1pY2FsbHlcclxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgWUFNTCBmcm9tICd5YW1sJztcclxuaW1wb3J0IHsgQmFzZWxpbmVSdWxlcywgdmFsaWRhdGVCYXNlbGluZVJ1bGVzIH0gZnJvbSAnLi9iYXNlbGluZS50eXBlcyc7XHJcblxyXG4vLyBVc2UgcHJvY2Vzcy5jd2QoKSBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxyXG5cclxuLy8gQ2FjaGUgZm9yIGxvYWRlZCBydWxlc1xyXG5sZXQgcnVsZXNDYWNoZTogQmFzZWxpbmVSdWxlcyB8IG51bGwgPSBudWxsO1xyXG5sZXQgcnVsZXNDYWNoZVRpbWVzdGFtcDogbnVtYmVyID0gMDtcclxuXHJcbi8qKlxyXG4gKiBMb2FkIGJhc2VsaW5lIHJ1bGVzIGZyb20gWUFNTCBjb25maWd1cmF0aW9uIGZpbGVcclxuICogQHBhcmFtIGNvbmZpZ1BhdGggT3B0aW9uYWwgcGF0aCB0byBjb25maWcgZmlsZSwgZGVmYXVsdHMgdG8gY29uZmlnL2Jhc2VsaW5lLnJ1bGVzLnlhbWxcclxuICogQHJldHVybnMgUGFyc2VkIGFuZCB2YWxpZGF0ZWQgYmFzZWxpbmUgcnVsZXNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkQmFzZWxpbmVSdWxlcyhjb25maWdQYXRoPzogc3RyaW5nKTogUHJvbWlzZTxCYXNlbGluZVJ1bGVzPiB7XHJcbiAgY29uc3QgZGVmYXVsdFBhdGggPSBqb2luKHByb2Nlc3MuY3dkKCksICdjb25maWcnLCAnYmFzZWxpbmUucnVsZXMueWFtbCcpO1xyXG4gIGNvbnN0IHBhdGggPSBjb25maWdQYXRoIHx8IGRlZmF1bHRQYXRoO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGNhY2hlZCBydWxlcyBhbmQgdGhleSdyZSBzdGlsbCB2YWxpZFxyXG4gICAgY29uc3QgeyBzdGF0U3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhwYXRoKTtcclxuICAgIGNvbnN0IG10aW1lID0gc3RhdHMubXRpbWUuZ2V0VGltZSgpO1xyXG4gICAgXHJcbiAgICBpZiAocnVsZXNDYWNoZSAmJiBtdGltZSA8PSBydWxlc0NhY2hlVGltZXN0YW1wKSB7XHJcbiAgICAgIHJldHVybiBydWxlc0NhY2hlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBSZWFkIGFuZCBwYXJzZSBZQU1MIGZpbGVcclxuICAgIGNvbnN0IHsgcmVhZEZpbGVTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2ZzJyk7XHJcbiAgICBjb25zdCB5YW1sQ29udGVudCA9IHJlYWRGaWxlU3luYyhwYXRoLCAndXRmOCcpO1xyXG4gICAgY29uc3QgcmF3UnVsZXMgPSBZQU1MLnBhcnNlKHlhbWxDb250ZW50KTtcclxuICAgIFxyXG4gICAgLy8gVmFsaWRhdGUgYW5kIHBhcnNlIHJ1bGVzXHJcbiAgICBjb25zdCBydWxlcyA9IHZhbGlkYXRlQmFzZWxpbmVSdWxlcyhyYXdSdWxlcyk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjYWNoZVxyXG4gICAgcnVsZXNDYWNoZSA9IHJ1bGVzO1xyXG4gICAgcnVsZXNDYWNoZVRpbWVzdGFtcCA9IG10aW1lO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcnVsZXM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgYmFzZWxpbmUgcnVsZXMgZnJvbSAke3BhdGh9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBjYWNoZWQgYmFzZWxpbmUgcnVsZXMgd2l0aG91dCBmaWxlIHN5c3RlbSBhY2Nlc3NcclxuICogQHJldHVybnMgQ2FjaGVkIHJ1bGVzIG9yIHRocm93cyBpZiBub3QgbG9hZGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVkQmFzZWxpbmVSdWxlcygpOiBCYXNlbGluZVJ1bGVzIHtcclxuICBpZiAoIXJ1bGVzQ2FjaGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQmFzZWxpbmUgcnVsZXMgbm90IGxvYWRlZC4gQ2FsbCBsb2FkQmFzZWxpbmVSdWxlcygpIGZpcnN0LicpO1xyXG4gIH1cclxuICByZXR1cm4gcnVsZXNDYWNoZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFyIHRoZSBydWxlcyBjYWNoZSAodXNlZnVsIGZvciB0ZXN0aW5nKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyUnVsZXNDYWNoZSgpOiB2b2lkIHtcclxuICBydWxlc0NhY2hlID0gbnVsbDtcclxuICBydWxlc0NhY2hlVGltZXN0YW1wID0gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHJ1bGVzIGFyZSBjYWNoZWQgYW5kIHVwIHRvIGRhdGVcclxuICogQHBhcmFtIGNvbmZpZ1BhdGggT3B0aW9uYWwgcGF0aCB0byBjb25maWcgZmlsZVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGNhY2hlZCBydWxlcyBhcmUgdmFsaWRcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc1J1bGVzQ2FjaGVWYWxpZChjb25maWdQYXRoPzogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFydWxlc0NhY2hlKSByZXR1cm4gZmFsc2U7XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGRlZmF1bHRQYXRoID0gam9pbihwcm9jZXNzLmN3ZCgpLCAnY29uZmlnJywgJ2Jhc2VsaW5lLnJ1bGVzLnlhbWwnKTtcclxuICAgIGNvbnN0IHBhdGggPSBjb25maWdQYXRoIHx8IGRlZmF1bHRQYXRoO1xyXG4gICAgY29uc3QgeyBzdGF0U3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhwYXRoKTtcclxuICAgIGNvbnN0IG10aW1lID0gc3RhdHMubXRpbWUuZ2V0VGltZSgpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gbXRpbWUgPD0gcnVsZXNDYWNoZVRpbWVzdGFtcDtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZGVmYXVsdCBiYXNlbGluZSBydWxlcyAoZmFsbGJhY2sgaWYgZmlsZSBsb2FkaW5nIGZhaWxzKVxyXG4gKiBAcmV0dXJucyBNaW5pbWFsIGRlZmF1bHQgcnVsZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0QmFzZWxpbmVSdWxlcygpOiBCYXNlbGluZVJ1bGVzIHtcclxuICByZXR1cm4ge1xyXG4gICAgbGFuZ3VhZ2VfcnVudGltZXM6IHtcclxuICAgICAgbm9kZTogJz49MTguMC4wJyxcclxuICAgICAgcHl0aG9uOiAnPj0zLjEwLjAnLFxyXG4gICAgICBqYXZhOiAnPj0xNy4wLjAnLFxyXG4gICAgICBnbzogJz49MS4yMS4wJyxcclxuICAgICAgZG90bmV0OiAnPj02LjAuMCcsXHJcbiAgICB9LFxyXG4gICAgcGFja2FnZV9taW5zOiB7XHJcbiAgICAgIG5vZGU6IHtcclxuICAgICAgICByZWFjdDogJz49MTguMC4wJyxcclxuICAgICAgICBuZXh0OiAnPj0xMy4wLjAnLFxyXG4gICAgICAgIGV4cHJlc3M6ICc+PTQuMTguMCcsXHJcbiAgICAgIH0sXHJcbiAgICAgIHB5dGhvbjoge1xyXG4gICAgICAgIG51bXB5OiAnPj0xLjIyLjAnLFxyXG4gICAgICAgIHBhbmRhczogJz49MS40LjAnLFxyXG4gICAgICAgIHRvcmNoOiAnPj0yLjAuMCcsXHJcbiAgICAgIH0sXHJcbiAgICAgIGphdmE6IHt9LFxyXG4gICAgICBnbzoge30sXHJcbiAgICAgIGRvdG5ldDoge30sXHJcbiAgICB9LFxyXG4gICAgZGVwcmVjYXRlZF9wYXR0ZXJuczoge1xyXG4gICAgICBub2RlOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcGF0dGVybjogJ2ZzXFxcXC5leGlzdHNcXFxcKCcsXHJcbiAgICAgICAgICBtZXNzYWdlOiAnZnMuZXhpc3RzKCkgaXMgZGVwcmVjYXRlZCwgdXNlIGZzLmFjY2VzcygpIG9yIGZzLnN0YXQoKScsXHJcbiAgICAgICAgICBhbHRlcm5hdGl2ZTogJ1VzZSBmcy5hY2Nlc3MoKSBvciBmcy5wcm9taXNlcy5hY2Nlc3MoKScsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgcHl0aG9uOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcGF0dGVybjogJ251bXB5XFxcXC5hc3NjYWxhcicsXHJcbiAgICAgICAgICBtZXNzYWdlOiAnbnVtcHkuYXNzY2FsYXIgaXMgZGVwcmVjYXRlZCwgdXNlIGl0ZW0oKSBpbnN0ZWFkJyxcclxuICAgICAgICAgIGFsdGVybmF0aXZlOiAnVXNlIG51bXB5Lml0ZW0oKSBvciBkaXJlY3QgYXJyYXkgaW5kZXhpbmcnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIGphdmE6IFtdLFxyXG4gICAgICBnbzogW10sXHJcbiAgICAgIGRvdG5ldDogW10sXHJcbiAgICB9LFxyXG4gICAgc2Nhbl9maWxlX2V4dHM6IFsnLnB5JywgJy5qcycsICcudHMnLCAnLnRzeCcsICcuanN4JywgJy5qYXZhJywgJy5nbycsICcuY3MnXSxcclxuICAgIGlnbm9yZV9wYXRoczogWycvbm9kZV9tb2R1bGVzLycsICcvLnZlbnYvJywgJy92ZW52LycsICcvZGlzdC8nLCAnL2J1aWxkLycsICcvLmdpdC8nXSxcclxuICAgIG1heF9maWxlX3NpemU6IDIwOTcxNTIsIC8vIDJNQlxyXG4gICAgbWF4X2ZpbGVzOiA1MDAwMCxcclxuICAgIHF1aWNrX2ZpeGVzOiB7XHJcbiAgICAgIGRlcGVuZGVuY3lfdXBncmFkZToge1xyXG4gICAgICAgIG5vZGU6ICducG0gaW5zdGFsbCB7cGFja2FnZX1Ae3ZlcnNpb259JyxcclxuICAgICAgICBweXRob246ICdwaXAgaW5zdGFsbCBcXCd7cGFja2FnZX0+PXt2ZXJzaW9ufVxcJycsXHJcbiAgICAgICAgamF2YTogJ1VwZGF0ZSB7cGFja2FnZX0gdG8gdmVyc2lvbiB7dmVyc2lvbn0gaW4gcG9tLnhtbCBvciBidWlsZC5ncmFkbGUnLFxyXG4gICAgICAgIGdvOiAnZ28gZ2V0IHtwYWNrYWdlfUB7dmVyc2lvbn0nLFxyXG4gICAgICAgIGRvdG5ldDogJ2RvdG5ldCBhZGQgcGFja2FnZSB7cGFja2FnZX0gLS12ZXJzaW9uIHt2ZXJzaW9ufScsXHJcbiAgICAgIH0sXHJcbiAgICAgIHBhdHRlcm5fcmVwbGFjZW1lbnQ6IHtcclxuICAgICAgICBub2RlOiB7XHJcbiAgICAgICAgICAnZnMuZXhpc3RzKCc6ICdVc2UgZnMuYWNjZXNzKCkgb3IgZnMucHJvbWlzZXMuYWNjZXNzKCknLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHl0aG9uOiB7XHJcbiAgICAgICAgICAnbnVtcHkuYXNzY2FsYXInOiAnVXNlIC5pdGVtKCkgbWV0aG9kIGluc3RlYWQnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgamF2YToge30sXHJcbiAgICAgICAgZ286IHt9LFxyXG4gICAgICAgIGRvdG5ldDoge30sXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkIGJhc2VsaW5lIHJ1bGVzIHdpdGggZmFsbGJhY2sgdG8gZGVmYXVsdHNcclxuICogQHBhcmFtIGNvbmZpZ1BhdGggT3B0aW9uYWwgcGF0aCB0byBjb25maWcgZmlsZVxyXG4gKiBAcmV0dXJucyBCYXNlbGluZSBydWxlcyAobG9hZGVkIG9yIGRlZmF1bHQpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEJhc2VsaW5lUnVsZXNXaXRoRmFsbGJhY2soY29uZmlnUGF0aD86IHN0cmluZyk6IFByb21pc2U8QmFzZWxpbmVSdWxlcz4ge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gYXdhaXQgbG9hZEJhc2VsaW5lUnVsZXMoY29uZmlnUGF0aCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGxvYWQgYmFzZWxpbmUgcnVsZXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgICBjb25zb2xlLndhcm4oJ1VzaW5nIGRlZmF1bHQgYmFzZWxpbmUgcnVsZXMnKTtcclxuICAgIHJldHVybiBnZXREZWZhdWx0QmFzZWxpbmVSdWxlcygpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIHRoYXQgYSBydWxlcyBvYmplY3QgaGFzIGFsbCByZXF1aXJlZCBmaWVsZHNcclxuICogQHBhcmFtIHJ1bGVzIFJ1bGVzIG9iamVjdCB0byB2YWxpZGF0ZVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHZhbGlkXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVSdWxlc1N0cnVjdHVyZShydWxlczogdW5rbm93bik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIHRyeSB7XHJcbiAgICB2YWxpZGF0ZUJhc2VsaW5lUnVsZXMocnVsZXMpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHJ1bGVzIGZvciBhIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgdG8gZ2V0IHJ1bGVzIGZvclxyXG4gKiBAcmV0dXJucyBSdWxlcyBzcGVjaWZpYyB0byB0aGUgbGFuZ3VhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5ndWFnZVJ1bGVzKHJ1bGVzOiBCYXNlbGluZVJ1bGVzLCBsYW5ndWFnZToga2V5b2YgQmFzZWxpbmVSdWxlc1sncGFja2FnZV9taW5zJ10pIHtcclxuICByZXR1cm4ge1xyXG4gICAgcGFja2FnZU1pbnM6IHJ1bGVzLnBhY2thZ2VfbWluc1tsYW5ndWFnZV0gfHwge30sXHJcbiAgICBkZXByZWNhdGVkUGF0dGVybnM6IHJ1bGVzLmRlcHJlY2F0ZWRfcGF0dGVybnNbbGFuZ3VhZ2VdIHx8IFtdLFxyXG4gICAgcnVudGltZTogcnVsZXMubGFuZ3VhZ2VfcnVudGltZXNbbGFuZ3VhZ2VdLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGZpbGUgZXh0ZW5zaW9uIHNob3VsZCBiZSBzY2FubmVkXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gZXh0ZW5zaW9uIEZpbGUgZXh0ZW5zaW9uICh3aXRoIG9yIHdpdGhvdXQgZG90KVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHNob3VsZCBiZSBzY2FubmVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkU2NhbkZpbGUocnVsZXM6IEJhc2VsaW5lUnVsZXMsIGV4dGVuc2lvbjogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgZXh0ID0gZXh0ZW5zaW9uLnN0YXJ0c1dpdGgoJy4nKSA/IGV4dGVuc2lvbiA6IGAuJHtleHRlbnNpb259YDtcclxuICByZXR1cm4gcnVsZXMuc2Nhbl9maWxlX2V4dHMuaW5jbHVkZXMoZXh0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgcGF0aCBzaG91bGQgYmUgaWdub3JlZFxyXG4gKiBAcGFyYW0gcnVsZXMgQmFzZWxpbmUgcnVsZXNcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aCB0byBjaGVja1xyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHNob3VsZCBiZSBpZ25vcmVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkSWdub3JlUGF0aChydWxlczogQmFzZWxpbmVSdWxlcywgZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIGlmICghZmlsZVBhdGggfHwgIXJ1bGVzLmlnbm9yZV9wYXRocykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gcnVsZXMuaWdub3JlX3BhdGhzLnNvbWUoaWdub3JlUGF0aCA9PiBcclxuICAgIGZpbGVQYXRoLmluY2x1ZGVzKGlnbm9yZVBhdGgpIHx8IGZpbGVQYXRoLnN0YXJ0c1dpdGgoaWdub3JlUGF0aClcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHF1aWNrIGZpeCB0ZW1wbGF0ZSBmb3IgZGVwZW5kZW5jeSB1cGdyYWRlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2VcclxuICogQHJldHVybnMgVGVtcGxhdGUgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeVVwZ3JhZGVUZW1wbGF0ZShydWxlczogQmFzZWxpbmVSdWxlcywgbGFuZ3VhZ2U6IGtleW9mIEJhc2VsaW5lUnVsZXNbJ3F1aWNrX2ZpeGVzJ11bJ2RlcGVuZGVuY3lfdXBncmFkZSddKTogc3RyaW5nIHtcclxuICByZXR1cm4gcnVsZXMucXVpY2tfZml4ZXMuZGVwZW5kZW5jeV91cGdyYWRlW2xhbmd1YWdlXSB8fCAnVXBkYXRlIHtwYWNrYWdlfSB0byB7dmVyc2lvbn0nO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHF1aWNrIGZpeCBmb3IgcGF0dGVybiByZXBsYWNlbWVudFxyXG4gKiBAcGFyYW0gcnVsZXMgQmFzZWxpbmUgcnVsZXNcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXHJcbiAqIEBwYXJhbSBwYXR0ZXJuIFBhdHRlcm4gdG8gcmVwbGFjZVxyXG4gKiBAcmV0dXJucyBRdWljayBmaXggc3VnZ2VzdGlvbiBvciB1bmRlZmluZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXR0ZXJuUXVpY2tGaXgoXHJcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXMsIFxyXG4gIGxhbmd1YWdlOiBrZXlvZiBCYXNlbGluZVJ1bGVzWydxdWlja19maXhlcyddWydwYXR0ZXJuX3JlcGxhY2VtZW50J10sIFxyXG4gIHBhdHRlcm46IHN0cmluZ1xyXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gIHJldHVybiBydWxlcy5xdWlja19maXhlcy5wYXR0ZXJuX3JlcGxhY2VtZW50W2xhbmd1YWdlXT8uW3BhdHRlcm5dO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJqb2luIiwiWUFNTCIsInZhbGlkYXRlQmFzZWxpbmVSdWxlcyIsInJ1bGVzQ2FjaGUiLCJydWxlc0NhY2hlVGltZXN0YW1wIiwibG9hZEJhc2VsaW5lUnVsZXMiLCJjb25maWdQYXRoIiwiZGVmYXVsdFBhdGgiLCJwcm9jZXNzIiwiY3dkIiwicGF0aCIsInN0YXRTeW5jIiwic3RhdHMiLCJtdGltZSIsImdldFRpbWUiLCJyZWFkRmlsZVN5bmMiLCJ5YW1sQ29udGVudCIsInJhd1J1bGVzIiwicGFyc2UiLCJydWxlcyIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiZ2V0Q2FjaGVkQmFzZWxpbmVSdWxlcyIsImNsZWFyUnVsZXNDYWNoZSIsImlzUnVsZXNDYWNoZVZhbGlkIiwiZ2V0RGVmYXVsdEJhc2VsaW5lUnVsZXMiLCJsYW5ndWFnZV9ydW50aW1lcyIsIm5vZGUiLCJweXRob24iLCJqYXZhIiwiZ28iLCJkb3RuZXQiLCJwYWNrYWdlX21pbnMiLCJyZWFjdCIsIm5leHQiLCJleHByZXNzIiwibnVtcHkiLCJwYW5kYXMiLCJ0b3JjaCIsImRlcHJlY2F0ZWRfcGF0dGVybnMiLCJwYXR0ZXJuIiwiYWx0ZXJuYXRpdmUiLCJzY2FuX2ZpbGVfZXh0cyIsImlnbm9yZV9wYXRocyIsIm1heF9maWxlX3NpemUiLCJtYXhfZmlsZXMiLCJxdWlja19maXhlcyIsImRlcGVuZGVuY3lfdXBncmFkZSIsInBhdHRlcm5fcmVwbGFjZW1lbnQiLCJsb2FkQmFzZWxpbmVSdWxlc1dpdGhGYWxsYmFjayIsImNvbnNvbGUiLCJ3YXJuIiwidmFsaWRhdGVSdWxlc1N0cnVjdHVyZSIsImdldExhbmd1YWdlUnVsZXMiLCJsYW5ndWFnZSIsInBhY2thZ2VNaW5zIiwiZGVwcmVjYXRlZFBhdHRlcm5zIiwicnVudGltZSIsInNob3VsZFNjYW5GaWxlIiwiZXh0ZW5zaW9uIiwiZXh0Iiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwic2hvdWxkSWdub3JlUGF0aCIsImZpbGVQYXRoIiwic29tZSIsImlnbm9yZVBhdGgiLCJnZXREZXBlbmRlbmN5VXBncmFkZVRlbXBsYXRlIiwiZ2V0UGF0dGVyblF1aWNrRml4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/baseline.loader.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/baseline.types.ts":
/*!****************************************!*\
  !*** ./lib/analysis/baseline.types.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalysisContextSchema: () => (/* binding */ AnalysisContextSchema),\n/* harmony export */   AnalysisErrorSchema: () => (/* binding */ AnalysisErrorSchema),\n/* harmony export */   AnalyzeResponseSchema: () => (/* binding */ AnalyzeResponseSchema),\n/* harmony export */   BaselineRulesSchema: () => (/* binding */ BaselineRulesSchema),\n/* harmony export */   DependencyFindingSchema: () => (/* binding */ DependencyFindingSchema),\n/* harmony export */   DeprecatedPatternSchema: () => (/* binding */ DeprecatedPatternSchema),\n/* harmony export */   ExtractedFileSchema: () => (/* binding */ ExtractedFileSchema),\n/* harmony export */   FindingSchema: () => (/* binding */ FindingSchema),\n/* harmony export */   LanguageRuntimesSchema: () => (/* binding */ LanguageRuntimesSchema),\n/* harmony export */   LanguageSchema: () => (/* binding */ LanguageSchema),\n/* harmony export */   LanguageSummarySchema: () => (/* binding */ LanguageSummarySchema),\n/* harmony export */   PackageMinsSchema: () => (/* binding */ PackageMinsSchema),\n/* harmony export */   PatternFindingSchema: () => (/* binding */ PatternFindingSchema),\n/* harmony export */   ProjectManifestSchema: () => (/* binding */ ProjectManifestSchema),\n/* harmony export */   QuickFixesSchema: () => (/* binding */ QuickFixesSchema),\n/* harmony export */   ReportSchema: () => (/* binding */ ReportSchema),\n/* harmony export */   ReportSummarySchema: () => (/* binding */ ReportSummarySchema),\n/* harmony export */   StatusSchema: () => (/* binding */ StatusSchema),\n/* harmony export */   getStatusBadgeClass: () => (/* binding */ getStatusBadgeClass),\n/* harmony export */   getStatusColor: () => (/* binding */ getStatusColor),\n/* harmony export */   getStatusIcon: () => (/* binding */ getStatusIcon),\n/* harmony export */   isDependencyFinding: () => (/* binding */ isDependencyFinding),\n/* harmony export */   isPatternFinding: () => (/* binding */ isPatternFinding),\n/* harmony export */   validateAnalyzeResponse: () => (/* binding */ validateAnalyzeResponse),\n/* harmony export */   validateBaselineRules: () => (/* binding */ validateBaselineRules),\n/* harmony export */   validateFinding: () => (/* binding */ validateFinding),\n/* harmony export */   validateReport: () => (/* binding */ validateReport)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n\n// Language types\nconst LanguageSchema = zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n    'python',\n    'node',\n    'java',\n    'go',\n    'dotnet'\n]);\n// Status types\nconst StatusSchema = zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n    'ok',\n    'affected',\n    'unknown'\n]);\n// Finding types\nconst DependencyFindingSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    kind: zod__WEBPACK_IMPORTED_MODULE_0__.literal('dependency'),\n    lang: LanguageSchema,\n    component: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    foundVersion: zod__WEBPACK_IMPORTED_MODULE_0__.string().nullable(),\n    baselineRequired: zod__WEBPACK_IMPORTED_MODULE_0__.string().nullable(),\n    status: StatusSchema,\n    reason: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    file: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    quickFix: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n});\nconst PatternFindingSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    kind: zod__WEBPACK_IMPORTED_MODULE_0__.literal('pattern'),\n    lang: LanguageSchema,\n    file: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    line: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    status: zod__WEBPACK_IMPORTED_MODULE_0__.literal('affected'),\n    reason: zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n        'deprecated-api',\n        'code-quality',\n        'security',\n        'performance'\n    ]),\n    issue: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    pattern: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    quickFix: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n});\nconst FindingSchema = zod__WEBPACK_IMPORTED_MODULE_0__.discriminatedUnion('kind', [\n    DependencyFindingSchema,\n    PatternFindingSchema\n]);\n// Summary types\nconst LanguageSummarySchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    ok: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    affected: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    unknown: zod__WEBPACK_IMPORTED_MODULE_0__.number()\n});\nconst ReportSummarySchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    ok: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    affected: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    unknown: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    byLanguage: zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, LanguageSummarySchema)\n});\n// Report type\nconst ReportSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    findings: zod__WEBPACK_IMPORTED_MODULE_0__.array(FindingSchema),\n    summary: ReportSummarySchema,\n    metadata: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        analysisId: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n        timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n        projectName: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n        detectedLanguages: zod__WEBPACK_IMPORTED_MODULE_0__.array(LanguageSchema),\n        totalFiles: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n        scannedFiles: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n        skippedFiles: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n        groqAnalysis: zod__WEBPACK_IMPORTED_MODULE_0__.array(zod__WEBPACK_IMPORTED_MODULE_0__.object({\n            analysis: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n            filename: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n            timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string()\n        })).optional()\n    })\n});\n// Rules configuration types\nconst DeprecatedPatternSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    pattern: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    message: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    alternative: zod__WEBPACK_IMPORTED_MODULE_0__.string()\n});\nconst PackageMinsSchema = zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()));\nconst LanguageRuntimesSchema = zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.string());\nconst QuickFixesSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    dependency_upgrade: zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.string()),\n    pattern_replacement: zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()))\n});\nconst BaselineRulesSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    language_runtimes: LanguageRuntimesSchema,\n    package_mins: PackageMinsSchema,\n    deprecated_patterns: zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.array(DeprecatedPatternSchema)),\n    scan_file_exts: zod__WEBPACK_IMPORTED_MODULE_0__.array(zod__WEBPACK_IMPORTED_MODULE_0__.string()),\n    ignore_paths: zod__WEBPACK_IMPORTED_MODULE_0__.array(zod__WEBPACK_IMPORTED_MODULE_0__.string()),\n    max_file_size: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    max_files: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    quick_fixes: QuickFixesSchema\n});\n// API types\nconst AnalyzeResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    analysisId: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    summary: ReportSummarySchema,\n    artifacts: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        jsonUrl: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n        csvUrl: zod__WEBPACK_IMPORTED_MODULE_0__.string()\n    }),\n    report: ReportSchema.optional()\n});\n// Project detection types\nconst ProjectManifestSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    language: LanguageSchema,\n    file: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    dependencies: zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()).optional(),\n    devDependencies: zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()).optional(),\n    peerDependencies: zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()).optional(),\n    optionalDependencies: zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()).optional()\n});\n// File processing types\nconst ExtractedFileSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    path: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    content: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    size: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    language: LanguageSchema.optional()\n});\n// Analysis context types\nconst AnalysisContextSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    rules: BaselineRulesSchema,\n    extractedFiles: zod__WEBPACK_IMPORTED_MODULE_0__.array(ExtractedFileSchema),\n    manifests: zod__WEBPACK_IMPORTED_MODULE_0__.array(ProjectManifestSchema),\n    detectedLanguages: zod__WEBPACK_IMPORTED_MODULE_0__.array(LanguageSchema)\n});\n// Error types\nconst AnalysisErrorSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    code: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    message: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    details: zod__WEBPACK_IMPORTED_MODULE_0__.any().optional()\n});\n// Validation helpers\nfunction validateFinding(finding) {\n    return FindingSchema.parse(finding);\n}\nfunction validateReport(report) {\n    return ReportSchema.parse(report);\n}\nfunction validateBaselineRules(rules) {\n    return BaselineRulesSchema.parse(rules);\n}\nfunction validateAnalyzeResponse(response) {\n    return AnalyzeResponseSchema.parse(response);\n}\n// Type guards\nfunction isDependencyFinding(finding) {\n    return finding.kind === 'dependency';\n}\nfunction isPatternFinding(finding) {\n    return finding.kind === 'pattern';\n}\n// Status helpers\nfunction getStatusIcon(status) {\n    switch(status){\n        case 'ok':\n            return '✅';\n        case 'affected':\n            return '⚠️';\n        case 'unknown':\n            return '❓';\n        default:\n            return '❓';\n    }\n}\nfunction getStatusColor(status) {\n    switch(status){\n        case 'ok':\n            return 'text-green-600';\n        case 'affected':\n            return 'text-yellow-600';\n        case 'unknown':\n            return 'text-gray-600';\n        default:\n            return 'text-gray-600';\n    }\n}\nfunction getStatusBadgeClass(status) {\n    switch(status){\n        case 'ok':\n            return 'bg-green-100 text-green-800';\n        case 'affected':\n            return 'bg-yellow-100 text-yellow-800';\n        case 'unknown':\n            return 'bg-gray-100 text-gray-800';\n        default:\n            return 'bg-gray-100 text-gray-800';\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvYW5hbHlzaXMvYmFzZWxpbmUudHlwZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUV4QixpQkFBaUI7QUFDVixNQUFNQyxpQkFBaUJELHdDQUFNLENBQUM7SUFBQztJQUFVO0lBQVE7SUFBUTtJQUFNO0NBQVMsRUFBRTtBQUdqRixlQUFlO0FBQ1IsTUFBTUcsZUFBZUgsd0NBQU0sQ0FBQztJQUFDO0lBQU07SUFBWTtDQUFVLEVBQUU7QUFHbEUsZ0JBQWdCO0FBQ1QsTUFBTUksMEJBQTBCSix1Q0FBUSxDQUFDO0lBQzlDTSxNQUFNTix3Q0FBUyxDQUFDO0lBQ2hCUSxNQUFNUDtJQUNOUSxXQUFXVCx1Q0FBUTtJQUNuQlcsY0FBY1gsdUNBQVEsR0FBR1ksUUFBUTtJQUNqQ0Msa0JBQWtCYix1Q0FBUSxHQUFHWSxRQUFRO0lBQ3JDRSxRQUFRWDtJQUNSWSxRQUFRZix1Q0FBUTtJQUNoQmdCLE1BQU1oQix1Q0FBUTtJQUNkaUIsVUFBVWpCLHVDQUFRLEdBQUdrQixRQUFRO0FBQy9CLEdBQUc7QUFFSSxNQUFNQyx1QkFBdUJuQix1Q0FBUSxDQUFDO0lBQzNDTSxNQUFNTix3Q0FBUyxDQUFDO0lBQ2hCUSxNQUFNUDtJQUNOZSxNQUFNaEIsdUNBQVE7SUFDZG9CLE1BQU1wQix1Q0FBUTtJQUNkYyxRQUFRZCx3Q0FBUyxDQUFDO0lBQ2xCZSxRQUFRZix3Q0FBTSxDQUFDO1FBQUM7UUFBa0I7UUFBZ0I7UUFBWTtLQUFjO0lBQzVFc0IsT0FBT3RCLHVDQUFRO0lBQ2Z1QixTQUFTdkIsdUNBQVE7SUFDakJpQixVQUFVakIsdUNBQVEsR0FBR2tCLFFBQVE7QUFDL0IsR0FBRztBQUVJLE1BQU1NLGdCQUFnQnhCLG1EQUFvQixDQUFDLFFBQVE7SUFDeERJO0lBQ0FlO0NBQ0QsRUFBRTtBQU1ILGdCQUFnQjtBQUNULE1BQU1PLHdCQUF3QjFCLHVDQUFRLENBQUM7SUFDNUMyQixJQUFJM0IsdUNBQVE7SUFD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Q0Y7QUFFTyxTQUFTb0YsZUFBZXBGLE1BQWM7SUFDM0MsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUNFLE9BQU87SUFDWDtBQUNGO0FBRU8sU0FBU3FGLG9CQUFvQnJGLE1BQWM7SUFDaEQsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUNFLE9BQU87SUFDWDtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxiYXNlbGluZS50eXBlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcblxuLy8gTGFuZ3VhZ2UgdHlwZXNcbmV4cG9ydCBjb25zdCBMYW5ndWFnZVNjaGVtYSA9IHouZW51bShbJ3B5dGhvbicsICdub2RlJywgJ2phdmEnLCAnZ28nLCAnZG90bmV0J10pO1xuZXhwb3J0IHR5cGUgTGFuZ3VhZ2UgPSB6LmluZmVyPHR5cGVvZiBMYW5ndWFnZVNjaGVtYT47XG5cbi8vIFN0YXR1cyB0eXBlc1xuZXhwb3J0IGNvbnN0IFN0YXR1c1NjaGVtYSA9IHouZW51bShbJ29rJywgJ2FmZmVjdGVkJywgJ3Vua25vd24nXSk7XG5leHBvcnQgdHlwZSBTdGF0dXMgPSB6LmluZmVyPHR5cGVvZiBTdGF0dXNTY2hlbWE+O1xuXG4vLyBGaW5kaW5nIHR5cGVzXG5leHBvcnQgY29uc3QgRGVwZW5kZW5jeUZpbmRpbmdTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGtpbmQ6IHoubGl0ZXJhbCgnZGVwZW5kZW5jeScpLFxuICBsYW5nOiBMYW5ndWFnZVNjaGVtYSxcbiAgY29tcG9uZW50OiB6LnN0cmluZygpLFxuICBmb3VuZFZlcnNpb246IHouc3RyaW5nKCkubnVsbGFibGUoKSxcbiAgYmFzZWxpbmVSZXF1aXJlZDogei5zdHJpbmcoKS5udWxsYWJsZSgpLFxuICBzdGF0dXM6IFN0YXR1c1NjaGVtYSxcbiAgcmVhc29uOiB6LnN0cmluZygpLFxuICBmaWxlOiB6LnN0cmluZygpLFxuICBxdWlja0ZpeDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG5cbmV4cG9ydCBjb25zdCBQYXR0ZXJuRmluZGluZ1NjaGVtYSA9IHoub2JqZWN0KHtcbiAga2luZDogei5saXRlcmFsKCdwYXR0ZXJuJyksXG4gIGxhbmc6IExhbmd1YWdlU2NoZW1hLFxuICBmaWxlOiB6LnN0cmluZygpLFxuICBsaW5lOiB6Lm51bWJlcigpLFxuICBzdGF0dXM6IHoubGl0ZXJhbCgnYWZmZWN0ZWQnKSxcbiAgcmVhc29uOiB6LmVudW0oWydkZXByZWNhdGVkLWFwaScsICdjb2RlLXF1YWxpdHknLCAnc2VjdXJpdHknLCAncGVyZm9ybWFuY2UnXSksXG4gIGlzc3VlOiB6LnN0cmluZygpLFxuICBwYXR0ZXJuOiB6LnN0cmluZygpLFxuICBxdWlja0ZpeDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG5cbmV4cG9ydCBjb25zdCBGaW5kaW5nU2NoZW1hID0gei5kaXNjcmltaW5hdGVkVW5pb24oJ2tpbmQnLCBbXG4gIERlcGVuZGVuY3lGaW5kaW5nU2NoZW1hLFxuICBQYXR0ZXJuRmluZGluZ1NjaGVtYSxcbl0pO1xuXG5leHBvcnQgdHlwZSBEZXBlbmRlbmN5RmluZGluZyA9IHouaW5mZXI8dHlwZW9mIERlcGVuZGVuY3lGaW5kaW5nU2NoZW1hPjtcbmV4cG9ydCB0eXBlIFBhdHRlcm5GaW5kaW5nID0gei5pbmZlcjx0eXBlb2YgUGF0dGVybkZpbmRpbmdTY2hlbWE+O1xuZXhwb3J0IHR5cGUgRmluZGluZyA9IHouaW5mZXI8dHlwZW9mIEZpbmRpbmdTY2hlbWE+O1xuXG4vLyBTdW1tYXJ5IHR5cGVzXG5leHBvcnQgY29uc3QgTGFuZ3VhZ2VTdW1tYXJ5U2NoZW1hID0gei5vYmplY3Qoe1xuICBvazogei5udW1iZXIoKSxcbiAgYWZmZWN0ZWQ6IHoubnVtYmVyKCksXG4gIHVua25vd246IHoubnVtYmVyKCksXG59KTtcblxuZXhwb3J0IGNvbnN0IFJlcG9ydFN1bW1hcnlTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIG9rOiB6Lm51bWJlcigpLFxuICBhZmZlY3RlZDogei5udW1iZXIoKSxcbiAgdW5rbm93bjogei5udW1iZXIoKSxcbiAgYnlMYW5ndWFnZTogei5yZWNvcmQoTGFuZ3VhZ2VTY2hlbWEsIExhbmd1YWdlU3VtbWFyeVNjaGVtYSksXG59KTtcblxuLy8gUmVwb3J0IHR5cGVcbmV4cG9ydCBjb25zdCBSZXBvcnRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGZpbmRpbmdzOiB6LmFycmF5KEZpbmRpbmdTY2hlbWEpLFxuICBzdW1tYXJ5OiBSZXBvcnRTdW1tYXJ5U2NoZW1hLFxuICBtZXRhZGF0YTogei5vYmplY3Qoe1xuICAgIGFuYWx5c2lzSWQ6IHouc3RyaW5nKCksXG4gICAgdGltZXN0YW1wOiB6LnN0cmluZygpLFxuICAgIHByb2plY3ROYW1lOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgZGV0ZWN0ZWRMYW5ndWFnZXM6IHouYXJyYXkoTGFuZ3VhZ2VTY2hlbWEpLFxuICAgIHRvdGFsRmlsZXM6IHoubnVtYmVyKCksXG4gICAgc2Nhbm5lZEZpbGVzOiB6Lm51bWJlcigpLFxuICAgIHNraXBwZWRGaWxlczogei5udW1iZXIoKSxcbiAgICBncm9xQW5hbHlzaXM6IHouYXJyYXkoei5vYmplY3Qoe1xuICAgICAgYW5hbHlzaXM6IHouc3RyaW5nKCksXG4gICAgICBmaWxlbmFtZTogei5zdHJpbmcoKSxcbiAgICAgIHRpbWVzdGFtcDogei5zdHJpbmcoKSxcbiAgICB9KSkub3B0aW9uYWwoKSxcbiAgfSksXG59KTtcblxuZXhwb3J0IHR5cGUgTGFuZ3VhZ2VTdW1tYXJ5ID0gei5pbmZlcjx0eXBlb2YgTGFuZ3VhZ2VTdW1tYXJ5U2NoZW1hPjtcbmV4cG9ydCB0eXBlIFJlcG9ydFN1bW1hcnkgPSB6LmluZmVyPHR5cGVvZiBSZXBvcnRTdW1tYXJ5U2NoZW1hPjtcbmV4cG9ydCB0eXBlIFJlcG9ydCA9IHouaW5mZXI8dHlwZW9mIFJlcG9ydFNjaGVtYT47XG5cbi8vIFJ1bGVzIGNvbmZpZ3VyYXRpb24gdHlwZXNcbmV4cG9ydCBjb25zdCBEZXByZWNhdGVkUGF0dGVyblNjaGVtYSA9IHoub2JqZWN0KHtcbiAgcGF0dGVybjogei5zdHJpbmcoKSxcbiAgbWVzc2FnZTogei5zdHJpbmcoKSxcbiAgYWx0ZXJuYXRpdmU6IHouc3RyaW5nKCksXG59KTtcblxuZXhwb3J0IGNvbnN0IFBhY2thZ2VNaW5zU2NoZW1hID0gei5yZWNvcmQoTGFuZ3VhZ2VTY2hlbWEsIHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpKTtcblxuZXhwb3J0IGNvbnN0IExhbmd1YWdlUnVudGltZXNTY2hlbWEgPSB6LnJlY29yZChMYW5ndWFnZVNjaGVtYSwgei5zdHJpbmcoKSk7XG5cbmV4cG9ydCBjb25zdCBRdWlja0ZpeGVzU2NoZW1hID0gei5vYmplY3Qoe1xuICBkZXBlbmRlbmN5X3VwZ3JhZGU6IHoucmVjb3JkKExhbmd1YWdlU2NoZW1hLCB6LnN0cmluZygpKSxcbiAgcGF0dGVybl9yZXBsYWNlbWVudDogei5yZWNvcmQoTGFuZ3VhZ2VTY2hlbWEsIHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpKSxcbn0pO1xuXG5leHBvcnQgY29uc3QgQmFzZWxpbmVSdWxlc1NjaGVtYSA9IHoub2JqZWN0KHtcbiAgbGFuZ3VhZ2VfcnVudGltZXM6IExhbmd1YWdlUnVudGltZXNTY2hlbWEsXG4gIHBhY2thZ2VfbWluczogUGFja2FnZU1pbnNTY2hlbWEsXG4gIGRlcHJlY2F0ZWRfcGF0dGVybnM6IHoucmVjb3JkKExhbmd1YWdlU2NoZW1hLCB6LmFycmF5KERlcHJlY2F0ZWRQYXR0ZXJuU2NoZW1hKSksXG4gIHNjYW5fZmlsZV9leHRzOiB6LmFycmF5KHouc3RyaW5nKCkpLFxuICBpZ25vcmVfcGF0aHM6IHouYXJyYXkoei5zdHJpbmcoKSksXG4gIG1heF9maWxlX3NpemU6IHoubnVtYmVyKCksXG4gIG1heF9maWxlczogei5udW1iZXIoKSxcbiAgcXVpY2tfZml4ZXM6IFF1aWNrRml4ZXNTY2hlbWEsXG59KTtcblxuZXhwb3J0IHR5cGUgRGVwcmVjYXRlZFBhdHRlcm4gPSB6LmluZmVyPHR5cGVvZiBEZXByZWNhdGVkUGF0dGVyblNjaGVtYT47XG5leHBvcnQgdHlwZSBQYWNrYWdlTWlucyA9IHouaW5mZXI8dHlwZW9mIFBhY2thZ2VNaW5zU2NoZW1hPjtcbmV4cG9ydCB0eXBlIExhbmd1YWdlUnVudGltZXMgPSB6LmluZmVyPHR5cGVvZiBMYW5ndWFnZVJ1bnRpbWVzU2NoZW1hPjtcbmV4cG9ydCB0eXBlIFF1aWNrRml4ZXMgPSB6LmluZmVyPHR5cGVvZiBRdWlja0ZpeGVzU2NoZW1hPjtcbmV4cG9ydCB0eXBlIEJhc2VsaW5lUnVsZXMgPSB6LmluZmVyPHR5cGVvZiBCYXNlbGluZVJ1bGVzU2NoZW1hPjtcblxuLy8gQVBJIHR5cGVzXG5leHBvcnQgY29uc3QgQW5hbHl6ZVJlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xuICBhbmFseXNpc0lkOiB6LnN0cmluZygpLFxuICBzdW1tYXJ5OiBSZXBvcnRTdW1tYXJ5U2NoZW1hLFxuICBhcnRpZmFjdHM6IHoub2JqZWN0KHtcbiAgICBqc29uVXJsOiB6LnN0cmluZygpLFxuICAgIGNzdlVybDogei5zdHJpbmcoKSxcbiAgfSksXG4gIHJlcG9ydDogUmVwb3J0U2NoZW1hLm9wdGlvbmFsKCksXG59KTtcblxuZXhwb3J0IHR5cGUgQW5hbHl6ZVJlc3BvbnNlID0gei5pbmZlcjx0eXBlb2YgQW5hbHl6ZVJlc3BvbnNlU2NoZW1hPjtcblxuLy8gUHJvamVjdCBkZXRlY3Rpb24gdHlwZXNcbmV4cG9ydCBjb25zdCBQcm9qZWN0TWFuaWZlc3RTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGxhbmd1YWdlOiBMYW5ndWFnZVNjaGVtYSxcbiAgZmlsZTogei5zdHJpbmcoKSxcbiAgZGVwZW5kZW5jaWVzOiB6LnJlY29yZCh6LnN0cmluZygpLCB6LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICBkZXZEZXBlbmRlbmNpZXM6IHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gIHBlZXJEZXBlbmRlbmNpZXM6IHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gIG9wdGlvbmFsRGVwZW5kZW5jaWVzOiB6LnJlY29yZCh6LnN0cmluZygpLCB6LnN0cmluZygpKS5vcHRpb25hbCgpLFxufSk7XG5cbmV4cG9ydCB0eXBlIFByb2plY3RNYW5pZmVzdCA9IHouaW5mZXI8dHlwZW9mIFByb2plY3RNYW5pZmVzdFNjaGVtYT47XG5cbi8vIEZpbGUgcHJvY2Vzc2luZyB0eXBlc1xuZXhwb3J0IGNvbnN0IEV4dHJhY3RlZEZpbGVTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHBhdGg6IHouc3RyaW5nKCksXG4gIGNvbnRlbnQ6IHouc3RyaW5nKCksXG4gIHNpemU6IHoubnVtYmVyKCksXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVNjaGVtYS5vcHRpb25hbCgpLFxufSk7XG5cbmV4cG9ydCB0eXBlIEV4dHJhY3RlZEZpbGUgPSB6LmluZmVyPHR5cGVvZiBFeHRyYWN0ZWRGaWxlU2NoZW1hPjtcblxuLy8gQW5hbHlzaXMgY29udGV4dCB0eXBlc1xuZXhwb3J0IGNvbnN0IEFuYWx5c2lzQ29udGV4dFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNTY2hlbWEsXG4gIGV4dHJhY3RlZEZpbGVzOiB6LmFycmF5KEV4dHJhY3RlZEZpbGVTY2hlbWEpLFxuICBtYW5pZmVzdHM6IHouYXJyYXkoUHJvamVjdE1hbmlmZXN0U2NoZW1hKSxcbiAgZGV0ZWN0ZWRMYW5ndWFnZXM6IHouYXJyYXkoTGFuZ3VhZ2VTY2hlbWEpLFxufSk7XG5cbmV4cG9ydCB0eXBlIEFuYWx5c2lzQ29udGV4dCA9IHouaW5mZXI8dHlwZW9mIEFuYWx5c2lzQ29udGV4dFNjaGVtYT47XG5cbi8vIEVycm9yIHR5cGVzXG5leHBvcnQgY29uc3QgQW5hbHlzaXNFcnJvclNjaGVtYSA9IHoub2JqZWN0KHtcbiAgY29kZTogei5zdHJpbmcoKSxcbiAgbWVzc2FnZTogei5zdHJpbmcoKSxcbiAgZGV0YWlsczogei5hbnkoKS5vcHRpb25hbCgpLFxufSk7XG5cbmV4cG9ydCB0eXBlIEFuYWx5c2lzRXJyb3IgPSB6LmluZmVyPHR5cGVvZiBBbmFseXNpc0Vycm9yU2NoZW1hPjtcblxuLy8gVXRpbGl0eSB0eXBlcyBmb3IgVUlcbmV4cG9ydCBpbnRlcmZhY2UgRmlsdGVyT3B0aW9ucyB7XG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2U7XG4gIHN0YXR1cz86IFN0YXR1cztcbiAgc2VhcmNoVGV4dD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb3J0T3B0aW9ucyB7XG4gIGZpZWxkOiAnY29tcG9uZW50JyB8ICdmaWxlJyB8ICdzdGF0dXMnIHwgJ3JlYXNvbic7XG4gIGRpcmVjdGlvbjogJ2FzYycgfCAnZGVzYyc7XG59XG5cbi8vIENTViBleHBvcnQgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgQ1NWUm93IHtcbiAgS2luZDogc3RyaW5nO1xuICBMYW5ndWFnZTogc3RyaW5nO1xuICBDb21wb25lbnQ6IHN0cmluZztcbiAgRmlsZTogc3RyaW5nO1xuICBMaW5lOiBzdHJpbmc7XG4gIFN0YXR1czogc3RyaW5nO1xuICBSZWFzb246IHN0cmluZztcbiAgJ1F1aWNrIEZpeCc6IHN0cmluZztcbiAgJ0ZvdW5kIFZlcnNpb24nOiBzdHJpbmc7XG4gICdSZXF1aXJlZCBWZXJzaW9uJzogc3RyaW5nO1xufVxuXG4vLyBWYWxpZGF0aW9uIGhlbHBlcnNcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpbmRpbmcoZmluZGluZzogdW5rbm93bik6IEZpbmRpbmcge1xuICByZXR1cm4gRmluZGluZ1NjaGVtYS5wYXJzZShmaW5kaW5nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVwb3J0KHJlcG9ydDogdW5rbm93bik6IFJlcG9ydCB7XG4gIHJldHVybiBSZXBvcnRTY2hlbWEucGFyc2UocmVwb3J0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzZWxpbmVSdWxlcyhydWxlczogdW5rbm93bik6IEJhc2VsaW5lUnVsZXMge1xuICByZXR1cm4gQmFzZWxpbmVSdWxlc1NjaGVtYS5wYXJzZShydWxlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFuYWx5emVSZXNwb25zZShyZXNwb25zZTogdW5rbm93bik6IEFuYWx5emVSZXNwb25zZSB7XG4gIHJldHVybiBBbmFseXplUmVzcG9uc2VTY2hlbWEucGFyc2UocmVzcG9uc2UpO1xufVxuXG4vLyBUeXBlIGd1YXJkc1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVwZW5kZW5jeUZpbmRpbmcoZmluZGluZzogRmluZGluZyk6IGZpbmRpbmcgaXMgRGVwZW5kZW5jeUZpbmRpbmcge1xuICByZXR1cm4gZmluZGluZy5raW5kID09PSAnZGVwZW5kZW5jeSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdHRlcm5GaW5kaW5nKGZpbmRpbmc6IEZpbmRpbmcpOiBmaW5kaW5nIGlzIFBhdHRlcm5GaW5kaW5nIHtcbiAgcmV0dXJuIGZpbmRpbmcua2luZCA9PT0gJ3BhdHRlcm4nO1xufVxuXG4vLyBTdGF0dXMgaGVscGVyc1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXR1c0ljb24oc3RhdHVzOiBTdGF0dXMpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgJ29rJzpcbiAgICAgIHJldHVybiAn4pyFJztcbiAgICBjYXNlICdhZmZlY3RlZCc6XG4gICAgICByZXR1cm4gJ+KaoO+4jyc7XG4gICAgY2FzZSAndW5rbm93bic6XG4gICAgICByZXR1cm4gJ+Kdkyc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAn4p2TJztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdHVzQ29sb3Ioc3RhdHVzOiBTdGF0dXMpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgJ29rJzpcbiAgICAgIHJldHVybiAndGV4dC1ncmVlbi02MDAnO1xuICAgIGNhc2UgJ2FmZmVjdGVkJzpcbiAgICAgIHJldHVybiAndGV4dC15ZWxsb3ctNjAwJztcbiAgICBjYXNlICd1bmtub3duJzpcbiAgICAgIHJldHVybiAndGV4dC1ncmF5LTYwMCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAndGV4dC1ncmF5LTYwMCc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXR1c0JhZGdlQ2xhc3Moc3RhdHVzOiBTdGF0dXMpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgJ29rJzpcbiAgICAgIHJldHVybiAnYmctZ3JlZW4tMTAwIHRleHQtZ3JlZW4tODAwJztcbiAgICBjYXNlICdhZmZlY3RlZCc6XG4gICAgICByZXR1cm4gJ2JnLXllbGxvdy0xMDAgdGV4dC15ZWxsb3ctODAwJztcbiAgICBjYXNlICd1bmtub3duJzpcbiAgICAgIHJldHVybiAnYmctZ3JheS0xMDAgdGV4dC1ncmF5LTgwMCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnYmctZ3JheS0xMDAgdGV4dC1ncmF5LTgwMCc7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ6IiwiTGFuZ3VhZ2VTY2hlbWEiLCJlbnVtIiwiU3RhdHVzU2NoZW1hIiwiRGVwZW5kZW5jeUZpbmRpbmdTY2hlbWEiLCJvYmplY3QiLCJraW5kIiwibGl0ZXJhbCIsImxhbmciLCJjb21wb25lbnQiLCJzdHJpbmciLCJmb3VuZFZlcnNpb24iLCJudWxsYWJsZSIsImJhc2VsaW5lUmVxdWlyZWQiLCJzdGF0dXMiLCJyZWFzb24iLCJmaWxlIiwicXVpY2tGaXgiLCJvcHRpb25hbCIsIlBhdHRlcm5GaW5kaW5nU2NoZW1hIiwibGluZSIsIm51bWJlciIsImlzc3VlIiwicGF0dGVybiIsIkZpbmRpbmdTY2hlbWEiLCJkaXNjcmltaW5hdGVkVW5pb24iLCJMYW5ndWFnZVN1bW1hcnlTY2hlbWEiLCJvayIsImFmZmVjdGVkIiwidW5rbm93biIsIlJlcG9ydFN1bW1hcnlTY2hlbWEiLCJieUxhbmd1YWdlIiwicmVjb3JkIiwiUmVwb3J0U2NoZW1hIiwiZmluZGluZ3MiLCJhcnJheSIsInN1bW1hcnkiLCJtZXRhZGF0YSIsImFuYWx5c2lzSWQiLCJ0aW1lc3RhbXAiLCJwcm9qZWN0TmFtZSIsImRldGVjdGVkTGFuZ3VhZ2VzIiwidG90YWxGaWxlcyIsInNjYW5uZWRGaWxlcyIsInNraXBwZWRGaWxlcyIsImdyb3FBbmFseXNpcyIsImFuYWx5c2lzIiwiZmlsZW5hbWUiLCJEZXByZWNhdGVkUGF0dGVyblNjaGVtYSIsIm1lc3NhZ2UiLCJhbHRlcm5hdGl2ZSIsIlBhY2thZ2VNaW5zU2NoZW1hIiwiTGFuZ3VhZ2VSdW50aW1lc1NjaGVtYSIsIlF1aWNrRml4ZXNTY2hlbWEiLCJkZXBlbmRlbmN5X3VwZ3JhZGUiLCJwYXR0ZXJuX3JlcGxhY2VtZW50IiwiQmFzZWxpbmVSdWxlc1NjaGVtYSIsImxhbmd1YWdlX3J1bnRpbWVzIiwicGFja2FnZV9taW5zIiwiZGVwcmVjYXRlZF9wYXR0ZXJucyIsInNjYW5fZmlsZV9leHRzIiwiaWdub3JlX3BhdGhzIiwibWF4X2ZpbGVfc2l6ZSIsIm1heF9maWxlcyIsInF1aWNrX2ZpeGVzIiwiQW5hbHl6ZVJlc3BvbnNlU2NoZW1hIiwiYXJ0aWZhY3RzIiwianNvblVybCIsImNzdlVybCIsInJlcG9ydCIsIlByb2plY3RNYW5pZmVzdFNjaGVtYSIsImxhbmd1YWdlIiwiZGVwZW5kZW5jaWVzIiwiZGV2RGVwZW5kZW5jaWVzIiwicGVlckRlcGVuZGVuY2llcyIsIm9wdGlvbmFsRGVwZW5kZW5jaWVzIiwiRXh0cmFjdGVkRmlsZVNjaGVtYSIsInBhdGgiLCJjb250ZW50Iiwic2l6ZSIsIkFuYWx5c2lzQ29udGV4dFNjaGVtYSIsInJ1bGVzIiwiZXh0cmFjdGVkRmlsZXMiLCJtYW5pZmVzdHMiLCJBbmFseXNpc0Vycm9yU2NoZW1hIiwiY29kZSIsImRldGFpbHMiLCJhbnkiLCJ2YWxpZGF0ZUZpbmRpbmciLCJmaW5kaW5nIiwicGFyc2UiLCJ2YWxpZGF0ZVJlcG9ydCIsInZhbGlkYXRlQmFzZWxpbmVSdWxlcyIsInZhbGlkYXRlQW5hbHl6ZVJlc3BvbnNlIiwicmVzcG9uc2UiLCJpc0RlcGVuZGVuY3lGaW5kaW5nIiwiaXNQYXR0ZXJuRmluZGluZyIsImdldFN0YXR1c0ljb24iLCJnZXRTdGF0dXNDb2xvciIsImdldFN0YXR1c0JhZGdlQ2xhc3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/baseline.types.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/compare.ts":
/*!*********************************!*\
  !*** ./lib/analysis/compare.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareVersions: () => (/* binding */ compareVersions),\n/* harmony export */   getLatestStableVersion: () => (/* binding */ getLatestStableVersion),\n/* harmony export */   getVersionDifference: () => (/* binding */ getVersionDifference),\n/* harmony export */   isPreRelease: () => (/* binding */ isPreRelease),\n/* harmony export */   parseVersion: () => (/* binding */ parseVersion),\n/* harmony export */   satisfiesRequirement: () => (/* binding */ satisfiesRequirement)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\r\n * Compare two version strings\r\n * @param version1 First version\r\n * @param version2 Second version (baseline)\r\n * @param language Language context for parsing\r\n * @returns Comparison result\r\n */ function compareVersions(version1, version2, language) {\n    try {\n        const v1 = parseVersion(version1, language);\n        const v2 = parseVersion(version2, language);\n        if (!v1 || !v2) {\n            return 'unknown';\n        }\n        // Use semver for Node.js packages\n        if (language === 'node') {\n            return compareWithSemver(v1, v2);\n        }\n        // Use custom comparison for other languages\n        return compareVersionsCustom(v1, v2, language);\n    } catch (error) {\n        console.warn(`Version comparison failed: ${error}`);\n        return 'unknown';\n    }\n}\n/**\r\n * Compare versions using semver (for Node.js)\r\n * @param version1 First version\r\n * @param version2 Second version\r\n * @returns Comparison result\r\n */ function compareWithSemver(version1, version2) {\n    try {\n        // Clean versions for semver\n        const v1 = cleanVersionForSemver(version1);\n        const v2 = cleanVersionForSemver(version2);\n        if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(v1) || !semver__WEBPACK_IMPORTED_MODULE_0___default().valid(v2)) {\n            return 'unknown';\n        }\n        const result = semver__WEBPACK_IMPORTED_MODULE_0___default().compare(v1, v2);\n        if (result > 0) return 'greater';\n        if (result < 0) return 'less';\n        return 'equal';\n    } catch  {\n        return 'unknown';\n    }\n}\n/**\r\n * Clean version string for semver parsing\r\n * @param version Version string\r\n * @returns Cleaned version\r\n */ function cleanVersionForSemver(version) {\n    // Remove common prefixes and suffixes\n    let cleaned = version.replace(/^v/, '') // Remove v prefix\n    .replace(/^[~^>=<!=]+/, '') // Remove operators\n    .trim();\n    // Handle pre-release versions\n    if (cleaned.includes('-')) {\n        const parts = cleaned.split('-');\n        cleaned = parts[0];\n    }\n    // Handle build metadata\n    if (cleaned.includes('+')) {\n        const parts = cleaned.split('+');\n        cleaned = parts[0];\n    }\n    return cleaned;\n}\n/**\r\n * Custom version comparison for non-Node.js languages\r\n * @param version1 First version\r\n * @param version2 Second version\r\n * @param language Language context\r\n * @returns Comparison result\r\n */ function compareVersionsCustom(version1, version2, language) {\n    try {\n        const v1Parts = parseVersionParts(version1, language);\n        const v2Parts = parseVersionParts(version2, language);\n        if (!v1Parts || !v2Parts) {\n            return 'unknown';\n        }\n        // Compare major, minor, patch\n        for(let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++){\n            const v1Part = v1Parts[i] || 0;\n            const v2Part = v2Parts[i] || 0;\n            if (v1Part > v2Part) return 'greater';\n            if (v1Part < v2Part) return 'less';\n        }\n        return 'equal';\n    } catch  {\n        return 'unknown';\n    }\n}\n/**\r\n * Parse version into numeric parts\r\n * @param version Version string\r\n * @param language Language context\r\n * @returns Array of numeric parts\r\n */ function parseVersionParts(version, language) {\n    try {\n        // Clean version\n        let cleaned = version.replace(/^v/, '').replace(/^[~^>=<!=]+/, '').trim();\n        // Handle different version formats\n        if (language === 'python') {\n            // Python: 1.2.3, 1.2, 1.2.3a1, 1.2.3b1, 1.2.3rc1\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        } else if (language === 'java') {\n            // Java: 1.8.0, 11, 17.0.1\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        } else if (language === 'go') {\n            // Go: v1.21.0, 1.21.0\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        } else if (language === 'dotnet') {\n            // .NET: 6.0.0, 7.0.0-preview.1\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        }\n        // Split by dots and convert to numbers\n        const parts = cleaned.split('.').map((part)=>{\n            const num = parseInt(part, 10);\n            return isNaN(num) ? 0 : num;\n        });\n        return parts.length > 0 ? parts : null;\n    } catch  {\n        return null;\n    }\n}\n/**\r\n * Parse version string and extract version number\r\n * @param versionString Version string (may contain operators)\r\n * @param language Language context\r\n * @returns Clean version string\r\n */ function parseVersion(versionString, language) {\n    if (!versionString || versionString === '*') {\n        return '0.0.0';\n    }\n    // Remove common operators and prefixes\n    let clean = versionString.replace(/^[~^>=<!=]+/, '') // Remove operators\n    .replace(/^v/, '') // Remove v prefix\n    .trim();\n    // Handle special cases\n    if (clean === 'latest' || clean === '') {\n        return '0.0.0';\n    }\n    // Handle Python version specifiers\n    if (language === 'python') {\n        // Remove Python-specific operators\n        clean = clean.replace(/^[~=!<>]+/, '');\n    }\n    // Handle Go version suffixes\n    if (language === 'go') {\n        // Remove +incompatible, +incompatible.20210101, etc.\n        clean = clean.replace(/\\+.*$/, '');\n    }\n    // Handle Java version ranges\n    if (language === 'java') {\n        // Extract version from ranges like [1.0,2.0) or (1.0,2.0]\n        const rangeMatch = clean.match(/[[(]([^,]+),/);\n        if (rangeMatch) {\n            clean = rangeMatch[1];\n        }\n    }\n    return clean;\n}\n/**\r\n * Check if a version satisfies a requirement\r\n * @param version Version to check\r\n * @param requirement Requirement (e.g., \">=1.0.0\", \"~1.2.3\")\r\n * @param language Language context\r\n * @returns True if version satisfies requirement\r\n */ function satisfiesRequirement(version, requirement, language) {\n    try {\n        if (language === 'node') {\n            // Use semver for Node.js\n            const cleanVersion = cleanVersionForSemver(version);\n            if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(cleanVersion)) return false;\n            return semver__WEBPACK_IMPORTED_MODULE_0___default().satisfies(cleanVersion, requirement);\n        }\n        // Custom logic for other languages\n        return satisfiesRequirementCustom(version, requirement, language);\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Custom requirement satisfaction check\r\n * @param version Version to check\r\n * @param requirement Requirement\r\n * @param language Language context\r\n * @returns True if version satisfies requirement\r\n */ function satisfiesRequirementCustom(version, requirement, language) {\n    try {\n        const cleanVersion = parseVersion(version, language);\n        const cleanRequirement = parseVersion(requirement, language);\n        if (!cleanVersion || !cleanRequirement) return false;\n        // Extract operator from requirement\n        const operatorMatch = requirement.match(/^([~^>=<!=]+)/);\n        const operator = operatorMatch ? operatorMatch[1] : '>=';\n        const comparison = compareVersions(cleanVersion, cleanRequirement, language);\n        switch(operator){\n            case '>=':\n                return comparison === 'greater' || comparison === 'equal';\n            case '>':\n                return comparison === 'greater';\n            case '<=':\n                return comparison === 'less' || comparison === 'equal';\n            case '<':\n                return comparison === 'less';\n            case '=':\n            case '==':\n                return comparison === 'equal';\n            case '~':\n                // Tilde: allow patch-level changes\n                return satisfiesTilde(cleanVersion, cleanRequirement, language);\n            case '^':\n                // Caret: allow minor-level changes\n                return satisfiesCaret(cleanVersion, cleanRequirement, language);\n            default:\n                return comparison === 'equal';\n        }\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Check if version satisfies tilde requirement\r\n * @param version Version to check\r\n * @param requirement Requirement\r\n * @param language Language context\r\n * @returns True if satisfies\r\n */ function satisfiesTilde(version, requirement, language) {\n    const vParts = parseVersionParts(version, language);\n    const rParts = parseVersionParts(requirement, language);\n    if (!vParts || !rParts) return false;\n    // Major and minor must match, patch can be higher\n    if (vParts[0] !== rParts[0]) return false;\n    if (vParts[1] !== rParts[1]) return false;\n    return vParts[2] >= (rParts[2] || 0);\n}\n/**\r\n * Check if version satisfies caret requirement\r\n * @param version Version to check\r\n * @param requirement Requirement\r\n * @param language Language context\r\n * @returns True if satisfies\r\n */ function satisfiesCaret(version, requirement, language) {\n    const vParts = parseVersionParts(version, language);\n    const rParts = parseVersionParts(requirement, language);\n    if (!vParts || !rParts) return false;\n    // Major must match, minor and patch can be higher\n    if (vParts[0] !== rParts[0]) return false;\n    return vParts[1] > (rParts[1] || 0) || vParts[1] === (rParts[1] || 0) && vParts[2] >= (rParts[2] || 0);\n}\n/**\r\n * Get version difference description\r\n * @param version1 First version\r\n * @param version2 Second version\r\n * @param language Language context\r\n * @returns Description of difference\r\n */ function getVersionDifference(version1, version2, language) {\n    const comparison = compareVersions(version1, version2, language);\n    switch(comparison){\n        case 'greater':\n            return `${version1} is newer than ${version2}`;\n        case 'less':\n            return `${version1} is older than ${version2}`;\n        case 'equal':\n            return `${version1} matches ${version2}`;\n        case 'unknown':\n            return `Cannot compare ${version1} with ${version2}`;\n        default:\n            return 'Unknown comparison';\n    }\n}\n/**\r\n * Check if a version is a pre-release\r\n * @param version Version string\r\n * @param language Language context\r\n * @returns True if pre-release\r\n */ function isPreRelease(version, language) {\n    const clean = parseVersion(version, language);\n    // Check for common pre-release indicators\n    return /[a-zA-Z]/.test(clean) || clean.includes('-') || clean.includes('alpha') || clean.includes('beta') || clean.includes('rc') || clean.includes('preview');\n}\n/**\r\n * Get the latest stable version from a list\r\n * @param versions Array of version strings\r\n * @param language Language context\r\n * @returns Latest stable version or null\r\n */ function getLatestStableVersion(versions, language) {\n    const stableVersions = versions.filter((v)=>!isPreRelease(v, language));\n    if (stableVersions.length === 0) return null;\n    let latest = stableVersions[0];\n    for (const version of stableVersions){\n        if (compareVersions(version, latest, language) === 'greater') {\n            latest = version;\n        }\n    }\n    return latest;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWtCLEVBQ2xCdkQsUUFBa0I7SUFFbEIsTUFBTXdELGlCQUFpQkQsU0FBU0UsTUFBTSxDQUFDQyxDQUFBQSxJQUFLLENBQUNOLGFBQWFNLEdBQUcxRDtJQUU3RCxJQUFJd0QsZUFBZTlCLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFFeEMsSUFBSWlDLFNBQVNILGNBQWMsQ0FBQyxFQUFFO0lBRTlCLEtBQUssTUFBTTNDLFdBQVcyQyxlQUFnQjtRQUNwQyxJQUFJM0QsZ0JBQWdCZ0IsU0FBUzhDLFFBQVEzRCxjQUFjLFdBQVc7WUFDNUQyRCxTQUFTOUM7UUFDWDtJQUNGO0lBRUEsT0FBTzhDO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcYW5hbHlzaXNcXGNvbXBhcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xyXG5pbXBvcnQgeyBMYW5ndWFnZSB9IGZyb20gJy4vYmFzZWxpbmUudHlwZXMnO1xyXG5cclxuZXhwb3J0IHR5cGUgQ29tcGFyaXNvblJlc3VsdCA9ICdncmVhdGVyJyB8ICdlcXVhbCcgfCAnbGVzcycgfCAndW5rbm93bic7XHJcblxyXG4vKipcclxuICogQ29tcGFyZSB0d28gdmVyc2lvbiBzdHJpbmdzXHJcbiAqIEBwYXJhbSB2ZXJzaW9uMSBGaXJzdCB2ZXJzaW9uXHJcbiAqIEBwYXJhbSB2ZXJzaW9uMiBTZWNvbmQgdmVyc2lvbiAoYmFzZWxpbmUpXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0IGZvciBwYXJzaW5nXHJcbiAqIEByZXR1cm5zIENvbXBhcmlzb24gcmVzdWx0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVZlcnNpb25zKFxyXG4gIHZlcnNpb24xOiBzdHJpbmcsXHJcbiAgdmVyc2lvbjI6IHN0cmluZyxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2VcclxuKTogQ29tcGFyaXNvblJlc3VsdCB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHYxID0gcGFyc2VWZXJzaW9uKHZlcnNpb24xLCBsYW5ndWFnZSk7XHJcbiAgICBjb25zdCB2MiA9IHBhcnNlVmVyc2lvbih2ZXJzaW9uMiwgbGFuZ3VhZ2UpO1xyXG4gICAgXHJcbiAgICBpZiAoIXYxIHx8ICF2Mikge1xyXG4gICAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBVc2Ugc2VtdmVyIGZvciBOb2RlLmpzIHBhY2thZ2VzXHJcbiAgICBpZiAobGFuZ3VhZ2UgPT09ICdub2RlJykge1xyXG4gICAgICByZXR1cm4gY29tcGFyZVdpdGhTZW12ZXIodjEsIHYyKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVXNlIGN1c3RvbSBjb21wYXJpc29uIGZvciBvdGhlciBsYW5ndWFnZXNcclxuICAgIHJldHVybiBjb21wYXJlVmVyc2lvbnNDdXN0b20odjEsIHYyLCBsYW5ndWFnZSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybihgVmVyc2lvbiBjb21wYXJpc29uIGZhaWxlZDogJHtlcnJvcn1gKTtcclxuICAgIHJldHVybiAndW5rbm93bic7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29tcGFyZSB2ZXJzaW9ucyB1c2luZyBzZW12ZXIgKGZvciBOb2RlLmpzKVxyXG4gKiBAcGFyYW0gdmVyc2lvbjEgRmlyc3QgdmVyc2lvblxyXG4gKiBAcGFyYW0gdmVyc2lvbjIgU2Vjb25kIHZlcnNpb25cclxuICogQHJldHVybnMgQ29tcGFyaXNvbiByZXN1bHRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVXaXRoU2VtdmVyKHZlcnNpb24xOiBzdHJpbmcsIHZlcnNpb24yOiBzdHJpbmcpOiBDb21wYXJpc29uUmVzdWx0IHtcclxuICB0cnkge1xyXG4gICAgLy8gQ2xlYW4gdmVyc2lvbnMgZm9yIHNlbXZlclxyXG4gICAgY29uc3QgdjEgPSBjbGVhblZlcnNpb25Gb3JTZW12ZXIodmVyc2lvbjEpO1xyXG4gICAgY29uc3QgdjIgPSBjbGVhblZlcnNpb25Gb3JTZW12ZXIodmVyc2lvbjIpO1xyXG4gICAgXHJcbiAgICBpZiAoIXNlbXZlci52YWxpZCh2MSkgfHwgIXNlbXZlci52YWxpZCh2MikpIHtcclxuICAgICAgcmV0dXJuICd1bmtub3duJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgcmVzdWx0ID0gc2VtdmVyLmNvbXBhcmUodjEsIHYyKTtcclxuICAgIFxyXG4gICAgaWYgKHJlc3VsdCA+IDApIHJldHVybiAnZ3JlYXRlcic7XHJcbiAgICBpZiAocmVzdWx0IDwgMCkgcmV0dXJuICdsZXNzJztcclxuICAgIHJldHVybiAnZXF1YWwnO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuICd1bmtub3duJztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhbiB2ZXJzaW9uIHN0cmluZyBmb3Igc2VtdmVyIHBhcnNpbmdcclxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiBzdHJpbmdcclxuICogQHJldHVybnMgQ2xlYW5lZCB2ZXJzaW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGVhblZlcnNpb25Gb3JTZW12ZXIodmVyc2lvbjogc3RyaW5nKTogc3RyaW5nIHtcclxuICAvLyBSZW1vdmUgY29tbW9uIHByZWZpeGVzIGFuZCBzdWZmaXhlc1xyXG4gIGxldCBjbGVhbmVkID0gdmVyc2lvblxyXG4gICAgLnJlcGxhY2UoL152LywgJycpIC8vIFJlbW92ZSB2IHByZWZpeFxyXG4gICAgLnJlcGxhY2UoL15bfl4+PTwhPV0rLywgJycpIC8vIFJlbW92ZSBvcGVyYXRvcnNcclxuICAgIC50cmltKCk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHByZS1yZWxlYXNlIHZlcnNpb25zXHJcbiAgaWYgKGNsZWFuZWQuaW5jbHVkZXMoJy0nKSkge1xyXG4gICAgY29uc3QgcGFydHMgPSBjbGVhbmVkLnNwbGl0KCctJyk7XHJcbiAgICBjbGVhbmVkID0gcGFydHNbMF07XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBidWlsZCBtZXRhZGF0YVxyXG4gIGlmIChjbGVhbmVkLmluY2x1ZGVzKCcrJykpIHtcclxuICAgIGNvbnN0IHBhcnRzID0gY2xlYW5lZC5zcGxpdCgnKycpO1xyXG4gICAgY2xlYW5lZCA9IHBhcnRzWzBdO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gY2xlYW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEN1c3RvbSB2ZXJzaW9uIGNvbXBhcmlzb24gZm9yIG5vbi1Ob2RlLmpzIGxhbmd1YWdlc1xyXG4gKiBAcGFyYW0gdmVyc2lvbjEgRmlyc3QgdmVyc2lvblxyXG4gKiBAcGFyYW0gdmVyc2lvbjIgU2Vjb25kIHZlcnNpb25cclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgQ29tcGFyaXNvbiByZXN1bHRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9uc0N1c3RvbShcclxuICB2ZXJzaW9uMTogc3RyaW5nLFxyXG4gIHZlcnNpb24yOiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IENvbXBhcmlzb25SZXN1bHQge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB2MVBhcnRzID0gcGFyc2VWZXJzaW9uUGFydHModmVyc2lvbjEsIGxhbmd1YWdlKTtcclxuICAgIGNvbnN0IHYyUGFydHMgPSBwYXJzZVZlcnNpb25QYXJ0cyh2ZXJzaW9uMiwgbGFuZ3VhZ2UpO1xyXG4gICAgXHJcbiAgICBpZiAoIXYxUGFydHMgfHwgIXYyUGFydHMpIHtcclxuICAgICAgcmV0dXJuICd1bmtub3duJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ29tcGFyZSBtYWpvciwgbWlub3IsIHBhdGNoXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHYxUGFydHMubGVuZ3RoLCB2MlBhcnRzLmxlbmd0aCk7IGkrKykge1xyXG4gICAgICBjb25zdCB2MVBhcnQgPSB2MVBhcnRzW2ldIHx8IDA7XHJcbiAgICAgIGNvbnN0IHYyUGFydCA9IHYyUGFydHNbaV0gfHwgMDtcclxuICAgICAgXHJcbiAgICAgIGlmICh2MVBhcnQgPiB2MlBhcnQpIHJldHVybiAnZ3JlYXRlcic7XHJcbiAgICAgIGlmICh2MVBhcnQgPCB2MlBhcnQpIHJldHVybiAnbGVzcyc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAnZXF1YWwnO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuICd1bmtub3duJztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSB2ZXJzaW9uIGludG8gbnVtZXJpYyBwYXJ0c1xyXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIHN0cmluZ1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBudW1lcmljIHBhcnRzXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVZlcnNpb25QYXJ0cyh2ZXJzaW9uOiBzdHJpbmcsIGxhbmd1YWdlOiBMYW5ndWFnZSk6IG51bWJlcltdIHwgbnVsbCB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIENsZWFuIHZlcnNpb25cclxuICAgIGxldCBjbGVhbmVkID0gdmVyc2lvblxyXG4gICAgICAucmVwbGFjZSgvXnYvLCAnJylcclxuICAgICAgLnJlcGxhY2UoL15bfl4+PTwhPV0rLywgJycpXHJcbiAgICAgIC50cmltKCk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgdmVyc2lvbiBmb3JtYXRzXHJcbiAgICBpZiAobGFuZ3VhZ2UgPT09ICdweXRob24nKSB7XHJcbiAgICAgIC8vIFB5dGhvbjogMS4yLjMsIDEuMiwgMS4yLjNhMSwgMS4yLjNiMSwgMS4yLjNyYzFcclxuICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvW2EtekEtWl0uKiQvLCAnJyk7IC8vIFJlbW92ZSBwcmUtcmVsZWFzZSBpbmZvXHJcbiAgICB9IGVsc2UgaWYgKGxhbmd1YWdlID09PSAnamF2YScpIHtcclxuICAgICAgLy8gSmF2YTogMS44LjAsIDExLCAxNy4wLjFcclxuICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvW2EtekEtWl0uKiQvLCAnJyk7IC8vIFJlbW92ZSBwcmUtcmVsZWFzZSBpbmZvXHJcbiAgICB9IGVsc2UgaWYgKGxhbmd1YWdlID09PSAnZ28nKSB7XHJcbiAgICAgIC8vIEdvOiB2MS4yMS4wLCAxLjIxLjBcclxuICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvW2EtekEtWl0uKiQvLCAnJyk7IC8vIFJlbW92ZSBwcmUtcmVsZWFzZSBpbmZvXHJcbiAgICB9IGVsc2UgaWYgKGxhbmd1YWdlID09PSAnZG90bmV0Jykge1xyXG4gICAgICAvLyAuTkVUOiA2LjAuMCwgNy4wLjAtcHJldmlldy4xXHJcbiAgICAgIGNsZWFuZWQgPSBjbGVhbmVkLnJlcGxhY2UoL1thLXpBLVpdLiokLywgJycpOyAvLyBSZW1vdmUgcHJlLXJlbGVhc2UgaW5mb1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTcGxpdCBieSBkb3RzIGFuZCBjb252ZXJ0IHRvIG51bWJlcnNcclxuICAgIGNvbnN0IHBhcnRzID0gY2xlYW5lZC5zcGxpdCgnLicpLm1hcChwYXJ0ID0+IHtcclxuICAgICAgY29uc3QgbnVtID0gcGFyc2VJbnQocGFydCwgMTApO1xyXG4gICAgICByZXR1cm4gaXNOYU4obnVtKSA/IDAgOiBudW07XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cyA6IG51bGw7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSB2ZXJzaW9uIHN0cmluZyBhbmQgZXh0cmFjdCB2ZXJzaW9uIG51bWJlclxyXG4gKiBAcGFyYW0gdmVyc2lvblN0cmluZyBWZXJzaW9uIHN0cmluZyAobWF5IGNvbnRhaW4gb3BlcmF0b3JzKVxyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBDbGVhbiB2ZXJzaW9uIHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVmVyc2lvbih2ZXJzaW9uU3RyaW5nOiBzdHJpbmcsIGxhbmd1YWdlOiBMYW5ndWFnZSk6IHN0cmluZyB7XHJcbiAgaWYgKCF2ZXJzaW9uU3RyaW5nIHx8IHZlcnNpb25TdHJpbmcgPT09ICcqJykge1xyXG4gICAgcmV0dXJuICcwLjAuMCc7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFJlbW92ZSBjb21tb24gb3BlcmF0b3JzIGFuZCBwcmVmaXhlc1xyXG4gIGxldCBjbGVhbiA9IHZlcnNpb25TdHJpbmdcclxuICAgIC5yZXBsYWNlKC9eW35ePj08IT1dKy8sICcnKSAvLyBSZW1vdmUgb3BlcmF0b3JzXHJcbiAgICAucmVwbGFjZSgvXnYvLCAnJykgLy8gUmVtb3ZlIHYgcHJlZml4XHJcbiAgICAudHJpbSgpO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2VzXHJcbiAgaWYgKGNsZWFuID09PSAnbGF0ZXN0JyB8fCBjbGVhbiA9PT0gJycpIHtcclxuICAgIHJldHVybiAnMC4wLjAnO1xyXG4gIH1cclxuICBcclxuICAvLyBIYW5kbGUgUHl0aG9uIHZlcnNpb24gc3BlY2lmaWVyc1xyXG4gIGlmIChsYW5ndWFnZSA9PT0gJ3B5dGhvbicpIHtcclxuICAgIC8vIFJlbW92ZSBQeXRob24tc3BlY2lmaWMgb3BlcmF0b3JzXHJcbiAgICBjbGVhbiA9IGNsZWFuLnJlcGxhY2UoL15bfj0hPD5dKy8sICcnKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIEdvIHZlcnNpb24gc3VmZml4ZXNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdnbycpIHtcclxuICAgIC8vIFJlbW92ZSAraW5jb21wYXRpYmxlLCAraW5jb21wYXRpYmxlLjIwMjEwMTAxLCBldGMuXHJcbiAgICBjbGVhbiA9IGNsZWFuLnJlcGxhY2UoL1xcKy4qJC8sICcnKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIEphdmEgdmVyc2lvbiByYW5nZXNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdqYXZhJykge1xyXG4gICAgLy8gRXh0cmFjdCB2ZXJzaW9uIGZyb20gcmFuZ2VzIGxpa2UgWzEuMCwyLjApIG9yICgxLjAsMi4wXVxyXG4gICAgY29uc3QgcmFuZ2VNYXRjaCA9IGNsZWFuLm1hdGNoKC9bWyhdKFteLF0rKSwvKTtcclxuICAgIGlmIChyYW5nZU1hdGNoKSB7XHJcbiAgICAgIGNsZWFuID0gcmFuZ2VNYXRjaFsxXTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGNsZWFuO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYSB2ZXJzaW9uIHNhdGlzZmllcyBhIHJlcXVpcmVtZW50XHJcbiAqIEBwYXJhbSB2ZXJzaW9uIFZlcnNpb24gdG8gY2hlY2tcclxuICogQHBhcmFtIHJlcXVpcmVtZW50IFJlcXVpcmVtZW50IChlLmcuLCBcIj49MS4wLjBcIiwgXCJ+MS4yLjNcIilcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgVHJ1ZSBpZiB2ZXJzaW9uIHNhdGlzZmllcyByZXF1aXJlbWVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNhdGlzZmllc1JlcXVpcmVtZW50KFxyXG4gIHZlcnNpb246IHN0cmluZyxcclxuICByZXF1aXJlbWVudDogc3RyaW5nLFxyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxyXG4pOiBib29sZWFuIHtcclxuICB0cnkge1xyXG4gICAgaWYgKGxhbmd1YWdlID09PSAnbm9kZScpIHtcclxuICAgICAgLy8gVXNlIHNlbXZlciBmb3IgTm9kZS5qc1xyXG4gICAgICBjb25zdCBjbGVhblZlcnNpb24gPSBjbGVhblZlcnNpb25Gb3JTZW12ZXIodmVyc2lvbik7XHJcbiAgICAgIGlmICghc2VtdmVyLnZhbGlkKGNsZWFuVmVyc2lvbikpIHJldHVybiBmYWxzZTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKGNsZWFuVmVyc2lvbiwgcmVxdWlyZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDdXN0b20gbG9naWMgZm9yIG90aGVyIGxhbmd1YWdlc1xyXG4gICAgcmV0dXJuIHNhdGlzZmllc1JlcXVpcmVtZW50Q3VzdG9tKHZlcnNpb24sIHJlcXVpcmVtZW50LCBsYW5ndWFnZSk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3VzdG9tIHJlcXVpcmVtZW50IHNhdGlzZmFjdGlvbiBjaGVja1xyXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIHRvIGNoZWNrXHJcbiAqIEBwYXJhbSByZXF1aXJlbWVudCBSZXF1aXJlbWVudFxyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHZlcnNpb24gc2F0aXNmaWVzIHJlcXVpcmVtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBzYXRpc2ZpZXNSZXF1aXJlbWVudEN1c3RvbShcclxuICB2ZXJzaW9uOiBzdHJpbmcsXHJcbiAgcmVxdWlyZW1lbnQ6IHN0cmluZyxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2VcclxuKTogYm9vbGVhbiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNsZWFuVmVyc2lvbiA9IHBhcnNlVmVyc2lvbih2ZXJzaW9uLCBsYW5ndWFnZSk7XHJcbiAgICBjb25zdCBjbGVhblJlcXVpcmVtZW50ID0gcGFyc2VWZXJzaW9uKHJlcXVpcmVtZW50LCBsYW5ndWFnZSk7XHJcbiAgICBcclxuICAgIGlmICghY2xlYW5WZXJzaW9uIHx8ICFjbGVhblJlcXVpcmVtZW50KSByZXR1cm4gZmFsc2U7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3Qgb3BlcmF0b3IgZnJvbSByZXF1aXJlbWVudFxyXG4gICAgY29uc3Qgb3BlcmF0b3JNYXRjaCA9IHJlcXVpcmVtZW50Lm1hdGNoKC9eKFt+Xj49PCE9XSspLyk7XHJcbiAgICBjb25zdCBvcGVyYXRvciA9IG9wZXJhdG9yTWF0Y2ggPyBvcGVyYXRvck1hdGNoWzFdIDogJz49JztcclxuICAgIFxyXG4gICAgY29uc3QgY29tcGFyaXNvbiA9IGNvbXBhcmVWZXJzaW9ucyhjbGVhblZlcnNpb24sIGNsZWFuUmVxdWlyZW1lbnQsIGxhbmd1YWdlKTtcclxuICAgIFxyXG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xyXG4gICAgICBjYXNlICc+PSc6XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPT09ICdncmVhdGVyJyB8fCBjb21wYXJpc29uID09PSAnZXF1YWwnO1xyXG4gICAgICBjYXNlICc+JzpcclxuICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gJ2dyZWF0ZXInO1xyXG4gICAgICBjYXNlICc8PSc6XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPT09ICdsZXNzJyB8fCBjb21wYXJpc29uID09PSAnZXF1YWwnO1xyXG4gICAgICBjYXNlICc8JzpcclxuICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gJ2xlc3MnO1xyXG4gICAgICBjYXNlICc9JzpcclxuICAgICAgY2FzZSAnPT0nOlxyXG4gICAgICAgIHJldHVybiBjb21wYXJpc29uID09PSAnZXF1YWwnO1xyXG4gICAgICBjYXNlICd+JzpcclxuICAgICAgICAvLyBUaWxkZTogYWxsb3cgcGF0Y2gtbGV2ZWwgY2hhbmdlc1xyXG4gICAgICAgIHJldHVybiBzYXRpc2ZpZXNUaWxkZShjbGVhblZlcnNpb24sIGNsZWFuUmVxdWlyZW1lbnQsIGxhbmd1YWdlKTtcclxuICAgICAgY2FzZSAnXic6XHJcbiAgICAgICAgLy8gQ2FyZXQ6IGFsbG93IG1pbm9yLWxldmVsIGNoYW5nZXNcclxuICAgICAgICByZXR1cm4gc2F0aXNmaWVzQ2FyZXQoY2xlYW5WZXJzaW9uLCBjbGVhblJlcXVpcmVtZW50LCBsYW5ndWFnZSk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPT09ICdlcXVhbCc7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdmVyc2lvbiBzYXRpc2ZpZXMgdGlsZGUgcmVxdWlyZW1lbnRcclxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiB0byBjaGVja1xyXG4gKiBAcGFyYW0gcmVxdWlyZW1lbnQgUmVxdWlyZW1lbnRcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgVHJ1ZSBpZiBzYXRpc2ZpZXNcclxuICovXHJcbmZ1bmN0aW9uIHNhdGlzZmllc1RpbGRlKFxyXG4gIHZlcnNpb246IHN0cmluZyxcclxuICByZXF1aXJlbWVudDogc3RyaW5nLFxyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxyXG4pOiBib29sZWFuIHtcclxuICBjb25zdCB2UGFydHMgPSBwYXJzZVZlcnNpb25QYXJ0cyh2ZXJzaW9uLCBsYW5ndWFnZSk7XHJcbiAgY29uc3QgclBhcnRzID0gcGFyc2VWZXJzaW9uUGFydHMocmVxdWlyZW1lbnQsIGxhbmd1YWdlKTtcclxuICBcclxuICBpZiAoIXZQYXJ0cyB8fCAhclBhcnRzKSByZXR1cm4gZmFsc2U7XHJcbiAgXHJcbiAgLy8gTWFqb3IgYW5kIG1pbm9yIG11c3QgbWF0Y2gsIHBhdGNoIGNhbiBiZSBoaWdoZXJcclxuICBpZiAodlBhcnRzWzBdICE9PSByUGFydHNbMF0pIHJldHVybiBmYWxzZTtcclxuICBpZiAodlBhcnRzWzFdICE9PSByUGFydHNbMV0pIHJldHVybiBmYWxzZTtcclxuICBcclxuICByZXR1cm4gdlBhcnRzWzJdID49IChyUGFydHNbMl0gfHwgMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2ZXJzaW9uIHNhdGlzZmllcyBjYXJldCByZXF1aXJlbWVudFxyXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIHRvIGNoZWNrXHJcbiAqIEBwYXJhbSByZXF1aXJlbWVudCBSZXF1aXJlbWVudFxyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHNhdGlzZmllc1xyXG4gKi9cclxuZnVuY3Rpb24gc2F0aXNmaWVzQ2FyZXQoXHJcbiAgdmVyc2lvbjogc3RyaW5nLFxyXG4gIHJlcXVpcmVtZW50OiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IHZQYXJ0cyA9IHBhcnNlVmVyc2lvblBhcnRzKHZlcnNpb24sIGxhbmd1YWdlKTtcclxuICBjb25zdCByUGFydHMgPSBwYXJzZVZlcnNpb25QYXJ0cyhyZXF1aXJlbWVudCwgbGFuZ3VhZ2UpO1xyXG4gIFxyXG4gIGlmICghdlBhcnRzIHx8ICFyUGFydHMpIHJldHVybiBmYWxzZTtcclxuICBcclxuICAvLyBNYWpvciBtdXN0IG1hdGNoLCBtaW5vciBhbmQgcGF0Y2ggY2FuIGJlIGhpZ2hlclxyXG4gIGlmICh2UGFydHNbMF0gIT09IHJQYXJ0c1swXSkgcmV0dXJuIGZhbHNlO1xyXG4gIFxyXG4gIHJldHVybiB2UGFydHNbMV0gPiAoclBhcnRzWzFdIHx8IDApIHx8IFxyXG4gICAgICAgICAodlBhcnRzWzFdID09PSAoclBhcnRzWzFdIHx8IDApICYmIHZQYXJ0c1syXSA+PSAoclBhcnRzWzJdIHx8IDApKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB2ZXJzaW9uIGRpZmZlcmVuY2UgZGVzY3JpcHRpb25cclxuICogQHBhcmFtIHZlcnNpb24xIEZpcnN0IHZlcnNpb25cclxuICogQHBhcmFtIHZlcnNpb24yIFNlY29uZCB2ZXJzaW9uXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIERlc2NyaXB0aW9uIG9mIGRpZmZlcmVuY2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzaW9uRGlmZmVyZW5jZShcclxuICB2ZXJzaW9uMTogc3RyaW5nLFxyXG4gIHZlcnNpb24yOiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IHN0cmluZyB7XHJcbiAgY29uc3QgY29tcGFyaXNvbiA9IGNvbXBhcmVWZXJzaW9ucyh2ZXJzaW9uMSwgdmVyc2lvbjIsIGxhbmd1YWdlKTtcclxuICBcclxuICBzd2l0Y2ggKGNvbXBhcmlzb24pIHtcclxuICAgIGNhc2UgJ2dyZWF0ZXInOlxyXG4gICAgICByZXR1cm4gYCR7dmVyc2lvbjF9IGlzIG5ld2VyIHRoYW4gJHt2ZXJzaW9uMn1gO1xyXG4gICAgY2FzZSAnbGVzcyc6XHJcbiAgICAgIHJldHVybiBgJHt2ZXJzaW9uMX0gaXMgb2xkZXIgdGhhbiAke3ZlcnNpb24yfWA7XHJcbiAgICBjYXNlICdlcXVhbCc6XHJcbiAgICAgIHJldHVybiBgJHt2ZXJzaW9uMX0gbWF0Y2hlcyAke3ZlcnNpb24yfWA7XHJcbiAgICBjYXNlICd1bmtub3duJzpcclxuICAgICAgcmV0dXJuIGBDYW5ub3QgY29tcGFyZSAke3ZlcnNpb24xfSB3aXRoICR7dmVyc2lvbjJ9YDtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiAnVW5rbm93biBjb21wYXJpc29uJztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZlcnNpb24gaXMgYSBwcmUtcmVsZWFzZVxyXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIHN0cmluZ1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHByZS1yZWxlYXNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQcmVSZWxlYXNlKHZlcnNpb246IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgY2xlYW4gPSBwYXJzZVZlcnNpb24odmVyc2lvbiwgbGFuZ3VhZ2UpO1xyXG4gIFxyXG4gIC8vIENoZWNrIGZvciBjb21tb24gcHJlLXJlbGVhc2UgaW5kaWNhdG9yc1xyXG4gIHJldHVybiAvW2EtekEtWl0vLnRlc3QoY2xlYW4pIHx8IFxyXG4gICAgICAgICBjbGVhbi5pbmNsdWRlcygnLScpIHx8IFxyXG4gICAgICAgICBjbGVhbi5pbmNsdWRlcygnYWxwaGEnKSB8fFxyXG4gICAgICAgICBjbGVhbi5pbmNsdWRlcygnYmV0YScpIHx8XHJcbiAgICAgICAgIGNsZWFuLmluY2x1ZGVzKCdyYycpIHx8XHJcbiAgICAgICAgIGNsZWFuLmluY2x1ZGVzKCdwcmV2aWV3Jyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGxhdGVzdCBzdGFibGUgdmVyc2lvbiBmcm9tIGEgbGlzdFxyXG4gKiBAcGFyYW0gdmVyc2lvbnMgQXJyYXkgb2YgdmVyc2lvbiBzdHJpbmdzXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIExhdGVzdCBzdGFibGUgdmVyc2lvbiBvciBudWxsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF0ZXN0U3RhYmxlVmVyc2lvbihcclxuICB2ZXJzaW9uczogc3RyaW5nW10sXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IHN0cmluZyB8IG51bGwge1xyXG4gIGNvbnN0IHN0YWJsZVZlcnNpb25zID0gdmVyc2lvbnMuZmlsdGVyKHYgPT4gIWlzUHJlUmVsZWFzZSh2LCBsYW5ndWFnZSkpO1xyXG4gIFxyXG4gIGlmIChzdGFibGVWZXJzaW9ucy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xyXG4gIFxyXG4gIGxldCBsYXRlc3QgPSBzdGFibGVWZXJzaW9uc1swXTtcclxuICBcclxuICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygc3RhYmxlVmVyc2lvbnMpIHtcclxuICAgIGlmIChjb21wYXJlVmVyc2lvbnModmVyc2lvbiwgbGF0ZXN0LCBsYW5ndWFnZSkgPT09ICdncmVhdGVyJykge1xyXG4gICAgICBsYXRlc3QgPSB2ZXJzaW9uO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gbGF0ZXN0O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJzZW12ZXIiLCJjb21wYXJlVmVyc2lvbnMiLCJ2ZXJzaW9uMSIsInZlcnNpb24yIiwibGFuZ3VhZ2UiLCJ2MSIsInBhcnNlVmVyc2lvbiIsInYyIiwiY29tcGFyZVdpdGhTZW12ZXIiLCJjb21wYXJlVmVyc2lvbnNDdXN0b20iLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiY2xlYW5WZXJzaW9uRm9yU2VtdmVyIiwidmFsaWQiLCJyZXN1bHQiLCJjb21wYXJlIiwidmVyc2lvbiIsImNsZWFuZWQiLCJyZXBsYWNlIiwidHJpbSIsImluY2x1ZGVzIiwicGFydHMiLCJzcGxpdCIsInYxUGFydHMiLCJwYXJzZVZlcnNpb25QYXJ0cyIsInYyUGFydHMiLCJpIiwiTWF0aCIsIm1heCIsImxlbmd0aCIsInYxUGFydCIsInYyUGFydCIsIm1hcCIsInBhcnQiLCJudW0iLCJwYXJzZUludCIsImlzTmFOIiwidmVyc2lvblN0cmluZyIsImNsZWFuIiwicmFuZ2VNYXRjaCIsIm1hdGNoIiwic2F0aXNmaWVzUmVxdWlyZW1lbnQiLCJyZXF1aXJlbWVudCIsImNsZWFuVmVyc2lvbiIsInNhdGlzZmllcyIsInNhdGlzZmllc1JlcXVpcmVtZW50Q3VzdG9tIiwiY2xlYW5SZXF1aXJlbWVudCIsIm9wZXJhdG9yTWF0Y2giLCJvcGVyYXRvciIsImNvbXBhcmlzb24iLCJzYXRpc2ZpZXNUaWxkZSIsInNhdGlzZmllc0NhcmV0IiwidlBhcnRzIiwiclBhcnRzIiwiZ2V0VmVyc2lvbkRpZmZlcmVuY2UiLCJpc1ByZVJlbGVhc2UiLCJ0ZXN0IiwiZ2V0TGF0ZXN0U3RhYmxlVmVyc2lvbiIsInZlcnNpb25zIiwic3RhYmxlVmVyc2lvbnMiLCJmaWx0ZXIiLCJ2IiwibGF0ZXN0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/compare.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/deps.ts":
/*!******************************!*\
  !*** ./lib/analysis/deps.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeDependencies: () => (/* binding */ analyzeDependencies),\n/* harmony export */   filterDependenciesByLanguage: () => (/* binding */ filterDependenciesByLanguage),\n/* harmony export */   getBaselineVersion: () => (/* binding */ getBaselineVersion),\n/* harmony export */   getDependencySummary: () => (/* binding */ getDependencySummary),\n/* harmony export */   groupDependenciesByStatus: () => (/* binding */ groupDependenciesByStatus),\n/* harmony export */   hasBaselineRule: () => (/* binding */ hasBaselineRule),\n/* harmony export */   isValidVersion: () => (/* binding */ isValidVersion),\n/* harmony export */   normalizePackageName: () => (/* binding */ normalizePackageName),\n/* harmony export */   parseVersion: () => (/* binding */ parseVersion),\n/* harmony export */   sortDependencies: () => (/* binding */ sortDependencies)\n/* harmony export */ });\n/* harmony import */ var _compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compare */ \"(rsc)/./lib/analysis/compare.ts\");\n\n/**\r\n * Analyze dependencies from project manifests\r\n * @param manifests Array of project manifests\r\n * @param rules Baseline rules\r\n * @returns Array of dependency findings\r\n */ function analyzeDependencies(manifests, rules) {\n    const findings = [];\n    for (const manifest of manifests){\n        if (!manifest.dependencies) continue;\n        const languageRules = rules.package_mins[manifest.language] || {};\n        for (const [packageName, foundVersion] of Object.entries(manifest.dependencies)){\n            const baselineVersion = languageRules[packageName];\n            if (!baselineVersion) {\n                // No baseline rule for this package\n                findings.push({\n                    kind: 'dependency',\n                    lang: manifest.language,\n                    component: packageName,\n                    foundVersion,\n                    baselineRequired: null,\n                    status: 'unknown',\n                    reason: 'no-baseline-rule',\n                    file: manifest.file\n                });\n                continue;\n            }\n            // Compare versions\n            const comparison = (0,_compare__WEBPACK_IMPORTED_MODULE_0__.compareVersions)(foundVersion, baselineVersion, manifest.language);\n            let status;\n            let reason;\n            switch(comparison){\n                case 'greater':\n                case 'equal':\n                    status = 'ok';\n                    reason = 'meets-baseline';\n                    break;\n                case 'less':\n                    status = 'affected';\n                    reason = 'below-baseline';\n                    break;\n                case 'unknown':\n                    status = 'unknown';\n                    reason = 'version-parse-error';\n                    break;\n                default:\n                    status = 'unknown';\n                    reason = 'unknown-comparison';\n            }\n            findings.push({\n                kind: 'dependency',\n                lang: manifest.language,\n                component: packageName,\n                foundVersion,\n                baselineRequired: baselineVersion,\n                status,\n                reason,\n                file: manifest.file,\n                quickFix: getDependencyQuickFix(rules, manifest.language, packageName, baselineVersion)\n            });\n        }\n    }\n    return findings;\n}\n/**\r\n * Get quick fix for dependency upgrade\r\n * @param rules Baseline rules\r\n * @param language Language\r\n * @param packageName Package name\r\n * @param version Required version\r\n * @returns Quick fix string\r\n */ function getDependencyQuickFix(rules, language, packageName, version) {\n    const template = rules.quick_fixes.dependency_upgrade[language] || 'Update {package} to {version}';\n    return template.replace('{package}', packageName).replace('{version}', version);\n}\n/**\r\n * Parse version string and extract version number\r\n * @param versionString Version string (may contain operators)\r\n * @param language Language context\r\n * @returns Clean version string\r\n */ function parseVersion(versionString, language) {\n    if (!versionString || versionString === '*') {\n        return '0.0.0';\n    }\n    // Remove common operators and prefixes\n    let clean = versionString.replace(/^[~^>=<!=]+/, '') // Remove operators\n    .replace(/^v/, '') // Remove v prefix\n    .trim();\n    // Handle special cases\n    if (clean === 'latest' || clean === '') {\n        return '0.0.0';\n    }\n    // Handle Python version specifiers\n    if (language === 'python') {\n        // Remove Python-specific operators\n        clean = clean.replace(/^[~=!<>]+/, '');\n    }\n    // Handle Go version suffixes\n    if (language === 'go') {\n        // Remove +incompatible, +incompatible.20210101, etc.\n        clean = clean.replace(/\\+.*$/, '');\n    }\n    // Handle Java version ranges\n    if (language === 'java') {\n        // Extract version from ranges like [1.0,2.0) or (1.0,2.0]\n        const rangeMatch = clean.match(/[[(]([^,]+),/);\n        if (rangeMatch) {\n            clean = rangeMatch[1];\n        }\n    }\n    return clean;\n}\n/**\r\n * Check if a version string is valid\r\n * @param versionString Version string\r\n * @param language Language context\r\n * @returns True if valid\r\n */ function isValidVersion(versionString, language) {\n    if (!versionString || versionString === '*') return false;\n    const clean = parseVersion(versionString, language);\n    // Basic version pattern validation\n    const versionPatterns = {\n        node: /^\\d+\\.\\d+\\.\\d+(-[a-zA-Z0-9.-]+)?(\\+[a-zA-Z0-9.-]+)?$/,\n        python: /^\\d+\\.\\d+(\\.\\d+)?([a-zA-Z0-9.-]+)?$/,\n        java: /^\\d+(\\.\\d+)*(-[a-zA-Z0-9.-]+)?$/,\n        go: /^v?\\d+\\.\\d+\\.\\d+(-[a-zA-Z0-9.-]+)?(\\+[a-zA-Z0-9.-]+)?$/,\n        dotnet: /^\\d+\\.\\d+(\\.\\d+)?(-[a-zA-Z0-9.-]+)?$/\n    };\n    const pattern = versionPatterns[language];\n    return pattern ? pattern.test(clean) : false;\n}\n/**\r\n * Normalize package name for comparison\r\n * @param packageName Package name\r\n * @param language Language context\r\n * @returns Normalized package name\r\n */ function normalizePackageName(packageName, language) {\n    let normalized = packageName.toLowerCase().trim();\n    // Handle scoped packages (Node.js)\n    if (language === 'node' && normalized.startsWith('@')) {\n        // Keep @scope/package format\n        return normalized;\n    }\n    // Handle Java group:artifact format\n    if (language === 'java' && normalized.includes(':')) {\n        return normalized;\n    }\n    // Handle Go modules\n    if (language === 'go') {\n        // Remove common prefixes\n        normalized = normalized.replace(/^github\\.com\\//, '');\n        normalized = normalized.replace(/^golang\\.org\\/x\\//, '');\n    }\n    // Handle .NET packages\n    if (language === 'dotnet') {\n        // Remove common prefixes\n        normalized = normalized.replace(/^microsoft\\./, '');\n        normalized = normalized.replace(/^system\\./, '');\n    }\n    return normalized;\n}\n/**\r\n * Check if a package is in the baseline rules\r\n * @param packageName Package name\r\n * @param language Language\r\n * @param rules Baseline rules\r\n * @returns True if package has baseline rules\r\n */ function hasBaselineRule(packageName, language, rules) {\n    const languageRules = rules.package_mins[language] || {};\n    const normalized = normalizePackageName(packageName, language);\n    // Check exact match first\n    if (languageRules[packageName]) return true;\n    if (languageRules[normalized]) return true;\n    // Check for partial matches (for scoped packages, etc.)\n    for (const [rulePackage] of Object.entries(languageRules)){\n        if (normalizePackageName(rulePackage, language) === normalized) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\r\n * Get baseline version for a package\r\n * @param packageName Package name\r\n * @param language Language\r\n * @param rules Baseline rules\r\n * @returns Baseline version or null\r\n */ function getBaselineVersion(packageName, language, rules) {\n    const languageRules = rules.package_mins[language] || {};\n    const normalized = normalizePackageName(packageName, language);\n    // Check exact match first\n    if (languageRules[packageName]) return languageRules[packageName];\n    if (languageRules[normalized]) return languageRules[normalized];\n    // Check for partial matches\n    for (const [rulePackage, version] of Object.entries(languageRules)){\n        if (normalizePackageName(rulePackage, language) === normalized) {\n            return version;\n        }\n    }\n    return null;\n}\n/**\r\n * Group dependencies by status\r\n * @param findings Dependency findings\r\n * @returns Grouped findings\r\n */ function groupDependenciesByStatus(findings) {\n    return {\n        ok: findings.filter((f)=>f.status === 'ok'),\n        affected: findings.filter((f)=>f.status === 'affected'),\n        unknown: findings.filter((f)=>f.status === 'unknown')\n    };\n}\n/**\r\n * Get dependency summary statistics\r\n * @param findings Dependency findings\r\n * @returns Summary statistics\r\n */ function getDependencySummary(findings) {\n    const total = findings.length;\n    const ok = findings.filter((f)=>f.status === 'ok').length;\n    const affected = findings.filter((f)=>f.status === 'affected').length;\n    const unknown = findings.filter((f)=>f.status === 'unknown').length;\n    return {\n        total,\n        ok,\n        affected,\n        unknown,\n        okPercentage: total > 0 ? ok / total * 100 : 0,\n        affectedPercentage: total > 0 ? affected / total * 100 : 0,\n        unknownPercentage: total > 0 ? unknown / total * 100 : 0\n    };\n}\n/**\r\n * Filter dependencies by language\r\n * @param findings Dependency findings\r\n * @param language Language to filter by\r\n * @returns Filtered findings\r\n */ function filterDependenciesByLanguage(findings, language) {\n    return findings.filter((f)=>f.lang === language);\n}\n/**\r\n * Sort dependencies by status and name\r\n * @param findings Dependency findings\r\n * @returns Sorted findings\r\n */ function sortDependencies(findings) {\n    const statusOrder = {\n        affected: 0,\n        unknown: 1,\n        ok: 2\n    };\n    return [\n        ...findings\n    ].sort((a, b)=>{\n        // First by status\n        const statusDiff = statusOrder[a.status] - statusOrder[b.status];\n        if (statusDiff !== 0) return statusDiff;\n        // Then by language\n        const langDiff = a.lang.localeCompare(b.lang);\n        if (langDiff !== 0) return langDiff;\n        // Finally by component name\n        return a.component.localeCompare(b.component);\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0tBQVMsQ0FBQ2lFLElBQUksQ0FBQyxDQUFDQyxHQUFHQztRQUM1QixrQkFBa0I7UUFDbEIsTUFBTUMsYUFBYUosV0FBVyxDQUFDRSxFQUFFbEQsTUFBTSxDQUFDLEdBQUdnRCxXQUFXLENBQUNHLEVBQUVuRCxNQUFNLENBQUM7UUFDaEUsSUFBSW9ELGVBQWUsR0FBRyxPQUFPQTtRQUU3QixtQkFBbUI7UUFDbkIsTUFBTUMsV0FBV0gsRUFBRXJELElBQUksQ0FBQ3lELGFBQWEsQ0FBQ0gsRUFBRXRELElBQUk7UUFDNUMsSUFBSXdELGFBQWEsR0FBRyxPQUFPQTtRQUUzQiw0QkFBNEI7UUFDNUIsT0FBT0gsRUFBRXBELFNBQVMsQ0FBQ3dELGFBQWEsQ0FBQ0gsRUFBRXJELFNBQVM7SUFDOUM7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxDa2hhZGFyXFxEb3dubG9hZHNcXEFJX0Jhc2VsaW5lX01hcFxcbGliXFxhbmFseXNpc1xcZGVwcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5ndWFnZSwgRGVwZW5kZW5jeUZpbmRpbmcsIFN0YXR1cyB9IGZyb20gJy4vYmFzZWxpbmUudHlwZXMnO1xyXG5pbXBvcnQgeyBCYXNlbGluZVJ1bGVzIH0gZnJvbSAnLi9iYXNlbGluZS50eXBlcyc7XHJcbmltcG9ydCB7IGNvbXBhcmVWZXJzaW9ucyB9IGZyb20gJy4vY29tcGFyZSc7XHJcblxyXG4vKipcclxuICogQW5hbHl6ZSBkZXBlbmRlbmNpZXMgZnJvbSBwcm9qZWN0IG1hbmlmZXN0c1xyXG4gKiBAcGFyYW0gbWFuaWZlc3RzIEFycmF5IG9mIHByb2plY3QgbWFuaWZlc3RzXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBkZXBlbmRlbmN5IGZpbmRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYW5hbHl6ZURlcGVuZGVuY2llcyhcclxuICBtYW5pZmVzdHM6IEFycmF5PHsgbGFuZ3VhZ2U6IExhbmd1YWdlOyBmaWxlOiBzdHJpbmc7IGRlcGVuZGVuY2llcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfT4sXHJcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNcclxuKTogRGVwZW5kZW5jeUZpbmRpbmdbXSB7XHJcbiAgY29uc3QgZmluZGluZ3M6IERlcGVuZGVuY3lGaW5kaW5nW10gPSBbXTtcclxuICBcclxuICBmb3IgKGNvbnN0IG1hbmlmZXN0IG9mIG1hbmlmZXN0cykge1xyXG4gICAgaWYgKCFtYW5pZmVzdC5kZXBlbmRlbmNpZXMpIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICBjb25zdCBsYW5ndWFnZVJ1bGVzID0gcnVsZXMucGFja2FnZV9taW5zW21hbmlmZXN0Lmxhbmd1YWdlXSB8fCB7fTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBbcGFja2FnZU5hbWUsIGZvdW5kVmVyc2lvbl0gb2YgT2JqZWN0LmVudHJpZXMobWFuaWZlc3QuZGVwZW5kZW5jaWVzKSkge1xyXG4gICAgICBjb25zdCBiYXNlbGluZVZlcnNpb24gPSBsYW5ndWFnZVJ1bGVzW3BhY2thZ2VOYW1lXTtcclxuICAgICAgXHJcbiAgICAgIGlmICghYmFzZWxpbmVWZXJzaW9uKSB7XHJcbiAgICAgICAgLy8gTm8gYmFzZWxpbmUgcnVsZSBmb3IgdGhpcyBwYWNrYWdlXHJcbiAgICAgICAgZmluZGluZ3MucHVzaCh7XHJcbiAgICAgICAgICBraW5kOiAnZGVwZW5kZW5jeScsXHJcbiAgICAgICAgICBsYW5nOiBtYW5pZmVzdC5sYW5ndWFnZSxcclxuICAgICAgICAgIGNvbXBvbmVudDogcGFja2FnZU5hbWUsXHJcbiAgICAgICAgICBmb3VuZFZlcnNpb24sXHJcbiAgICAgICAgICBiYXNlbGluZVJlcXVpcmVkOiBudWxsLFxyXG4gICAgICAgICAgc3RhdHVzOiAndW5rbm93bicsXHJcbiAgICAgICAgICByZWFzb246ICduby1iYXNlbGluZS1ydWxlJyxcclxuICAgICAgICAgIGZpbGU6IG1hbmlmZXN0LmZpbGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIENvbXBhcmUgdmVyc2lvbnNcclxuICAgICAgY29uc3QgY29tcGFyaXNvbiA9IGNvbXBhcmVWZXJzaW9ucyhmb3VuZFZlcnNpb24sIGJhc2VsaW5lVmVyc2lvbiwgbWFuaWZlc3QubGFuZ3VhZ2UpO1xyXG4gICAgICBcclxuICAgICAgbGV0IHN0YXR1czogU3RhdHVzO1xyXG4gICAgICBsZXQgcmVhc29uOiBzdHJpbmc7XHJcbiAgICAgIFxyXG4gICAgICBzd2l0Y2ggKGNvbXBhcmlzb24pIHtcclxuICAgICAgICBjYXNlICdncmVhdGVyJzpcclxuICAgICAgICBjYXNlICdlcXVhbCc6XHJcbiAgICAgICAgICBzdGF0dXMgPSAnb2snO1xyXG4gICAgICAgICAgcmVhc29uID0gJ21lZXRzLWJhc2VsaW5lJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2xlc3MnOlxyXG4gICAgICAgICAgc3RhdHVzID0gJ2FmZmVjdGVkJztcclxuICAgICAgICAgIHJlYXNvbiA9ICdiZWxvdy1iYXNlbGluZSc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd1bmtub3duJzpcclxuICAgICAgICAgIHN0YXR1cyA9ICd1bmtub3duJztcclxuICAgICAgICAgIHJlYXNvbiA9ICd2ZXJzaW9uLXBhcnNlLWVycm9yJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBzdGF0dXMgPSAndW5rbm93bic7XHJcbiAgICAgICAgICByZWFzb24gPSAndW5rbm93bi1jb21wYXJpc29uJztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgZmluZGluZ3MucHVzaCh7XHJcbiAgICAgICAga2luZDogJ2RlcGVuZGVuY3knLFxyXG4gICAgICAgIGxhbmc6IG1hbmlmZXN0Lmxhbmd1YWdlLFxyXG4gICAgICAgIGNvbXBvbmVudDogcGFja2FnZU5hbWUsXHJcbiAgICAgICAgZm91bmRWZXJzaW9uLFxyXG4gICAgICAgIGJhc2VsaW5lUmVxdWlyZWQ6IGJhc2VsaW5lVmVyc2lvbixcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgcmVhc29uLFxyXG4gICAgICAgIGZpbGU6IG1hbmlmZXN0LmZpbGUsXHJcbiAgICAgICAgcXVpY2tGaXg6IGdldERlcGVuZGVuY3lRdWlja0ZpeChydWxlcywgbWFuaWZlc3QubGFuZ3VhZ2UsIHBhY2thZ2VOYW1lLCBiYXNlbGluZVZlcnNpb24pLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGZpbmRpbmdzO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHF1aWNrIGZpeCBmb3IgZGVwZW5kZW5jeSB1cGdyYWRlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2VcclxuICogQHBhcmFtIHBhY2thZ2VOYW1lIFBhY2thZ2UgbmFtZVxyXG4gKiBAcGFyYW0gdmVyc2lvbiBSZXF1aXJlZCB2ZXJzaW9uXHJcbiAqIEByZXR1cm5zIFF1aWNrIGZpeCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGdldERlcGVuZGVuY3lRdWlja0ZpeChcclxuICBydWxlczogQmFzZWxpbmVSdWxlcyxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2UsXHJcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcclxuICB2ZXJzaW9uOiBzdHJpbmdcclxuKTogc3RyaW5nIHtcclxuICBjb25zdCB0ZW1wbGF0ZSA9IHJ1bGVzLnF1aWNrX2ZpeGVzLmRlcGVuZGVuY3lfdXBncmFkZVtsYW5ndWFnZV0gfHwgJ1VwZGF0ZSB7cGFja2FnZX0gdG8ge3ZlcnNpb259JztcclxuICBcclxuICByZXR1cm4gdGVtcGxhdGVcclxuICAgIC5yZXBsYWNlKCd7cGFja2FnZX0nLCBwYWNrYWdlTmFtZSlcclxuICAgIC5yZXBsYWNlKCd7dmVyc2lvbn0nLCB2ZXJzaW9uKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHZlcnNpb24gc3RyaW5nIGFuZCBleHRyYWN0IHZlcnNpb24gbnVtYmVyXHJcbiAqIEBwYXJhbSB2ZXJzaW9uU3RyaW5nIFZlcnNpb24gc3RyaW5nIChtYXkgY29udGFpbiBvcGVyYXRvcnMpXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIENsZWFuIHZlcnNpb24gc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VWZXJzaW9uKHZlcnNpb25TdHJpbmc6IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogc3RyaW5nIHtcclxuICBpZiAoIXZlcnNpb25TdHJpbmcgfHwgdmVyc2lvblN0cmluZyA9PT0gJyonKSB7XHJcbiAgICByZXR1cm4gJzAuMC4wJztcclxuICB9XHJcbiAgXHJcbiAgLy8gUmVtb3ZlIGNvbW1vbiBvcGVyYXRvcnMgYW5kIHByZWZpeGVzXHJcbiAgbGV0IGNsZWFuID0gdmVyc2lvblN0cmluZ1xyXG4gICAgLnJlcGxhY2UoL15bfl4+PTwhPV0rLywgJycpIC8vIFJlbW92ZSBvcGVyYXRvcnNcclxuICAgIC5yZXBsYWNlKC9edi8sICcnKSAvLyBSZW1vdmUgdiBwcmVmaXhcclxuICAgIC50cmltKCk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcclxuICBpZiAoY2xlYW4gPT09ICdsYXRlc3QnIHx8IGNsZWFuID09PSAnJykge1xyXG4gICAgcmV0dXJuICcwLjAuMCc7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBQeXRob24gdmVyc2lvbiBzcGVjaWZpZXJzXHJcbiAgaWYgKGxhbmd1YWdlID09PSAncHl0aG9uJykge1xyXG4gICAgLy8gUmVtb3ZlIFB5dGhvbi1zcGVjaWZpYyBvcGVyYXRvcnNcclxuICAgIGNsZWFuID0gY2xlYW4ucmVwbGFjZSgvXlt+PSE8Pl0rLywgJycpO1xyXG4gIH1cclxuICBcclxuICAvLyBIYW5kbGUgR28gdmVyc2lvbiBzdWZmaXhlc1xyXG4gIGlmIChsYW5ndWFnZSA9PT0gJ2dvJykge1xyXG4gICAgLy8gUmVtb3ZlICtpbmNvbXBhdGlibGUsICtpbmNvbXBhdGlibGUuMjAyMTAxMDEsIGV0Yy5cclxuICAgIGNsZWFuID0gY2xlYW4ucmVwbGFjZSgvXFwrLiokLywgJycpO1xyXG4gIH1cclxuICBcclxuICAvLyBIYW5kbGUgSmF2YSB2ZXJzaW9uIHJhbmdlc1xyXG4gIGlmIChsYW5ndWFnZSA9PT0gJ2phdmEnKSB7XHJcbiAgICAvLyBFeHRyYWN0IHZlcnNpb24gZnJvbSByYW5nZXMgbGlrZSBbMS4wLDIuMCkgb3IgKDEuMCwyLjBdXHJcbiAgICBjb25zdCByYW5nZU1hdGNoID0gY2xlYW4ubWF0Y2goL1tbKF0oW14sXSspLC8pO1xyXG4gICAgaWYgKHJhbmdlTWF0Y2gpIHtcclxuICAgICAgY2xlYW4gPSByYW5nZU1hdGNoWzFdO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gY2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZlcnNpb24gc3RyaW5nIGlzIHZhbGlkXHJcbiAqIEBwYXJhbSB2ZXJzaW9uU3RyaW5nIFZlcnNpb24gc3RyaW5nXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdmFsaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkVmVyc2lvbih2ZXJzaW9uU3RyaW5nOiBzdHJpbmcsIGxhbmd1YWdlOiBMYW5ndWFnZSk6IGJvb2xlYW4ge1xyXG4gIGlmICghdmVyc2lvblN0cmluZyB8fCB2ZXJzaW9uU3RyaW5nID09PSAnKicpIHJldHVybiBmYWxzZTtcclxuICBcclxuICBjb25zdCBjbGVhbiA9IHBhcnNlVmVyc2lvbih2ZXJzaW9uU3RyaW5nLCBsYW5ndWFnZSk7XHJcbiAgXHJcbiAgLy8gQmFzaWMgdmVyc2lvbiBwYXR0ZXJuIHZhbGlkYXRpb25cclxuICBjb25zdCB2ZXJzaW9uUGF0dGVybnMgPSB7XHJcbiAgICBub2RlOiAvXlxcZCtcXC5cXGQrXFwuXFxkKygtW2EtekEtWjAtOS4tXSspPyhcXCtbYS16QS1aMC05Li1dKyk/JC8sXHJcbiAgICBweXRob246IC9eXFxkK1xcLlxcZCsoXFwuXFxkKyk/KFthLXpBLVowLTkuLV0rKT8kLyxcclxuICAgIGphdmE6IC9eXFxkKyhcXC5cXGQrKSooLVthLXpBLVowLTkuLV0rKT8kLyxcclxuICAgIGdvOiAvXnY/XFxkK1xcLlxcZCtcXC5cXGQrKC1bYS16QS1aMC05Li1dKyk/KFxcK1thLXpBLVowLTkuLV0rKT8kLyxcclxuICAgIGRvdG5ldDogL15cXGQrXFwuXFxkKyhcXC5cXGQrKT8oLVthLXpBLVowLTkuLV0rKT8kLyxcclxuICB9O1xyXG4gIFxyXG4gIGNvbnN0IHBhdHRlcm4gPSB2ZXJzaW9uUGF0dGVybnNbbGFuZ3VhZ2VdO1xyXG4gIHJldHVybiBwYXR0ZXJuID8gcGF0dGVybi50ZXN0KGNsZWFuKSA6IGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIHBhY2thZ2UgbmFtZSBmb3IgY29tcGFyaXNvblxyXG4gKiBAcGFyYW0gcGFja2FnZU5hbWUgUGFja2FnZSBuYW1lXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgcGFja2FnZSBuYW1lXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUGFja2FnZU5hbWUocGFja2FnZU5hbWU6IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogc3RyaW5nIHtcclxuICBsZXQgbm9ybWFsaXplZCA9IHBhY2thZ2VOYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSBzY29wZWQgcGFja2FnZXMgKE5vZGUuanMpXHJcbiAgaWYgKGxhbmd1YWdlID09PSAnbm9kZScgJiYgbm9ybWFsaXplZC5zdGFydHNXaXRoKCdAJykpIHtcclxuICAgIC8vIEtlZXAgQHNjb3BlL3BhY2thZ2UgZm9ybWF0XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIEphdmEgZ3JvdXA6YXJ0aWZhY3QgZm9ybWF0XHJcbiAgaWYgKGxhbmd1YWdlID09PSAnamF2YScgJiYgbm9ybWFsaXplZC5pbmNsdWRlcygnOicpKSB7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIEdvIG1vZHVsZXNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdnbycpIHtcclxuICAgIC8vIFJlbW92ZSBjb21tb24gcHJlZml4ZXNcclxuICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLnJlcGxhY2UoL15naXRodWJcXC5jb21cXC8vLCAnJyk7XHJcbiAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9eZ29sYW5nXFwub3JnXFwveFxcLy8sICcnKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIC5ORVQgcGFja2FnZXNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdkb3RuZXQnKSB7XHJcbiAgICAvLyBSZW1vdmUgY29tbW9uIHByZWZpeGVzXHJcbiAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9ebWljcm9zb2Z0XFwuLywgJycpO1xyXG4gICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXnN5c3RlbVxcLi8sICcnKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHBhY2thZ2UgaXMgaW4gdGhlIGJhc2VsaW5lIHJ1bGVzXHJcbiAqIEBwYXJhbSBwYWNrYWdlTmFtZSBQYWNrYWdlIG5hbWVcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHBhY2thZ2UgaGFzIGJhc2VsaW5lIHJ1bGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzQmFzZWxpbmVSdWxlKFxyXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlLFxyXG4gIHJ1bGVzOiBCYXNlbGluZVJ1bGVzXHJcbik6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IGxhbmd1YWdlUnVsZXMgPSBydWxlcy5wYWNrYWdlX21pbnNbbGFuZ3VhZ2VdIHx8IHt9O1xyXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQYWNrYWdlTmFtZShwYWNrYWdlTmFtZSwgbGFuZ3VhZ2UpO1xyXG4gIFxyXG4gIC8vIENoZWNrIGV4YWN0IG1hdGNoIGZpcnN0XHJcbiAgaWYgKGxhbmd1YWdlUnVsZXNbcGFja2FnZU5hbWVdKSByZXR1cm4gdHJ1ZTtcclxuICBpZiAobGFuZ3VhZ2VSdWxlc1tub3JtYWxpemVkXSkgcmV0dXJuIHRydWU7XHJcbiAgXHJcbiAgLy8gQ2hlY2sgZm9yIHBhcnRpYWwgbWF0Y2hlcyAoZm9yIHNjb3BlZCBwYWNrYWdlcywgZXRjLilcclxuICBmb3IgKGNvbnN0IFtydWxlUGFja2FnZV0gb2YgT2JqZWN0LmVudHJpZXMobGFuZ3VhZ2VSdWxlcykpIHtcclxuICAgIGlmIChub3JtYWxpemVQYWNrYWdlTmFtZShydWxlUGFja2FnZSwgbGFuZ3VhZ2UpID09PSBub3JtYWxpemVkKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYmFzZWxpbmUgdmVyc2lvbiBmb3IgYSBwYWNrYWdlXHJcbiAqIEBwYXJhbSBwYWNrYWdlTmFtZSBQYWNrYWdlIG5hbWVcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcmV0dXJucyBCYXNlbGluZSB2ZXJzaW9uIG9yIG51bGxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXNlbGluZVZlcnNpb24oXHJcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2UsXHJcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNcclxuKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgY29uc3QgbGFuZ3VhZ2VSdWxlcyA9IHJ1bGVzLnBhY2thZ2VfbWluc1tsYW5ndWFnZV0gfHwge307XHJcbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVBhY2thZ2VOYW1lKHBhY2thZ2VOYW1lLCBsYW5ndWFnZSk7XHJcbiAgXHJcbiAgLy8gQ2hlY2sgZXhhY3QgbWF0Y2ggZmlyc3RcclxuICBpZiAobGFuZ3VhZ2VSdWxlc1twYWNrYWdlTmFtZV0pIHJldHVybiBsYW5ndWFnZVJ1bGVzW3BhY2thZ2VOYW1lXTtcclxuICBpZiAobGFuZ3VhZ2VSdWxlc1tub3JtYWxpemVkXSkgcmV0dXJuIGxhbmd1YWdlUnVsZXNbbm9ybWFsaXplZF07XHJcbiAgXHJcbiAgLy8gQ2hlY2sgZm9yIHBhcnRpYWwgbWF0Y2hlc1xyXG4gIGZvciAoY29uc3QgW3J1bGVQYWNrYWdlLCB2ZXJzaW9uXSBvZiBPYmplY3QuZW50cmllcyhsYW5ndWFnZVJ1bGVzKSkge1xyXG4gICAgaWYgKG5vcm1hbGl6ZVBhY2thZ2VOYW1lKHJ1bGVQYWNrYWdlLCBsYW5ndWFnZSkgPT09IG5vcm1hbGl6ZWQpIHtcclxuICAgICAgcmV0dXJuIHZlcnNpb247XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogR3JvdXAgZGVwZW5kZW5jaWVzIGJ5IHN0YXR1c1xyXG4gKiBAcGFyYW0gZmluZGluZ3MgRGVwZW5kZW5jeSBmaW5kaW5nc1xyXG4gKiBAcmV0dXJucyBHcm91cGVkIGZpbmRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBEZXBlbmRlbmNpZXNCeVN0YXR1cyhmaW5kaW5nczogRGVwZW5kZW5jeUZpbmRpbmdbXSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBvazogZmluZGluZ3MuZmlsdGVyKGYgPT4gZi5zdGF0dXMgPT09ICdvaycpLFxyXG4gICAgYWZmZWN0ZWQ6IGZpbmRpbmdzLmZpbHRlcihmID0+IGYuc3RhdHVzID09PSAnYWZmZWN0ZWQnKSxcclxuICAgIHVua25vd246IGZpbmRpbmdzLmZpbHRlcihmID0+IGYuc3RhdHVzID09PSAndW5rbm93bicpLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZGVwZW5kZW5jeSBzdW1tYXJ5IHN0YXRpc3RpY3NcclxuICogQHBhcmFtIGZpbmRpbmdzIERlcGVuZGVuY3kgZmluZGluZ3NcclxuICogQHJldHVybnMgU3VtbWFyeSBzdGF0aXN0aWNzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeVN1bW1hcnkoZmluZGluZ3M6IERlcGVuZGVuY3lGaW5kaW5nW10pIHtcclxuICBjb25zdCB0b3RhbCA9IGZpbmRpbmdzLmxlbmd0aDtcclxuICBjb25zdCBvayA9IGZpbmRpbmdzLmZpbHRlcihmID0+IGYuc3RhdHVzID09PSAnb2snKS5sZW5ndGg7XHJcbiAgY29uc3QgYWZmZWN0ZWQgPSBmaW5kaW5ncy5maWx0ZXIoZiA9PiBmLnN0YXR1cyA9PT0gJ2FmZmVjdGVkJykubGVuZ3RoO1xyXG4gIGNvbnN0IHVua25vd24gPSBmaW5kaW5ncy5maWx0ZXIoZiA9PiBmLnN0YXR1cyA9PT0gJ3Vua25vd24nKS5sZW5ndGg7XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIHRvdGFsLFxyXG4gICAgb2ssXHJcbiAgICBhZmZlY3RlZCxcclxuICAgIHVua25vd24sXHJcbiAgICBva1BlcmNlbnRhZ2U6IHRvdGFsID4gMCA/IChvayAvIHRvdGFsKSAqIDEwMCA6IDAsXHJcbiAgICBhZmZlY3RlZFBlcmNlbnRhZ2U6IHRvdGFsID4gMCA/IChhZmZlY3RlZCAvIHRvdGFsKSAqIDEwMCA6IDAsXHJcbiAgICB1bmtub3duUGVyY2VudGFnZTogdG90YWwgPiAwID8gKHVua25vd24gLyB0b3RhbCkgKiAxMDAgOiAwLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaWx0ZXIgZGVwZW5kZW5jaWVzIGJ5IGxhbmd1YWdlXHJcbiAqIEBwYXJhbSBmaW5kaW5ncyBEZXBlbmRlbmN5IGZpbmRpbmdzXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSB0byBmaWx0ZXIgYnlcclxuICogQHJldHVybnMgRmlsdGVyZWQgZmluZGluZ3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJEZXBlbmRlbmNpZXNCeUxhbmd1YWdlKFxyXG4gIGZpbmRpbmdzOiBEZXBlbmRlbmN5RmluZGluZ1tdLFxyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxyXG4pOiBEZXBlbmRlbmN5RmluZGluZ1tdIHtcclxuICByZXR1cm4gZmluZGluZ3MuZmlsdGVyKGYgPT4gZi5sYW5nID09PSBsYW5ndWFnZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTb3J0IGRlcGVuZGVuY2llcyBieSBzdGF0dXMgYW5kIG5hbWVcclxuICogQHBhcmFtIGZpbmRpbmdzIERlcGVuZGVuY3kgZmluZGluZ3NcclxuICogQHJldHVybnMgU29ydGVkIGZpbmRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29ydERlcGVuZGVuY2llcyhmaW5kaW5nczogRGVwZW5kZW5jeUZpbmRpbmdbXSk6IERlcGVuZGVuY3lGaW5kaW5nW10ge1xyXG4gIGNvbnN0IHN0YXR1c09yZGVyID0geyBhZmZlY3RlZDogMCwgdW5rbm93bjogMSwgb2s6IDIgfTtcclxuICBcclxuICByZXR1cm4gWy4uLmZpbmRpbmdzXS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAvLyBGaXJzdCBieSBzdGF0dXNcclxuICAgIGNvbnN0IHN0YXR1c0RpZmYgPSBzdGF0dXNPcmRlclthLnN0YXR1c10gLSBzdGF0dXNPcmRlcltiLnN0YXR1c107XHJcbiAgICBpZiAoc3RhdHVzRGlmZiAhPT0gMCkgcmV0dXJuIHN0YXR1c0RpZmY7XHJcbiAgICBcclxuICAgIC8vIFRoZW4gYnkgbGFuZ3VhZ2VcclxuICAgIGNvbnN0IGxhbmdEaWZmID0gYS5sYW5nLmxvY2FsZUNvbXBhcmUoYi5sYW5nKTtcclxuICAgIGlmIChsYW5nRGlmZiAhPT0gMCkgcmV0dXJuIGxhbmdEaWZmO1xyXG4gICAgXHJcbiAgICAvLyBGaW5hbGx5IGJ5IGNvbXBvbmVudCBuYW1lXHJcbiAgICByZXR1cm4gYS5jb21wb25lbnQubG9jYWxlQ29tcGFyZShiLmNvbXBvbmVudCk7XHJcbiAgfSk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNvbXBhcmVWZXJzaW9ucyIsImFuYWx5emVEZXBlbmRlbmNpZXMiLCJtYW5pZmVzdHMiLCJydWxlcyIsImZpbmRpbmdzIiwibWFuaWZlc3QiLCJkZXBlbmRlbmNpZXMiLCJsYW5ndWFnZVJ1bGVzIiwicGFja2FnZV9taW5zIiwibGFuZ3VhZ2UiLCJwYWNrYWdlTmFtZSIsImZvdW5kVmVyc2lvbiIsIk9iamVjdCIsImVudHJpZXMiLCJiYXNlbGluZVZlcnNpb24iLCJwdXNoIiwia2luZCIsImxhbmciLCJjb21wb25lbnQiLCJiYXNlbGluZVJlcXVpcmVkIiwic3RhdHVzIiwicmVhc29uIiwiZmlsZSIsImNvbXBhcmlzb24iLCJxdWlja0ZpeCIsImdldERlcGVuZGVuY3lRdWlja0ZpeCIsInZlcnNpb24iLCJ0ZW1wbGF0ZSIsInF1aWNrX2ZpeGVzIiwiZGVwZW5kZW5jeV91cGdyYWRlIiwicmVwbGFjZSIsInBhcnNlVmVyc2lvbiIsInZlcnNpb25TdHJpbmciLCJjbGVhbiIsInRyaW0iLCJyYW5nZU1hdGNoIiwibWF0Y2giLCJpc1ZhbGlkVmVyc2lvbiIsInZlcnNpb25QYXR0ZXJucyIsIm5vZGUiLCJweXRob24iLCJqYXZhIiwiZ28iLCJkb3RuZXQiLCJwYXR0ZXJuIiwidGVzdCIsIm5vcm1hbGl6ZVBhY2thZ2VOYW1lIiwibm9ybWFsaXplZCIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwiaGFzQmFzZWxpbmVSdWxlIiwicnVsZVBhY2thZ2UiLCJnZXRCYXNlbGluZVZlcnNpb24iLCJncm91cERlcGVuZGVuY2llc0J5U3RhdHVzIiwib2siLCJmaWx0ZXIiLCJmIiwiYWZmZWN0ZWQiLCJ1bmtub3duIiwiZ2V0RGVwZW5kZW5jeVN1bW1hcnkiLCJ0b3RhbCIsImxlbmd0aCIsIm9rUGVyY2VudGFnZSIsImFmZmVjdGVkUGVyY2VudGFnZSIsInVua25vd25QZXJjZW50YWdlIiwiZmlsdGVyRGVwZW5kZW5jaWVzQnlMYW5ndWFnZSIsInNvcnREZXBlbmRlbmNpZXMiLCJzdGF0dXNPcmRlciIsInNvcnQiLCJhIiwiYiIsInN0YXR1c0RpZmYiLCJsYW5nRGlmZiIsImxvY2FsZUNvbXBhcmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/deps.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/detect.ts":
/*!********************************!*\
  !*** ./lib/analysis/detect.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectLanguagesFromFiles: () => (/* binding */ detectLanguagesFromFiles),\n/* harmony export */   detectProjectManifests: () => (/* binding */ detectProjectManifests),\n/* harmony export */   getManifestType: () => (/* binding */ getManifestType),\n/* harmony export */   getPrimaryLanguage: () => (/* binding */ getPrimaryLanguage),\n/* harmony export */   isManifestFile: () => (/* binding */ isManifestFile)\n/* harmony export */ });\n/**\r\n * Detect project languages and manifests from extracted files\r\n * @param files Array of extracted files\r\n * @returns Array of detected project manifests\r\n */ function detectProjectManifests(files) {\n    const manifests = [];\n    // Look for package.json (Node.js)\n    const packageJson = files.find((f)=>(f.path || f.name)?.endsWith('package.json'));\n    if (packageJson) {\n        try {\n            const pkg = JSON.parse(packageJson.content);\n            manifests.push({\n                language: 'node',\n                file: packageJson.path || packageJson.name || 'package.json',\n                dependencies: pkg.dependencies,\n                devDependencies: pkg.devDependencies,\n                peerDependencies: pkg.peerDependencies,\n                optionalDependencies: pkg.optionalDependencies\n            });\n        } catch (error) {\n            console.warn(`Failed to parse package.json: ${error}`);\n        }\n    }\n    // Look for requirements.txt (Python)\n    const requirementsTxt = files.find((f)=>(f.path || f.name)?.endsWith('requirements.txt'));\n    if (requirementsTxt) {\n        manifests.push({\n            language: 'python',\n            file: requirementsTxt.path || requirementsTxt.name || 'requirements.txt',\n            dependencies: parseRequirementsTxt(requirementsTxt.content)\n        });\n    }\n    // Look for pyproject.toml (Python)\n    const pyprojectToml = files.find((f)=>(f.path || f.name)?.endsWith('pyproject.toml'));\n    if (pyprojectToml) {\n        try {\n            const deps = parsePyprojectToml(pyprojectToml.content);\n            if (deps) {\n                manifests.push({\n                    language: 'python',\n                    file: pyprojectToml.path || pyprojectToml.name || 'pyproject.toml',\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse pyproject.toml: ${error}`);\n        }\n    }\n    // Look for pom.xml (Java Maven)\n    const pomXml = files.find((f)=>(f.path || f.name)?.endsWith('pom.xml'));\n    if (pomXml) {\n        try {\n            const deps = parsePomXml(pomXml.content);\n            if (deps) {\n                manifests.push({\n                    language: 'java',\n                    file: pomXml.path || pomXml.name || 'pom.xml',\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse pom.xml: ${error}`);\n        }\n    }\n    // Look for build.gradle (Java Gradle)\n    const buildGradle = files.find((f)=>{\n        const path = f.path || f.name;\n        return path?.endsWith('build.gradle') || path?.endsWith('build.gradle.kts');\n    });\n    if (buildGradle) {\n        try {\n            const deps = parseBuildGradle(buildGradle.content);\n            if (deps) {\n                manifests.push({\n                    language: 'java',\n                    file: buildGradle.path || buildGradle.name || 'build.gradle',\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse build.gradle: ${error}`);\n        }\n    }\n    // Look for go.mod (Go)\n    const goMod = files.find((f)=>(f.path || f.name)?.endsWith('go.mod'));\n    if (goMod) {\n        try {\n            const deps = parseGoMod(goMod.content);\n            if (deps) {\n                manifests.push({\n                    language: 'go',\n                    file: goMod.path || goMod.name || 'go.mod',\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse go.mod: ${error}`);\n        }\n    }\n    // Look for .csproj files (.NET)\n    const csprojFiles = files.filter((f)=>(f.path || f.name)?.endsWith('.csproj'));\n    for (const csproj of csprojFiles){\n        try {\n            const deps = parseCsproj(csproj.content);\n            if (deps) {\n                manifests.push({\n                    language: 'dotnet',\n                    file: csproj.path || csproj.name || 'project.csproj',\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse ${csproj.path || csproj.name || 'project.csproj'}: ${error}`);\n        }\n    }\n    return manifests;\n}\n/**\r\n * Parse requirements.txt content\r\n * @param content requirements.txt content\r\n * @returns Dependencies object\r\n */ function parseRequirementsTxt(content) {\n    const deps = {};\n    const lines = content.split('\\n');\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (!trimmed || trimmed.startsWith('#')) continue;\n        // Handle various requirement formats\n        // package==1.0.0\n        // package>=1.0.0\n        // package~=1.0.0\n        // package\n        const match = trimmed.match(/^([a-zA-Z0-9_-]+)(.*)$/);\n        if (match) {\n            const [, name, version] = match;\n            deps[name] = version || '*';\n        }\n    }\n    return deps;\n}\n/**\r\n * Parse pyproject.toml content (basic parsing)\r\n * @param content pyproject.toml content\r\n * @returns Dependencies object or null\r\n */ function parsePyprojectToml(content) {\n    const deps = {};\n    // Simple TOML parsing for dependencies\n    const lines = content.split('\\n');\n    let inDependencies = false;\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (trimmed.startsWith('[tool.poetry.dependencies]') || trimmed.startsWith('[project.dependencies]') || trimmed.startsWith('[dependencies]')) {\n            inDependencies = true;\n            continue;\n        }\n        if (trimmed.startsWith('[') && inDependencies) {\n            break;\n        }\n        if (inDependencies && trimmed && !trimmed.startsWith('#')) {\n            const match = trimmed.match(/^([a-zA-Z0-9_-]+)\\s*=\\s*[\"']?([^\"']+)[\"']?/);\n            if (match) {\n                const [, name, version] = match;\n                deps[name] = version;\n            }\n        }\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse pom.xml content (basic XML parsing)\r\n * @param content pom.xml content\r\n * @returns Dependencies object or null\r\n */ function parsePomXml(content) {\n    const deps = {};\n    // Simple XML parsing for dependencies\n    const dependencyRegex = /<dependency>\\s*<groupId>([^<]+)<\\/groupId>\\s*<artifactId>([^<]+)<\\/artifactId>\\s*<version>([^<]+)<\\/version>/g;\n    let match;\n    while((match = dependencyRegex.exec(content)) !== null){\n        const [, groupId, artifactId, version] = match;\n        const fullName = `${groupId}:${artifactId}`;\n        deps[fullName] = version;\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse build.gradle content (basic parsing)\r\n * @param content build.gradle content\r\n * @returns Dependencies object or null\r\n */ function parseBuildGradle(content) {\n    const deps = {};\n    // Simple Gradle parsing for dependencies\n    const lines = content.split('\\n');\n    let inDependencies = false;\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (trimmed.includes('dependencies') && trimmed.includes('{')) {\n            inDependencies = true;\n            continue;\n        }\n        if (trimmed === '}' && inDependencies) {\n            break;\n        }\n        if (inDependencies && trimmed.includes('implementation') || trimmed.includes('compile')) {\n            // implementation 'group:artifact:version'\n            // implementation(\"group:artifact:version\")\n            const match = trimmed.match(/(?:implementation|compile)\\s*[(\"]?([^:)]+):([^:)]+):([^:)]+)/);\n            if (match) {\n                const [, group, artifact, version] = match;\n                const fullName = `${group}:${artifact}`;\n                deps[fullName] = version;\n            }\n        }\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse go.mod content\r\n * @param content go.mod content\r\n * @returns Dependencies object or null\r\n */ function parseGoMod(content) {\n    const deps = {};\n    const lines = content.split('\\n');\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (trimmed.startsWith('require')) {\n            continue;\n        }\n        if (trimmed.startsWith('require ')) {\n            // require module v1.0.0\n            const match = trimmed.match(/require\\s+([^\\s]+)\\s+([^\\s]+)/);\n            if (match) {\n                const [, module, version] = match;\n                deps[module] = version;\n            }\n        } else if (trimmed && !trimmed.startsWith('go ') && !trimmed.startsWith('module ') && !trimmed.startsWith('//')) {\n            // Module version line\n            const match = trimmed.match(/^([^\\s]+)\\s+([^\\s]+)/);\n            if (match) {\n                const [, module, version] = match;\n                deps[module] = version;\n            }\n        }\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse .csproj content (basic XML parsing)\r\n * @param content .csproj content\r\n * @returns Dependencies object or null\r\n */ function parseCsproj(content) {\n    const deps = {};\n    // Simple XML parsing for PackageReference\n    const packageRefRegex = /<PackageReference\\s+Include=\"([^\"]+)\"\\s+Version=\"([^\"]+)\"\\s*\\/?>/g;\n    let match;\n    while((match = packageRefRegex.exec(content)) !== null){\n        const [, packageName, version] = match;\n        deps[packageName] = version;\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Detect languages from file extensions\r\n * @param files Array of extracted files\r\n * @returns Array of detected languages\r\n */ function detectLanguagesFromFiles(files) {\n    const languageMap = {\n        '.js': 'node',\n        '.jsx': 'node',\n        '.ts': 'node',\n        '.tsx': 'node',\n        '.py': 'python',\n        '.java': 'java',\n        '.go': 'go',\n        '.cs': 'dotnet',\n        '.fs': 'dotnet',\n        '.vb': 'dotnet'\n    };\n    const detectedLanguages = new Set();\n    for (const file of files){\n        const filePath = file.path || file.name;\n        if (filePath) {\n            const ext = getFileExtension(filePath);\n            const language = languageMap[ext];\n            if (language) {\n                detectedLanguages.add(language);\n            }\n        }\n    }\n    return Array.from(detectedLanguages);\n}\n/**\r\n * Get file extension from path\r\n * @param filePath File path\r\n * @returns File extension with dot\r\n */ function getFileExtension(filePath) {\n    const lastDot = filePath.lastIndexOf('.');\n    if (lastDot === -1) return '';\n    return filePath.substring(lastDot);\n}\n/**\r\n * Get primary language from manifests\r\n * @param manifests Array of project manifests\r\n * @returns Primary language or null\r\n */ function getPrimaryLanguage(manifests) {\n    if (manifests.length === 0) return null;\n    // Priority order: node, python, java, go, dotnet\n    const priority = [\n        'node',\n        'python',\n        'java',\n        'go',\n        'dotnet'\n    ];\n    for (const lang of priority){\n        if (manifests.some((m)=>m.language === lang)) {\n            return lang;\n        }\n    }\n    return manifests[0].language;\n}\n/**\r\n * Check if a file is a manifest file\r\n * @param filePath File path\r\n * @returns True if it's a manifest file\r\n */ function isManifestFile(filePath) {\n    const manifestFiles = [\n        'package.json',\n        'requirements.txt',\n        'pyproject.toml',\n        'pom.xml',\n        'build.gradle',\n        'build.gradle.kts',\n        'go.mod',\n        '.csproj'\n    ];\n    return manifestFiles.some((manifest)=>filePath.endsWith(manifest));\n}\n/**\r\n * Get manifest file type from path\r\n * @param filePath File path\r\n * @returns Manifest type or null\r\n */ function getManifestType(filePath) {\n    if (filePath.endsWith('package.json')) {\n        return {\n            language: 'node',\n            type: 'package.json'\n        };\n    }\n    if (filePath.endsWith('requirements.txt')) {\n        return {\n            language: 'python',\n            type: 'requirements.txt'\n        };\n    }\n    if (filePath.endsWith('pyproject.toml')) {\n        return {\n            language: 'python',\n            type: 'pyproject.toml'\n        };\n    }\n    if (filePath.endsWith('pom.xml')) {\n        return {\n            language: 'java',\n            type: 'pom.xml'\n        };\n    }\n    if (filePath.endsWith('build.gradle') || filePath.endsWith('build.gradle.kts')) {\n        return {\n            language: 'java',\n            type: 'build.gradle'\n        };\n    }\n    if (filePath.endsWith('go.mod')) {\n        return {\n            language: 'go',\n            type: 'go.mod'\n        };\n    }\n    if (filePath.endsWith('.csproj')) {\n        return {\n            language: 'dotnet',\n            type: '.csproj'\n        };\n    }\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFVO1lBQVFxRSxNQUFNO1FBQVU7SUFDN0M7SUFDQSxJQUFJbEIsU0FBU3pELFFBQVEsQ0FBQyxtQkFBbUJ5RCxTQUFTekQsUUFBUSxDQUFDLHFCQUFxQjtRQUM5RSxPQUFPO1lBQUVNLFVBQVU7WUFBUXFFLE1BQU07UUFBZTtJQUNsRDtJQUNBLElBQUlsQixTQUFTekQsUUFBUSxDQUFDLFdBQVc7UUFDL0IsT0FBTztZQUFFTSxVQUFVO1lBQU1xRSxNQUFNO1FBQVM7SUFDMUM7SUFDQSxJQUFJbEIsU0FBU3pELFFBQVEsQ0FBQyxZQUFZO1FBQ2hDLE9BQU87WUFBRU0sVUFBVTtZQUFVcUUsTUFBTTtRQUFVO0lBQy9DO0lBRUEsT0FBTztBQUNUIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxkZXRlY3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTGFuZ3VhZ2UsIFByb2plY3RNYW5pZmVzdCB9IGZyb20gJy4vYmFzZWxpbmUudHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIERldGVjdCBwcm9qZWN0IGxhbmd1YWdlcyBhbmQgbWFuaWZlc3RzIGZyb20gZXh0cmFjdGVkIGZpbGVzXHJcbiAqIEBwYXJhbSBmaWxlcyBBcnJheSBvZiBleHRyYWN0ZWQgZmlsZXNcclxuICogQHJldHVybnMgQXJyYXkgb2YgZGV0ZWN0ZWQgcHJvamVjdCBtYW5pZmVzdHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RQcm9qZWN0TWFuaWZlc3RzKGZpbGVzOiB7IHBhdGg/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZyB9W10pOiBQcm9qZWN0TWFuaWZlc3RbXSB7XHJcbiAgY29uc3QgbWFuaWZlc3RzOiBQcm9qZWN0TWFuaWZlc3RbXSA9IFtdO1xyXG4gIFxyXG4gIC8vIExvb2sgZm9yIHBhY2thZ2UuanNvbiAoTm9kZS5qcylcclxuICBjb25zdCBwYWNrYWdlSnNvbiA9IGZpbGVzLmZpbmQoZiA9PiAoZi5wYXRoIHx8IGYubmFtZSk/LmVuZHNXaXRoKCdwYWNrYWdlLmpzb24nKSk7XHJcbiAgaWYgKHBhY2thZ2VKc29uKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwa2cgPSBKU09OLnBhcnNlKHBhY2thZ2VKc29uLmNvbnRlbnQpO1xyXG4gICAgICBtYW5pZmVzdHMucHVzaCh7XHJcbiAgICAgICAgbGFuZ3VhZ2U6ICdub2RlJyxcclxuICAgICAgICBmaWxlOiBwYWNrYWdlSnNvbi5wYXRoIHx8IHBhY2thZ2VKc29uLm5hbWUgfHwgJ3BhY2thZ2UuanNvbicsXHJcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBwa2cuZGVwZW5kZW5jaWVzLFxyXG4gICAgICAgIGRldkRlcGVuZGVuY2llczogcGtnLmRldkRlcGVuZGVuY2llcyxcclxuICAgICAgICBwZWVyRGVwZW5kZW5jaWVzOiBwa2cucGVlckRlcGVuZGVuY2llcyxcclxuICAgICAgICBvcHRpb25hbERlcGVuZGVuY2llczogcGtnLm9wdGlvbmFsRGVwZW5kZW5jaWVzLFxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHBhcnNlIHBhY2thZ2UuanNvbjogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgcmVxdWlyZW1lbnRzLnR4dCAoUHl0aG9uKVxyXG4gIGNvbnN0IHJlcXVpcmVtZW50c1R4dCA9IGZpbGVzLmZpbmQoZiA9PiAoZi5wYXRoIHx8IGYubmFtZSk/LmVuZHNXaXRoKCdyZXF1aXJlbWVudHMudHh0JykpO1xyXG4gIGlmIChyZXF1aXJlbWVudHNUeHQpIHtcclxuICAgIG1hbmlmZXN0cy5wdXNoKHtcclxuICAgICAgbGFuZ3VhZ2U6ICdweXRob24nLFxyXG4gICAgICAgIGZpbGU6IHJlcXVpcmVtZW50c1R4dC5wYXRoIHx8IHJlcXVpcmVtZW50c1R4dC5uYW1lIHx8ICdyZXF1aXJlbWVudHMudHh0JyxcclxuICAgICAgZGVwZW5kZW5jaWVzOiBwYXJzZVJlcXVpcmVtZW50c1R4dChyZXF1aXJlbWVudHNUeHQuY29udGVudCksXHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgcHlwcm9qZWN0LnRvbWwgKFB5dGhvbilcclxuICBjb25zdCBweXByb2plY3RUb21sID0gZmlsZXMuZmluZChmID0+IChmLnBhdGggfHwgZi5uYW1lKT8uZW5kc1dpdGgoJ3B5cHJvamVjdC50b21sJykpO1xyXG4gIGlmIChweXByb2plY3RUb21sKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkZXBzID0gcGFyc2VQeXByb2plY3RUb21sKHB5cHJvamVjdFRvbWwuY29udGVudCk7XHJcbiAgICAgIGlmIChkZXBzKSB7XHJcbiAgICAgICAgbWFuaWZlc3RzLnB1c2goe1xyXG4gICAgICAgICAgbGFuZ3VhZ2U6ICdweXRob24nLFxyXG4gICAgICAgICAgZmlsZTogcHlwcm9qZWN0VG9tbC5wYXRoIHx8IHB5cHJvamVjdFRvbWwubmFtZSB8fCAncHlwcm9qZWN0LnRvbWwnLFxyXG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBkZXBzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBwYXJzZSBweXByb2plY3QudG9tbDogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgcG9tLnhtbCAoSmF2YSBNYXZlbilcclxuICBjb25zdCBwb21YbWwgPSBmaWxlcy5maW5kKGYgPT4gKGYucGF0aCB8fCBmLm5hbWUpPy5lbmRzV2l0aCgncG9tLnhtbCcpKTtcclxuICBpZiAocG9tWG1sKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkZXBzID0gcGFyc2VQb21YbWwocG9tWG1sLmNvbnRlbnQpO1xyXG4gICAgICBpZiAoZGVwcykge1xyXG4gICAgICAgIG1hbmlmZXN0cy5wdXNoKHtcclxuICAgICAgICAgIGxhbmd1YWdlOiAnamF2YScsXHJcbiAgICAgICAgICBmaWxlOiBwb21YbWwucGF0aCB8fCBwb21YbWwubmFtZSB8fCAncG9tLnhtbCcsXHJcbiAgICAgICAgICBkZXBlbmRlbmNpZXM6IGRlcHMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHBhcnNlIHBvbS54bWw6ICR7ZXJyb3J9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIExvb2sgZm9yIGJ1aWxkLmdyYWRsZSAoSmF2YSBHcmFkbGUpXHJcbiAgY29uc3QgYnVpbGRHcmFkbGUgPSBmaWxlcy5maW5kKGYgPT4ge1xyXG4gICAgY29uc3QgcGF0aCA9IGYucGF0aCB8fCBmLm5hbWU7XHJcbiAgICByZXR1cm4gcGF0aD8uZW5kc1dpdGgoJ2J1aWxkLmdyYWRsZScpIHx8IHBhdGg/LmVuZHNXaXRoKCdidWlsZC5ncmFkbGUua3RzJyk7XHJcbiAgfSk7XHJcbiAgaWYgKGJ1aWxkR3JhZGxlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkZXBzID0gcGFyc2VCdWlsZEdyYWRsZShidWlsZEdyYWRsZS5jb250ZW50KTtcclxuICAgICAgaWYgKGRlcHMpIHtcclxuICAgICAgICBtYW5pZmVzdHMucHVzaCh7XHJcbiAgICAgICAgICBsYW5ndWFnZTogJ2phdmEnLFxyXG4gICAgICAgICAgZmlsZTogYnVpbGRHcmFkbGUucGF0aCB8fCBidWlsZEdyYWRsZS5uYW1lIHx8ICdidWlsZC5ncmFkbGUnLFxyXG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBkZXBzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBwYXJzZSBidWlsZC5ncmFkbGU6ICR7ZXJyb3J9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIExvb2sgZm9yIGdvLm1vZCAoR28pXHJcbiAgY29uc3QgZ29Nb2QgPSBmaWxlcy5maW5kKGYgPT4gKGYucGF0aCB8fCBmLm5hbWUpPy5lbmRzV2l0aCgnZ28ubW9kJykpO1xyXG4gIGlmIChnb01vZCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGVwcyA9IHBhcnNlR29Nb2QoZ29Nb2QuY29udGVudCk7XHJcbiAgICAgIGlmIChkZXBzKSB7XHJcbiAgICAgICAgbWFuaWZlc3RzLnB1c2goe1xyXG4gICAgICAgICAgbGFuZ3VhZ2U6ICdnbycsXHJcbiAgICAgICAgICBmaWxlOiBnb01vZC5wYXRoIHx8IGdvTW9kLm5hbWUgfHwgJ2dvLm1vZCcsXHJcbiAgICAgICAgICBkZXBlbmRlbmNpZXM6IGRlcHMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHBhcnNlIGdvLm1vZDogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgLmNzcHJvaiBmaWxlcyAoLk5FVClcclxuICBjb25zdCBjc3Byb2pGaWxlcyA9IGZpbGVzLmZpbHRlcihmID0+IChmLnBhdGggfHwgZi5uYW1lKT8uZW5kc1dpdGgoJy5jc3Byb2onKSk7XHJcbiAgZm9yIChjb25zdCBjc3Byb2ogb2YgY3Nwcm9qRmlsZXMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRlcHMgPSBwYXJzZUNzcHJvaihjc3Byb2ouY29udGVudCk7XHJcbiAgICAgIGlmIChkZXBzKSB7XHJcbiAgICAgICAgbWFuaWZlc3RzLnB1c2goe1xyXG4gICAgICAgICAgbGFuZ3VhZ2U6ICdkb3RuZXQnLFxyXG4gICAgICAgICAgZmlsZTogY3Nwcm9qLnBhdGggfHwgY3Nwcm9qLm5hbWUgfHwgJ3Byb2plY3QuY3Nwcm9qJyxcclxuICAgICAgICAgIGRlcGVuZGVuY2llczogZGVwcyxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gcGFyc2UgJHtjc3Byb2oucGF0aCB8fCBjc3Byb2oubmFtZSB8fCAncHJvamVjdC5jc3Byb2onfTogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIG1hbmlmZXN0cztcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHJlcXVpcmVtZW50cy50eHQgY29udGVudFxyXG4gKiBAcGFyYW0gY29udGVudCByZXF1aXJlbWVudHMudHh0IGNvbnRlbnRcclxuICogQHJldHVybnMgRGVwZW5kZW5jaWVzIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VSZXF1aXJlbWVudHNUeHQoY29udGVudDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XHJcbiAgY29uc3QgZGVwczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xyXG4gIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XHJcbiAgXHJcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XHJcbiAgICBpZiAoIXRyaW1tZWQgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCcjJykpIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgdmFyaW91cyByZXF1aXJlbWVudCBmb3JtYXRzXHJcbiAgICAvLyBwYWNrYWdlPT0xLjAuMFxyXG4gICAgLy8gcGFja2FnZT49MS4wLjBcclxuICAgIC8vIHBhY2thZ2V+PTEuMC4wXHJcbiAgICAvLyBwYWNrYWdlXHJcbiAgICBjb25zdCBtYXRjaCA9IHRyaW1tZWQubWF0Y2goL14oW2EtekEtWjAtOV8tXSspKC4qKSQvKTtcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICBjb25zdCBbLCBuYW1lLCB2ZXJzaW9uXSA9IG1hdGNoO1xyXG4gICAgICBkZXBzW25hbWVdID0gdmVyc2lvbiB8fCAnKic7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBkZXBzO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgcHlwcm9qZWN0LnRvbWwgY29udGVudCAoYmFzaWMgcGFyc2luZylcclxuICogQHBhcmFtIGNvbnRlbnQgcHlwcm9qZWN0LnRvbWwgY29udGVudFxyXG4gKiBAcmV0dXJucyBEZXBlbmRlbmNpZXMgb2JqZWN0IG9yIG51bGxcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlUHlwcm9qZWN0VG9tbChjb250ZW50OiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbCB7XHJcbiAgY29uc3QgZGVwczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xyXG4gIFxyXG4gIC8vIFNpbXBsZSBUT01MIHBhcnNpbmcgZm9yIGRlcGVuZGVuY2llc1xyXG4gIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XHJcbiAgbGV0IGluRGVwZW5kZW5jaWVzID0gZmFsc2U7XHJcbiAgXHJcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XHJcbiAgICBcclxuICAgIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoJ1t0b29sLnBvZXRyeS5kZXBlbmRlbmNpZXNdJykgfHwgXHJcbiAgICAgICAgdHJpbW1lZC5zdGFydHNXaXRoKCdbcHJvamVjdC5kZXBlbmRlbmNpZXNdJykgfHxcclxuICAgICAgICB0cmltbWVkLnN0YXJ0c1dpdGgoJ1tkZXBlbmRlbmNpZXNdJykpIHtcclxuICAgICAgaW5EZXBlbmRlbmNpZXMgPSB0cnVlO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRyaW1tZWQuc3RhcnRzV2l0aCgnWycpICYmIGluRGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoaW5EZXBlbmRlbmNpZXMgJiYgdHJpbW1lZCAmJiAhdHJpbW1lZC5zdGFydHNXaXRoKCcjJykpIHtcclxuICAgICAgY29uc3QgbWF0Y2ggPSB0cmltbWVkLm1hdGNoKC9eKFthLXpBLVowLTlfLV0rKVxccyo9XFxzKltcIiddPyhbXlwiJ10rKVtcIiddPy8pO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBbLCBuYW1lLCB2ZXJzaW9uXSA9IG1hdGNoO1xyXG4gICAgICAgIGRlcHNbbmFtZV0gPSB2ZXJzaW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBPYmplY3Qua2V5cyhkZXBzKS5sZW5ndGggPiAwID8gZGVwcyA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBwb20ueG1sIGNvbnRlbnQgKGJhc2ljIFhNTCBwYXJzaW5nKVxyXG4gKiBAcGFyYW0gY29udGVudCBwb20ueG1sIGNvbnRlbnRcclxuICogQHJldHVybnMgRGVwZW5kZW5jaWVzIG9iamVjdCBvciBudWxsXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVBvbVhtbChjb250ZW50OiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbCB7XHJcbiAgY29uc3QgZGVwczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xyXG4gIFxyXG4gIC8vIFNpbXBsZSBYTUwgcGFyc2luZyBmb3IgZGVwZW5kZW5jaWVzXHJcbiAgY29uc3QgZGVwZW5kZW5jeVJlZ2V4ID0gLzxkZXBlbmRlbmN5Plxccyo8Z3JvdXBJZD4oW148XSspPFxcL2dyb3VwSWQ+XFxzKjxhcnRpZmFjdElkPihbXjxdKyk8XFwvYXJ0aWZhY3RJZD5cXHMqPHZlcnNpb24+KFtePF0rKTxcXC92ZXJzaW9uPi9nO1xyXG4gIGxldCBtYXRjaDtcclxuICBcclxuICB3aGlsZSAoKG1hdGNoID0gZGVwZW5kZW5jeVJlZ2V4LmV4ZWMoY29udGVudCkpICE9PSBudWxsKSB7XHJcbiAgICBjb25zdCBbLCBncm91cElkLCBhcnRpZmFjdElkLCB2ZXJzaW9uXSA9IG1hdGNoO1xyXG4gICAgY29uc3QgZnVsbE5hbWUgPSBgJHtncm91cElkfToke2FydGlmYWN0SWR9YDtcclxuICAgIGRlcHNbZnVsbE5hbWVdID0gdmVyc2lvbjtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRlcHMpLmxlbmd0aCA+IDAgPyBkZXBzIDogbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIGJ1aWxkLmdyYWRsZSBjb250ZW50IChiYXNpYyBwYXJzaW5nKVxyXG4gKiBAcGFyYW0gY29udGVudCBidWlsZC5ncmFkbGUgY29udGVudFxyXG4gKiBAcmV0dXJucyBEZXBlbmRlbmNpZXMgb2JqZWN0IG9yIG51bGxcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlQnVpbGRHcmFkbGUoY29udGVudDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IG51bGwge1xyXG4gIGNvbnN0IGRlcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcclxuICBcclxuICAvLyBTaW1wbGUgR3JhZGxlIHBhcnNpbmcgZm9yIGRlcGVuZGVuY2llc1xyXG4gIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XHJcbiAgbGV0IGluRGVwZW5kZW5jaWVzID0gZmFsc2U7XHJcbiAgXHJcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XHJcbiAgICBcclxuICAgIGlmICh0cmltbWVkLmluY2x1ZGVzKCdkZXBlbmRlbmNpZXMnKSAmJiB0cmltbWVkLmluY2x1ZGVzKCd7JykpIHtcclxuICAgICAgaW5EZXBlbmRlbmNpZXMgPSB0cnVlO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRyaW1tZWQgPT09ICd9JyAmJiBpbkRlcGVuZGVuY2llcykge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKGluRGVwZW5kZW5jaWVzICYmIHRyaW1tZWQuaW5jbHVkZXMoJ2ltcGxlbWVudGF0aW9uJykgfHwgdHJpbW1lZC5pbmNsdWRlcygnY29tcGlsZScpKSB7XHJcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uICdncm91cDphcnRpZmFjdDp2ZXJzaW9uJ1xyXG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbihcImdyb3VwOmFydGlmYWN0OnZlcnNpb25cIilcclxuICAgICAgY29uc3QgbWF0Y2ggPSB0cmltbWVkLm1hdGNoKC8oPzppbXBsZW1lbnRhdGlvbnxjb21waWxlKVxccypbKFwiXT8oW146KV0rKTooW146KV0rKTooW146KV0rKS8pO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBbLCBncm91cCwgYXJ0aWZhY3QsIHZlcnNpb25dID0gbWF0Y2g7XHJcbiAgICAgICAgY29uc3QgZnVsbE5hbWUgPSBgJHtncm91cH06JHthcnRpZmFjdH1gO1xyXG4gICAgICAgIGRlcHNbZnVsbE5hbWVdID0gdmVyc2lvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gT2JqZWN0LmtleXMoZGVwcykubGVuZ3RoID4gMCA/IGRlcHMgOiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgZ28ubW9kIGNvbnRlbnRcclxuICogQHBhcmFtIGNvbnRlbnQgZ28ubW9kIGNvbnRlbnRcclxuICogQHJldHVybnMgRGVwZW5kZW5jaWVzIG9iamVjdCBvciBudWxsXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUdvTW9kKGNvbnRlbnQ6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBudWxsIHtcclxuICBjb25zdCBkZXBzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XHJcbiAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcclxuICBcclxuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcclxuICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcclxuICAgIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoJ3JlcXVpcmUnKSkge1xyXG4gICAgICAvLyByZXF1aXJlIChcclxuICAgICAgLy8gICBtb2R1bGUgdjEuMC4wXHJcbiAgICAgIC8vIClcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoJ3JlcXVpcmUgJykpIHtcclxuICAgICAgLy8gcmVxdWlyZSBtb2R1bGUgdjEuMC4wXHJcbiAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaCgvcmVxdWlyZVxccysoW15cXHNdKylcXHMrKFteXFxzXSspLyk7XHJcbiAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IFssIG1vZHVsZSwgdmVyc2lvbl0gPSBtYXRjaDtcclxuICAgICAgICBkZXBzW21vZHVsZV0gPSB2ZXJzaW9uO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRyaW1tZWQgJiYgIXRyaW1tZWQuc3RhcnRzV2l0aCgnZ28gJykgJiYgIXRyaW1tZWQuc3RhcnRzV2l0aCgnbW9kdWxlICcpICYmICF0cmltbWVkLnN0YXJ0c1dpdGgoJy8vJykpIHtcclxuICAgICAgLy8gTW9kdWxlIHZlcnNpb24gbGluZVxyXG4gICAgICBjb25zdCBtYXRjaCA9IHRyaW1tZWQubWF0Y2goL14oW15cXHNdKylcXHMrKFteXFxzXSspLyk7XHJcbiAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IFssIG1vZHVsZSwgdmVyc2lvbl0gPSBtYXRjaDtcclxuICAgICAgICBkZXBzW21vZHVsZV0gPSB2ZXJzaW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBPYmplY3Qua2V5cyhkZXBzKS5sZW5ndGggPiAwID8gZGVwcyA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSAuY3Nwcm9qIGNvbnRlbnQgKGJhc2ljIFhNTCBwYXJzaW5nKVxyXG4gKiBAcGFyYW0gY29udGVudCAuY3Nwcm9qIGNvbnRlbnRcclxuICogQHJldHVybnMgRGVwZW5kZW5jaWVzIG9iamVjdCBvciBudWxsXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUNzcHJvaihjb250ZW50OiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbCB7XHJcbiAgY29uc3QgZGVwczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xyXG4gIFxyXG4gIC8vIFNpbXBsZSBYTUwgcGFyc2luZyBmb3IgUGFja2FnZVJlZmVyZW5jZVxyXG4gIGNvbnN0IHBhY2thZ2VSZWZSZWdleCA9IC88UGFja2FnZVJlZmVyZW5jZVxccytJbmNsdWRlPVwiKFteXCJdKylcIlxccytWZXJzaW9uPVwiKFteXCJdKylcIlxccypcXC8/Pi9nO1xyXG4gIGxldCBtYXRjaDtcclxuICBcclxuICB3aGlsZSAoKG1hdGNoID0gcGFja2FnZVJlZlJlZ2V4LmV4ZWMoY29udGVudCkpICE9PSBudWxsKSB7XHJcbiAgICBjb25zdCBbLCBwYWNrYWdlTmFtZSwgdmVyc2lvbl0gPSBtYXRjaDtcclxuICAgIGRlcHNbcGFja2FnZU5hbWVdID0gdmVyc2lvbjtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRlcHMpLmxlbmd0aCA+IDAgPyBkZXBzIDogbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVjdCBsYW5ndWFnZXMgZnJvbSBmaWxlIGV4dGVuc2lvbnNcclxuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBkZXRlY3RlZCBsYW5ndWFnZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RMYW5ndWFnZXNGcm9tRmlsZXMoZmlsZXM6IHsgcGF0aD86IHN0cmluZzsgbmFtZT86IHN0cmluZyB9W10pOiBMYW5ndWFnZVtdIHtcclxuICBjb25zdCBsYW5ndWFnZU1hcDogUmVjb3JkPHN0cmluZywgTGFuZ3VhZ2U+ID0ge1xyXG4gICAgJy5qcyc6ICdub2RlJyxcclxuICAgICcuanN4JzogJ25vZGUnLFxyXG4gICAgJy50cyc6ICdub2RlJyxcclxuICAgICcudHN4JzogJ25vZGUnLFxyXG4gICAgJy5weSc6ICdweXRob24nLFxyXG4gICAgJy5qYXZhJzogJ2phdmEnLFxyXG4gICAgJy5nbyc6ICdnbycsXHJcbiAgICAnLmNzJzogJ2RvdG5ldCcsXHJcbiAgICAnLmZzJzogJ2RvdG5ldCcsXHJcbiAgICAnLnZiJzogJ2RvdG5ldCcsXHJcbiAgfTtcclxuICBcclxuICBjb25zdCBkZXRlY3RlZExhbmd1YWdlcyA9IG5ldyBTZXQ8TGFuZ3VhZ2U+KCk7XHJcbiAgXHJcbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aCB8fCBmaWxlLm5hbWU7XHJcbiAgICBpZiAoZmlsZVBhdGgpIHtcclxuICAgICAgY29uc3QgZXh0ID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XHJcbiAgICAgIGNvbnN0IGxhbmd1YWdlID0gbGFuZ3VhZ2VNYXBbZXh0XTtcclxuICAgICAgaWYgKGxhbmd1YWdlKSB7XHJcbiAgICAgICAgZGV0ZWN0ZWRMYW5ndWFnZXMuYWRkKGxhbmd1YWdlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gQXJyYXkuZnJvbShkZXRlY3RlZExhbmd1YWdlcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZmlsZSBleHRlbnNpb24gZnJvbSBwYXRoXHJcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcclxuICogQHJldHVybnMgRmlsZSBleHRlbnNpb24gd2l0aCBkb3RcclxuICovXHJcbmZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgbGFzdERvdCA9IGZpbGVQYXRoLmxhc3RJbmRleE9mKCcuJyk7XHJcbiAgaWYgKGxhc3REb3QgPT09IC0xKSByZXR1cm4gJyc7XHJcbiAgcmV0dXJuIGZpbGVQYXRoLnN1YnN0cmluZyhsYXN0RG90KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBwcmltYXJ5IGxhbmd1YWdlIGZyb20gbWFuaWZlc3RzXHJcbiAqIEBwYXJhbSBtYW5pZmVzdHMgQXJyYXkgb2YgcHJvamVjdCBtYW5pZmVzdHNcclxuICogQHJldHVybnMgUHJpbWFyeSBsYW5ndWFnZSBvciBudWxsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJpbWFyeUxhbmd1YWdlKG1hbmlmZXN0czogUHJvamVjdE1hbmlmZXN0W10pOiBMYW5ndWFnZSB8IG51bGwge1xyXG4gIGlmIChtYW5pZmVzdHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuICBcclxuICAvLyBQcmlvcml0eSBvcmRlcjogbm9kZSwgcHl0aG9uLCBqYXZhLCBnbywgZG90bmV0XHJcbiAgY29uc3QgcHJpb3JpdHk6IExhbmd1YWdlW10gPSBbJ25vZGUnLCAncHl0aG9uJywgJ2phdmEnLCAnZ28nLCAnZG90bmV0J107XHJcbiAgXHJcbiAgZm9yIChjb25zdCBsYW5nIG9mIHByaW9yaXR5KSB7XHJcbiAgICBpZiAobWFuaWZlc3RzLnNvbWUobSA9PiBtLmxhbmd1YWdlID09PSBsYW5nKSkge1xyXG4gICAgICByZXR1cm4gbGFuZztcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIG1hbmlmZXN0c1swXS5sYW5ndWFnZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgZmlsZSBpcyBhIG1hbmlmZXN0IGZpbGVcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGl0J3MgYSBtYW5pZmVzdCBmaWxlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNNYW5pZmVzdEZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IG1hbmlmZXN0RmlsZXMgPSBbXHJcbiAgICAncGFja2FnZS5qc29uJyxcclxuICAgICdyZXF1aXJlbWVudHMudHh0JyxcclxuICAgICdweXByb2plY3QudG9tbCcsXHJcbiAgICAncG9tLnhtbCcsXHJcbiAgICAnYnVpbGQuZ3JhZGxlJyxcclxuICAgICdidWlsZC5ncmFkbGUua3RzJyxcclxuICAgICdnby5tb2QnLFxyXG4gICAgJy5jc3Byb2onLFxyXG4gIF07XHJcbiAgXHJcbiAgcmV0dXJuIG1hbmlmZXN0RmlsZXMuc29tZShtYW5pZmVzdCA9PiBmaWxlUGF0aC5lbmRzV2l0aChtYW5pZmVzdCkpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IG1hbmlmZXN0IGZpbGUgdHlwZSBmcm9tIHBhdGhcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aFxyXG4gKiBAcmV0dXJucyBNYW5pZmVzdCB0eXBlIG9yIG51bGxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYW5pZmVzdFR5cGUoZmlsZVBhdGg6IHN0cmluZyk6IHsgbGFuZ3VhZ2U6IExhbmd1YWdlOyB0eXBlOiBzdHJpbmcgfSB8IG51bGwge1xyXG4gIGlmIChmaWxlUGF0aC5lbmRzV2l0aCgncGFja2FnZS5qc29uJykpIHtcclxuICAgIHJldHVybiB7IGxhbmd1YWdlOiAnbm9kZScsIHR5cGU6ICdwYWNrYWdlLmpzb24nIH07XHJcbiAgfVxyXG4gIGlmIChmaWxlUGF0aC5lbmRzV2l0aCgncmVxdWlyZW1lbnRzLnR4dCcpKSB7XHJcbiAgICByZXR1cm4geyBsYW5ndWFnZTogJ3B5dGhvbicsIHR5cGU6ICdyZXF1aXJlbWVudHMudHh0JyB9O1xyXG4gIH1cclxuICBpZiAoZmlsZVBhdGguZW5kc1dpdGgoJ3B5cHJvamVjdC50b21sJykpIHtcclxuICAgIHJldHVybiB7IGxhbmd1YWdlOiAncHl0aG9uJywgdHlwZTogJ3B5cHJvamVjdC50b21sJyB9O1xyXG4gIH1cclxuICBpZiAoZmlsZVBhdGguZW5kc1dpdGgoJ3BvbS54bWwnKSkge1xyXG4gICAgcmV0dXJuIHsgbGFuZ3VhZ2U6ICdqYXZhJywgdHlwZTogJ3BvbS54bWwnIH07XHJcbiAgfVxyXG4gIGlmIChmaWxlUGF0aC5lbmRzV2l0aCgnYnVpbGQuZ3JhZGxlJykgfHwgZmlsZVBhdGguZW5kc1dpdGgoJ2J1aWxkLmdyYWRsZS5rdHMnKSkge1xyXG4gICAgcmV0dXJuIHsgbGFuZ3VhZ2U6ICdqYXZhJywgdHlwZTogJ2J1aWxkLmdyYWRsZScgfTtcclxuICB9XHJcbiAgaWYgKGZpbGVQYXRoLmVuZHNXaXRoKCdnby5tb2QnKSkge1xyXG4gICAgcmV0dXJuIHsgbGFuZ3VhZ2U6ICdnbycsIHR5cGU6ICdnby5tb2QnIH07XHJcbiAgfVxyXG4gIGlmIChmaWxlUGF0aC5lbmRzV2l0aCgnLmNzcHJvaicpKSB7XHJcbiAgICByZXR1cm4geyBsYW5ndWFnZTogJ2RvdG5ldCcsIHR5cGU6ICcuY3Nwcm9qJyB9O1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gbnVsbDtcclxufVxyXG4iXSwibmFtZXMiOlsiZGV0ZWN0UHJvamVjdE1hbmlmZXN0cyIsImZpbGVzIiwibWFuaWZlc3RzIiwicGFja2FnZUpzb24iLCJmaW5kIiwiZiIsInBhdGgiLCJuYW1lIiwiZW5kc1dpdGgiLCJwa2ciLCJKU09OIiwicGFyc2UiLCJjb250ZW50IiwicHVzaCIsImxhbmd1YWdlIiwiZmlsZSIsImRlcGVuZGVuY2llcyIsImRldkRlcGVuZGVuY2llcyIsInBlZXJEZXBlbmRlbmNpZXMiLCJvcHRpb25hbERlcGVuZGVuY2llcyIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJyZXF1aXJlbWVudHNUeHQiLCJwYXJzZVJlcXVpcmVtZW50c1R4dCIsInB5cHJvamVjdFRvbWwiLCJkZXBzIiwicGFyc2VQeXByb2plY3RUb21sIiwicG9tWG1sIiwicGFyc2VQb21YbWwiLCJidWlsZEdyYWRsZSIsInBhcnNlQnVpbGRHcmFkbGUiLCJnb01vZCIsInBhcnNlR29Nb2QiLCJjc3Byb2pGaWxlcyIsImZpbHRlciIsImNzcHJvaiIsInBhcnNlQ3Nwcm9qIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJ0cmltbWVkIiwidHJpbSIsInN0YXJ0c1dpdGgiLCJtYXRjaCIsInZlcnNpb24iLCJpbkRlcGVuZGVuY2llcyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJkZXBlbmRlbmN5UmVnZXgiLCJleGVjIiwiZ3JvdXBJZCIsImFydGlmYWN0SWQiLCJmdWxsTmFtZSIsImluY2x1ZGVzIiwiZ3JvdXAiLCJhcnRpZmFjdCIsIm1vZHVsZSIsInBhY2thZ2VSZWZSZWdleCIsInBhY2thZ2VOYW1lIiwiZGV0ZWN0TGFuZ3VhZ2VzRnJvbUZpbGVzIiwibGFuZ3VhZ2VNYXAiLCJkZXRlY3RlZExhbmd1YWdlcyIsIlNldCIsImZpbGVQYXRoIiwiZXh0IiwiZ2V0RmlsZUV4dGVuc2lvbiIsImFkZCIsIkFycmF5IiwiZnJvbSIsImxhc3REb3QiLCJsYXN0SW5kZXhPZiIsInN1YnN0cmluZyIsImdldFByaW1hcnlMYW5ndWFnZSIsInByaW9yaXR5IiwibGFuZyIsInNvbWUiLCJtIiwiaXNNYW5pZmVzdEZpbGUiLCJtYW5pZmVzdEZpbGVzIiwibWFuaWZlc3QiLCJnZXRNYW5pZmVzdFR5cGUiLCJ0eXBlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/detect.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/run.ts":
/*!*****************************!*\
  !*** ./lib/analysis/run.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkAnalysisFeasibility: () => (/* binding */ checkAnalysisFeasibility),\n/* harmony export */   estimateAnalysisTime: () => (/* binding */ estimateAnalysisTime),\n/* harmony export */   getAnalysisProgress: () => (/* binding */ getAnalysisProgress),\n/* harmony export */   runAnalysisOnFiles: () => (/* binding */ runAnalysisOnFiles),\n/* harmony export */   runBaselineAnalysis: () => (/* binding */ runBaselineAnalysis),\n/* harmony export */   validateAnalysisOptions: () => (/* binding */ validateAnalysisOptions)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _baseline_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./baseline.loader */ \"(rsc)/./lib/analysis/baseline.loader.ts\");\n/* harmony import */ var _detect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detect */ \"(rsc)/./lib/analysis/detect.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deps */ \"(rsc)/./lib/analysis/deps.ts\");\n/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scan */ \"(rsc)/./lib/analysis/scan.ts\");\n/* harmony import */ var _files_unzip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../files/unzip */ \"(rsc)/./lib/files/unzip.ts\");\n/* harmony import */ var _files_single_file__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../files/single-file */ \"(rsc)/./lib/files/single-file.ts\");\n/* harmony import */ var _files_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../files/store */ \"(rsc)/./lib/files/store.ts\");\n\n\n\n\n\n\n\n\n/**\n * Run complete baseline analysis on a ZIP file\n * @param zipPath Path to ZIP file\n * @param options Analysis options\n * @returns Analysis result with report and artifacts\n */ async function analyzeWithGroq(files, projectType, dependencies) {\n    const results = [];\n    // Skip Groq analysis if no GROQ_API_KEY is available\n    if (!process.env.GROQ_API_KEY) {\n        console.log('Skipping Groq analysis: GROQ_API_KEY not configured');\n        return results;\n    }\n    // Analyze up to 5 key files to avoid rate limits\n    const keyFiles = files.filter((file)=>{\n        const fileName = file.name || file.path || 'unknown';\n        const ext = fileName.split('.').pop()?.toLowerCase();\n        return [\n            'js',\n            'ts',\n            'jsx',\n            'tsx',\n            'css',\n            'html',\n            'vue',\n            'svelte',\n            'py',\n            'java',\n            'go',\n            'cs'\n        ].includes(ext || '');\n    }).slice(0, 5);\n    for (const file of keyFiles){\n        try {\n            // Use absolute URL for server-side fetch\n            const baseUrl = process.env.PUBLIC_URL || 'http://localhost:3000';\n            const response = await fetch(`${baseUrl}/api/analyze/groq`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    code: file.content,\n                    filename: file.name || file.path || 'unknown',\n                    projectType,\n                    dependencies\n                })\n            });\n            if (response.ok) {\n                const result = await response.json();\n                results.push(result);\n            } else {\n                console.error(`Groq analysis failed for ${file.name || file.path}: ${response.status} ${response.statusText}`);\n            }\n        } catch (error) {\n            console.error(`Groq analysis failed for ${file.name || file.path}:`, error);\n        }\n    }\n    return results;\n}\nasync function runBaselineAnalysis(filePath, options = {}) {\n    const { maxFiles = 50000, maxFileSize = 2 * 1024 * 1024, allowedExtensions = [\n        '.html',\n        '.htm',\n        '.css',\n        '.js',\n        '.mjs',\n        '.ts',\n        '.svg',\n        '.wasm',\n        '.json',\n        '.webmanifest'\n    ], ignorePaths = [\n        '/node_modules/',\n        '/.venv/',\n        '/venv/',\n        '/dist/',\n        '/build/',\n        '/.git/',\n        '/.next/'\n    ], storeResults = true, publicUrl = 'http://localhost:3000' } = options;\n    const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomUUID)();\n    const startTime = Date.now();\n    try {\n        // Load baseline rules\n        const rules = await (0,_baseline_loader__WEBPACK_IMPORTED_MODULE_1__.loadBaselineRules)();\n        // Determine if file is ZIP or single file\n        const isZipFile = filePath.toLowerCase().endsWith('.zip');\n        let extractResult;\n        if (isZipFile) {\n            // Extract ZIP file\n            extractResult = await (0,_files_unzip__WEBPACK_IMPORTED_MODULE_5__.extractZipToMemory)(filePath, {\n                maxFiles,\n                maxFileSize,\n                allowedExtensions,\n                ignorePaths\n            });\n            if (extractResult.errors.length > 0) {\n                console.warn('Extraction warnings:', extractResult.errors);\n            }\n        } else {\n            // Process single file\n            const fs = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n            const content = fs.readFileSync(filePath, 'utf8');\n            if (!(0,_files_single_file__WEBPACK_IMPORTED_MODULE_6__.shouldAnalyzeFile)(filePath)) {\n                throw new Error(`File type not supported for analysis: ${filePath}`);\n            }\n            extractResult = (0,_files_single_file__WEBPACK_IMPORTED_MODULE_6__.processSingleFile)(filePath, content, maxFileSize);\n        }\n        // Detect project manifests and languages\n        const manifests = (0,_detect__WEBPACK_IMPORTED_MODULE_2__.detectProjectManifests)(extractResult.files);\n        const detectedLanguages = (0,_detect__WEBPACK_IMPORTED_MODULE_2__.detectLanguagesFromFiles)(extractResult.files);\n        // Create analysis context\n        const context = {\n            rules,\n            extractedFiles: extractResult.files,\n            manifests,\n            detectedLanguages\n        };\n        // Run analysis\n        const findings = await runAnalysis(context);\n        // Add additional analysis findings\n        const additionalFindings = await runAdditionalAnalysis(context);\n        findings.push(...additionalFindings);\n        // Generate summary\n        const summary = generateSummary(findings, detectedLanguages);\n        // Run Groq AI analysis\n        const groqResults = await analyzeWithGroq(extractResult.files, detectedLanguages.join(', '), context.manifests.flatMap((m)=>Object.keys(m.dependencies || {})));\n        // Create report\n        const report = {\n            findings,\n            summary,\n            metadata: {\n                analysisId,\n                timestamp: new Date().toISOString(),\n                projectName: getProjectName(filePath),\n                detectedLanguages,\n                totalFiles: extractResult.totalFiles,\n                scannedFiles: extractResult.files.length,\n                skippedFiles: extractResult.skippedFiles,\n                groqAnalysis: groqResults\n            }\n        };\n        // Store results if requested\n        let artifacts;\n        if (storeResults) {\n            artifacts = (0,_files_store__WEBPACK_IMPORTED_MODULE_7__.storeAnalysisResults)(report, {\n                publicUrl\n            });\n        }\n        const endTime = Date.now();\n        console.log(`Analysis completed in ${endTime - startTime}ms`);\n        return {\n            report,\n            artifacts\n        };\n    } catch (error) {\n        console.error('Analysis failed:', error);\n        throw new Error(`Analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\n * Run analysis on extracted files and manifests\n * @param context Analysis context\n * @returns Array of findings\n */ async function runAnalysis(context) {\n    const findings = [];\n    // Analyze dependencies\n    const dependencyFindings = (0,_deps__WEBPACK_IMPORTED_MODULE_3__.analyzeDependencies)(context.manifests, context.rules);\n    findings.push(...dependencyFindings);\n    // Scan source files for deprecated patterns\n    const patternFindings = (0,_scan__WEBPACK_IMPORTED_MODULE_4__.scanSourceFiles)(context.extractedFiles, context.rules);\n    findings.push(...patternFindings);\n    return findings;\n}\n/**\n * Run additional analysis for enhanced detection\n * @param context Analysis context\n * @returns Array of additional findings\n */ async function runAdditionalAnalysis(context) {\n    const findings = [];\n    // Analyze code quality and best practices\n    const qualityFindings = analyzeCodeQuality(context.extractedFiles);\n    findings.push(...qualityFindings);\n    // Analyze security vulnerabilities\n    const securityFindings = analyzeSecurityVulnerabilities(context.extractedFiles);\n    findings.push(...securityFindings);\n    // Analyze performance issues\n    const performanceFindings = analyzePerformanceIssues(context.extractedFiles);\n    findings.push(...performanceFindings);\n    return findings;\n}\n/**\n * Analyze code quality and best practices\n * @param files Array of extracted files\n * @returns Array of quality findings\n */ function analyzeCodeQuality(files) {\n    const findings = [];\n    for (const file of files){\n        const filePath = file.path || file.name || 'unknown';\n        const extension = getFileExtension(filePath);\n        const language = detectLanguageFromExtension(extension);\n        if (!language) continue;\n        const lines = file.content.split('\\n');\n        // Check for code quality issues\n        for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n            const line = lines[lineIndex];\n            const lineNumber = lineIndex + 1;\n            // Skip empty lines and comments\n            if (isCommentLine(line, language) || line.trim() === '') {\n                continue;\n            }\n            // Check for long lines\n            if (line.length > 120) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'Line is too long (>120 characters)',\n                    pattern: 'long-line',\n                    quickFix: 'Break long lines for better readability'\n                });\n            }\n            // Check for trailing whitespace\n            if (line.endsWith(' ') || line.endsWith('\\t')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'Trailing whitespace detected',\n                    pattern: 'trailing-whitespace',\n                    quickFix: 'Remove trailing whitespace'\n                });\n            }\n            // Check for mixed tabs and spaces\n            if (line.includes('\\t') && line.includes(' ')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'Mixed tabs and spaces for indentation',\n                    pattern: 'mixed-indentation',\n                    quickFix: 'Use consistent indentation (prefer spaces)'\n                });\n            }\n            // Check for TODO/FIXME comments\n            if (line.toLowerCase().includes('todo') || line.toLowerCase().includes('fixme')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'TODO/FIXME comment found',\n                    pattern: 'todo-comment',\n                    quickFix: 'Address TODO/FIXME items before production'\n                });\n            }\n            // Check for console.log in production code\n            if (language === 'node' && line.includes('console.log')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'console.log should be removed in production',\n                    pattern: 'console-log',\n                    quickFix: 'Use proper logging library or remove debug statements'\n                });\n            }\n            // Check for print statements in Python\n            if (language === 'python' && line.includes('print(')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'print() should be removed in production',\n                    pattern: 'print-statement',\n                    quickFix: 'Use proper logging library or remove debug statements'\n                });\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Analyze security vulnerabilities\n * @param files Array of extracted files\n * @returns Array of security findings\n */ function analyzeSecurityVulnerabilities(files) {\n    const findings = [];\n    for (const file of files){\n        const filePath = file.path || file.name || 'unknown';\n        const extension = getFileExtension(filePath);\n        const language = detectLanguageFromExtension(extension);\n        if (!language) continue;\n        const lines = file.content.split('\\n');\n        // Check for security vulnerabilities\n        for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n            const line = lines[lineIndex];\n            const lineNumber = lineIndex + 1;\n            // Skip empty lines and comments\n            if (isCommentLine(line, language) || line.trim() === '') {\n                continue;\n            }\n            // Check for hardcoded passwords\n            if (line.toLowerCase().includes('password') && line.includes('=') && !line.includes('input(')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'security',\n                    issue: 'Potential hardcoded password detected',\n                    pattern: 'hardcoded-password',\n                    quickFix: 'Use environment variables or secure credential storage'\n                });\n            }\n            // Check for hardcoded API keys\n            if (line.toLowerCase().includes('api') && line.toLowerCase().includes('key') && line.includes('=')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'security',\n                    issue: 'Potential hardcoded API key detected',\n                    pattern: 'hardcoded-api-key',\n                    quickFix: 'Use environment variables or secure credential storage'\n                });\n            }\n            // Check for SQL injection vulnerabilities\n            if (line.includes('SELECT') || line.includes('INSERT') || line.includes('UPDATE') || line.includes('DELETE')) {\n                if (line.includes('+') || line.includes('${') || line.includes('%s')) {\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: filePath,\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'security',\n                        issue: 'Potential SQL injection vulnerability',\n                        pattern: 'sql-injection',\n                        quickFix: 'Use parameterized queries or prepared statements'\n                    });\n                }\n            }\n            // Check for XSS vulnerabilities\n            if (line.includes('innerHTML') || line.includes('outerHTML') || line.includes('document.write')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'security',\n                    issue: 'Potential XSS vulnerability',\n                    pattern: 'xss-vulnerability',\n                    quickFix: 'Use textContent or sanitize HTML content'\n                });\n            }\n            // Check for unsafe deserialization\n            if (line.includes('pickle.load') || line.includes('unpickle') || line.includes('deserialize')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'security',\n                    issue: 'Unsafe deserialization detected',\n                    pattern: 'unsafe-deserialization',\n                    quickFix: 'Use safe serialization formats like JSON'\n                });\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Analyze performance issues\n * @param files Array of extracted files\n * @returns Array of performance findings\n */ function analyzePerformanceIssues(files) {\n    const findings = [];\n    for (const file of files){\n        const filePath = file.path || file.name || 'unknown';\n        const extension = getFileExtension(filePath);\n        const language = detectLanguageFromExtension(extension);\n        if (!language) continue;\n        const lines = file.content.split('\\n');\n        // Check for performance issues\n        for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n            const line = lines[lineIndex];\n            const lineNumber = lineIndex + 1;\n            // Skip empty lines and comments\n            if (isCommentLine(line, language) || line.trim() === '') {\n                continue;\n            }\n            // Check for synchronous file operations\n            if (language === 'node' && (line.includes('fs.readFileSync') || line.includes('fs.writeFileSync'))) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'performance',\n                    issue: 'Synchronous file operation can block the event loop',\n                    pattern: 'sync-file-operation',\n                    quickFix: 'Use asynchronous file operations (fs.promises)'\n                });\n            }\n            // Check for blocking operations\n            if (line.includes('sleep(') || line.includes('time.sleep(')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'performance',\n                    issue: 'Blocking sleep operation detected',\n                    pattern: 'blocking-sleep',\n                    quickFix: 'Use asynchronous alternatives or reduce sleep time'\n                });\n            }\n            // Check for inefficient loops\n            if (line.includes('for') && line.includes('in') && line.includes('range(')) {\n                if (line.includes('len(') || line.includes('.length')) {\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: filePath,\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'performance',\n                        issue: 'Inefficient loop with len()/length call',\n                        pattern: 'inefficient-loop',\n                        quickFix: 'Cache length or use enumerate()/entries()'\n                    });\n                }\n            }\n            // Check for string concatenation in loops\n            if (line.includes('+=') && line.includes('str') || line.includes('+=') && line.includes('string')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'performance',\n                    issue: 'String concatenation in loop is inefficient',\n                    pattern: 'string-concatenation',\n                    quickFix: 'Use join() or StringBuilder for better performance'\n                });\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Get file extension from path\n * @param filePath File path\n * @returns File extension with dot\n */ function getFileExtension(filePath) {\n    const lastDot = filePath.lastIndexOf('.');\n    if (lastDot === -1) return '';\n    return filePath.substring(lastDot);\n}\n/**\n * Detect language from file extension\n * @param extension File extension\n * @returns Language or null\n */ function detectLanguageFromExtension(extension) {\n    const languageMap = {\n        '.html': 'node',\n        '.htm': 'node',\n        '.css': 'node',\n        '.js': 'node',\n        '.jsx': 'node',\n        '.mjs': 'node',\n        '.ts': 'node',\n        '.tsx': 'node',\n        '.svg': 'node',\n        '.wasm': 'node',\n        '.json': 'node',\n        '.webmanifest': 'node',\n        '.py': 'python',\n        '.java': 'java',\n        '.go': 'go',\n        '.cs': 'dotnet',\n        '.fs': 'dotnet',\n        '.vb': 'dotnet'\n    };\n    return languageMap[extension] || null;\n}\n/**\n * Check if a line is a comment\n * @param line Line content\n * @param language Language context\n * @returns True if comment line\n */ function isCommentLine(line, language) {\n    const trimmed = line.trim();\n    switch(language){\n        case 'node':\n        case 'java':\n        case 'go':\n        case 'dotnet':\n            return trimmed.startsWith('//') || trimmed.startsWith('/*') || trimmed.startsWith('*') || trimmed.startsWith('<!--');\n        case 'python':\n            return trimmed.startsWith('#');\n        default:\n            return false;\n    }\n}\n/**\n * Generate summary from findings\n * @param findings Array of findings\n * @param detectedLanguages Array of detected languages\n * @returns Report summary\n */ function generateSummary(findings, detectedLanguages) {\n    const summary = {\n        ok: 0,\n        affected: 0,\n        unknown: 0,\n        byLanguage: {}\n    };\n    // Initialize language summaries\n    for (const language of detectedLanguages){\n        summary.byLanguage[language] = {\n            ok: 0,\n            affected: 0,\n            unknown: 0\n        };\n    }\n    // Count findings by status and language\n    for (const finding of findings){\n        if (finding.kind === 'dependency') {\n            summary[finding.status]++;\n            if (summary.byLanguage[finding.lang]) {\n                summary.byLanguage[finding.lang][finding.status]++;\n            }\n        } else if (finding.kind === 'pattern') {\n            summary.affected++;\n            if (summary.byLanguage[finding.lang]) {\n                summary.byLanguage[finding.lang].affected++;\n            }\n        }\n    }\n    return summary;\n}\n/**\n * Get project name from ZIP path\n * @param zipPath ZIP file path\n * @returns Project name\n */ function getProjectName(zipPath) {\n    const pathParts = zipPath.split('/');\n    const fileName = pathParts[pathParts.length - 1];\n    return fileName.replace(/\\.zip$/i, '');\n}\n/**\n * Run analysis on extracted files (for testing)\n * @param files Array of extracted files\n * @param manifests Array of project manifests\n * @param rules Baseline rules\n * @returns Analysis result\n */ async function runAnalysisOnFiles(files, manifests, rules) {\n    const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomUUID)();\n    const detectedLanguages = (0,_detect__WEBPACK_IMPORTED_MODULE_2__.detectLanguagesFromFiles)(files);\n    const context = {\n        rules,\n        extractedFiles: files,\n        manifests,\n        detectedLanguages\n    };\n    const findings = await runAnalysis(context);\n    const summary = generateSummary(findings, detectedLanguages);\n    const report = {\n        findings,\n        summary,\n        metadata: {\n            analysisId,\n            timestamp: new Date().toISOString(),\n            projectName: 'test-project',\n            detectedLanguages,\n            totalFiles: files.length,\n            scannedFiles: files.length,\n            skippedFiles: 0\n        }\n    };\n    return {\n        report\n    };\n}\n/**\n * Validate analysis options\n * @param options Analysis options\n * @returns Validated options\n */ function validateAnalysisOptions(options) {\n    return {\n        maxFiles: Math.min(options.maxFiles || 50000, 100000),\n        maxFileSize: Math.min(options.maxFileSize || 2 * 1024 * 1024, 10 * 1024 * 1024),\n        allowedExtensions: options.allowedExtensions || [\n            '.html',\n            '.htm',\n            '.css',\n            '.js',\n            '.mjs',\n            '.ts',\n            '.svg',\n            '.wasm',\n            '.json',\n            '.webmanifest'\n        ],\n        ignorePaths: options.ignorePaths || [\n            '/node_modules/',\n            '/.venv/',\n            '/venv/',\n            '/dist/',\n            '/build/',\n            '/.git/',\n            '/.next/'\n        ],\n        storeResults: options.storeResults !== false,\n        publicUrl: options.publicUrl || 'http://localhost:3000'\n    };\n}\n/**\n * Get analysis progress (for long-running analyses)\n * @param context Analysis context\n * @param currentStep Current step\n * @param totalSteps Total steps\n * @returns Progress information\n */ function getAnalysisProgress(context, currentStep, totalSteps) {\n    const steps = [\n        'Loading baseline rules',\n        'Extracting ZIP file',\n        'Detecting project manifests',\n        'Analyzing dependencies',\n        'Scanning source files',\n        'Generating report'\n    ];\n    const step = steps[currentStep] || 'Unknown';\n    const progress = currentStep / totalSteps * 100;\n    let details = '';\n    if (currentStep === 1) {\n        details = `Extracted ${context.extractedFiles.length} files`;\n    } else if (currentStep === 2) {\n        details = `Found ${context.manifests.length} manifests, ${context.detectedLanguages.length} languages`;\n    } else if (currentStep === 3) {\n        details = `Analyzing ${context.manifests.length} dependency manifests`;\n    } else if (currentStep === 4) {\n        details = `Scanning ${context.extractedFiles.length} source files`;\n    }\n    return {\n        step,\n        progress,\n        details\n    };\n}\n/**\n * Estimate analysis time\n * @param fileCount Number of files\n * @param manifestCount Number of manifests\n * @returns Estimated time in milliseconds\n */ function estimateAnalysisTime(fileCount, manifestCount) {\n    // Base time: 1 second\n    let estimated = 1000;\n    // Add time for file processing: 10ms per file\n    estimated += fileCount * 10;\n    // Add time for manifest processing: 50ms per manifest\n    estimated += manifestCount * 50;\n    // Add time for pattern scanning: 5ms per file\n    estimated += fileCount * 5;\n    return Math.min(estimated, 30000); // Cap at 30 seconds\n}\n/**\n * Check if analysis is feasible\n * @param fileCount Number of files\n * @param totalSize Total size in bytes\n * @returns Feasibility check result\n */ function checkAnalysisFeasibility(fileCount, totalSize) {\n    const warnings = [];\n    let feasible = true;\n    // Check file count\n    if (fileCount > 50000) {\n        feasible = false;\n        warnings.push(`Too many files: ${fileCount} (limit: 50,000)`);\n    } else if (fileCount > 10000) {\n        warnings.push(`Large number of files: ${fileCount} (analysis may take longer)`);\n    }\n    // Check total size\n    if (totalSize > 100 * 1024 * 1024) {\n        feasible = false;\n        warnings.push(`Archive too large: ${Math.round(totalSize / 1024 / 1024)}MB (limit: 100MB)`);\n    } else if (totalSize > 50 * 1024 * 1024) {\n        warnings.push(`Large archive: ${Math.round(totalSize / 1024 / 1024)}MB (analysis may take longer)`);\n    }\n    const estimatedTimeMs = estimateAnalysisTime(fileCount, Math.min(fileCount / 100, 50));\n    const estimatedTime = `${Math.round(estimatedTimeMs / 1000)}s`;\n    return {\n        feasible,\n        warnings,\n        estimatedTime\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUMsV0FBVztJQUVmLG1CQUFtQjtJQUNuQixJQUFJTixZQUFZLE9BQU87UUFDckJNLFdBQVc7UUFDWEQsU0FBUzlHLElBQUksQ0FBQyxDQUFDLGdCQUFnQixFQUFFeUcsVUFBVSxnQkFBZ0IsQ0FBQztJQUM5RCxPQUFPLElBQUlBLFlBQVksT0FBTztRQUM1QkssU0FBUzlHLElBQUksQ0FBQyxDQUFDLHVCQUF1QixFQUFFeUcsVUFBVSwyQkFBMkIsQ0FBQztJQUNoRjtJQUVBLG1CQUFtQjtJQUNuQixJQUFJSSxZQUFZLE1BQU0sT0FBTyxNQUFNO1FBQ2pDRSxXQUFXO1FBQ1hELFNBQVM5RyxJQUFJLENBQUMsQ0FBQyxtQkFBbUIsRUFBRStGLEtBQUtpQixLQUFLLENBQUNILFlBQVksT0FBTyxNQUFNLGlCQUFpQixDQUFDO0lBQzVGLE9BQU8sSUFBSUEsWUFBWSxLQUFLLE9BQU8sTUFBTTtRQUN2Q0MsU0FBUzlHLElBQUksQ0FBQyxDQUFDLGVBQWUsRUFBRStGLEtBQUtpQixLQUFLLENBQUNILFlBQVksT0FBTyxNQUFNLDZCQUE2QixDQUFDO0lBQ3BHO0lBRUEsTUFBTUksa0JBQWtCVCxxQkFBcUJDLFdBQVdWLEtBQUtDLEdBQUcsQ0FBQ1MsWUFBWSxLQUFLO0lBQ2xGLE1BQU1TLGdCQUFnQixHQUFHbkIsS0FBS2lCLEtBQUssQ0FBQ0Msa0JBQWtCLE1BQU0sQ0FBQyxDQUFDO0lBRTlELE9BQU87UUFDTEY7UUFDQUQ7UUFDQUk7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxydW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmFuZG9tVVVJRCB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBsb2FkQmFzZWxpbmVSdWxlcyB9IGZyb20gJy4vYmFzZWxpbmUubG9hZGVyJztcbmltcG9ydCB7IGRldGVjdFByb2plY3RNYW5pZmVzdHMsIGRldGVjdExhbmd1YWdlc0Zyb21GaWxlcyB9IGZyb20gJy4vZGV0ZWN0JztcbmltcG9ydCB7IGFuYWx5emVEZXBlbmRlbmNpZXMgfSBmcm9tICcuL2RlcHMnO1xuaW1wb3J0IHsgc2NhblNvdXJjZUZpbGVzIH0gZnJvbSAnLi9zY2FuJztcbmltcG9ydCB7IGV4dHJhY3RaaXBUb01lbW9yeSB9IGZyb20gJy4uL2ZpbGVzL3VuemlwJztcbmltcG9ydCB7IHByb2Nlc3NTaW5nbGVGaWxlLCBzaG91bGRBbmFseXplRmlsZSB9IGZyb20gJy4uL2ZpbGVzL3NpbmdsZS1maWxlJztcbmltcG9ydCB7IHN0b3JlQW5hbHlzaXNSZXN1bHRzIH0gZnJvbSAnLi4vZmlsZXMvc3RvcmUnO1xuaW1wb3J0IHtcbiAgUmVwb3J0LFxuICBGaW5kaW5nLFxuICBMYW5ndWFnZSxcbiAgUmVwb3J0U3VtbWFyeSxcbiAgQW5hbHlzaXNDb250ZXh0LFxuICBFeHRyYWN0ZWRGaWxlLFxuICBQcm9qZWN0TWFuaWZlc3QsXG4gIEJhc2VsaW5lUnVsZXNcbn0gZnJvbSAnLi9iYXNlbGluZS50eXBlcyc7XG5cbmludGVyZmFjZSBHcm9xQW5hbHlzaXNSZXN1bHQge1xuICBhbmFseXNpczogc3RyaW5nO1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICB0aW1lc3RhbXA6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbmFseXNpc09wdGlvbnMge1xuICBtYXhGaWxlcz86IG51bWJlcjtcbiAgbWF4RmlsZVNpemU/OiBudW1iZXI7XG4gIGFsbG93ZWRFeHRlbnNpb25zPzogc3RyaW5nW107XG4gIGlnbm9yZVBhdGhzPzogc3RyaW5nW107XG4gIHN0b3JlUmVzdWx0cz86IGJvb2xlYW47XG4gIHB1YmxpY1VybD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbmFseXNpc1Jlc3VsdCB7XG4gIHJlcG9ydDogUmVwb3J0O1xuICBhcnRpZmFjdHM/OiB7XG4gICAganNvblVybDogc3RyaW5nO1xuICAgIGNzdlVybDogc3RyaW5nO1xuICAgIGFuYWx5c2lzSWQ6IHN0cmluZztcbiAgfTtcbn1cblxuLyoqXG4gKiBSdW4gY29tcGxldGUgYmFzZWxpbmUgYW5hbHlzaXMgb24gYSBaSVAgZmlsZVxuICogQHBhcmFtIHppcFBhdGggUGF0aCB0byBaSVAgZmlsZVxuICogQHBhcmFtIG9wdGlvbnMgQW5hbHlzaXMgb3B0aW9uc1xuICogQHJldHVybnMgQW5hbHlzaXMgcmVzdWx0IHdpdGggcmVwb3J0IGFuZCBhcnRpZmFjdHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYW5hbHl6ZVdpdGhHcm9xKFxuICBmaWxlczogRXh0cmFjdGVkRmlsZVtdLFxuICBwcm9qZWN0VHlwZTogc3RyaW5nLFxuICBkZXBlbmRlbmNpZXM6IHN0cmluZ1tdXG4pOiBQcm9taXNlPEdyb3FBbmFseXNpc1Jlc3VsdFtdPiB7XG4gIGNvbnN0IHJlc3VsdHM6IEdyb3FBbmFseXNpc1Jlc3VsdFtdID0gW107XG4gIFxuICAvLyBTa2lwIEdyb3EgYW5hbHlzaXMgaWYgbm8gR1JPUV9BUElfS0VZIGlzIGF2YWlsYWJsZVxuICBpZiAoIXByb2Nlc3MuZW52LkdST1FfQVBJX0tFWSkge1xuICAgIGNvbnNvbGUubG9nKCdTa2lwcGluZyBHcm9xIGFuYWx5c2lzOiBHUk9RX0FQSV9LRVkgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBcbiAgLy8gQW5hbHl6ZSB1cCB0byA1IGtleSBmaWxlcyB0byBhdm9pZCByYXRlIGxpbWl0c1xuICBjb25zdCBrZXlGaWxlcyA9IGZpbGVzXG4gICAgLmZpbHRlcihmaWxlID0+IHtcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gKGZpbGUgYXMgeyBuYW1lPzogc3RyaW5nOyBwYXRoOiBzdHJpbmcgfSkubmFtZSB8fCBmaWxlLnBhdGggfHwgJ3Vua25vd24nO1xuICAgICAgY29uc3QgZXh0ID0gZmlsZU5hbWUuc3BsaXQoJy4nKS5wb3AoKT8udG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBbJ2pzJywgJ3RzJywgJ2pzeCcsICd0c3gnLCAnY3NzJywgJ2h0bWwnLCAndnVlJywgJ3N2ZWx0ZScsICdweScsICdqYXZhJywgJ2dvJywgJ2NzJ10uaW5jbHVkZXMoZXh0IHx8ICcnKTtcbiAgICB9KVxuICAgIC5zbGljZSgwLCA1KTtcblxuICBmb3IgKGNvbnN0IGZpbGUgb2Yga2V5RmlsZXMpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIGFic29sdXRlIFVSTCBmb3Igc2VydmVyLXNpZGUgZmV0Y2hcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSBwcm9jZXNzLmVudi5QVUJMSUNfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfS9hcGkvYW5hbHl6ZS9ncm9xYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb2RlOiBmaWxlLmNvbnRlbnQsXG4gICAgICAgICAgZmlsZW5hbWU6IChmaWxlIGFzIHsgbmFtZT86IHN0cmluZzsgcGF0aDogc3RyaW5nIH0pLm5hbWUgfHwgZmlsZS5wYXRoIHx8ICd1bmtub3duJyxcbiAgICAgICAgICBwcm9qZWN0VHlwZSxcbiAgICAgICAgICBkZXBlbmRlbmNpZXNcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEdyb3EgYW5hbHlzaXMgZmFpbGVkIGZvciAkeyhmaWxlIGFzIHsgbmFtZT86IHN0cmluZzsgcGF0aDogc3RyaW5nIH0pLm5hbWUgfHwgZmlsZS5wYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgR3JvcSBhbmFseXNpcyBmYWlsZWQgZm9yICR7KGZpbGUgYXMgeyBuYW1lPzogc3RyaW5nOyBwYXRoOiBzdHJpbmcgfSkubmFtZSB8fCBmaWxlLnBhdGh9OmAsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bkJhc2VsaW5lQW5hbHlzaXMoXG4gIGZpbGVQYXRoOiBzdHJpbmcsXG4gIG9wdGlvbnM6IEFuYWx5c2lzT3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPEFuYWx5c2lzUmVzdWx0PiB7XG4gIGNvbnN0IHtcbiAgICBtYXhGaWxlcyA9IDUwMDAwLFxuICAgIG1heEZpbGVTaXplID0gMiAqIDEwMjQgKiAxMDI0LCAvLyAyTUJcbiAgICBhbGxvd2VkRXh0ZW5zaW9ucyA9IFsnLmh0bWwnLCAnLmh0bScsICcuY3NzJywgJy5qcycsICcubWpzJywgJy50cycsICcuc3ZnJywgJy53YXNtJywgJy5qc29uJywgJy53ZWJtYW5pZmVzdCddLFxuICAgIGlnbm9yZVBhdGhzID0gWycvbm9kZV9tb2R1bGVzLycsICcvLnZlbnYvJywgJy92ZW52LycsICcvZGlzdC8nLCAnL2J1aWxkLycsICcvLmdpdC8nLCAnLy5uZXh0LyddLFxuICAgIHN0b3JlUmVzdWx0cyA9IHRydWUsXG4gICAgcHVibGljVXJsID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IGFuYWx5c2lzSWQgPSByYW5kb21VVUlEKCk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExvYWQgYmFzZWxpbmUgcnVsZXNcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gYXdhaXQgbG9hZEJhc2VsaW5lUnVsZXMoKTtcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgaWYgZmlsZSBpcyBaSVAgb3Igc2luZ2xlIGZpbGVcbiAgICBjb25zdCBpc1ppcEZpbGUgPSBmaWxlUGF0aC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuemlwJyk7XG4gICAgbGV0IGV4dHJhY3RSZXN1bHQ7XG4gICAgXG4gICAgaWYgKGlzWmlwRmlsZSkge1xuICAgICAgLy8gRXh0cmFjdCBaSVAgZmlsZVxuICAgICAgZXh0cmFjdFJlc3VsdCA9IGF3YWl0IGV4dHJhY3RaaXBUb01lbW9yeShmaWxlUGF0aCwge1xuICAgICAgICBtYXhGaWxlcyxcbiAgICAgICAgbWF4RmlsZVNpemUsXG4gICAgICAgIGFsbG93ZWRFeHRlbnNpb25zLFxuICAgICAgICBpZ25vcmVQYXRocyxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXh0cmFjdFJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4dHJhY3Rpb24gd2FybmluZ3M6JywgZXh0cmFjdFJlc3VsdC5lcnJvcnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcm9jZXNzIHNpbmdsZSBmaWxlXG4gICAgICBjb25zdCBmcyA9IGF3YWl0IGltcG9ydCgnZnMnKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgICBcbiAgICAgIGlmICghc2hvdWxkQW5hbHl6ZUZpbGUoZmlsZVBhdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSB0eXBlIG5vdCBzdXBwb3J0ZWQgZm9yIGFuYWx5c2lzOiAke2ZpbGVQYXRofWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBleHRyYWN0UmVzdWx0ID0gcHJvY2Vzc1NpbmdsZUZpbGUoZmlsZVBhdGgsIGNvbnRlbnQsIG1heEZpbGVTaXplKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3QgcHJvamVjdCBtYW5pZmVzdHMgYW5kIGxhbmd1YWdlc1xuICAgIGNvbnN0IG1hbmlmZXN0cyA9IGRldGVjdFByb2plY3RNYW5pZmVzdHMoZXh0cmFjdFJlc3VsdC5maWxlcyk7XG4gICAgY29uc3QgZGV0ZWN0ZWRMYW5ndWFnZXMgPSBkZXRlY3RMYW5ndWFnZXNGcm9tRmlsZXMoZXh0cmFjdFJlc3VsdC5maWxlcyk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGFuYWx5c2lzIGNvbnRleHRcbiAgICBjb25zdCBjb250ZXh0OiBBbmFseXNpc0NvbnRleHQgPSB7XG4gICAgICBydWxlcyxcbiAgICAgIGV4dHJhY3RlZEZpbGVzOiBleHRyYWN0UmVzdWx0LmZpbGVzLFxuICAgICAgbWFuaWZlc3RzLFxuICAgICAgZGV0ZWN0ZWRMYW5ndWFnZXMsXG4gICAgfTtcblxuICAgIC8vIFJ1biBhbmFseXNpc1xuICAgIGNvbnN0IGZpbmRpbmdzID0gYXdhaXQgcnVuQW5hbHlzaXMoY29udGV4dCk7XG4gICAgXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgYW5hbHlzaXMgZmluZGluZ3NcbiAgICBjb25zdCBhZGRpdGlvbmFsRmluZGluZ3MgPSBhd2FpdCBydW5BZGRpdGlvbmFsQW5hbHlzaXMoY29udGV4dCk7XG4gICAgZmluZGluZ3MucHVzaCguLi5hZGRpdGlvbmFsRmluZGluZ3MpO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHN1bW1hcnlcbiAgICBjb25zdCBzdW1tYXJ5ID0gZ2VuZXJhdGVTdW1tYXJ5KGZpbmRpbmdzLCBkZXRlY3RlZExhbmd1YWdlcyk7XG4gICAgXG4gICAgLy8gUnVuIEdyb3EgQUkgYW5hbHlzaXNcbiAgICBjb25zdCBncm9xUmVzdWx0cyA9IGF3YWl0IGFuYWx5emVXaXRoR3JvcShcbiAgICAgIGV4dHJhY3RSZXN1bHQuZmlsZXMsXG4gICAgICBkZXRlY3RlZExhbmd1YWdlcy5qb2luKCcsICcpLFxuICAgICAgY29udGV4dC5tYW5pZmVzdHMuZmxhdE1hcChtID0+IE9iamVjdC5rZXlzKG0uZGVwZW5kZW5jaWVzIHx8IHt9KSlcbiAgICApO1xuICAgIFxuICAgIC8vIENyZWF0ZSByZXBvcnRcbiAgICBjb25zdCByZXBvcnQ6IFJlcG9ydCA9IHtcbiAgICAgIGZpbmRpbmdzLFxuICAgICAgc3VtbWFyeSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIGFuYWx5c2lzSWQsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBwcm9qZWN0TmFtZTogZ2V0UHJvamVjdE5hbWUoZmlsZVBhdGgpLFxuICAgICAgICBkZXRlY3RlZExhbmd1YWdlcyxcbiAgICAgICAgdG90YWxGaWxlczogZXh0cmFjdFJlc3VsdC50b3RhbEZpbGVzLFxuICAgICAgICBzY2FubmVkRmlsZXM6IGV4dHJhY3RSZXN1bHQuZmlsZXMubGVuZ3RoLFxuICAgICAgICBza2lwcGVkRmlsZXM6IGV4dHJhY3RSZXN1bHQuc2tpcHBlZEZpbGVzLFxuICAgICAgICBncm9xQW5hbHlzaXM6IGdyb3FSZXN1bHRzLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gU3RvcmUgcmVzdWx0cyBpZiByZXF1ZXN0ZWRcbiAgICBsZXQgYXJ0aWZhY3RzO1xuICAgIGlmIChzdG9yZVJlc3VsdHMpIHtcbiAgICAgIGFydGlmYWN0cyA9IHN0b3JlQW5hbHlzaXNSZXN1bHRzKHJlcG9ydCwgeyBwdWJsaWNVcmwgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coYEFuYWx5c2lzIGNvbXBsZXRlZCBpbiAke2VuZFRpbWUgLSBzdGFydFRpbWV9bXNgKTtcblxuICAgIHJldHVybiB7XG4gICAgICByZXBvcnQsXG4gICAgICBhcnRpZmFjdHMsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdBbmFseXNpcyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQW5hbHlzaXMgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICB9XG59XG5cbi8qKlxuICogUnVuIGFuYWx5c2lzIG9uIGV4dHJhY3RlZCBmaWxlcyBhbmQgbWFuaWZlc3RzXG4gKiBAcGFyYW0gY29udGV4dCBBbmFseXNpcyBjb250ZXh0XG4gKiBAcmV0dXJucyBBcnJheSBvZiBmaW5kaW5nc1xuICovXG5hc3luYyBmdW5jdGlvbiBydW5BbmFseXNpcyhjb250ZXh0OiBBbmFseXNpc0NvbnRleHQpOiBQcm9taXNlPEZpbmRpbmdbXT4ge1xuICBjb25zdCBmaW5kaW5nczogRmluZGluZ1tdID0gW107XG5cbiAgLy8gQW5hbHl6ZSBkZXBlbmRlbmNpZXNcbiAgY29uc3QgZGVwZW5kZW5jeUZpbmRpbmdzID0gYW5hbHl6ZURlcGVuZGVuY2llcyhjb250ZXh0Lm1hbmlmZXN0cywgY29udGV4dC5ydWxlcyk7XG4gIGZpbmRpbmdzLnB1c2goLi4uZGVwZW5kZW5jeUZpbmRpbmdzKTtcblxuICAvLyBTY2FuIHNvdXJjZSBmaWxlcyBmb3IgZGVwcmVjYXRlZCBwYXR0ZXJuc1xuICBjb25zdCBwYXR0ZXJuRmluZGluZ3MgPSBzY2FuU291cmNlRmlsZXMoY29udGV4dC5leHRyYWN0ZWRGaWxlcywgY29udGV4dC5ydWxlcyk7XG4gIGZpbmRpbmdzLnB1c2goLi4ucGF0dGVybkZpbmRpbmdzKTtcblxuICByZXR1cm4gZmluZGluZ3M7XG59XG5cbi8qKlxuICogUnVuIGFkZGl0aW9uYWwgYW5hbHlzaXMgZm9yIGVuaGFuY2VkIGRldGVjdGlvblxuICogQHBhcmFtIGNvbnRleHQgQW5hbHlzaXMgY29udGV4dFxuICogQHJldHVybnMgQXJyYXkgb2YgYWRkaXRpb25hbCBmaW5kaW5nc1xuICovXG5hc3luYyBmdW5jdGlvbiBydW5BZGRpdGlvbmFsQW5hbHlzaXMoY29udGV4dDogQW5hbHlzaXNDb250ZXh0KTogUHJvbWlzZTxGaW5kaW5nW10+IHtcbiAgY29uc3QgZmluZGluZ3M6IEZpbmRpbmdbXSA9IFtdO1xuXG4gIC8vIEFuYWx5emUgY29kZSBxdWFsaXR5IGFuZCBiZXN0IHByYWN0aWNlc1xuICBjb25zdCBxdWFsaXR5RmluZGluZ3MgPSBhbmFseXplQ29kZVF1YWxpdHkoY29udGV4dC5leHRyYWN0ZWRGaWxlcyk7XG4gIGZpbmRpbmdzLnB1c2goLi4ucXVhbGl0eUZpbmRpbmdzKTtcblxuICAvLyBBbmFseXplIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllc1xuICBjb25zdCBzZWN1cml0eUZpbmRpbmdzID0gYW5hbHl6ZVNlY3VyaXR5VnVsbmVyYWJpbGl0aWVzKGNvbnRleHQuZXh0cmFjdGVkRmlsZXMpO1xuICBmaW5kaW5ncy5wdXNoKC4uLnNlY3VyaXR5RmluZGluZ3MpO1xuXG4gIC8vIEFuYWx5emUgcGVyZm9ybWFuY2UgaXNzdWVzXG4gIGNvbnN0IHBlcmZvcm1hbmNlRmluZGluZ3MgPSBhbmFseXplUGVyZm9ybWFuY2VJc3N1ZXMoY29udGV4dC5leHRyYWN0ZWRGaWxlcyk7XG4gIGZpbmRpbmdzLnB1c2goLi4ucGVyZm9ybWFuY2VGaW5kaW5ncyk7XG5cbiAgcmV0dXJuIGZpbmRpbmdzO1xufVxuXG4vKipcbiAqIEFuYWx5emUgY29kZSBxdWFsaXR5IGFuZCBiZXN0IHByYWN0aWNlc1xuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xuICogQHJldHVybnMgQXJyYXkgb2YgcXVhbGl0eSBmaW5kaW5nc1xuICovXG5mdW5jdGlvbiBhbmFseXplQ29kZVF1YWxpdHkoZmlsZXM6IEFycmF5PHsgcGF0aD86IHN0cmluZzsgbmFtZT86IHN0cmluZzsgY29udGVudDogc3RyaW5nOyBzaXplOiBudW1iZXIgfT4pOiBGaW5kaW5nW10ge1xuICBjb25zdCBmaW5kaW5nczogRmluZGluZ1tdID0gW107XG5cbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGggfHwgZmlsZS5uYW1lIHx8ICd1bmtub3duJztcbiAgICBjb25zdCBleHRlbnNpb24gPSBnZXRGaWxlRXh0ZW5zaW9uKGZpbGVQYXRoKTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IGRldGVjdExhbmd1YWdlRnJvbUV4dGVuc2lvbihleHRlbnNpb24pO1xuICAgIFxuICAgIGlmICghbGFuZ3VhZ2UpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgbGluZXMgPSBmaWxlLmNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBjb2RlIHF1YWxpdHkgaXNzdWVzXG4gICAgZm9yIChsZXQgbGluZUluZGV4ID0gMDsgbGluZUluZGV4IDwgbGluZXMubGVuZ3RoOyBsaW5lSW5kZXgrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2xpbmVJbmRleF07XG4gICAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBhbmQgY29tbWVudHNcbiAgICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBsb25nIGxpbmVzXG4gICAgICBpZiAobGluZS5sZW5ndGggPiAxMjApIHtcbiAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxuICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgIGZpbGU6IGZpbGVQYXRoLFxuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogJ2NvZGUtcXVhbGl0eScsXG4gICAgICAgICAgaXNzdWU6ICdMaW5lIGlzIHRvbyBsb25nICg+MTIwIGNoYXJhY3RlcnMpJyxcbiAgICAgICAgICBwYXR0ZXJuOiAnbG9uZy1saW5lJyxcbiAgICAgICAgICBxdWlja0ZpeDogJ0JyZWFrIGxvbmcgbGluZXMgZm9yIGJldHRlciByZWFkYWJpbGl0eScsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgaWYgKGxpbmUuZW5kc1dpdGgoJyAnKSB8fCBsaW5lLmVuZHNXaXRoKCdcXHQnKSkge1xuICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICBraW5kOiAncGF0dGVybicsXG4gICAgICAgICAgbGFuZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBzdGF0dXM6ICdhZmZlY3RlZCcsXG4gICAgICAgICAgcmVhc29uOiAnY29kZS1xdWFsaXR5JyxcbiAgICAgICAgICBpc3N1ZTogJ1RyYWlsaW5nIHdoaXRlc3BhY2UgZGV0ZWN0ZWQnLFxuICAgICAgICAgIHBhdHRlcm46ICd0cmFpbGluZy13aGl0ZXNwYWNlJyxcbiAgICAgICAgICBxdWlja0ZpeDogJ1JlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBtaXhlZCB0YWJzIGFuZCBzcGFjZXNcbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdcXHQnKSAmJiBsaW5lLmluY2x1ZGVzKCcgJykpIHtcbiAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxuICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgIGZpbGU6IGZpbGVQYXRoLFxuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogJ2NvZGUtcXVhbGl0eScsXG4gICAgICAgICAgaXNzdWU6ICdNaXhlZCB0YWJzIGFuZCBzcGFjZXMgZm9yIGluZGVudGF0aW9uJyxcbiAgICAgICAgICBwYXR0ZXJuOiAnbWl4ZWQtaW5kZW50YXRpb24nLFxuICAgICAgICAgIHF1aWNrRml4OiAnVXNlIGNvbnNpc3RlbnQgaW5kZW50YXRpb24gKHByZWZlciBzcGFjZXMpJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBUT0RPL0ZJWE1FIGNvbW1lbnRzXG4gICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd0b2RvJykgfHwgbGluZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmaXhtZScpKSB7XG4gICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBmaWxlOiBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICByZWFzb246ICdjb2RlLXF1YWxpdHknLFxuICAgICAgICAgIGlzc3VlOiAnVE9ETy9GSVhNRSBjb21tZW50IGZvdW5kJyxcbiAgICAgICAgICBwYXR0ZXJuOiAndG9kby1jb21tZW50JyxcbiAgICAgICAgICBxdWlja0ZpeDogJ0FkZHJlc3MgVE9ETy9GSVhNRSBpdGVtcyBiZWZvcmUgcHJvZHVjdGlvbicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgY29uc29sZS5sb2cgaW4gcHJvZHVjdGlvbiBjb2RlXG4gICAgICBpZiAobGFuZ3VhZ2UgPT09ICdub2RlJyAmJiBsaW5lLmluY2x1ZGVzKCdjb25zb2xlLmxvZycpKSB7XG4gICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBmaWxlOiBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICByZWFzb246ICdjb2RlLXF1YWxpdHknLFxuICAgICAgICAgIGlzc3VlOiAnY29uc29sZS5sb2cgc2hvdWxkIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbicsXG4gICAgICAgICAgcGF0dGVybjogJ2NvbnNvbGUtbG9nJyxcbiAgICAgICAgICBxdWlja0ZpeDogJ1VzZSBwcm9wZXIgbG9nZ2luZyBsaWJyYXJ5IG9yIHJlbW92ZSBkZWJ1ZyBzdGF0ZW1lbnRzJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBwcmludCBzdGF0ZW1lbnRzIGluIFB5dGhvblxuICAgICAgaWYgKGxhbmd1YWdlID09PSAncHl0aG9uJyAmJiBsaW5lLmluY2x1ZGVzKCdwcmludCgnKSkge1xuICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICBraW5kOiAncGF0dGVybicsXG4gICAgICAgICAgbGFuZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBzdGF0dXM6ICdhZmZlY3RlZCcsXG4gICAgICAgICAgcmVhc29uOiAnY29kZS1xdWFsaXR5JyxcbiAgICAgICAgICBpc3N1ZTogJ3ByaW50KCkgc2hvdWxkIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbicsXG4gICAgICAgICAgcGF0dGVybjogJ3ByaW50LXN0YXRlbWVudCcsXG4gICAgICAgICAgcXVpY2tGaXg6ICdVc2UgcHJvcGVyIGxvZ2dpbmcgbGlicmFyeSBvciByZW1vdmUgZGVidWcgc3RhdGVtZW50cycsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5kaW5ncztcbn1cblxuLyoqXG4gKiBBbmFseXplIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllc1xuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xuICogQHJldHVybnMgQXJyYXkgb2Ygc2VjdXJpdHkgZmluZGluZ3NcbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZVNlY3VyaXR5VnVsbmVyYWJpbGl0aWVzKGZpbGVzOiBBcnJheTx7IHBhdGg/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZzsgc2l6ZTogbnVtYmVyIH0+KTogRmluZGluZ1tdIHtcbiAgY29uc3QgZmluZGluZ3M6IEZpbmRpbmdbXSA9IFtdO1xuXG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoIHx8IGZpbGUubmFtZSB8fCAndW5rbm93bic7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKTtcbiAgICBcbiAgICBpZiAoIWxhbmd1YWdlKSBjb250aW51ZTtcblxuICAgIGNvbnN0IGxpbmVzID0gZmlsZS5jb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3Igc2VjdXJpdHkgdnVsbmVyYWJpbGl0aWVzXG4gICAgZm9yIChsZXQgbGluZUluZGV4ID0gMDsgbGluZUluZGV4IDwgbGluZXMubGVuZ3RoOyBsaW5lSW5kZXgrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2xpbmVJbmRleF07XG4gICAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBhbmQgY29tbWVudHNcbiAgICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBoYXJkY29kZWQgcGFzc3dvcmRzXG4gICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdwYXNzd29yZCcpICYmIGxpbmUuaW5jbHVkZXMoJz0nKSAmJiAhbGluZS5pbmNsdWRlcygnaW5wdXQoJykpIHtcbiAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxuICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgIGZpbGU6IGZpbGVQYXRoLFxuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogJ3NlY3VyaXR5JyxcbiAgICAgICAgICBpc3N1ZTogJ1BvdGVudGlhbCBoYXJkY29kZWQgcGFzc3dvcmQgZGV0ZWN0ZWQnLFxuICAgICAgICAgIHBhdHRlcm46ICdoYXJkY29kZWQtcGFzc3dvcmQnLFxuICAgICAgICAgIHF1aWNrRml4OiAnVXNlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvciBzZWN1cmUgY3JlZGVudGlhbCBzdG9yYWdlJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBoYXJkY29kZWQgQVBJIGtleXNcbiAgICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2FwaScpICYmIGxpbmUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygna2V5JykgJiYgbGluZS5pbmNsdWRlcygnPScpKSB7XG4gICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBmaWxlOiBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICByZWFzb246ICdzZWN1cml0eScsXG4gICAgICAgICAgaXNzdWU6ICdQb3RlbnRpYWwgaGFyZGNvZGVkIEFQSSBrZXkgZGV0ZWN0ZWQnLFxuICAgICAgICAgIHBhdHRlcm46ICdoYXJkY29kZWQtYXBpLWtleScsXG4gICAgICAgICAgcXVpY2tGaXg6ICdVc2UgZW52aXJvbm1lbnQgdmFyaWFibGVzIG9yIHNlY3VyZSBjcmVkZW50aWFsIHN0b3JhZ2UnLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIFNRTCBpbmplY3Rpb24gdnVsbmVyYWJpbGl0aWVzXG4gICAgICBpZiAobGluZS5pbmNsdWRlcygnU0VMRUNUJykgfHwgbGluZS5pbmNsdWRlcygnSU5TRVJUJykgfHwgbGluZS5pbmNsdWRlcygnVVBEQVRFJykgfHwgbGluZS5pbmNsdWRlcygnREVMRVRFJykpIHtcbiAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJysnKSB8fCBsaW5lLmluY2x1ZGVzKCckeycpIHx8IGxpbmUuaW5jbHVkZXMoJyVzJykpIHtcbiAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgICAgcmVhc29uOiAnc2VjdXJpdHknLFxuICAgICAgICAgICAgaXNzdWU6ICdQb3RlbnRpYWwgU1FMIGluamVjdGlvbiB2dWxuZXJhYmlsaXR5JyxcbiAgICAgICAgICAgIHBhdHRlcm46ICdzcWwtaW5qZWN0aW9uJyxcbiAgICAgICAgICAgIHF1aWNrRml4OiAnVXNlIHBhcmFtZXRlcml6ZWQgcXVlcmllcyBvciBwcmVwYXJlZCBzdGF0ZW1lbnRzJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgWFNTIHZ1bG5lcmFiaWxpdGllc1xuICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJ2lubmVySFRNTCcpIHx8IGxpbmUuaW5jbHVkZXMoJ291dGVySFRNTCcpIHx8IGxpbmUuaW5jbHVkZXMoJ2RvY3VtZW50LndyaXRlJykpIHtcbiAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxuICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgIGZpbGU6IGZpbGVQYXRoLFxuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogJ3NlY3VyaXR5JyxcbiAgICAgICAgICBpc3N1ZTogJ1BvdGVudGlhbCBYU1MgdnVsbmVyYWJpbGl0eScsXG4gICAgICAgICAgcGF0dGVybjogJ3hzcy12dWxuZXJhYmlsaXR5JyxcbiAgICAgICAgICBxdWlja0ZpeDogJ1VzZSB0ZXh0Q29udGVudCBvciBzYW5pdGl6ZSBIVE1MIGNvbnRlbnQnLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIHVuc2FmZSBkZXNlcmlhbGl6YXRpb25cbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdwaWNrbGUubG9hZCcpIHx8IGxpbmUuaW5jbHVkZXMoJ3VucGlja2xlJykgfHwgbGluZS5pbmNsdWRlcygnZGVzZXJpYWxpemUnKSkge1xuICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICBraW5kOiAncGF0dGVybicsXG4gICAgICAgICAgbGFuZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBzdGF0dXM6ICdhZmZlY3RlZCcsXG4gICAgICAgICAgcmVhc29uOiAnc2VjdXJpdHknLFxuICAgICAgICAgIGlzc3VlOiAnVW5zYWZlIGRlc2VyaWFsaXphdGlvbiBkZXRlY3RlZCcsXG4gICAgICAgICAgcGF0dGVybjogJ3Vuc2FmZS1kZXNlcmlhbGl6YXRpb24nLFxuICAgICAgICAgIHF1aWNrRml4OiAnVXNlIHNhZmUgc2VyaWFsaXphdGlvbiBmb3JtYXRzIGxpa2UgSlNPTicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5kaW5ncztcbn1cblxuLyoqXG4gKiBBbmFseXplIHBlcmZvcm1hbmNlIGlzc3Vlc1xuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xuICogQHJldHVybnMgQXJyYXkgb2YgcGVyZm9ybWFuY2UgZmluZGluZ3NcbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZVBlcmZvcm1hbmNlSXNzdWVzKGZpbGVzOiBBcnJheTx7IHBhdGg/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZzsgc2l6ZTogbnVtYmVyIH0+KTogRmluZGluZ1tdIHtcbiAgY29uc3QgZmluZGluZ3M6IEZpbmRpbmdbXSA9IFtdO1xuXG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoIHx8IGZpbGUubmFtZSB8fCAndW5rbm93bic7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKTtcbiAgICBcbiAgICBpZiAoIWxhbmd1YWdlKSBjb250aW51ZTtcblxuICAgIGNvbnN0IGxpbmVzID0gZmlsZS5jb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgcGVyZm9ybWFuY2UgaXNzdWVzXG4gICAgZm9yIChsZXQgbGluZUluZGV4ID0gMDsgbGluZUluZGV4IDwgbGluZXMubGVuZ3RoOyBsaW5lSW5kZXgrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2xpbmVJbmRleF07XG4gICAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBhbmQgY29tbWVudHNcbiAgICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBzeW5jaHJvbm91cyBmaWxlIG9wZXJhdGlvbnNcbiAgICAgIGlmIChsYW5ndWFnZSA9PT0gJ25vZGUnICYmIChsaW5lLmluY2x1ZGVzKCdmcy5yZWFkRmlsZVN5bmMnKSB8fCBsaW5lLmluY2x1ZGVzKCdmcy53cml0ZUZpbGVTeW5jJykpKSB7XG4gICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBmaWxlOiBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICByZWFzb246ICdwZXJmb3JtYW5jZScsXG4gICAgICAgICAgaXNzdWU6ICdTeW5jaHJvbm91cyBmaWxlIG9wZXJhdGlvbiBjYW4gYmxvY2sgdGhlIGV2ZW50IGxvb3AnLFxuICAgICAgICAgIHBhdHRlcm46ICdzeW5jLWZpbGUtb3BlcmF0aW9uJyxcbiAgICAgICAgICBxdWlja0ZpeDogJ1VzZSBhc3luY2hyb25vdXMgZmlsZSBvcGVyYXRpb25zIChmcy5wcm9taXNlcyknLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIGJsb2NraW5nIG9wZXJhdGlvbnNcbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdzbGVlcCgnKSB8fCBsaW5lLmluY2x1ZGVzKCd0aW1lLnNsZWVwKCcpKSB7XG4gICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBmaWxlOiBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICByZWFzb246ICdwZXJmb3JtYW5jZScsXG4gICAgICAgICAgaXNzdWU6ICdCbG9ja2luZyBzbGVlcCBvcGVyYXRpb24gZGV0ZWN0ZWQnLFxuICAgICAgICAgIHBhdHRlcm46ICdibG9ja2luZy1zbGVlcCcsXG4gICAgICAgICAgcXVpY2tGaXg6ICdVc2UgYXN5bmNocm9ub3VzIGFsdGVybmF0aXZlcyBvciByZWR1Y2Ugc2xlZXAgdGltZScsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgaW5lZmZpY2llbnQgbG9vcHNcbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdmb3InKSAmJiBsaW5lLmluY2x1ZGVzKCdpbicpICYmIGxpbmUuaW5jbHVkZXMoJ3JhbmdlKCcpKSB7XG4gICAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdsZW4oJykgfHwgbGluZS5pbmNsdWRlcygnLmxlbmd0aCcpKSB7XG4gICAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICBraW5kOiAncGF0dGVybicsXG4gICAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICAgIGZpbGU6IGZpbGVQYXRoLFxuICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICAgIHJlYXNvbjogJ3BlcmZvcm1hbmNlJyxcbiAgICAgICAgICAgIGlzc3VlOiAnSW5lZmZpY2llbnQgbG9vcCB3aXRoIGxlbigpL2xlbmd0aCBjYWxsJyxcbiAgICAgICAgICAgIHBhdHRlcm46ICdpbmVmZmljaWVudC1sb29wJyxcbiAgICAgICAgICAgIHF1aWNrRml4OiAnQ2FjaGUgbGVuZ3RoIG9yIHVzZSBlbnVtZXJhdGUoKS9lbnRyaWVzKCknLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBzdHJpbmcgY29uY2F0ZW5hdGlvbiBpbiBsb29wc1xuICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJys9JykgJiYgbGluZS5pbmNsdWRlcygnc3RyJykgfHwgbGluZS5pbmNsdWRlcygnKz0nKSAmJiBsaW5lLmluY2x1ZGVzKCdzdHJpbmcnKSkge1xuICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICBraW5kOiAncGF0dGVybicsXG4gICAgICAgICAgbGFuZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBzdGF0dXM6ICdhZmZlY3RlZCcsXG4gICAgICAgICAgcmVhc29uOiAncGVyZm9ybWFuY2UnLFxuICAgICAgICAgIGlzc3VlOiAnU3RyaW5nIGNvbmNhdGVuYXRpb24gaW4gbG9vcCBpcyBpbmVmZmljaWVudCcsXG4gICAgICAgICAgcGF0dGVybjogJ3N0cmluZy1jb25jYXRlbmF0aW9uJyxcbiAgICAgICAgICBxdWlja0ZpeDogJ1VzZSBqb2luKCkgb3IgU3RyaW5nQnVpbGRlciBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmRpbmdzO1xufVxuXG4vKipcbiAqIEdldCBmaWxlIGV4dGVuc2lvbiBmcm9tIHBhdGhcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcbiAqIEByZXR1cm5zIEZpbGUgZXh0ZW5zaW9uIHdpdGggZG90XG4gKi9cbmZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGxhc3REb3QgPSBmaWxlUGF0aC5sYXN0SW5kZXhPZignLicpO1xuICBpZiAobGFzdERvdCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIGZpbGVQYXRoLnN1YnN0cmluZyhsYXN0RG90KTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgbGFuZ3VhZ2UgZnJvbSBmaWxlIGV4dGVuc2lvblxuICogQHBhcmFtIGV4dGVuc2lvbiBGaWxlIGV4dGVuc2lvblxuICogQHJldHVybnMgTGFuZ3VhZ2Ugb3IgbnVsbFxuICovXG5mdW5jdGlvbiBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uOiBzdHJpbmcpOiBMYW5ndWFnZSB8IG51bGwge1xuICBjb25zdCBsYW5ndWFnZU1hcDogUmVjb3JkPHN0cmluZywgTGFuZ3VhZ2U+ID0ge1xuICAgICcuaHRtbCc6ICdub2RlJyxcbiAgICAnLmh0bSc6ICdub2RlJyxcbiAgICAnLmNzcyc6ICdub2RlJyxcbiAgICAnLmpzJzogJ25vZGUnLFxuICAgICcuanN4JzogJ25vZGUnLFxuICAgICcubWpzJzogJ25vZGUnLFxuICAgICcudHMnOiAnbm9kZScsXG4gICAgJy50c3gnOiAnbm9kZScsXG4gICAgJy5zdmcnOiAnbm9kZScsXG4gICAgJy53YXNtJzogJ25vZGUnLFxuICAgICcuanNvbic6ICdub2RlJyxcbiAgICAnLndlYm1hbmlmZXN0JzogJ25vZGUnLFxuICAgICcucHknOiAncHl0aG9uJyxcbiAgICAnLmphdmEnOiAnamF2YScsXG4gICAgJy5nbyc6ICdnbycsXG4gICAgJy5jcyc6ICdkb3RuZXQnLFxuICAgICcuZnMnOiAnZG90bmV0JyxcbiAgICAnLnZiJzogJ2RvdG5ldCcsXG4gIH07XG4gIFxuICByZXR1cm4gbGFuZ3VhZ2VNYXBbZXh0ZW5zaW9uXSB8fCBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbGluZSBpcyBhIGNvbW1lbnRcbiAqIEBwYXJhbSBsaW5lIExpbmUgY29udGVudFxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcbiAqIEByZXR1cm5zIFRydWUgaWYgY29tbWVudCBsaW5lXG4gKi9cbmZ1bmN0aW9uIGlzQ29tbWVudExpbmUobGluZTogc3RyaW5nLCBsYW5ndWFnZTogTGFuZ3VhZ2UpOiBib29sZWFuIHtcbiAgY29uc3QgdHJpbW1lZCA9IGxpbmUudHJpbSgpO1xuICBcbiAgc3dpdGNoIChsYW5ndWFnZSkge1xuICAgIGNhc2UgJ25vZGUnOlxuICAgIGNhc2UgJ2phdmEnOlxuICAgIGNhc2UgJ2dvJzpcbiAgICBjYXNlICdkb3RuZXQnOlxuICAgICAgcmV0dXJuIHRyaW1tZWQuc3RhcnRzV2l0aCgnLy8nKSB8fCB0cmltbWVkLnN0YXJ0c1dpdGgoJy8qJykgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCcqJykgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCc8IS0tJyk7XG4gICAgXG4gICAgY2FzZSAncHl0aG9uJzpcbiAgICAgIHJldHVybiB0cmltbWVkLnN0YXJ0c1dpdGgoJyMnKTtcbiAgICBcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgc3VtbWFyeSBmcm9tIGZpbmRpbmdzXG4gKiBAcGFyYW0gZmluZGluZ3MgQXJyYXkgb2YgZmluZGluZ3NcbiAqIEBwYXJhbSBkZXRlY3RlZExhbmd1YWdlcyBBcnJheSBvZiBkZXRlY3RlZCBsYW5ndWFnZXNcbiAqIEByZXR1cm5zIFJlcG9ydCBzdW1tYXJ5XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU3VtbWFyeShmaW5kaW5nczogRmluZGluZ1tdLCBkZXRlY3RlZExhbmd1YWdlczogTGFuZ3VhZ2VbXSk6IFJlcG9ydFN1bW1hcnkge1xuICBjb25zdCBzdW1tYXJ5OiBSZXBvcnRTdW1tYXJ5ID0ge1xuICAgIG9rOiAwLFxuICAgIGFmZmVjdGVkOiAwLFxuICAgIHVua25vd246IDAsXG4gICAgYnlMYW5ndWFnZToge30sXG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYW5ndWFnZSBzdW1tYXJpZXNcbiAgZm9yIChjb25zdCBsYW5ndWFnZSBvZiBkZXRlY3RlZExhbmd1YWdlcykge1xuICAgIHN1bW1hcnkuYnlMYW5ndWFnZVtsYW5ndWFnZV0gPSB7XG4gICAgICBvazogMCxcbiAgICAgIGFmZmVjdGVkOiAwLFxuICAgICAgdW5rbm93bjogMCxcbiAgICB9O1xuICB9XG5cbiAgLy8gQ291bnQgZmluZGluZ3MgYnkgc3RhdHVzIGFuZCBsYW5ndWFnZVxuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgZmluZGluZ3MpIHtcbiAgICBpZiAoZmluZGluZy5raW5kID09PSAnZGVwZW5kZW5jeScpIHtcbiAgICAgIHN1bW1hcnlbZmluZGluZy5zdGF0dXNdKys7XG4gICAgICBpZiAoc3VtbWFyeS5ieUxhbmd1YWdlW2ZpbmRpbmcubGFuZ10pIHtcbiAgICAgICAgc3VtbWFyeS5ieUxhbmd1YWdlW2ZpbmRpbmcubGFuZ10hW2ZpbmRpbmcuc3RhdHVzXSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmluZGluZy5raW5kID09PSAncGF0dGVybicpIHtcbiAgICAgIHN1bW1hcnkuYWZmZWN0ZWQrKztcbiAgICAgIGlmIChzdW1tYXJ5LmJ5TGFuZ3VhZ2VbZmluZGluZy5sYW5nXSkge1xuICAgICAgICBzdW1tYXJ5LmJ5TGFuZ3VhZ2VbZmluZGluZy5sYW5nXSEuYWZmZWN0ZWQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VtbWFyeTtcbn1cblxuLyoqXG4gKiBHZXQgcHJvamVjdCBuYW1lIGZyb20gWklQIHBhdGhcbiAqIEBwYXJhbSB6aXBQYXRoIFpJUCBmaWxlIHBhdGhcbiAqIEByZXR1cm5zIFByb2plY3QgbmFtZVxuICovXG5mdW5jdGlvbiBnZXRQcm9qZWN0TmFtZSh6aXBQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYXRoUGFydHMgPSB6aXBQYXRoLnNwbGl0KCcvJyk7XG4gIGNvbnN0IGZpbGVOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGZpbGVOYW1lLnJlcGxhY2UoL1xcLnppcCQvaSwgJycpO1xufVxuXG4vKipcbiAqIFJ1biBhbmFseXNpcyBvbiBleHRyYWN0ZWQgZmlsZXMgKGZvciB0ZXN0aW5nKVxuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xuICogQHBhcmFtIG1hbmlmZXN0cyBBcnJheSBvZiBwcm9qZWN0IG1hbmlmZXN0c1xuICogQHBhcmFtIHJ1bGVzIEJhc2VsaW5lIHJ1bGVzXG4gKiBAcmV0dXJucyBBbmFseXNpcyByZXN1bHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bkFuYWx5c2lzT25GaWxlcyhcbiAgZmlsZXM6IEV4dHJhY3RlZEZpbGVbXSxcbiAgbWFuaWZlc3RzOiBQcm9qZWN0TWFuaWZlc3RbXSxcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNcbik6IFByb21pc2U8QW5hbHlzaXNSZXN1bHQ+IHtcbiAgY29uc3QgYW5hbHlzaXNJZCA9IHJhbmRvbVVVSUQoKTtcbiAgY29uc3QgZGV0ZWN0ZWRMYW5ndWFnZXMgPSBkZXRlY3RMYW5ndWFnZXNGcm9tRmlsZXMoZmlsZXMpO1xuICBcbiAgY29uc3QgY29udGV4dDogQW5hbHlzaXNDb250ZXh0ID0ge1xuICAgIHJ1bGVzLFxuICAgIGV4dHJhY3RlZEZpbGVzOiBmaWxlcyxcbiAgICBtYW5pZmVzdHMsXG4gICAgZGV0ZWN0ZWRMYW5ndWFnZXMsXG4gIH07XG5cbiAgY29uc3QgZmluZGluZ3MgPSBhd2FpdCBydW5BbmFseXNpcyhjb250ZXh0KTtcbiAgY29uc3Qgc3VtbWFyeSA9IGdlbmVyYXRlU3VtbWFyeShmaW5kaW5ncywgZGV0ZWN0ZWRMYW5ndWFnZXMpO1xuICBcbiAgY29uc3QgcmVwb3J0OiBSZXBvcnQgPSB7XG4gICAgZmluZGluZ3MsXG4gICAgc3VtbWFyeSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgYW5hbHlzaXNJZCxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgcHJvamVjdE5hbWU6ICd0ZXN0LXByb2plY3QnLFxuICAgICAgZGV0ZWN0ZWRMYW5ndWFnZXMsXG4gICAgICB0b3RhbEZpbGVzOiBmaWxlcy5sZW5ndGgsXG4gICAgICBzY2FubmVkRmlsZXM6IGZpbGVzLmxlbmd0aCxcbiAgICAgIHNraXBwZWRGaWxlczogMCxcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiB7IHJlcG9ydCB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuYWx5c2lzIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zIEFuYWx5c2lzIG9wdGlvbnNcbiAqIEByZXR1cm5zIFZhbGlkYXRlZCBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFuYWx5c2lzT3B0aW9ucyhvcHRpb25zOiBBbmFseXNpc09wdGlvbnMpOiBBbmFseXNpc09wdGlvbnMge1xuICByZXR1cm4ge1xuICAgIG1heEZpbGVzOiBNYXRoLm1pbihvcHRpb25zLm1heEZpbGVzIHx8IDUwMDAwLCAxMDAwMDApLCAvLyBDYXAgYXQgMTAwa1xuICAgIG1heEZpbGVTaXplOiBNYXRoLm1pbihvcHRpb25zLm1heEZpbGVTaXplIHx8IDIgKiAxMDI0ICogMTAyNCwgMTAgKiAxMDI0ICogMTAyNCksIC8vIENhcCBhdCAxME1CXG4gICAgYWxsb3dlZEV4dGVuc2lvbnM6IG9wdGlvbnMuYWxsb3dlZEV4dGVuc2lvbnMgfHwgWycuaHRtbCcsICcuaHRtJywgJy5jc3MnLCAnLmpzJywgJy5tanMnLCAnLnRzJywgJy5zdmcnLCAnLndhc20nLCAnLmpzb24nLCAnLndlYm1hbmlmZXN0J10sXG4gICAgaWdub3JlUGF0aHM6IG9wdGlvbnMuaWdub3JlUGF0aHMgfHwgWycvbm9kZV9tb2R1bGVzLycsICcvLnZlbnYvJywgJy92ZW52LycsICcvZGlzdC8nLCAnL2J1aWxkLycsICcvLmdpdC8nLCAnLy5uZXh0LyddLFxuICAgIHN0b3JlUmVzdWx0czogb3B0aW9ucy5zdG9yZVJlc3VsdHMgIT09IGZhbHNlLFxuICAgIHB1YmxpY1VybDogb3B0aW9ucy5wdWJsaWNVcmwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcsXG4gIH07XG59XG5cbi8qKlxuICogR2V0IGFuYWx5c2lzIHByb2dyZXNzIChmb3IgbG9uZy1ydW5uaW5nIGFuYWx5c2VzKVxuICogQHBhcmFtIGNvbnRleHQgQW5hbHlzaXMgY29udGV4dFxuICogQHBhcmFtIGN1cnJlbnRTdGVwIEN1cnJlbnQgc3RlcFxuICogQHBhcmFtIHRvdGFsU3RlcHMgVG90YWwgc3RlcHNcbiAqIEByZXR1cm5zIFByb2dyZXNzIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmFseXNpc1Byb2dyZXNzKFxuICBjb250ZXh0OiBBbmFseXNpc0NvbnRleHQsXG4gIGN1cnJlbnRTdGVwOiBudW1iZXIsXG4gIHRvdGFsU3RlcHM6IG51bWJlclxuKToge1xuICBzdGVwOiBzdHJpbmc7XG4gIHByb2dyZXNzOiBudW1iZXI7XG4gIGRldGFpbHM6IHN0cmluZztcbn0ge1xuICBjb25zdCBzdGVwcyA9IFtcbiAgICAnTG9hZGluZyBiYXNlbGluZSBydWxlcycsXG4gICAgJ0V4dHJhY3RpbmcgWklQIGZpbGUnLFxuICAgICdEZXRlY3RpbmcgcHJvamVjdCBtYW5pZmVzdHMnLFxuICAgICdBbmFseXppbmcgZGVwZW5kZW5jaWVzJyxcbiAgICAnU2Nhbm5pbmcgc291cmNlIGZpbGVzJyxcbiAgICAnR2VuZXJhdGluZyByZXBvcnQnLFxuICBdO1xuXG4gIGNvbnN0IHN0ZXAgPSBzdGVwc1tjdXJyZW50U3RlcF0gfHwgJ1Vua25vd24nO1xuICBjb25zdCBwcm9ncmVzcyA9IChjdXJyZW50U3RlcCAvIHRvdGFsU3RlcHMpICogMTAwO1xuICBcbiAgbGV0IGRldGFpbHMgPSAnJztcbiAgaWYgKGN1cnJlbnRTdGVwID09PSAxKSB7XG4gICAgZGV0YWlscyA9IGBFeHRyYWN0ZWQgJHtjb250ZXh0LmV4dHJhY3RlZEZpbGVzLmxlbmd0aH0gZmlsZXNgO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRTdGVwID09PSAyKSB7XG4gICAgZGV0YWlscyA9IGBGb3VuZCAke2NvbnRleHQubWFuaWZlc3RzLmxlbmd0aH0gbWFuaWZlc3RzLCAke2NvbnRleHQuZGV0ZWN0ZWRMYW5ndWFnZXMubGVuZ3RofSBsYW5ndWFnZXNgO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRTdGVwID09PSAzKSB7XG4gICAgZGV0YWlscyA9IGBBbmFseXppbmcgJHtjb250ZXh0Lm1hbmlmZXN0cy5sZW5ndGh9IGRlcGVuZGVuY3kgbWFuaWZlc3RzYDtcbiAgfSBlbHNlIGlmIChjdXJyZW50U3RlcCA9PT0gNCkge1xuICAgIGRldGFpbHMgPSBgU2Nhbm5pbmcgJHtjb250ZXh0LmV4dHJhY3RlZEZpbGVzLmxlbmd0aH0gc291cmNlIGZpbGVzYDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RlcCxcbiAgICBwcm9ncmVzcyxcbiAgICBkZXRhaWxzLFxuICB9O1xufVxuXG4vKipcbiAqIEVzdGltYXRlIGFuYWx5c2lzIHRpbWVcbiAqIEBwYXJhbSBmaWxlQ291bnQgTnVtYmVyIG9mIGZpbGVzXG4gKiBAcGFyYW0gbWFuaWZlc3RDb3VudCBOdW1iZXIgb2YgbWFuaWZlc3RzXG4gKiBAcmV0dXJucyBFc3RpbWF0ZWQgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzdGltYXRlQW5hbHlzaXNUaW1lKGZpbGVDb3VudDogbnVtYmVyLCBtYW5pZmVzdENvdW50OiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBCYXNlIHRpbWU6IDEgc2Vjb25kXG4gIGxldCBlc3RpbWF0ZWQgPSAxMDAwO1xuICBcbiAgLy8gQWRkIHRpbWUgZm9yIGZpbGUgcHJvY2Vzc2luZzogMTBtcyBwZXIgZmlsZVxuICBlc3RpbWF0ZWQgKz0gZmlsZUNvdW50ICogMTA7XG4gIFxuICAvLyBBZGQgdGltZSBmb3IgbWFuaWZlc3QgcHJvY2Vzc2luZzogNTBtcyBwZXIgbWFuaWZlc3RcbiAgZXN0aW1hdGVkICs9IG1hbmlmZXN0Q291bnQgKiA1MDtcbiAgXG4gIC8vIEFkZCB0aW1lIGZvciBwYXR0ZXJuIHNjYW5uaW5nOiA1bXMgcGVyIGZpbGVcbiAgZXN0aW1hdGVkICs9IGZpbGVDb3VudCAqIDU7XG4gIFxuICByZXR1cm4gTWF0aC5taW4oZXN0aW1hdGVkLCAzMDAwMCk7IC8vIENhcCBhdCAzMCBzZWNvbmRzXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW5hbHlzaXMgaXMgZmVhc2libGVcbiAqIEBwYXJhbSBmaWxlQ291bnQgTnVtYmVyIG9mIGZpbGVzXG4gKiBAcGFyYW0gdG90YWxTaXplIFRvdGFsIHNpemUgaW4gYnl0ZXNcbiAqIEByZXR1cm5zIEZlYXNpYmlsaXR5IGNoZWNrIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tBbmFseXNpc0ZlYXNpYmlsaXR5KFxuICBmaWxlQ291bnQ6IG51bWJlcixcbiAgdG90YWxTaXplOiBudW1iZXJcbik6IHtcbiAgZmVhc2libGU6IGJvb2xlYW47XG4gIHdhcm5pbmdzOiBzdHJpbmdbXTtcbiAgZXN0aW1hdGVkVGltZTogc3RyaW5nO1xufSB7XG4gIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgZmVhc2libGUgPSB0cnVlO1xuXG4gIC8vIENoZWNrIGZpbGUgY291bnRcbiAgaWYgKGZpbGVDb3VudCA+IDUwMDAwKSB7XG4gICAgZmVhc2libGUgPSBmYWxzZTtcbiAgICB3YXJuaW5ncy5wdXNoKGBUb28gbWFueSBmaWxlczogJHtmaWxlQ291bnR9IChsaW1pdDogNTAsMDAwKWApO1xuICB9IGVsc2UgaWYgKGZpbGVDb3VudCA+IDEwMDAwKSB7XG4gICAgd2FybmluZ3MucHVzaChgTGFyZ2UgbnVtYmVyIG9mIGZpbGVzOiAke2ZpbGVDb3VudH0gKGFuYWx5c2lzIG1heSB0YWtlIGxvbmdlcilgKTtcbiAgfVxuXG4gIC8vIENoZWNrIHRvdGFsIHNpemVcbiAgaWYgKHRvdGFsU2l6ZSA+IDEwMCAqIDEwMjQgKiAxMDI0KSB7IC8vIDEwME1CXG4gICAgZmVhc2libGUgPSBmYWxzZTtcbiAgICB3YXJuaW5ncy5wdXNoKGBBcmNoaXZlIHRvbyBsYXJnZTogJHtNYXRoLnJvdW5kKHRvdGFsU2l6ZSAvIDEwMjQgLyAxMDI0KX1NQiAobGltaXQ6IDEwME1CKWApO1xuICB9IGVsc2UgaWYgKHRvdGFsU2l6ZSA+IDUwICogMTAyNCAqIDEwMjQpIHsgLy8gNTBNQlxuICAgIHdhcm5pbmdzLnB1c2goYExhcmdlIGFyY2hpdmU6ICR7TWF0aC5yb3VuZCh0b3RhbFNpemUgLyAxMDI0IC8gMTAyNCl9TUIgKGFuYWx5c2lzIG1heSB0YWtlIGxvbmdlcilgKTtcbiAgfVxuXG4gIGNvbnN0IGVzdGltYXRlZFRpbWVNcyA9IGVzdGltYXRlQW5hbHlzaXNUaW1lKGZpbGVDb3VudCwgTWF0aC5taW4oZmlsZUNvdW50IC8gMTAwLCA1MCkpO1xuICBjb25zdCBlc3RpbWF0ZWRUaW1lID0gYCR7TWF0aC5yb3VuZChlc3RpbWF0ZWRUaW1lTXMgLyAxMDAwKX1zYDtcblxuICByZXR1cm4ge1xuICAgIGZlYXNpYmxlLFxuICAgIHdhcm5pbmdzLFxuICAgIGVzdGltYXRlZFRpbWUsXG4gIH07XG59XG4iXSwibmFtZXMiOlsicmFuZG9tVVVJRCIsImxvYWRCYXNlbGluZVJ1bGVzIiwiZGV0ZWN0UHJvamVjdE1hbmlmZXN0cyIsImRldGVjdExhbmd1YWdlc0Zyb21GaWxlcyIsImFuYWx5emVEZXBlbmRlbmNpZXMiLCJzY2FuU291cmNlRmlsZXMiLCJleHRyYWN0WmlwVG9NZW1vcnkiLCJwcm9jZXNzU2luZ2xlRmlsZSIsInNob3VsZEFuYWx5emVGaWxlIiwic3RvcmVBbmFseXNpc1Jlc3VsdHMiLCJhbmFseXplV2l0aEdyb3EiLCJmaWxlcyIsInByb2plY3RUeXBlIiwiZGVwZW5kZW5jaWVzIiwicmVzdWx0cyIsInByb2Nlc3MiLCJlbnYiLCJHUk9RX0FQSV9LRVkiLCJjb25zb2xlIiwibG9nIiwia2V5RmlsZXMiLCJmaWx0ZXIiLCJmaWxlIiwiZmlsZU5hbWUiLCJuYW1lIiwicGF0aCIsImV4dCIsInNwbGl0IiwicG9wIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInNsaWNlIiwiYmFzZVVybCIsIlBVQkxJQ19VUkwiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiY29kZSIsImNvbnRlbnQiLCJmaWxlbmFtZSIsIm9rIiwicmVzdWx0IiwianNvbiIsInB1c2giLCJlcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJydW5CYXNlbGluZUFuYWx5c2lzIiwiZmlsZVBhdGgiLCJvcHRpb25zIiwibWF4RmlsZXMiLCJtYXhGaWxlU2l6ZSIsImFsbG93ZWRFeHRlbnNpb25zIiwiaWdub3JlUGF0aHMiLCJzdG9yZVJlc3VsdHMiLCJwdWJsaWNVcmwiLCJhbmFseXNpc0lkIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJ1bGVzIiwiaXNaaXBGaWxlIiwiZW5kc1dpdGgiLCJleHRyYWN0UmVzdWx0IiwiZXJyb3JzIiwibGVuZ3RoIiwid2FybiIsImZzIiwicmVhZEZpbGVTeW5jIiwiRXJyb3IiLCJtYW5pZmVzdHMiLCJkZXRlY3RlZExhbmd1YWdlcyIsImNvbnRleHQiLCJleHRyYWN0ZWRGaWxlcyIsImZpbmRpbmdzIiwicnVuQW5hbHlzaXMiLCJhZGRpdGlvbmFsRmluZGluZ3MiLCJydW5BZGRpdGlvbmFsQW5hbHlzaXMiLCJzdW1tYXJ5IiwiZ2VuZXJhdGVTdW1tYXJ5IiwiZ3JvcVJlc3VsdHMiLCJqb2luIiwiZmxhdE1hcCIsIm0iLCJPYmplY3QiLCJrZXlzIiwicmVwb3J0IiwibWV0YWRhdGEiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsInByb2plY3ROYW1lIiwiZ2V0UHJvamVjdE5hbWUiLCJ0b3RhbEZpbGVzIiwic2Nhbm5lZEZpbGVzIiwic2tpcHBlZEZpbGVzIiwiZ3JvcUFuYWx5c2lzIiwiYXJ0aWZhY3RzIiwiZW5kVGltZSIsIm1lc3NhZ2UiLCJkZXBlbmRlbmN5RmluZGluZ3MiLCJwYXR0ZXJuRmluZGluZ3MiLCJxdWFsaXR5RmluZGluZ3MiLCJhbmFseXplQ29kZVF1YWxpdHkiLCJzZWN1cml0eUZpbmRpbmdzIiwiYW5hbHl6ZVNlY3VyaXR5VnVsbmVyYWJpbGl0aWVzIiwicGVyZm9ybWFuY2VGaW5kaW5ncyIsImFuYWx5emVQZXJmb3JtYW5jZUlzc3VlcyIsImV4dGVuc2lvbiIsImdldEZpbGVFeHRlbnNpb24iLCJsYW5ndWFnZSIsImRldGVjdExhbmd1YWdlRnJvbUV4dGVuc2lvbiIsImxpbmVzIiwibGluZUluZGV4IiwibGluZSIsImxpbmVOdW1iZXIiLCJpc0NvbW1lbnRMaW5lIiwidHJpbSIsImtpbmQiLCJsYW5nIiwicmVhc29uIiwiaXNzdWUiLCJwYXR0ZXJuIiwicXVpY2tGaXgiLCJsYXN0RG90IiwibGFzdEluZGV4T2YiLCJzdWJzdHJpbmciLCJsYW5ndWFnZU1hcCIsInRyaW1tZWQiLCJzdGFydHNXaXRoIiwiYWZmZWN0ZWQiLCJ1bmtub3duIiwiYnlMYW5ndWFnZSIsImZpbmRpbmciLCJ6aXBQYXRoIiwicGF0aFBhcnRzIiwicmVwbGFjZSIsInJ1bkFuYWx5c2lzT25GaWxlcyIsInZhbGlkYXRlQW5hbHlzaXNPcHRpb25zIiwiTWF0aCIsIm1pbiIsImdldEFuYWx5c2lzUHJvZ3Jlc3MiLCJjdXJyZW50U3RlcCIsInRvdGFsU3RlcHMiLCJzdGVwcyIsInN0ZXAiLCJwcm9ncmVzcyIsImRldGFpbHMiLCJlc3RpbWF0ZUFuYWx5c2lzVGltZSIsImZpbGVDb3VudCIsIm1hbmlmZXN0Q291bnQiLCJlc3RpbWF0ZWQiLCJjaGVja0FuYWx5c2lzRmVhc2liaWxpdHkiLCJ0b3RhbFNpemUiLCJ3YXJuaW5ncyIsImZlYXNpYmxlIiwicm91bmQiLCJlc3RpbWF0ZWRUaW1lTXMiLCJlc3RpbWF0ZWRUaW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/run.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/scan.ts":
/*!******************************!*\
  !*** ./lib/analysis/scan.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fileHasDeprecatedPatterns: () => (/* binding */ fileHasDeprecatedPatterns),\n/* harmony export */   filterPatternFindingsByFile: () => (/* binding */ filterPatternFindingsByFile),\n/* harmony export */   filterPatternFindingsByLanguage: () => (/* binding */ filterPatternFindingsByLanguage),\n/* harmony export */   getDeprecatedPatternLines: () => (/* binding */ getDeprecatedPatternLines),\n/* harmony export */   getFilesWithDeprecatedPatterns: () => (/* binding */ getFilesWithDeprecatedPatterns),\n/* harmony export */   getMostCommonPatterns: () => (/* binding */ getMostCommonPatterns),\n/* harmony export */   getPatternFrequency: () => (/* binding */ getPatternFrequency),\n/* harmony export */   getPatternQuickFix: () => (/* binding */ getPatternQuickFix),\n/* harmony export */   getPatternSummary: () => (/* binding */ getPatternSummary),\n/* harmony export */   getUniquePatterns: () => (/* binding */ getUniquePatterns),\n/* harmony export */   groupPatternFindingsByFile: () => (/* binding */ groupPatternFindingsByFile),\n/* harmony export */   groupPatternFindingsByLanguage: () => (/* binding */ groupPatternFindingsByLanguage),\n/* harmony export */   scanSourceFiles: () => (/* binding */ scanSourceFiles),\n/* harmony export */   sortPatternFindings: () => (/* binding */ sortPatternFindings)\n/* harmony export */ });\n/* harmony import */ var _baseline_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./baseline.loader */ \"(rsc)/./lib/analysis/baseline.loader.ts\");\n\n/**\n * Scan source files for deprecated patterns\n * @param files Array of extracted files\n * @param rules Baseline rules\n * @returns Array of pattern findings\n */ function scanSourceFiles(files, rules) {\n    const findings = [];\n    for (const file of files){\n        // Skip files that are too large\n        if (file.size > rules.max_file_size) {\n            console.warn(`Skipping large file: ${file.path || file.name} (${file.size} bytes)`);\n            continue;\n        }\n        // Skip ignored paths\n        const filePath = file.path || file.name || 'unknown';\n        if ((0,_baseline_loader__WEBPACK_IMPORTED_MODULE_0__.shouldIgnorePath)(rules, filePath)) {\n            continue;\n        }\n        // Skip files that shouldn't be scanned\n        const extension = getFileExtension(filePath);\n        if (!(0,_baseline_loader__WEBPACK_IMPORTED_MODULE_0__.shouldScanFile)(rules, extension)) {\n            continue;\n        }\n        // Detect language from file extension\n        const language = detectLanguageFromExtension(extension);\n        if (!language) {\n            continue;\n        }\n        // Get deprecated patterns for this language\n        const patterns = rules.deprecated_patterns[language] || [];\n        if (patterns.length === 0) {\n            continue;\n        }\n        // Scan file content\n        const fileFindings = scanFileContent(file, language, patterns);\n        findings.push(...fileFindings);\n        // Add additional analysis for specific file types\n        if (language === 'node' && (extension === '.js' || extension === '.ts' || extension === '.jsx' || extension === '.tsx')) {\n            const jsFindings = analyzeJavaScriptPatterns(file, language);\n            findings.push(...jsFindings);\n        }\n        if (language === 'python' && extension === '.py') {\n            const pyFindings = analyzePythonPatterns(file, language);\n            findings.push(...pyFindings);\n        }\n    }\n    return findings;\n}\n/**\n * Scan a single file for deprecated patterns\n * @param file File to scan\n * @param language Language of the file\n * @param patterns Deprecated patterns to look for\n * @param rules Baseline rules\n * @returns Array of pattern findings\n */ function scanFileContent(file, language, patterns) {\n    const findings = [];\n    const lines = file.content.split('\\n');\n    const filePath = file.path || file.name || 'unknown';\n    for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n        const line = lines[lineIndex];\n        const lineNumber = lineIndex + 1;\n        // Skip empty lines and comments\n        if (isCommentLine(line, language) || line.trim() === '') {\n            continue;\n        }\n        // Check each pattern\n        for (const pattern of patterns){\n            try {\n                const regex = new RegExp(pattern.pattern, 'g');\n                let match;\n                while((match = regex.exec(line)) !== null){\n                    // Avoid infinite loops with zero-length matches\n                    if (match.index === regex.lastIndex) {\n                        regex.lastIndex++;\n                    }\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: filePath,\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'deprecated-api',\n                        issue: pattern.message,\n                        pattern: pattern.pattern,\n                        quickFix: pattern.alternative\n                    });\n                }\n            } catch (error) {\n                console.warn(`Invalid regex pattern: ${pattern.pattern} - ${error}`);\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Get file extension from path\n * @param filePath File path\n * @returns File extension with dot\n */ function getFileExtension(filePath) {\n    const lastDot = filePath.lastIndexOf('.');\n    if (lastDot === -1) return '';\n    return filePath.substring(lastDot);\n}\n/**\n * Detect language from file extension\n * @param extension File extension\n * @returns Language or null\n */ function detectLanguageFromExtension(extension) {\n    const languageMap = {\n        '.js': 'node',\n        '.jsx': 'node',\n        '.ts': 'node',\n        '.tsx': 'node',\n        '.py': 'python',\n        '.java': 'java',\n        '.go': 'go',\n        '.cs': 'dotnet',\n        '.fs': 'dotnet',\n        '.vb': 'dotnet'\n    };\n    return languageMap[extension] || null;\n}\n/**\n * Check if a line is a comment\n * @param line Line content\n * @param language Language context\n * @returns True if comment line\n */ function isCommentLine(line, language) {\n    const trimmed = line.trim();\n    switch(language){\n        case 'node':\n        case 'java':\n        case 'go':\n        case 'dotnet':\n            return trimmed.startsWith('//') || trimmed.startsWith('/*') || trimmed.startsWith('*');\n        case 'python':\n            return trimmed.startsWith('#');\n        default:\n            return false;\n    }\n}\n/**\n * Get quick fix for pattern replacement\n * @param rules Baseline rules\n * @param language Language\n * @param pattern Pattern to replace\n * @returns Quick fix suggestion or undefined\n */ function getPatternQuickFix(rules, language, pattern) {\n    return rules.quick_fixes.pattern_replacement[language]?.[pattern];\n}\n/**\n * Group pattern findings by file\n * @param findings Pattern findings\n * @returns Grouped findings by file\n */ function groupPatternFindingsByFile(findings) {\n    const grouped = {};\n    for (const finding of findings){\n        if (!grouped[finding.file]) {\n            grouped[finding.file] = [];\n        }\n        grouped[finding.file].push(finding);\n    }\n    return grouped;\n}\n/**\n * Group pattern findings by language\n * @param findings Pattern findings\n * @returns Grouped findings by language\n */ function groupPatternFindingsByLanguage(findings) {\n    const grouped = {\n        python: [],\n        node: [],\n        java: [],\n        go: [],\n        dotnet: []\n    };\n    for (const finding of findings){\n        if (!grouped[finding.lang]) {\n            grouped[finding.lang] = [];\n        }\n        grouped[finding.lang].push(finding);\n    }\n    return grouped;\n}\n/**\n * Get pattern summary statistics\n * @param findings Pattern findings\n * @returns Summary statistics\n */ function getPatternSummary(findings) {\n    const total = findings.length;\n    const byLanguage = groupPatternFindingsByLanguage(findings);\n    const byFile = groupPatternFindingsByFile(findings);\n    return {\n        total,\n        affectedFiles: Object.keys(byFile).length,\n        byLanguage: Object.fromEntries(Object.entries(byLanguage).map(([lang, findings])=>[\n                lang,\n                {\n                    count: findings.length,\n                    files: new Set(findings.map((f)=>f.file)).size\n                }\n            ]))\n    };\n}\n/**\n * Filter pattern findings by language\n * @param findings Pattern findings\n * @param language Language to filter by\n * @returns Filtered findings\n */ function filterPatternFindingsByLanguage(findings, language) {\n    return findings.filter((f)=>f.lang === language);\n}\n/**\n * Filter pattern findings by file\n * @param findings Pattern findings\n * @param filePath File path to filter by\n * @returns Filtered findings\n */ function filterPatternFindingsByFile(findings, filePath) {\n    return findings.filter((f)=>f.file === filePath);\n}\n/**\n * Sort pattern findings by file and line\n * @param findings Pattern findings\n * @returns Sorted findings\n */ function sortPatternFindings(findings) {\n    return [\n        ...findings\n    ].sort((a, b)=>{\n        // First by file path\n        const fileDiff = a.file.localeCompare(b.file);\n        if (fileDiff !== 0) return fileDiff;\n        // Then by line number\n        return a.line - b.line;\n    });\n}\n/**\n * Get unique patterns found\n * @param findings Pattern findings\n * @returns Array of unique patterns\n */ function getUniquePatterns(findings) {\n    const patterns = new Set();\n    for (const finding of findings){\n        patterns.add(finding.pattern);\n    }\n    return Array.from(patterns);\n}\n/**\n * Get pattern frequency\n * @param findings Pattern findings\n * @returns Pattern frequency map\n */ function getPatternFrequency(findings) {\n    const frequency = {};\n    for (const finding of findings){\n        frequency[finding.pattern] = (frequency[finding.pattern] || 0) + 1;\n    }\n    return frequency;\n}\n/**\n * Get most common patterns\n * @param findings Pattern findings\n * @param limit Maximum number of patterns to return\n * @returns Array of most common patterns\n */ function getMostCommonPatterns(findings, limit = 10) {\n    const frequency = getPatternFrequency(findings);\n    return Object.entries(frequency).map(([pattern, count])=>({\n            pattern,\n            count\n        })).sort((a, b)=>b.count - a.count).slice(0, limit);\n}\n/**\n * Check if a file contains any deprecated patterns\n * @param filePath File path\n * @param findings Pattern findings\n * @returns True if file has deprecated patterns\n */ function fileHasDeprecatedPatterns(filePath, findings) {\n    return findings.some((f)=>f.file === filePath);\n}\n/**\n * Get files with deprecated patterns\n * @param findings Pattern findings\n * @returns Array of file paths\n */ function getFilesWithDeprecatedPatterns(findings) {\n    const files = new Set();\n    for (const finding of findings){\n        files.add(finding.file);\n    }\n    return Array.from(files);\n}\n/**\n * Analyze JavaScript-specific patterns\n * @param file File to analyze\n * @param language Language context\n * @returns Array of pattern findings\n */ function analyzeJavaScriptPatterns(file, language) {\n    const findings = [];\n    const lines = file.content.split('\\n');\n    const filePath = file.path || file.name || 'unknown';\n    for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n        const line = lines[lineIndex];\n        const lineNumber = lineIndex + 1;\n        // Skip empty lines and comments\n        if (isCommentLine(line, language) || line.trim() === '') {\n            continue;\n        }\n        // Check for common JavaScript issues\n        const jsPatterns = [\n            {\n                pattern: /var\\s+\\w+/g,\n                message: \"var is deprecated, use let or const\",\n                alternative: \"Use let for variables that change, const for constants\"\n            },\n            {\n                pattern: /function\\s+\\w+\\s*\\(/g,\n                message: \"Function declarations are less preferred than arrow functions\",\n                alternative: \"Use arrow functions for better scope handling\"\n            },\n            {\n                pattern: /this\\.\\w+\\s*=/g,\n                message: \"Direct this assignment is discouraged\",\n                alternative: \"Use class properties or bind methods properly\"\n            },\n            {\n                pattern: /\\barguments\\b/g,\n                message: \"arguments object is deprecated, use rest parameters\",\n                alternative: \"Use ...args rest parameter syntax\"\n            },\n            {\n                pattern: /==\\s*\\w+|\\w+\\s*==/g,\n                message: \"== can cause type coercion issues\",\n                alternative: \"Use === for strict equality\"\n            },\n            {\n                pattern: /!=\\s*\\w+|\\w+\\s*!=/g,\n                message: \"!= can cause type coercion issues\",\n                alternative: \"Use !== for strict inequality\"\n            },\n            {\n                pattern: /typeof\\s+\\w+\\s*===\\s*['\"]undefined['\"]/g,\n                message: \"typeof undefined check is verbose\",\n                alternative: \"Use === undefined or optional chaining\"\n            },\n            {\n                pattern: /for\\s*\\(\\s*var\\s+/g,\n                message: \"var in for loops can cause scope issues\",\n                alternative: \"Use let in for loops\"\n            },\n            {\n                pattern: /with\\s*\\(/g,\n                message: \"with statement is deprecated and dangerous\",\n                alternative: \"Use explicit variable references\"\n            },\n            {\n                pattern: /eval\\s*\\(/g,\n                message: \"eval() is dangerous and should be avoided\",\n                alternative: \"Use safer alternatives or refactor code\"\n            },\n            {\n                pattern: /new\\s+Function\\s*\\(/g,\n                message: \"new Function() is dangerous\",\n                alternative: \"Use function declarations or arrow functions\"\n            },\n            {\n                pattern: /setTimeout\\s*\\(\\s*['\"]/g,\n                message: \"setTimeout with string is dangerous\",\n                alternative: \"Use function references instead of strings\"\n            },\n            {\n                pattern: /setInterval\\s*\\(\\s*['\"]/g,\n                message: \"setInterval with string is dangerous\",\n                alternative: \"Use function references instead of strings\"\n            },\n            {\n                pattern: /setImmediate\\s*\\(\\s*['\"]/g,\n                message: \"setImmediate with string is dangerous\",\n                alternative: \"Use function references instead of strings\"\n            },\n            {\n                pattern: /process\\.nextTick\\s*\\(\\s*['\"]/g,\n                message: \"process.nextTick with string is dangerous\",\n                alternative: \"Use function references instead of strings\"\n            },\n            {\n                pattern: /require\\s*\\(\\s*['\"]/g,\n                message: \"Dynamic require() can be dangerous\",\n                alternative: \"Use static imports or proper module loading\"\n            },\n            {\n                pattern: /import\\s*\\(\\s*['\"]/g,\n                message: \"Dynamic import() can be dangerous\",\n                alternative: \"Use static imports or proper module loading\"\n            },\n            {\n                pattern: /new\\s+RegExp\\s*\\(\\s*['\"]/g,\n                message: \"new RegExp() with user input is dangerous\",\n                alternative: \"Use literal regex or sanitize input\"\n            },\n            {\n                pattern: /RegExp\\s*\\(\\s*['\"]/g,\n                message: \"RegExp() with user input is dangerous\",\n                alternative: \"Use literal regex or sanitize input\"\n            },\n            {\n                pattern: /JSON\\.parse\\s*\\(\\s*['\"]/g,\n                message: \"JSON.parse() with untrusted data is dangerous\",\n                alternative: \"Validate and sanitize input before parsing\"\n            },\n            {\n                pattern: /JSON\\.stringify\\s*\\(/g,\n                message: \"JSON.stringify() can expose sensitive data\",\n                alternative: \"Filter sensitive properties before stringifying\"\n            },\n            {\n                pattern: /XMLHttpRequest/g,\n                message: \"XMLHttpRequest is deprecated, use fetch()\",\n                alternative: \"Use fetch() API or axios library\"\n            },\n            {\n                pattern: /ActiveXObject/g,\n                message: \"ActiveXObject is deprecated and insecure\",\n                alternative: \"Use modern alternatives\"\n            },\n            {\n                pattern: /attachEvent/g,\n                message: \"attachEvent is deprecated, use addEventListener\",\n                alternative: \"Use addEventListener() method\"\n            },\n            {\n                pattern: /detachEvent/g,\n                message: \"detachEvent is deprecated, use removeEventListener\",\n                alternative: \"Use removeEventListener() method\"\n            },\n            {\n                pattern: /document\\.write\\s*\\(/g,\n                message: \"document.write() is deprecated and dangerous\",\n                alternative: \"Use DOM manipulation methods\"\n            },\n            {\n                pattern: /innerHTML\\s*=/g,\n                message: \"innerHTML assignment can be dangerous\",\n                alternative: \"Use textContent or proper DOM methods\"\n            },\n            {\n                pattern: /outerHTML\\s*=/g,\n                message: \"outerHTML assignment can be dangerous\",\n                alternative: \"Use proper DOM manipulation methods\"\n            },\n            {\n                pattern: /alert\\s*\\(/g,\n                message: \"alert() should not be used in production\",\n                alternative: \"Use proper user interface components or logging\"\n            },\n            {\n                pattern: /confirm\\s*\\(/g,\n                message: \"confirm() should not be used in production\",\n                alternative: \"Use proper user interface components\"\n            },\n            {\n                pattern: /prompt\\s*\\(/g,\n                message: \"prompt() should not be used in production\",\n                alternative: \"Use proper user interface components\"\n            },\n            {\n                pattern: /debugger\\b/g,\n                message: \"debugger statement should be removed in production\",\n                alternative: \"Remove debugger statements or use proper debugging tools\"\n            },\n            {\n                pattern: /console\\.(log|warn|error|info|debug|trace|dir|table|time|timeEnd|count|countReset|group|groupEnd|groupCollapsed|assert|clear|profile|profileEnd|timeStamp|markTimeline|timeline|timelineEnd|memory|exception)\\s*\\(/g,\n                message: \"console methods should be removed in production\",\n                alternative: \"Use proper logging library or remove debug statements\"\n            }\n        ];\n        for (const pattern of jsPatterns){\n            try {\n                const regex = new RegExp(pattern.pattern.source, 'g');\n                let match;\n                while((match = regex.exec(line)) !== null){\n                    // Avoid infinite loops with zero-length matches\n                    if (match.index === regex.lastIndex) {\n                        regex.lastIndex++;\n                    }\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: filePath,\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'deprecated-api',\n                        issue: pattern.message,\n                        pattern: pattern.pattern.source,\n                        quickFix: pattern.alternative\n                    });\n                }\n            } catch (error) {\n                console.warn(`Invalid regex pattern: ${pattern.pattern} - ${error}`);\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Analyze Python-specific patterns\n * @param file File to analyze\n * @param language Language context\n * @returns Array of pattern findings\n */ function analyzePythonPatterns(file, language) {\n    const findings = [];\n    const lines = file.content.split('\\n');\n    const filePath = file.path || file.name || 'unknown';\n    for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n        const line = lines[lineIndex];\n        const lineNumber = lineIndex + 1;\n        // Skip empty lines and comments\n        if (isCommentLine(line, language) || line.trim() === '') {\n            continue;\n        }\n        // Check for common Python issues\n        const pyPatterns = [\n            {\n                pattern: /urllib2\\.|urllib\\.request/g,\n                message: \"urllib2 is deprecated in Python 3, use urllib.request\",\n                alternative: \"Use urllib.request or requests library\"\n            },\n            {\n                pattern: /execfile\\s*\\(/g,\n                message: \"execfile() is deprecated in Python 3\",\n                alternative: \"Use exec(open(filename).read())\"\n            },\n            {\n                pattern: /reload\\s*\\(/g,\n                message: \"reload() is deprecated, use importlib.reload()\",\n                alternative: \"Use importlib.reload(module)\"\n            },\n            {\n                pattern: /file\\s*\\(/g,\n                message: \"file() is deprecated, use open()\",\n                alternative: \"Use open() function instead\"\n            },\n            {\n                pattern: /raw_input\\s*\\(/g,\n                message: \"raw_input() is deprecated in Python 3, use input()\",\n                alternative: \"Use input() function\"\n            },\n            {\n                pattern: /xrange\\s*\\(/g,\n                message: \"xrange() is deprecated in Python 3, use range()\",\n                alternative: \"Use range() function\"\n            },\n            {\n                pattern: /basestring/g,\n                message: \"basestring is deprecated in Python 3\",\n                alternative: \"Use str or bytes directly\"\n            },\n            {\n                pattern: /unicode\\s*\\(/g,\n                message: \"unicode() is deprecated in Python 3\",\n                alternative: \"Use str() function\"\n            },\n            {\n                pattern: /long\\s*\\(/g,\n                message: \"long() is deprecated in Python 3\",\n                alternative: \"Use int() function\"\n            },\n            {\n                pattern: /cmp\\s*\\(/g,\n                message: \"cmp() is deprecated in Python 3\",\n                alternative: \"Use (a > b) - (a < b) or operator functions\"\n            },\n            {\n                pattern: /reduce\\s*\\(/g,\n                message: \"reduce() is deprecated, use functools.reduce()\",\n                alternative: \"Import and use functools.reduce()\"\n            },\n            {\n                pattern: /apply\\s*\\(/g,\n                message: \"apply() is deprecated in Python 3\",\n                alternative: \"Use function(*args, **kwargs) syntax\"\n            },\n            {\n                pattern: /coerce\\s*\\(/g,\n                message: \"coerce() is deprecated in Python 3\",\n                alternative: \"Use explicit type conversion\"\n            },\n            {\n                pattern: /intern\\s*\\(/g,\n                message: \"intern() is deprecated in Python 3\",\n                alternative: \"Use sys.intern() if needed\"\n            },\n            {\n                pattern: /unichr\\s*\\(/g,\n                message: \"unichr() is deprecated in Python 3\",\n                alternative: \"Use chr() function\"\n            },\n            {\n                pattern: /buffer\\s*\\(/g,\n                message: \"buffer() is deprecated in Python 3\",\n                alternative: \"Use memoryview() or bytes()\"\n            },\n            {\n                pattern: /StandardError/g,\n                message: \"StandardError is deprecated in Python 3\",\n                alternative: \"Use Exception or specific exception types\"\n            },\n            {\n                pattern: /exec\\s+\\w+\\s+in\\s+\\w+/g,\n                message: \"exec with 'in' syntax is deprecated\",\n                alternative: \"Use exec(code, globals, locals) syntax\"\n            },\n            {\n                pattern: /print\\s+\\w+/g,\n                message: \"print statement is deprecated in Python 3\",\n                alternative: \"Use print() function\"\n            },\n            {\n                pattern: /raise\\s+\\w+,\\s+\\w+/g,\n                message: \"raise with comma syntax is deprecated\",\n                alternative: \"Use raise Exception('message') syntax\"\n            },\n            {\n                pattern: /except\\s+\\w+,\\s+\\w+/g,\n                message: \"except with comma syntax is deprecated\",\n                alternative: \"Use except Exception as e: syntax\"\n            },\n            {\n                pattern: /def\\s+\\w+\\s*\\([^)]*\\):/g,\n                message: \"Check for Python 2 style function definitions\",\n                alternative: \"Ensure Python 3 compatibility\"\n            },\n            {\n                pattern: /from\\s+\\w+\\s+import\\s+\\*/g,\n                message: \"Wildcard imports are discouraged\",\n                alternative: \"Import specific functions or use qualified names\"\n            },\n            {\n                pattern: /eval\\s*\\(/g,\n                message: \"eval() is dangerous and should be avoided\",\n                alternative: \"Use safer alternatives like ast.literal_eval()\"\n            },\n            {\n                pattern: /exec\\s*\\(/g,\n                message: \"exec() is dangerous and should be avoided\",\n                alternative: \"Use safer alternatives or refactor code\"\n            },\n            {\n                pattern: /subprocess\\.call.*shell=True/g,\n                message: \"shell=True in subprocess is dangerous\",\n                alternative: \"Use shell=False and pass arguments as list\"\n            },\n            {\n                pattern: /os\\.system\\s*\\(/g,\n                message: \"os.system() is deprecated, use subprocess\",\n                alternative: \"Use subprocess.run() or subprocess.Popen()\"\n            },\n            {\n                pattern: /pickle\\.loads\\s*\\(/g,\n                message: \"pickle.loads() is unsafe with untrusted data\",\n                alternative: \"Use json.loads() or other safe serialization\"\n            },\n            {\n                pattern: /pickle\\.load\\s*\\(/g,\n                message: \"pickle.load() is unsafe with untrusted data\",\n                alternative: \"Use json.load() or other safe serialization\"\n            },\n            {\n                pattern: /md5\\.|sha1\\./g,\n                message: \"MD5 and SHA1 are cryptographically broken\",\n                alternative: \"Use hashlib.sha256() or hashlib.sha3_256()\"\n            },\n            {\n                pattern: /random\\.random\\s*\\(/g,\n                message: \"random.random() is not cryptographically secure\",\n                alternative: \"Use secrets module for cryptographic randomness\"\n            },\n            {\n                pattern: /time\\.time\\s*\\(/g,\n                message: \"time.time() is not suitable for timing attacks\",\n                alternative: \"Use time.perf_counter() for timing\"\n            },\n            {\n                pattern: /class\\s+\\w+.*:/g,\n                message: \"Check for old-style class definitions\",\n                alternative: \"Ensure all classes inherit from object or use new-style classes\"\n            },\n            {\n                pattern: /def\\s+\\w+\\s*\\(self,\\s*[^)]*\\):/g,\n                message: \"Check for Python 2 style method definitions\",\n                alternative: \"Ensure Python 3 compatibility\"\n            },\n            {\n                pattern: /import\\s+\\w+\\s*$/g,\n                message: \"Check for Python 2 style imports\",\n                alternative: \"Ensure Python 3 compatibility\"\n            }\n        ];\n        for (const pattern of pyPatterns){\n            try {\n                const regex = new RegExp(pattern.pattern.source, 'g');\n                let match;\n                while((match = regex.exec(line)) !== null){\n                    // Avoid infinite loops with zero-length matches\n                    if (match.index === regex.lastIndex) {\n                        regex.lastIndex++;\n                    }\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: filePath,\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'deprecated-api',\n                        issue: pattern.message,\n                        pattern: pattern.pattern.source,\n                        quickFix: pattern.alternative\n                    });\n                }\n            } catch (error) {\n                console.warn(`Invalid regex pattern: ${pattern.pattern} - ${error}`);\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Get line numbers with deprecated patterns for a file\n * @param filePath File path\n * @param findings Pattern findings\n * @returns Array of line numbers\n */ function getDeprecatedPatternLines(filePath, findings) {\n    return findings.filter((f)=>f.file === filePath).map((f)=>f.line).sort((a, b)=>a - b);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFD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Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1NBQ0Q7UUFFRCxLQUFLLE1BQU1kLFdBQVdzRSxXQUFZO1lBQ2hDLElBQUk7Z0JBQ0YsTUFBTXJFLFFBQVEsSUFBSUMsT0FBT0YsUUFBUUEsT0FBTyxDQUFDcUUsTUFBTSxFQUFFO2dCQUNqRCxJQUFJbEU7Z0JBRUosTUFBTyxDQUFDQSxRQUFRRixNQUFNRyxJQUFJLENBQUNSLEtBQUksTUFBTyxLQUFNO29CQUMxQyxnREFBZ0Q7b0JBQ2hELElBQUlPLE1BQU1FLEtBQUssS0FBS0osTUFBTUssU0FBUyxFQUFFO3dCQUNuQ0wsTUFBTUssU0FBUztvQkFDakI7b0JBRUFyQyxTQUFTa0IsSUFBSSxDQUFDO3dCQUNab0IsTUFBTTt3QkFDTkMsTUFBTTVCO3dCQUNOVixNQUFNTzt3QkFDTm1CLE1BQU1DO3dCQUNOWSxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxPQUFPWCxRQUFRWSxPQUFPO3dCQUN0QlosU0FBU0EsUUFBUUEsT0FBTyxDQUFDcUUsTUFBTTt3QkFDL0J4RCxVQUFVYixRQUFRYyxXQUFXO29CQUMvQjtnQkFDRjtZQUNGLEVBQUUsT0FBT0MsT0FBTztnQkFDZDFDLFFBQVFDLElBQUksQ0FBQyxDQUFDLHVCQUF1QixFQUFFMEIsUUFBUUEsT0FBTyxDQUFDLEdBQUcsRUFBRWUsT0FBTztZQUNyRTtRQUNGO0lBQ0Y7SUFFQSxPQUFPOUM7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU3NHLDBCQUNkOUYsUUFBZ0IsRUFDaEJSLFFBQTBCO0lBRTFCLE9BQU9BLFNBQ0orRSxNQUFNLENBQUNGLENBQUFBLElBQUtBLEVBQUU1RSxJQUFJLEtBQUtPLFVBQ3ZCa0UsR0FBRyxDQUFDRyxDQUFBQSxJQUFLQSxFQUFFbEQsSUFBSSxFQUNmdUQsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDO0FBQ3hCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxzY2FuLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExhbmd1YWdlLCBQYXR0ZXJuRmluZGluZywgQmFzZWxpbmVSdWxlcyB9IGZyb20gJy4vYmFzZWxpbmUudHlwZXMnO1xuaW1wb3J0IHsgc2hvdWxkU2NhbkZpbGUsIHNob3VsZElnbm9yZVBhdGggfSBmcm9tICcuL2Jhc2VsaW5lLmxvYWRlcic7XG5cbi8qKlxuICogU2NhbiBzb3VyY2UgZmlsZXMgZm9yIGRlcHJlY2F0ZWQgcGF0dGVybnNcbiAqIEBwYXJhbSBmaWxlcyBBcnJheSBvZiBleHRyYWN0ZWQgZmlsZXNcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xuICogQHJldHVybnMgQXJyYXkgb2YgcGF0dGVybiBmaW5kaW5nc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhblNvdXJjZUZpbGVzKFxuICBmaWxlczogQXJyYXk8eyBwYXRoPzogc3RyaW5nOyBuYW1lPzogc3RyaW5nOyBjb250ZW50OiBzdHJpbmc7IHNpemU6IG51bWJlciB9PixcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNcbik6IFBhdHRlcm5GaW5kaW5nW10ge1xuICBjb25zdCBmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSA9IFtdO1xuICBcbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgLy8gU2tpcCBmaWxlcyB0aGF0IGFyZSB0b28gbGFyZ2VcbiAgICBpZiAoZmlsZS5zaXplID4gcnVsZXMubWF4X2ZpbGVfc2l6ZSkge1xuICAgICAgY29uc29sZS53YXJuKGBTa2lwcGluZyBsYXJnZSBmaWxlOiAke2ZpbGUucGF0aCB8fCBmaWxlLm5hbWV9ICgke2ZpbGUuc2l6ZX0gYnl0ZXMpYCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2tpcCBpZ25vcmVkIHBhdGhzXG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGggfHwgZmlsZS5uYW1lIHx8ICd1bmtub3duJztcbiAgICBpZiAoc2hvdWxkSWdub3JlUGF0aChydWxlcywgZmlsZVBhdGgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2tpcCBmaWxlcyB0aGF0IHNob3VsZG4ndCBiZSBzY2FubmVkXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XG4gICAgaWYgKCFzaG91bGRTY2FuRmlsZShydWxlcywgZXh0ZW5zaW9uKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIFxuICAgIC8vIERldGVjdCBsYW5ndWFnZSBmcm9tIGZpbGUgZXh0ZW5zaW9uXG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKTtcbiAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IGRlcHJlY2F0ZWQgcGF0dGVybnMgZm9yIHRoaXMgbGFuZ3VhZ2VcbiAgICBjb25zdCBwYXR0ZXJucyA9IHJ1bGVzLmRlcHJlY2F0ZWRfcGF0dGVybnNbbGFuZ3VhZ2VdIHx8IFtdO1xuICAgIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBTY2FuIGZpbGUgY29udGVudFxuICAgIGNvbnN0IGZpbGVGaW5kaW5ncyA9IHNjYW5GaWxlQ29udGVudChmaWxlLCBsYW5ndWFnZSwgcGF0dGVybnMpO1xuICAgIGZpbmRpbmdzLnB1c2goLi4uZmlsZUZpbmRpbmdzKTtcbiAgICBcbiAgICAvLyBBZGQgYWRkaXRpb25hbCBhbmFseXNpcyBmb3Igc3BlY2lmaWMgZmlsZSB0eXBlc1xuICAgIGlmIChsYW5ndWFnZSA9PT0gJ25vZGUnICYmIChleHRlbnNpb24gPT09ICcuanMnIHx8IGV4dGVuc2lvbiA9PT0gJy50cycgfHwgZXh0ZW5zaW9uID09PSAnLmpzeCcgfHwgZXh0ZW5zaW9uID09PSAnLnRzeCcpKSB7XG4gICAgICBjb25zdCBqc0ZpbmRpbmdzID0gYW5hbHl6ZUphdmFTY3JpcHRQYXR0ZXJucyhmaWxlLCBsYW5ndWFnZSk7XG4gICAgICBmaW5kaW5ncy5wdXNoKC4uLmpzRmluZGluZ3MpO1xuICAgIH1cbiAgICBcbiAgICBpZiAobGFuZ3VhZ2UgPT09ICdweXRob24nICYmIGV4dGVuc2lvbiA9PT0gJy5weScpIHtcbiAgICAgIGNvbnN0IHB5RmluZGluZ3MgPSBhbmFseXplUHl0aG9uUGF0dGVybnMoZmlsZSwgbGFuZ3VhZ2UpO1xuICAgICAgZmluZGluZ3MucHVzaCguLi5weUZpbmRpbmdzKTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBmaW5kaW5ncztcbn1cblxuLyoqXG4gKiBTY2FuIGEgc2luZ2xlIGZpbGUgZm9yIGRlcHJlY2F0ZWQgcGF0dGVybnNcbiAqIEBwYXJhbSBmaWxlIEZpbGUgdG8gc2NhblxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0gcGF0dGVybnMgRGVwcmVjYXRlZCBwYXR0ZXJucyB0byBsb29rIGZvclxuICogQHBhcmFtIHJ1bGVzIEJhc2VsaW5lIHJ1bGVzXG4gKiBAcmV0dXJucyBBcnJheSBvZiBwYXR0ZXJuIGZpbmRpbmdzXG4gKi9cbmZ1bmN0aW9uIHNjYW5GaWxlQ29udGVudChcbiAgZmlsZTogeyBwYXRoPzogc3RyaW5nOyBuYW1lPzogc3RyaW5nOyBjb250ZW50OiBzdHJpbmcgfSxcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlLFxuICBwYXR0ZXJuczogQXJyYXk8eyBwYXR0ZXJuOiBzdHJpbmc7IG1lc3NhZ2U6IHN0cmluZzsgYWx0ZXJuYXRpdmU6IHN0cmluZyB9PlxuKTogUGF0dGVybkZpbmRpbmdbXSB7XG4gIGNvbnN0IGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdID0gW107XG4gIGNvbnN0IGxpbmVzID0gZmlsZS5jb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGggfHwgZmlsZS5uYW1lIHx8ICd1bmtub3duJztcbiAgXG4gIGZvciAobGV0IGxpbmVJbmRleCA9IDA7IGxpbmVJbmRleCA8IGxpbmVzLmxlbmd0aDsgbGluZUluZGV4KyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbbGluZUluZGV4XTtcbiAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcbiAgICBcbiAgICAvLyBTa2lwIGVtcHR5IGxpbmVzIGFuZCBjb21tZW50c1xuICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBlYWNoIHBhdHRlcm5cbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnBhdHRlcm4sICdnJyk7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIEF2b2lkIGluZmluaXRlIGxvb3BzIHdpdGggemVyby1sZW5ndGggbWF0Y2hlc1xuICAgICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gcmVnZXgubGFzdEluZGV4KSB7XG4gICAgICAgICAgICByZWdleC5sYXN0SW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxuICAgICAgICAgICAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiAnZGVwcmVjYXRlZC1hcGknLFxuICAgICAgICAgICAgICAgICAgICBpc3N1ZTogcGF0dGVybi5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIHF1aWNrRml4OiBwYXR0ZXJuLmFsdGVybmF0aXZlLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCByZWdleCBwYXR0ZXJuOiAke3BhdHRlcm4ucGF0dGVybn0gLSAke2Vycm9yfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGZpbmRpbmdzO1xufVxuXG4vKipcbiAqIEdldCBmaWxlIGV4dGVuc2lvbiBmcm9tIHBhdGhcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcbiAqIEByZXR1cm5zIEZpbGUgZXh0ZW5zaW9uIHdpdGggZG90XG4gKi9cbmZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGxhc3REb3QgPSBmaWxlUGF0aC5sYXN0SW5kZXhPZignLicpO1xuICBpZiAobGFzdERvdCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIGZpbGVQYXRoLnN1YnN0cmluZyhsYXN0RG90KTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgbGFuZ3VhZ2UgZnJvbSBmaWxlIGV4dGVuc2lvblxuICogQHBhcmFtIGV4dGVuc2lvbiBGaWxlIGV4dGVuc2lvblxuICogQHJldHVybnMgTGFuZ3VhZ2Ugb3IgbnVsbFxuICovXG5mdW5jdGlvbiBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uOiBzdHJpbmcpOiBMYW5ndWFnZSB8IG51bGwge1xuICBjb25zdCBsYW5ndWFnZU1hcDogUmVjb3JkPHN0cmluZywgTGFuZ3VhZ2U+ID0ge1xuICAgICcuanMnOiAnbm9kZScsXG4gICAgJy5qc3gnOiAnbm9kZScsXG4gICAgJy50cyc6ICdub2RlJyxcbiAgICAnLnRzeCc6ICdub2RlJyxcbiAgICAnLnB5JzogJ3B5dGhvbicsXG4gICAgJy5qYXZhJzogJ2phdmEnLFxuICAgICcuZ28nOiAnZ28nLFxuICAgICcuY3MnOiAnZG90bmV0JyxcbiAgICAnLmZzJzogJ2RvdG5ldCcsXG4gICAgJy52Yic6ICdkb3RuZXQnLFxuICB9O1xuICBcbiAgcmV0dXJuIGxhbmd1YWdlTWFwW2V4dGVuc2lvbl0gfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGxpbmUgaXMgYSBjb21tZW50XG4gKiBAcGFyYW0gbGluZSBMaW5lIGNvbnRlbnRcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XG4gKiBAcmV0dXJucyBUcnVlIGlmIGNvbW1lbnQgbGluZVxuICovXG5mdW5jdGlvbiBpc0NvbW1lbnRMaW5lKGxpbmU6IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogYm9vbGVhbiB7XG4gIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgXG4gIHN3aXRjaCAobGFuZ3VhZ2UpIHtcbiAgICBjYXNlICdub2RlJzpcbiAgICBjYXNlICdqYXZhJzpcbiAgICBjYXNlICdnbyc6XG4gICAgY2FzZSAnZG90bmV0JzpcbiAgICAgIHJldHVybiB0cmltbWVkLnN0YXJ0c1dpdGgoJy8vJykgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCcvKicpIHx8IHRyaW1tZWQuc3RhcnRzV2l0aCgnKicpO1xuICAgIFxuICAgIGNhc2UgJ3B5dGhvbic6XG4gICAgICByZXR1cm4gdHJpbW1lZC5zdGFydHNXaXRoKCcjJyk7XG4gICAgXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBxdWljayBmaXggZm9yIHBhdHRlcm4gcmVwbGFjZW1lbnRcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXG4gKiBAcGFyYW0gcGF0dGVybiBQYXR0ZXJuIHRvIHJlcGxhY2VcbiAqIEByZXR1cm5zIFF1aWNrIGZpeCBzdWdnZXN0aW9uIG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0dGVyblF1aWNrRml4KFxuICBydWxlczogQmFzZWxpbmVSdWxlcyxcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlLFxuICBwYXR0ZXJuOiBzdHJpbmdcbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBydWxlcy5xdWlja19maXhlcy5wYXR0ZXJuX3JlcGxhY2VtZW50W2xhbmd1YWdlXT8uW3BhdHRlcm5dO1xufVxuXG4vKipcbiAqIEdyb3VwIHBhdHRlcm4gZmluZGluZ3MgYnkgZmlsZVxuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcbiAqIEByZXR1cm5zIEdyb3VwZWQgZmluZGluZ3MgYnkgZmlsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBQYXR0ZXJuRmluZGluZ3NCeUZpbGUoZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10pOiBSZWNvcmQ8c3RyaW5nLCBQYXR0ZXJuRmluZGluZ1tdPiB7XG4gIGNvbnN0IGdyb3VwZWQ6IFJlY29yZDxzdHJpbmcsIFBhdHRlcm5GaW5kaW5nW10+ID0ge307XG4gIFxuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgZmluZGluZ3MpIHtcbiAgICBpZiAoIWdyb3VwZWRbZmluZGluZy5maWxlXSkge1xuICAgICAgZ3JvdXBlZFtmaW5kaW5nLmZpbGVdID0gW107XG4gICAgfVxuICAgIGdyb3VwZWRbZmluZGluZy5maWxlXS5wdXNoKGZpbmRpbmcpO1xuICB9XG4gIFxuICByZXR1cm4gZ3JvdXBlZDtcbn1cblxuLyoqXG4gKiBHcm91cCBwYXR0ZXJuIGZpbmRpbmdzIGJ5IGxhbmd1YWdlXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHJldHVybnMgR3JvdXBlZCBmaW5kaW5ncyBieSBsYW5ndWFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBQYXR0ZXJuRmluZGluZ3NCeUxhbmd1YWdlKGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdKTogUmVjb3JkPExhbmd1YWdlLCBQYXR0ZXJuRmluZGluZ1tdPiB7XG4gIGNvbnN0IGdyb3VwZWQ6IFJlY29yZDxMYW5ndWFnZSwgUGF0dGVybkZpbmRpbmdbXT4gPSB7XG4gICAgcHl0aG9uOiBbXSxcbiAgICBub2RlOiBbXSxcbiAgICBqYXZhOiBbXSxcbiAgICBnbzogW10sXG4gICAgZG90bmV0OiBbXVxuICB9O1xuICBcbiAgZm9yIChjb25zdCBmaW5kaW5nIG9mIGZpbmRpbmdzKSB7XG4gICAgaWYgKCFncm91cGVkW2ZpbmRpbmcubGFuZ10pIHtcbiAgICAgIGdyb3VwZWRbZmluZGluZy5sYW5nXSA9IFtdO1xuICAgIH1cbiAgICBncm91cGVkW2ZpbmRpbmcubGFuZ10ucHVzaChmaW5kaW5nKTtcbiAgfVxuICBcbiAgcmV0dXJuIGdyb3VwZWQ7XG59XG5cbi8qKlxuICogR2V0IHBhdHRlcm4gc3VtbWFyeSBzdGF0aXN0aWNzXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHJldHVybnMgU3VtbWFyeSBzdGF0aXN0aWNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXR0ZXJuU3VtbWFyeShmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSkge1xuICBjb25zdCB0b3RhbCA9IGZpbmRpbmdzLmxlbmd0aDtcbiAgY29uc3QgYnlMYW5ndWFnZSA9IGdyb3VwUGF0dGVybkZpbmRpbmdzQnlMYW5ndWFnZShmaW5kaW5ncyk7XG4gIGNvbnN0IGJ5RmlsZSA9IGdyb3VwUGF0dGVybkZpbmRpbmdzQnlGaWxlKGZpbmRpbmdzKTtcbiAgXG4gIHJldHVybiB7XG4gICAgdG90YWwsXG4gICAgYWZmZWN0ZWRGaWxlczogT2JqZWN0LmtleXMoYnlGaWxlKS5sZW5ndGgsXG4gICAgYnlMYW5ndWFnZTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMoYnlMYW5ndWFnZSkubWFwKChbbGFuZywgZmluZGluZ3NdKSA9PiBbXG4gICAgICAgIGxhbmcsXG4gICAgICAgIHtcbiAgICAgICAgICBjb3VudDogZmluZGluZ3MubGVuZ3RoLFxuICAgICAgICAgIGZpbGVzOiBuZXcgU2V0KGZpbmRpbmdzLm1hcChmID0+IGYuZmlsZSkpLnNpemUsXG4gICAgICAgIH0sXG4gICAgICBdKVxuICAgICksXG4gIH07XG59XG5cbi8qKlxuICogRmlsdGVyIHBhdHRlcm4gZmluZGluZ3MgYnkgbGFuZ3VhZ2VcbiAqIEBwYXJhbSBmaW5kaW5ncyBQYXR0ZXJuIGZpbmRpbmdzXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgdG8gZmlsdGVyIGJ5XG4gKiBAcmV0dXJucyBGaWx0ZXJlZCBmaW5kaW5nc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUGF0dGVybkZpbmRpbmdzQnlMYW5ndWFnZShcbiAgZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10sXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxuKTogUGF0dGVybkZpbmRpbmdbXSB7XG4gIHJldHVybiBmaW5kaW5ncy5maWx0ZXIoZiA9PiBmLmxhbmcgPT09IGxhbmd1YWdlKTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgcGF0dGVybiBmaW5kaW5ncyBieSBmaWxlXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aCB0byBmaWx0ZXIgYnlcbiAqIEByZXR1cm5zIEZpbHRlcmVkIGZpbmRpbmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJQYXR0ZXJuRmluZGluZ3NCeUZpbGUoXG4gIGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdLFxuICBmaWxlUGF0aDogc3RyaW5nXG4pOiBQYXR0ZXJuRmluZGluZ1tdIHtcbiAgcmV0dXJuIGZpbmRpbmdzLmZpbHRlcihmID0+IGYuZmlsZSA9PT0gZmlsZVBhdGgpO1xufVxuXG4vKipcbiAqIFNvcnQgcGF0dGVybiBmaW5kaW5ncyBieSBmaWxlIGFuZCBsaW5lXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHJldHVybnMgU29ydGVkIGZpbmRpbmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0UGF0dGVybkZpbmRpbmdzKGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdKTogUGF0dGVybkZpbmRpbmdbXSB7XG4gIHJldHVybiBbLi4uZmluZGluZ3NdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAvLyBGaXJzdCBieSBmaWxlIHBhdGhcbiAgICBjb25zdCBmaWxlRGlmZiA9IGEuZmlsZS5sb2NhbGVDb21wYXJlKGIuZmlsZSk7XG4gICAgaWYgKGZpbGVEaWZmICE9PSAwKSByZXR1cm4gZmlsZURpZmY7XG4gICAgXG4gICAgLy8gVGhlbiBieSBsaW5lIG51bWJlclxuICAgIHJldHVybiBhLmxpbmUgLSBiLmxpbmU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB1bmlxdWUgcGF0dGVybnMgZm91bmRcbiAqIEBwYXJhbSBmaW5kaW5ncyBQYXR0ZXJuIGZpbmRpbmdzXG4gKiBAcmV0dXJucyBBcnJheSBvZiB1bmlxdWUgcGF0dGVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXF1ZVBhdHRlcm5zKGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdKTogc3RyaW5nW10ge1xuICBjb25zdCBwYXR0ZXJucyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBcbiAgZm9yIChjb25zdCBmaW5kaW5nIG9mIGZpbmRpbmdzKSB7XG4gICAgcGF0dGVybnMuYWRkKGZpbmRpbmcucGF0dGVybik7XG4gIH1cbiAgXG4gIHJldHVybiBBcnJheS5mcm9tKHBhdHRlcm5zKTtcbn1cblxuLyoqXG4gKiBHZXQgcGF0dGVybiBmcmVxdWVuY3lcbiAqIEBwYXJhbSBmaW5kaW5ncyBQYXR0ZXJuIGZpbmRpbmdzXG4gKiBAcmV0dXJucyBQYXR0ZXJuIGZyZXF1ZW5jeSBtYXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdHRlcm5GcmVxdWVuY3koZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10pOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHtcbiAgY29uc3QgZnJlcXVlbmN5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIFxuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgZmluZGluZ3MpIHtcbiAgICBmcmVxdWVuY3lbZmluZGluZy5wYXR0ZXJuXSA9IChmcmVxdWVuY3lbZmluZGluZy5wYXR0ZXJuXSB8fCAwKSArIDE7XG4gIH1cbiAgXG4gIHJldHVybiBmcmVxdWVuY3k7XG59XG5cbi8qKlxuICogR2V0IG1vc3QgY29tbW9uIHBhdHRlcm5zXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHBhcmFtIGxpbWl0IE1heGltdW0gbnVtYmVyIG9mIHBhdHRlcm5zIHRvIHJldHVyblxuICogQHJldHVybnMgQXJyYXkgb2YgbW9zdCBjb21tb24gcGF0dGVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1vc3RDb21tb25QYXR0ZXJucyhcbiAgZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10sXG4gIGxpbWl0OiBudW1iZXIgPSAxMFxuKTogQXJyYXk8eyBwYXR0ZXJuOiBzdHJpbmc7IGNvdW50OiBudW1iZXIgfT4ge1xuICBjb25zdCBmcmVxdWVuY3kgPSBnZXRQYXR0ZXJuRnJlcXVlbmN5KGZpbmRpbmdzKTtcbiAgXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhmcmVxdWVuY3kpXG4gICAgLm1hcCgoW3BhdHRlcm4sIGNvdW50XSkgPT4gKHsgcGF0dGVybiwgY291bnQgfSkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KVxuICAgIC5zbGljZSgwLCBsaW1pdCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBmaWxlIGNvbnRhaW5zIGFueSBkZXByZWNhdGVkIHBhdHRlcm5zXG4gKiBAcGFyYW0gZmlsZVBhdGggRmlsZSBwYXRoXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHJldHVybnMgVHJ1ZSBpZiBmaWxlIGhhcyBkZXByZWNhdGVkIHBhdHRlcm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWxlSGFzRGVwcmVjYXRlZFBhdHRlcm5zKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXVxuKTogYm9vbGVhbiB7XG4gIHJldHVybiBmaW5kaW5ncy5zb21lKGYgPT4gZi5maWxlID09PSBmaWxlUGF0aCk7XG59XG5cbi8qKlxuICogR2V0IGZpbGVzIHdpdGggZGVwcmVjYXRlZCBwYXR0ZXJuc1xuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcbiAqIEByZXR1cm5zIEFycmF5IG9mIGZpbGUgcGF0aHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVzV2l0aERlcHJlY2F0ZWRQYXR0ZXJucyhmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSk6IHN0cmluZ1tdIHtcbiAgY29uc3QgZmlsZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgXG4gIGZvciAoY29uc3QgZmluZGluZyBvZiBmaW5kaW5ncykge1xuICAgIGZpbGVzLmFkZChmaW5kaW5nLmZpbGUpO1xuICB9XG4gIFxuICByZXR1cm4gQXJyYXkuZnJvbShmaWxlcyk7XG59XG5cbi8qKlxuICogQW5hbHl6ZSBKYXZhU2NyaXB0LXNwZWNpZmljIHBhdHRlcm5zXG4gKiBAcGFyYW0gZmlsZSBGaWxlIHRvIGFuYWx5emVcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XG4gKiBAcmV0dXJucyBBcnJheSBvZiBwYXR0ZXJuIGZpbmRpbmdzXG4gKi9cbmZ1bmN0aW9uIGFuYWx5emVKYXZhU2NyaXB0UGF0dGVybnMoXG4gIGZpbGU6IHsgcGF0aD86IHN0cmluZzsgbmFtZT86IHN0cmluZzsgY29udGVudDogc3RyaW5nIH0sXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxuKTogUGF0dGVybkZpbmRpbmdbXSB7XG4gIGNvbnN0IGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdID0gW107XG4gIGNvbnN0IGxpbmVzID0gZmlsZS5jb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGggfHwgZmlsZS5uYW1lIHx8ICd1bmtub3duJztcbiAgXG4gIGZvciAobGV0IGxpbmVJbmRleCA9IDA7IGxpbmVJbmRleCA8IGxpbmVzLmxlbmd0aDsgbGluZUluZGV4KyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbbGluZUluZGV4XTtcbiAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcbiAgICBcbiAgICAvLyBTa2lwIGVtcHR5IGxpbmVzIGFuZCBjb21tZW50c1xuICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBmb3IgY29tbW9uIEphdmFTY3JpcHQgaXNzdWVzXG4gICAgY29uc3QganNQYXR0ZXJucyA9IFtcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3ZhclxccytcXHcrL2csXG4gICAgICAgIG1lc3NhZ2U6IFwidmFyIGlzIGRlcHJlY2F0ZWQsIHVzZSBsZXQgb3IgY29uc3RcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGxldCBmb3IgdmFyaWFibGVzIHRoYXQgY2hhbmdlLCBjb25zdCBmb3IgY29uc3RhbnRzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9mdW5jdGlvblxccytcXHcrXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcIkZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmUgbGVzcyBwcmVmZXJyZWQgdGhhbiBhcnJvdyBmdW5jdGlvbnNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGFycm93IGZ1bmN0aW9ucyBmb3IgYmV0dGVyIHNjb3BlIGhhbmRsaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC90aGlzXFwuXFx3K1xccyo9L2csXG4gICAgICAgIG1lc3NhZ2U6IFwiRGlyZWN0IHRoaXMgYXNzaWdubWVudCBpcyBkaXNjb3VyYWdlZFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgY2xhc3MgcHJvcGVydGllcyBvciBiaW5kIG1ldGhvZHMgcHJvcGVybHlcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL1xcYmFyZ3VtZW50c1xcYi9nLFxuICAgICAgICBtZXNzYWdlOiBcImFyZ3VtZW50cyBvYmplY3QgaXMgZGVwcmVjYXRlZCwgdXNlIHJlc3QgcGFyYW1ldGVyc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgLi4uYXJncyByZXN0IHBhcmFtZXRlciBzeW50YXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogLz09XFxzKlxcdyt8XFx3K1xccyo9PS9nLFxuICAgICAgICBtZXNzYWdlOiBcIj09IGNhbiBjYXVzZSB0eXBlIGNvZXJjaW9uIGlzc3Vlc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgPT09IGZvciBzdHJpY3QgZXF1YWxpdHlcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogLyE9XFxzKlxcdyt8XFx3K1xccyohPS9nLFxuICAgICAgICBtZXNzYWdlOiBcIiE9IGNhbiBjYXVzZSB0eXBlIGNvZXJjaW9uIGlzc3Vlc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgIT09IGZvciBzdHJpY3QgaW5lcXVhbGl0eVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvdHlwZW9mXFxzK1xcdytcXHMqPT09XFxzKlsnXCJddW5kZWZpbmVkWydcIl0vZyxcbiAgICAgICAgbWVzc2FnZTogXCJ0eXBlb2YgdW5kZWZpbmVkIGNoZWNrIGlzIHZlcmJvc2VcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlID09PSB1bmRlZmluZWQgb3Igb3B0aW9uYWwgY2hhaW5pbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2ZvclxccypcXChcXHMqdmFyXFxzKy9nLFxuICAgICAgICBtZXNzYWdlOiBcInZhciBpbiBmb3IgbG9vcHMgY2FuIGNhdXNlIHNjb3BlIGlzc3Vlc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgbGV0IGluIGZvciBsb29wc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvd2l0aFxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJ3aXRoIHN0YXRlbWVudCBpcyBkZXByZWNhdGVkIGFuZCBkYW5nZXJvdXNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGV4cGxpY2l0IHZhcmlhYmxlIHJlZmVyZW5jZXNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2V2YWxcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiZXZhbCgpIGlzIGRhbmdlcm91cyBhbmQgc2hvdWxkIGJlIGF2b2lkZWRcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHNhZmVyIGFsdGVybmF0aXZlcyBvciByZWZhY3RvciBjb2RlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9uZXdcXHMrRnVuY3Rpb25cXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwibmV3IEZ1bmN0aW9uKCkgaXMgZGFuZ2Vyb3VzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgb3IgYXJyb3cgZnVuY3Rpb25zXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9zZXRUaW1lb3V0XFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcInNldFRpbWVvdXQgd2l0aCBzdHJpbmcgaXMgZGFuZ2Vyb3VzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBmdW5jdGlvbiByZWZlcmVuY2VzIGluc3RlYWQgb2Ygc3RyaW5nc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvc2V0SW50ZXJ2YWxcXHMqXFwoXFxzKlsnXCJdL2csXG4gICAgICAgIG1lc3NhZ2U6IFwic2V0SW50ZXJ2YWwgd2l0aCBzdHJpbmcgaXMgZGFuZ2Vyb3VzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBmdW5jdGlvbiByZWZlcmVuY2VzIGluc3RlYWQgb2Ygc3RyaW5nc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvc2V0SW1tZWRpYXRlXFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcInNldEltbWVkaWF0ZSB3aXRoIHN0cmluZyBpcyBkYW5nZXJvdXNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGZ1bmN0aW9uIHJlZmVyZW5jZXMgaW5zdGVhZCBvZiBzdHJpbmdzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9wcm9jZXNzXFwubmV4dFRpY2tcXHMqXFwoXFxzKlsnXCJdL2csXG4gICAgICAgIG1lc3NhZ2U6IFwicHJvY2Vzcy5uZXh0VGljayB3aXRoIHN0cmluZyBpcyBkYW5nZXJvdXNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGZ1bmN0aW9uIHJlZmVyZW5jZXMgaW5zdGVhZCBvZiBzdHJpbmdzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9yZXF1aXJlXFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcIkR5bmFtaWMgcmVxdWlyZSgpIGNhbiBiZSBkYW5nZXJvdXNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHN0YXRpYyBpbXBvcnRzIG9yIHByb3BlciBtb2R1bGUgbG9hZGluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvaW1wb3J0XFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcIkR5bmFtaWMgaW1wb3J0KCkgY2FuIGJlIGRhbmdlcm91c1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2Ugc3RhdGljIGltcG9ydHMgb3IgcHJvcGVyIG1vZHVsZSBsb2FkaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9uZXdcXHMrUmVnRXhwXFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcIm5ldyBSZWdFeHAoKSB3aXRoIHVzZXIgaW5wdXQgaXMgZGFuZ2Vyb3VzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBsaXRlcmFsIHJlZ2V4IG9yIHNhbml0aXplIGlucHV0XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9SZWdFeHBcXHMqXFwoXFxzKlsnXCJdL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiUmVnRXhwKCkgd2l0aCB1c2VyIGlucHV0IGlzIGRhbmdlcm91c1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgbGl0ZXJhbCByZWdleCBvciBzYW5pdGl6ZSBpbnB1dFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvSlNPTlxcLnBhcnNlXFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcIkpTT04ucGFyc2UoKSB3aXRoIHVudHJ1c3RlZCBkYXRhIGlzIGRhbmdlcm91c1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJWYWxpZGF0ZSBhbmQgc2FuaXRpemUgaW5wdXQgYmVmb3JlIHBhcnNpbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL0pTT05cXC5zdHJpbmdpZnlcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiSlNPTi5zdHJpbmdpZnkoKSBjYW4gZXhwb3NlIHNlbnNpdGl2ZSBkYXRhXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIkZpbHRlciBzZW5zaXRpdmUgcHJvcGVydGllcyBiZWZvcmUgc3RyaW5naWZ5aW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9YTUxIdHRwUmVxdWVzdC9nLFxuICAgICAgICBtZXNzYWdlOiBcIlhNTEh0dHBSZXF1ZXN0IGlzIGRlcHJlY2F0ZWQsIHVzZSBmZXRjaCgpXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBmZXRjaCgpIEFQSSBvciBheGlvcyBsaWJyYXJ5XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9BY3RpdmVYT2JqZWN0L2csXG4gICAgICAgIG1lc3NhZ2U6IFwiQWN0aXZlWE9iamVjdCBpcyBkZXByZWNhdGVkIGFuZCBpbnNlY3VyZVwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgbW9kZXJuIGFsdGVybmF0aXZlc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvYXR0YWNoRXZlbnQvZyxcbiAgICAgICAgbWVzc2FnZTogXCJhdHRhY2hFdmVudCBpcyBkZXByZWNhdGVkLCB1c2UgYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgYWRkRXZlbnRMaXN0ZW5lcigpIG1ldGhvZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZGV0YWNoRXZlbnQvZyxcbiAgICAgICAgbWVzc2FnZTogXCJkZXRhY2hFdmVudCBpcyBkZXByZWNhdGVkLCB1c2UgcmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIG1ldGhvZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZG9jdW1lbnRcXC53cml0ZVxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJkb2N1bWVudC53cml0ZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIGRhbmdlcm91c1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgRE9NIG1hbmlwdWxhdGlvbiBtZXRob2RzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9pbm5lckhUTUxcXHMqPS9nLFxuICAgICAgICBtZXNzYWdlOiBcImlubmVySFRNTCBhc3NpZ25tZW50IGNhbiBiZSBkYW5nZXJvdXNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHRleHRDb250ZW50IG9yIHByb3BlciBET00gbWV0aG9kc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvb3V0ZXJIVE1MXFxzKj0vZyxcbiAgICAgICAgbWVzc2FnZTogXCJvdXRlckhUTUwgYXNzaWdubWVudCBjYW4gYmUgZGFuZ2Vyb3VzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBwcm9wZXIgRE9NIG1hbmlwdWxhdGlvbiBtZXRob2RzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9hbGVydFxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJhbGVydCgpIHNob3VsZCBub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBwcm9wZXIgdXNlciBpbnRlcmZhY2UgY29tcG9uZW50cyBvciBsb2dnaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9jb25maXJtXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcImNvbmZpcm0oKSBzaG91bGQgbm90IGJlIHVzZWQgaW4gcHJvZHVjdGlvblwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgcHJvcGVyIHVzZXIgaW50ZXJmYWNlIGNvbXBvbmVudHNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3Byb21wdFxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJwcm9tcHQoKSBzaG91bGQgbm90IGJlIHVzZWQgaW4gcHJvZHVjdGlvblwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgcHJvcGVyIHVzZXIgaW50ZXJmYWNlIGNvbXBvbmVudHNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2RlYnVnZ2VyXFxiL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiZGVidWdnZXIgc3RhdGVtZW50IHNob3VsZCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb25cIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiUmVtb3ZlIGRlYnVnZ2VyIHN0YXRlbWVudHMgb3IgdXNlIHByb3BlciBkZWJ1Z2dpbmcgdG9vbHNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2NvbnNvbGVcXC4obG9nfHdhcm58ZXJyb3J8aW5mb3xkZWJ1Z3x0cmFjZXxkaXJ8dGFibGV8dGltZXx0aW1lRW5kfGNvdW50fGNvdW50UmVzZXR8Z3JvdXB8Z3JvdXBFbmR8Z3JvdXBDb2xsYXBzZWR8YXNzZXJ0fGNsZWFyfHByb2ZpbGV8cHJvZmlsZUVuZHx0aW1lU3RhbXB8bWFya1RpbWVsaW5lfHRpbWVsaW5lfHRpbWVsaW5lRW5kfG1lbW9yeXxleGNlcHRpb24pXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcImNvbnNvbGUgbWV0aG9kcyBzaG91bGQgYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBwcm9wZXIgbG9nZ2luZyBsaWJyYXJ5IG9yIHJlbW92ZSBkZWJ1ZyBzdGF0ZW1lbnRzXCJcbiAgICAgIH1cbiAgICBdO1xuICAgIFxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBqc1BhdHRlcm5zKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybi5wYXR0ZXJuLnNvdXJjZSwgJ2cnKTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gQXZvaWQgaW5maW5pdGUgbG9vcHMgd2l0aCB6ZXJvLWxlbmd0aCBtYXRjaGVzXG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSByZWdleC5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgICAgcmVhc29uOiAnZGVwcmVjYXRlZC1hcGknLFxuICAgICAgICAgICAgaXNzdWU6IHBhdHRlcm4ubWVzc2FnZSxcbiAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4ucGF0dGVybi5zb3VyY2UsXG4gICAgICAgICAgICBxdWlja0ZpeDogcGF0dGVybi5hbHRlcm5hdGl2ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHJlZ2V4IHBhdHRlcm46ICR7cGF0dGVybi5wYXR0ZXJufSAtICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZmluZGluZ3M7XG59XG5cbi8qKlxuICogQW5hbHl6ZSBQeXRob24tc3BlY2lmaWMgcGF0dGVybnNcbiAqIEBwYXJhbSBmaWxlIEZpbGUgdG8gYW5hbHl6ZVxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcbiAqIEByZXR1cm5zIEFycmF5IG9mIHBhdHRlcm4gZmluZGluZ3NcbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZVB5dGhvblBhdHRlcm5zKFxuICBmaWxlOiB7IHBhdGg/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZyB9LFxuICBsYW5ndWFnZTogTGFuZ3VhZ2Vcbik6IFBhdHRlcm5GaW5kaW5nW10ge1xuICBjb25zdCBmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSA9IFtdO1xuICBjb25zdCBsaW5lcyA9IGZpbGUuY29udGVudC5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoIHx8IGZpbGUubmFtZSB8fCAndW5rbm93bic7XG4gIFxuICBmb3IgKGxldCBsaW5lSW5kZXggPSAwOyBsaW5lSW5kZXggPCBsaW5lcy5sZW5ndGg7IGxpbmVJbmRleCsrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2xpbmVJbmRleF07XG4gICAgY29uc3QgbGluZU51bWJlciA9IGxpbmVJbmRleCArIDE7XG4gICAgXG4gICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBhbmQgY29tbWVudHNcbiAgICBpZiAoaXNDb21tZW50TGluZShsaW5lLCBsYW5ndWFnZSkgfHwgbGluZS50cmltKCkgPT09ICcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBQeXRob24gaXNzdWVzXG4gICAgY29uc3QgcHlQYXR0ZXJucyA9IFtcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3VybGxpYjJcXC58dXJsbGliXFwucmVxdWVzdC9nLFxuICAgICAgICBtZXNzYWdlOiBcInVybGxpYjIgaXMgZGVwcmVjYXRlZCBpbiBQeXRob24gMywgdXNlIHVybGxpYi5yZXF1ZXN0XCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSB1cmxsaWIucmVxdWVzdCBvciByZXF1ZXN0cyBsaWJyYXJ5XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9leGVjZmlsZVxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJleGVjZmlsZSgpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGV4ZWMob3BlbihmaWxlbmFtZSkucmVhZCgpKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvcmVsb2FkXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcInJlbG9hZCgpIGlzIGRlcHJlY2F0ZWQsIHVzZSBpbXBvcnRsaWIucmVsb2FkKClcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGltcG9ydGxpYi5yZWxvYWQobW9kdWxlKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZmlsZVxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJmaWxlKCkgaXMgZGVwcmVjYXRlZCwgdXNlIG9wZW4oKVwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2Ugb3BlbigpIGZ1bmN0aW9uIGluc3RlYWRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3Jhd19pbnB1dFxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJyYXdfaW5wdXQoKSBpcyBkZXByZWNhdGVkIGluIFB5dGhvbiAzLCB1c2UgaW5wdXQoKVwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgaW5wdXQoKSBmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAveHJhbmdlXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcInhyYW5nZSgpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDMsIHVzZSByYW5nZSgpXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSByYW5nZSgpIGZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9iYXNlc3RyaW5nL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiYmFzZXN0cmluZyBpcyBkZXByZWNhdGVkIGluIFB5dGhvbiAzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBzdHIgb3IgYnl0ZXMgZGlyZWN0bHlcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3VuaWNvZGVcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwidW5pY29kZSgpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHN0cigpIGZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9sb25nXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcImxvbmcoKSBpcyBkZXByZWNhdGVkIGluIFB5dGhvbiAzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBpbnQoKSBmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvY21wXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcImNtcCgpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIChhID4gYikgLSAoYSA8IGIpIG9yIG9wZXJhdG9yIGZ1bmN0aW9uc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvcmVkdWNlXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcInJlZHVjZSgpIGlzIGRlcHJlY2F0ZWQsIHVzZSBmdW5jdG9vbHMucmVkdWNlKClcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiSW1wb3J0IGFuZCB1c2UgZnVuY3Rvb2xzLnJlZHVjZSgpXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9hcHBseVxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJhcHBseSgpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGZ1bmN0aW9uKCphcmdzLCAqKmt3YXJncykgc3ludGF4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9jb2VyY2VcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiY29lcmNlKCkgaXMgZGVwcmVjYXRlZCBpbiBQeXRob24gM1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgZXhwbGljaXQgdHlwZSBjb252ZXJzaW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9pbnRlcm5cXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiaW50ZXJuKCkgaXMgZGVwcmVjYXRlZCBpbiBQeXRob24gM1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2Ugc3lzLmludGVybigpIGlmIG5lZWRlZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvdW5pY2hyXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcInVuaWNocigpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGNocigpIGZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9idWZmZXJcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiYnVmZmVyKCkgaXMgZGVwcmVjYXRlZCBpbiBQeXRob24gM1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgbWVtb3J5dmlldygpIG9yIGJ5dGVzKClcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL1N0YW5kYXJkRXJyb3IvZyxcbiAgICAgICAgbWVzc2FnZTogXCJTdGFuZGFyZEVycm9yIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIEV4Y2VwdGlvbiBvciBzcGVjaWZpYyBleGNlcHRpb24gdHlwZXNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2V4ZWNcXHMrXFx3K1xccytpblxccytcXHcrL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiZXhlYyB3aXRoICdpbicgc3ludGF4IGlzIGRlcHJlY2F0ZWRcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGV4ZWMoY29kZSwgZ2xvYmFscywgbG9jYWxzKSBzeW50YXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3ByaW50XFxzK1xcdysvZyxcbiAgICAgICAgbWVzc2FnZTogXCJwcmludCBzdGF0ZW1lbnQgaXMgZGVwcmVjYXRlZCBpbiBQeXRob24gM1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgcHJpbnQoKSBmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvcmFpc2VcXHMrXFx3KyxcXHMrXFx3Ky9nLFxuICAgICAgICBtZXNzYWdlOiBcInJhaXNlIHdpdGggY29tbWEgc3ludGF4IGlzIGRlcHJlY2F0ZWRcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHJhaXNlIEV4Y2VwdGlvbignbWVzc2FnZScpIHN5bnRheFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZXhjZXB0XFxzK1xcdyssXFxzK1xcdysvZyxcbiAgICAgICAgbWVzc2FnZTogXCJleGNlcHQgd2l0aCBjb21tYSBzeW50YXggaXMgZGVwcmVjYXRlZFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOiBzeW50YXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2RlZlxccytcXHcrXFxzKlxcKFteKV0qXFwpOi9nLFxuICAgICAgICBtZXNzYWdlOiBcIkNoZWNrIGZvciBQeXRob24gMiBzdHlsZSBmdW5jdGlvbiBkZWZpbml0aW9uc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJFbnN1cmUgUHl0aG9uIDMgY29tcGF0aWJpbGl0eVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZnJvbVxccytcXHcrXFxzK2ltcG9ydFxccytcXCovZyxcbiAgICAgICAgbWVzc2FnZTogXCJXaWxkY2FyZCBpbXBvcnRzIGFyZSBkaXNjb3VyYWdlZFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJJbXBvcnQgc3BlY2lmaWMgZnVuY3Rpb25zIG9yIHVzZSBxdWFsaWZpZWQgbmFtZXNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2V2YWxcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiZXZhbCgpIGlzIGRhbmdlcm91cyBhbmQgc2hvdWxkIGJlIGF2b2lkZWRcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHNhZmVyIGFsdGVybmF0aXZlcyBsaWtlIGFzdC5saXRlcmFsX2V2YWwoKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZXhlY1xccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJleGVjKCkgaXMgZGFuZ2Vyb3VzIGFuZCBzaG91bGQgYmUgYXZvaWRlZFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2Ugc2FmZXIgYWx0ZXJuYXRpdmVzIG9yIHJlZmFjdG9yIGNvZGVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3N1YnByb2Nlc3NcXC5jYWxsLipzaGVsbD1UcnVlL2csXG4gICAgICAgIG1lc3NhZ2U6IFwic2hlbGw9VHJ1ZSBpbiBzdWJwcm9jZXNzIGlzIGRhbmdlcm91c1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2Ugc2hlbGw9RmFsc2UgYW5kIHBhc3MgYXJndW1lbnRzIGFzIGxpc3RcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL29zXFwuc3lzdGVtXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcIm9zLnN5c3RlbSgpIGlzIGRlcHJlY2F0ZWQsIHVzZSBzdWJwcm9jZXNzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBzdWJwcm9jZXNzLnJ1bigpIG9yIHN1YnByb2Nlc3MuUG9wZW4oKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvcGlja2xlXFwubG9hZHNcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwicGlja2xlLmxvYWRzKCkgaXMgdW5zYWZlIHdpdGggdW50cnVzdGVkIGRhdGFcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGpzb24ubG9hZHMoKSBvciBvdGhlciBzYWZlIHNlcmlhbGl6YXRpb25cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3BpY2tsZVxcLmxvYWRcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwicGlja2xlLmxvYWQoKSBpcyB1bnNhZmUgd2l0aCB1bnRydXN0ZWQgZGF0YVwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UganNvbi5sb2FkKCkgb3Igb3RoZXIgc2FmZSBzZXJpYWxpemF0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9tZDVcXC58c2hhMVxcLi9nLFxuICAgICAgICBtZXNzYWdlOiBcIk1ENSBhbmQgU0hBMSBhcmUgY3J5cHRvZ3JhcGhpY2FsbHkgYnJva2VuXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBoYXNobGliLnNoYTI1NigpIG9yIGhhc2hsaWIuc2hhM18yNTYoKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvcmFuZG9tXFwucmFuZG9tXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcInJhbmRvbS5yYW5kb20oKSBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBzZWNyZXRzIG1vZHVsZSBmb3IgY3J5cHRvZ3JhcGhpYyByYW5kb21uZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC90aW1lXFwudGltZVxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJ0aW1lLnRpbWUoKSBpcyBub3Qgc3VpdGFibGUgZm9yIHRpbWluZyBhdHRhY2tzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSB0aW1lLnBlcmZfY291bnRlcigpIGZvciB0aW1pbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2NsYXNzXFxzK1xcdysuKjovZyxcbiAgICAgICAgbWVzc2FnZTogXCJDaGVjayBmb3Igb2xkLXN0eWxlIGNsYXNzIGRlZmluaXRpb25zXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIkVuc3VyZSBhbGwgY2xhc3NlcyBpbmhlcml0IGZyb20gb2JqZWN0IG9yIHVzZSBuZXctc3R5bGUgY2xhc3Nlc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZGVmXFxzK1xcdytcXHMqXFwoc2VsZixcXHMqW14pXSpcXCk6L2csXG4gICAgICAgIG1lc3NhZ2U6IFwiQ2hlY2sgZm9yIFB5dGhvbiAyIHN0eWxlIG1ldGhvZCBkZWZpbml0aW9uc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJFbnN1cmUgUHl0aG9uIDMgY29tcGF0aWJpbGl0eVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvaW1wb3J0XFxzK1xcdytcXHMqJC9nLFxuICAgICAgICBtZXNzYWdlOiBcIkNoZWNrIGZvciBQeXRob24gMiBzdHlsZSBpbXBvcnRzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIkVuc3VyZSBQeXRob24gMyBjb21wYXRpYmlsaXR5XCJcbiAgICAgIH1cbiAgICBdO1xuICAgIFxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBweVBhdHRlcm5zKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybi5wYXR0ZXJuLnNvdXJjZSwgJ2cnKTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gQXZvaWQgaW5maW5pdGUgbG9vcHMgd2l0aCB6ZXJvLWxlbmd0aCBtYXRjaGVzXG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSByZWdleC5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgICAgcmVhc29uOiAnZGVwcmVjYXRlZC1hcGknLFxuICAgICAgICAgICAgaXNzdWU6IHBhdHRlcm4ubWVzc2FnZSxcbiAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4ucGF0dGVybi5zb3VyY2UsXG4gICAgICAgICAgICBxdWlja0ZpeDogcGF0dGVybi5hbHRlcm5hdGl2ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHJlZ2V4IHBhdHRlcm46ICR7cGF0dGVybi5wYXR0ZXJufSAtICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZmluZGluZ3M7XG59XG5cbi8qKlxuICogR2V0IGxpbmUgbnVtYmVycyB3aXRoIGRlcHJlY2F0ZWQgcGF0dGVybnMgZm9yIGEgZmlsZVxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aFxuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcbiAqIEByZXR1cm5zIEFycmF5IG9mIGxpbmUgbnVtYmVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwcmVjYXRlZFBhdHRlcm5MaW5lcyhcbiAgZmlsZVBhdGg6IHN0cmluZyxcbiAgZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW11cbik6IG51bWJlcltdIHtcbiAgcmV0dXJuIGZpbmRpbmdzXG4gICAgLmZpbHRlcihmID0+IGYuZmlsZSA9PT0gZmlsZVBhdGgpXG4gICAgLm1hcChmID0+IGYubGluZSlcbiAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xufVxuIl0sIm5hbWVzIjpbInNob3VsZFNjYW5GaWxlIiwic2hvdWxkSWdub3JlUGF0aCIsInNjYW5Tb3VyY2VGaWxlcyIsImZpbGVzIiwicnVsZXMiLCJmaW5kaW5ncyIsImZpbGUiLCJzaXplIiwibWF4X2ZpbGVfc2l6ZSIsImNvbnNvbGUiLCJ3YXJuIiwicGF0aCIsIm5hbWUiLCJmaWxlUGF0aCIsImV4dGVuc2lvbiIsImdldEZpbGVFeHRlbnNpb24iLCJsYW5ndWFnZSIsImRldGVjdExhbmd1YWdlRnJvbUV4dGVuc2lvbiIsInBhdHRlcm5zIiwiZGVwcmVjYXRlZF9wYXR0ZXJucyIsImxlbmd0aCIsImZpbGVGaW5kaW5ncyIsInNjYW5GaWxlQ29udGVudCIsInB1c2giLCJqc0ZpbmRpbmdzIiwiYW5hbHl6ZUphdmFTY3JpcHRQYXR0ZXJucyIsInB5RmluZGluZ3MiLCJhbmFseXplUHl0aG9uUGF0dGVybnMiLCJsaW5lcyIsImNvbnRlbnQiLCJzcGxpdCIsImxpbmVJbmRleCIsImxpbmUiLCJsaW5lTnVtYmVyIiwiaXNDb21tZW50TGluZSIsInRyaW0iLCJwYXR0ZXJuIiwicmVnZXgiLCJSZWdFeHAiLCJtYXRjaCIsImV4ZWMiLCJpbmRleCIsImxhc3RJbmRleCIsImtpbmQiLCJsYW5nIiwic3RhdHVzIiwicmVhc29uIiwiaXNzdWUiLCJtZXNzYWdlIiwicXVpY2tGaXgiLCJhbHRlcm5hdGl2ZSIsImVycm9yIiwibGFzdERvdCIsImxhc3RJbmRleE9mIiwic3Vic3RyaW5nIiwibGFuZ3VhZ2VNYXAiLCJ0cmltbWVkIiwic3RhcnRzV2l0aCIsImdldFBhdHRlcm5RdWlja0ZpeCIsInF1aWNrX2ZpeGVzIiwicGF0dGVybl9yZXBsYWNlbWVudCIsImdyb3VwUGF0dGVybkZpbmRpbmdzQnlGaWxlIiwiZ3JvdXBlZCIsImZpbmRpbmciLCJncm91cFBhdHRlcm5GaW5kaW5nc0J5TGFuZ3VhZ2UiLCJweXRob24iLCJub2RlIiwiamF2YSIsImdvIiwiZG90bmV0IiwiZ2V0UGF0dGVyblN1bW1hcnkiLCJ0b3RhbCIsImJ5TGFuZ3VhZ2UiLCJieUZpbGUiLCJhZmZlY3RlZEZpbGVzIiwiT2JqZWN0Iiwia2V5cyIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm1hcCIsImNvdW50IiwiU2V0IiwiZiIsImZpbHRlclBhdHRlcm5GaW5kaW5nc0J5TGFuZ3VhZ2UiLCJmaWx0ZXIiLCJmaWx0ZXJQYXR0ZXJuRmluZGluZ3NCeUZpbGUiLCJzb3J0UGF0dGVybkZpbmRpbmdzIiwic29ydCIsImEiLCJiIiwiZmlsZURpZmYiLCJsb2NhbGVDb21wYXJlIiwiZ2V0VW5pcXVlUGF0dGVybnMiLCJhZGQiLCJBcnJheSIsImZyb20iLCJnZXRQYXR0ZXJuRnJlcXVlbmN5IiwiZnJlcXVlbmN5IiwiZ2V0TW9zdENvbW1vblBhdHRlcm5zIiwibGltaXQiLCJzbGljZSIsImZpbGVIYXNEZXByZWNhdGVkUGF0dGVybnMiLCJzb21lIiwiZ2V0RmlsZXNXaXRoRGVwcmVjYXRlZFBhdHRlcm5zIiwianNQYXR0ZXJucyIsInNvdXJjZSIsInB5UGF0dGVybnMiLCJnZXREZXByZWNhdGVkUGF0dGVybkxpbmVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/scan.ts\n");

/***/ }),

/***/ "(rsc)/./lib/files/single-file.ts":
/*!**********************************!*\
  !*** ./lib/files/single-file.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectFileType: () => (/* binding */ detectFileType),\n/* harmony export */   processSingleFile: () => (/* binding */ processSingleFile),\n/* harmony export */   shouldAnalyzeFile: () => (/* binding */ shouldAnalyzeFile)\n/* harmony export */ });\n/**\n * Process a single file for analysis\n * @param filePath Path to the file\n * @param content File content\n * @param maxFileSize Maximum file size in bytes\n * @returns Single file result\n */ function processSingleFile(filePath, content, maxFileSize = 2 * 1024 * 1024 // 2MB\n) {\n    // Check file size\n    const fileSize = Buffer.byteLength(content, 'utf8');\n    if (fileSize > maxFileSize) {\n        return {\n            files: [],\n            totalFiles: 1,\n            skippedFiles: 1\n        };\n    }\n    // Create extracted file object\n    const extractedFile = {\n        path: filePath,\n        content: content,\n        size: fileSize\n    };\n    return {\n        files: [\n            extractedFile\n        ],\n        totalFiles: 1,\n        skippedFiles: 0\n    };\n}\n/**\n * Detect file type from extension\n * @param filename File name\n * @returns File type category\n */ function detectFileType(filename) {\n    const ext = filename.split('.').pop()?.toLowerCase();\n    const typeMap = {\n        // Web files\n        'js': 'javascript',\n        'jsx': 'javascript',\n        'ts': 'typescript',\n        'tsx': 'typescript',\n        'html': 'html',\n        'htm': 'html',\n        'css': 'css',\n        'scss': 'css',\n        'sass': 'css',\n        'less': 'css',\n        // Python\n        'py': 'python',\n        'pyw': 'python',\n        // Java\n        'java': 'java',\n        'kt': 'kotlin',\n        'scala': 'scala',\n        // C/C++\n        'c': 'c',\n        'cpp': 'cpp',\n        'cc': 'cpp',\n        'cxx': 'cpp',\n        'h': 'c',\n        'hpp': 'cpp',\n        // C#\n        'cs': 'csharp',\n        'fs': 'fsharp',\n        'vb': 'vbnet',\n        // Go\n        'go': 'go',\n        // Rust\n        'rs': 'rust',\n        // PHP\n        'php': 'php',\n        // Ruby\n        'rb': 'ruby',\n        // Swift\n        'swift': 'swift',\n        // Configuration files\n        'json': 'json',\n        'yaml': 'yaml',\n        'yml': 'yaml',\n        'xml': 'xml',\n        'toml': 'toml',\n        'ini': 'ini',\n        'cfg': 'config',\n        'conf': 'config',\n        // Documentation\n        'md': 'markdown',\n        'txt': 'text',\n        'rst': 'restructuredtext',\n        // Shell scripts\n        'sh': 'shell',\n        'bash': 'shell',\n        'zsh': 'shell',\n        'fish': 'shell',\n        'ps1': 'powershell',\n        'bat': 'batch',\n        'cmd': 'batch',\n        // SQL\n        'sql': 'sql',\n        // Docker\n        'dockerfile': 'dockerfile',\n        'dockerignore': 'dockerignore',\n        // Git\n        'gitignore': 'gitignore',\n        'gitattributes': 'gitattributes',\n        // Package managers\n        'package.json': 'package.json',\n        'requirements.txt': 'requirements.txt',\n        'pom.xml': 'pom.xml',\n        'build.gradle': 'gradle',\n        'go.mod': 'go.mod',\n        'cargo.toml': 'cargo.toml',\n        'composer.json': 'composer.json',\n        'gemfile': 'gemfile',\n        'podfile': 'podfile',\n        'pubspec.yaml': 'pubspec.yaml'\n    };\n    return typeMap[ext || ''] || 'unknown';\n}\n/**\n * Check if file should be analyzed\n * @param filename File name\n * @returns Whether file should be analyzed\n */ function shouldAnalyzeFile(filename) {\n    const ext = filename.split('.').pop()?.toLowerCase();\n    // Only allow web file types\n    const allowedExtensions = [\n        'html',\n        'htm',\n        'css',\n        'js',\n        'mjs',\n        'ts',\n        'svg',\n        'wasm',\n        'json',\n        'webmanifest' // Web manifest files\n    ];\n    return allowedExtensions.includes(ext || '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvZmlsZXMvc2luZ2xlLWZpbGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBUUE7Ozs7OztDQU1DLEdBQ00sU0FBU0Esa0JBQ2RDLFFBQWdCLEVBQ2hCQyxPQUFlLEVBQ2ZDLGNBQXNCLElBQUksT0FBTyxLQUFLLE1BQU07QUFBUDtJQUVyQyxrQkFBa0I7SUFDbEIsTUFBTUMsV0FBV0MsT0FBT0MsVUFBVSxDQUFDSixTQUFTO0lBQzVDLElBQUlFLFdBQVdELGFBQWE7UUFDMUIsT0FBTztZQUNMSSxPQUFPLEVBQUU7WUFDVEMsWUFBWTtZQUNaQyxjQUFjO1FBQ2hCO0lBQ0Y7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTUMsZ0JBQStCO1FBQ25DQyxNQUFNVjtRQUNOQyxTQUFTQTtRQUNUVSxNQUFNUjtJQUNSO0lBRUEsT0FBTztRQUNMRyxPQUFPO1lBQUNHO1NBQWM7UUFDdEJGLFlBQVk7UUFDWkMsY0FBYztJQUNoQjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNJLGVBQWVDLFFBQWdCO0lBQzdDLE1BQU1DLE1BQU1ELFNBQVNFLEtBQUssQ0FBQyxLQUFLQyxHQUFHLElBQUlDO0lBRXZDLE1BQU1DLFVBQWtDO1FBQ3RDLFlBQVk7UUFDWixNQUFNO1FBQ04sT0FBTztRQUNQLE1BQU07UUFDTixPQUFPO1FBQ1AsUUFBUTtRQUNSLE9BQU87UUFDUCxPQUFPO1FBQ1AsUUFBUTtRQUNSLFFBQVE7UUFDUixRQUFRO1FBRVIsU0FBUztRQUNULE1BQU07UUFDTixPQUFPO1FBRVAsT0FBTztRQUNQLFFBQVE7UUFDUixNQUFNO1FBQ04sU0FBUztRQUVULFFBQVE7UUFDUixLQUFLO1FBQ0wsT0FBTztRQUNQLE1BQU07UUFDTixPQUFPO1FBQ1AsS0FBSztRQUNMLE9BQU87UUFFUCxLQUFLO1FBQ0wsTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO1FBRU4sS0FBSztRQUNMLE1BQU07UUFFTixPQUFPO1FBQ1AsTUFBTTtRQUVOLE1BQU07UUFDTixPQUFPO1FBRVAsT0FBTztRQUNQLE1BQU07UUFFTixRQUFRO1FBQ1IsU0FBUztRQUVULHNCQUFzQjtRQUN0QixRQUFRO1FBQ1IsUUFBUTtRQUNSLE9BQU87UUFDUCxPQUFPO1FBQ1AsUUFBUTtRQUNSLE9BQU87UUFDUCxPQUFPO1FBQ1AsUUFBUTtRQUVSLGdCQUFnQjtRQUNoQixNQUFNO1FBQ04sT0FBTztRQUNQLE9BQU87UUFFUCxnQkFBZ0I7UUFDaEIsTUFBTTtRQUNOLFFBQVE7UUFDUixPQUFPO1FBQ1AsUUFBUTtRQUNSLE9BQU87UUFDUCxPQUFPO1FBQ1AsT0FBTztRQUVQLE1BQU07UUFDTixPQUFPO1FBRVAsU0FBUztRQUNULGNBQWM7UUFDZCxnQkFBZ0I7UUFFaEIsTUFBTTtRQUNOLGFBQWE7UUFDYixpQkFBaUI7UUFFakIsbUJBQW1CO1FBQ25CLGdCQUFnQjtRQUNoQixvQkFBb0I7UUFDcEIsV0FBVztRQUNYLGdCQUFnQjtRQUNoQixVQUFVO1FBQ1YsY0FBYztRQUNkLGlCQUFpQjtRQUNqQixXQUFXO1FBQ1gsV0FBVztRQUNYLGdCQUFnQjtJQUNsQjtJQUVBLE9BQU9BLE9BQU8sQ0FBQ0osT0FBTyxHQUFHLElBQUk7QUFDL0I7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0ssa0JBQWtCTixRQUFnQjtJQUNoRCxNQUFNQyxNQUFNRCxTQUFTRSxLQUFLLENBQUMsS0FBS0MsR0FBRyxJQUFJQztJQUV2Qyw0QkFBNEI7SUFDNUIsTUFBTUcsb0JBQW9CO1FBQ3hCO1FBQVE7UUFDUjtRQUNBO1FBQU07UUFBTztRQUNiO1FBQ0E7UUFDQTtRQUNBLGNBQXlCLHFCQUFxQjtLQUMvQztJQUVELE9BQU9BLGtCQUFrQkMsUUFBUSxDQUFDUCxPQUFPO0FBQzNDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGZpbGVzXFxzaW5nbGUtZmlsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRyYWN0ZWRGaWxlIH0gZnJvbSAnLi4vYW5hbHlzaXMvYmFzZWxpbmUudHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpbmdsZUZpbGVSZXN1bHQge1xuICBmaWxlczogRXh0cmFjdGVkRmlsZVtdO1xuICB0b3RhbEZpbGVzOiBudW1iZXI7XG4gIHNraXBwZWRGaWxlczogbnVtYmVyO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBzaW5nbGUgZmlsZSBmb3IgYW5hbHlzaXNcbiAqIEBwYXJhbSBmaWxlUGF0aCBQYXRoIHRvIHRoZSBmaWxlXG4gKiBAcGFyYW0gY29udGVudCBGaWxlIGNvbnRlbnRcbiAqIEBwYXJhbSBtYXhGaWxlU2l6ZSBNYXhpbXVtIGZpbGUgc2l6ZSBpbiBieXRlc1xuICogQHJldHVybnMgU2luZ2xlIGZpbGUgcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzU2luZ2xlRmlsZShcbiAgZmlsZVBhdGg6IHN0cmluZyxcbiAgY29udGVudDogc3RyaW5nLFxuICBtYXhGaWxlU2l6ZTogbnVtYmVyID0gMiAqIDEwMjQgKiAxMDI0IC8vIDJNQlxuKTogU2luZ2xlRmlsZVJlc3VsdCB7XG4gIC8vIENoZWNrIGZpbGUgc2l6ZVxuICBjb25zdCBmaWxlU2l6ZSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNvbnRlbnQsICd1dGY4Jyk7XG4gIGlmIChmaWxlU2l6ZSA+IG1heEZpbGVTaXplKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGVzOiBbXSxcbiAgICAgIHRvdGFsRmlsZXM6IDEsXG4gICAgICBza2lwcGVkRmlsZXM6IDFcbiAgICB9O1xuICB9XG5cbiAgLy8gQ3JlYXRlIGV4dHJhY3RlZCBmaWxlIG9iamVjdFxuICBjb25zdCBleHRyYWN0ZWRGaWxlOiBFeHRyYWN0ZWRGaWxlID0ge1xuICAgIHBhdGg6IGZpbGVQYXRoLFxuICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgc2l6ZTogZmlsZVNpemVcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGZpbGVzOiBbZXh0cmFjdGVkRmlsZV0sXG4gICAgdG90YWxGaWxlczogMSxcbiAgICBza2lwcGVkRmlsZXM6IDBcbiAgfTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgZmlsZSB0eXBlIGZyb20gZXh0ZW5zaW9uXG4gKiBAcGFyYW0gZmlsZW5hbWUgRmlsZSBuYW1lXG4gKiBAcmV0dXJucyBGaWxlIHR5cGUgY2F0ZWdvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdEZpbGVUeXBlKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBleHQgPSBmaWxlbmFtZS5zcGxpdCgnLicpLnBvcCgpPy50b0xvd2VyQ2FzZSgpO1xuICBcbiAgY29uc3QgdHlwZU1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAvLyBXZWIgZmlsZXNcbiAgICAnanMnOiAnamF2YXNjcmlwdCcsXG4gICAgJ2pzeCc6ICdqYXZhc2NyaXB0JyxcbiAgICAndHMnOiAndHlwZXNjcmlwdCcsXG4gICAgJ3RzeCc6ICd0eXBlc2NyaXB0JyxcbiAgICAnaHRtbCc6ICdodG1sJyxcbiAgICAnaHRtJzogJ2h0bWwnLFxuICAgICdjc3MnOiAnY3NzJyxcbiAgICAnc2Nzcyc6ICdjc3MnLFxuICAgICdzYXNzJzogJ2NzcycsXG4gICAgJ2xlc3MnOiAnY3NzJyxcbiAgICBcbiAgICAvLyBQeXRob25cbiAgICAncHknOiAncHl0aG9uJyxcbiAgICAncHl3JzogJ3B5dGhvbicsXG4gICAgXG4gICAgLy8gSmF2YVxuICAgICdqYXZhJzogJ2phdmEnLFxuICAgICdrdCc6ICdrb3RsaW4nLFxuICAgICdzY2FsYSc6ICdzY2FsYScsXG4gICAgXG4gICAgLy8gQy9DKytcbiAgICAnYyc6ICdjJyxcbiAgICAnY3BwJzogJ2NwcCcsXG4gICAgJ2NjJzogJ2NwcCcsXG4gICAgJ2N4eCc6ICdjcHAnLFxuICAgICdoJzogJ2MnLFxuICAgICdocHAnOiAnY3BwJyxcbiAgICBcbiAgICAvLyBDI1xuICAgICdjcyc6ICdjc2hhcnAnLFxuICAgICdmcyc6ICdmc2hhcnAnLFxuICAgICd2Yic6ICd2Ym5ldCcsXG4gICAgXG4gICAgLy8gR29cbiAgICAnZ28nOiAnZ28nLFxuICAgIFxuICAgIC8vIFJ1c3RcbiAgICAncnMnOiAncnVzdCcsXG4gICAgXG4gICAgLy8gUEhQXG4gICAgJ3BocCc6ICdwaHAnLFxuICAgIFxuICAgIC8vIFJ1YnlcbiAgICAncmInOiAncnVieScsXG4gICAgXG4gICAgLy8gU3dpZnRcbiAgICAnc3dpZnQnOiAnc3dpZnQnLFxuICAgIFxuICAgIC8vIENvbmZpZ3VyYXRpb24gZmlsZXNcbiAgICAnanNvbic6ICdqc29uJyxcbiAgICAneWFtbCc6ICd5YW1sJyxcbiAgICAneW1sJzogJ3lhbWwnLFxuICAgICd4bWwnOiAneG1sJyxcbiAgICAndG9tbCc6ICd0b21sJyxcbiAgICAnaW5pJzogJ2luaScsXG4gICAgJ2NmZyc6ICdjb25maWcnLFxuICAgICdjb25mJzogJ2NvbmZpZycsXG4gICAgXG4gICAgLy8gRG9jdW1lbnRhdGlvblxuICAgICdtZCc6ICdtYXJrZG93bicsXG4gICAgJ3R4dCc6ICd0ZXh0JyxcbiAgICAncnN0JzogJ3Jlc3RydWN0dXJlZHRleHQnLFxuICAgIFxuICAgIC8vIFNoZWxsIHNjcmlwdHNcbiAgICAnc2gnOiAnc2hlbGwnLFxuICAgICdiYXNoJzogJ3NoZWxsJyxcbiAgICAnenNoJzogJ3NoZWxsJyxcbiAgICAnZmlzaCc6ICdzaGVsbCcsXG4gICAgJ3BzMSc6ICdwb3dlcnNoZWxsJyxcbiAgICAnYmF0JzogJ2JhdGNoJyxcbiAgICAnY21kJzogJ2JhdGNoJyxcbiAgICBcbiAgICAvLyBTUUxcbiAgICAnc3FsJzogJ3NxbCcsXG4gICAgXG4gICAgLy8gRG9ja2VyXG4gICAgJ2RvY2tlcmZpbGUnOiAnZG9ja2VyZmlsZScsXG4gICAgJ2RvY2tlcmlnbm9yZSc6ICdkb2NrZXJpZ25vcmUnLFxuICAgIFxuICAgIC8vIEdpdFxuICAgICdnaXRpZ25vcmUnOiAnZ2l0aWdub3JlJyxcbiAgICAnZ2l0YXR0cmlidXRlcyc6ICdnaXRhdHRyaWJ1dGVzJyxcbiAgICBcbiAgICAvLyBQYWNrYWdlIG1hbmFnZXJzXG4gICAgJ3BhY2thZ2UuanNvbic6ICdwYWNrYWdlLmpzb24nLFxuICAgICdyZXF1aXJlbWVudHMudHh0JzogJ3JlcXVpcmVtZW50cy50eHQnLFxuICAgICdwb20ueG1sJzogJ3BvbS54bWwnLFxuICAgICdidWlsZC5ncmFkbGUnOiAnZ3JhZGxlJyxcbiAgICAnZ28ubW9kJzogJ2dvLm1vZCcsXG4gICAgJ2NhcmdvLnRvbWwnOiAnY2FyZ28udG9tbCcsXG4gICAgJ2NvbXBvc2VyLmpzb24nOiAnY29tcG9zZXIuanNvbicsXG4gICAgJ2dlbWZpbGUnOiAnZ2VtZmlsZScsXG4gICAgJ3BvZGZpbGUnOiAncG9kZmlsZScsXG4gICAgJ3B1YnNwZWMueWFtbCc6ICdwdWJzcGVjLnlhbWwnXG4gIH07XG5cbiAgcmV0dXJuIHR5cGVNYXBbZXh0IHx8ICcnXSB8fCAndW5rbm93bic7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBzaG91bGQgYmUgYW5hbHl6ZWRcbiAqIEBwYXJhbSBmaWxlbmFtZSBGaWxlIG5hbWVcbiAqIEByZXR1cm5zIFdoZXRoZXIgZmlsZSBzaG91bGQgYmUgYW5hbHl6ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEFuYWx5emVGaWxlKGZpbGVuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgZXh0ID0gZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKT8udG9Mb3dlckNhc2UoKTtcbiAgXG4gIC8vIE9ubHkgYWxsb3cgd2ViIGZpbGUgdHlwZXNcbiAgY29uc3QgYWxsb3dlZEV4dGVuc2lvbnMgPSBbXG4gICAgJ2h0bWwnLCAnaHRtJywgICAgICAgICAgIC8vIEhUTUwgZmlsZXNcbiAgICAnY3NzJywgICAgICAgICAgICAgICAgICAgLy8gQ1NTIGZpbGVzXG4gICAgJ2pzJywgJ21qcycsICd0cycsICAgICAgIC8vIEphdmFTY3JpcHQvVHlwZVNjcmlwdCBmaWxlc1xuICAgICdzdmcnLCAgICAgICAgICAgICAgICAgICAvLyBTVkcgZmlsZXNcbiAgICAnd2FzbScsICAgICAgICAgICAgICAgICAgLy8gV2ViQXNzZW1ibHkgZmlsZXNcbiAgICAnanNvbicsICAgICAgICAgICAgICAgICAgLy8gSlNPTiBmaWxlc1xuICAgICd3ZWJtYW5pZmVzdCcgICAgICAgICAgICAvLyBXZWIgbWFuaWZlc3QgZmlsZXNcbiAgXTtcbiAgXG4gIHJldHVybiBhbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhleHQgfHwgJycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3NTaW5nbGVGaWxlIiwiZmlsZVBhdGgiLCJjb250ZW50IiwibWF4RmlsZVNpemUiLCJmaWxlU2l6ZSIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJmaWxlcyIsInRvdGFsRmlsZXMiLCJza2lwcGVkRmlsZXMiLCJleHRyYWN0ZWRGaWxlIiwicGF0aCIsInNpemUiLCJkZXRlY3RGaWxlVHlwZSIsImZpbGVuYW1lIiwiZXh0Iiwic3BsaXQiLCJwb3AiLCJ0b0xvd2VyQ2FzZSIsInR5cGVNYXAiLCJzaG91bGRBbmFseXplRmlsZSIsImFsbG93ZWRFeHRlbnNpb25zIiwiaW5jbHVkZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/files/single-file.ts\n");

/***/ }),

/***/ "(rsc)/./lib/files/store.ts":
/*!****************************!*\
  !*** ./lib/files/store.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analysisExists: () => (/* binding */ analysisExists),\n/* harmony export */   cleanupOldAnalyses: () => (/* binding */ cleanupOldAnalyses),\n/* harmony export */   deleteAnalysis: () => (/* binding */ deleteAnalysis),\n/* harmony export */   getAnalysisMetadata: () => (/* binding */ getAnalysisMetadata),\n/* harmony export */   getStorageStats: () => (/* binding */ getStorageStats),\n/* harmony export */   getStoredAnalysis: () => (/* binding */ getStoredAnalysis),\n/* harmony export */   listStoredAnalyses: () => (/* binding */ listStoredAnalyses),\n/* harmony export */   storeAnalysisResults: () => (/* binding */ storeAnalysisResults)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! papaparse */ \"(rsc)/./node_modules/papaparse/papaparse.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n/**\r\n * Store analysis results and return public URLs\r\n * @param report Analysis report\r\n * @param options Storage options\r\n * @returns Stored artifacts with public URLs\r\n */ function storeAnalysisResults(report, options = {}) {\n    const { baseDir = process.env.VERCEL ? '/tmp/analysis' : (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis'), publicUrl = 'http://localhost:3000', ttl = 24 * 60 * 60 * 1000 } = options;\n    const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_2__.randomUUID)();\n    // Ensure base directory exists\n    if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(baseDir)) {\n        (0,fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync)(baseDir, {\n            recursive: true\n        });\n    }\n    // Create analysis directory\n    const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n    if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir)) {\n        (0,fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync)(analysisDir, {\n            recursive: true\n        });\n    }\n    // Store JSON report\n    const jsonPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(analysisDir, 'report.json');\n    (0,fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync)(jsonPath, JSON.stringify(report, null, 2));\n    // Store CSV report\n    const csvPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(analysisDir, 'report.csv');\n    const csvContent = generateCSV(report);\n    (0,fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync)(csvPath, csvContent);\n    // Schedule cleanup\n    scheduleCleanup(analysisDir, ttl);\n    return {\n        jsonUrl: `${publicUrl}/api/analyze/${analysisId}?format=json`,\n        csvUrl: `${publicUrl}/api/analyze/${analysisId}?format=csv`,\n        analysisId\n    };\n}\n/**\r\n * Generate CSV content from report\r\n * @param report Analysis report\r\n * @returns CSV content\r\n */ function generateCSV(report) {\n    const rows = [];\n    for (const finding of report.findings){\n        if (finding.kind === 'dependency') {\n            rows.push({\n                Kind: 'Dependency',\n                Language: finding.lang,\n                Component: finding.component,\n                File: finding.file,\n                Line: '',\n                Status: finding.status,\n                Reason: finding.reason,\n                'Quick Fix': finding.quickFix || '',\n                'Found Version': finding.foundVersion || '',\n                'Required Version': finding.baselineRequired || ''\n            });\n        } else if (finding.kind === 'pattern') {\n            rows.push({\n                Kind: 'Pattern',\n                Language: finding.lang,\n                Component: '',\n                File: finding.file,\n                Line: finding.line.toString(),\n                Status: finding.status,\n                Reason: finding.issue,\n                'Quick Fix': finding.quickFix || '',\n                'Found Version': '',\n                'Required Version': ''\n            });\n        }\n    }\n    return papaparse__WEBPACK_IMPORTED_MODULE_3___default().unparse(rows);\n}\n/**\r\n * Schedule cleanup of analysis files\r\n * @param analysisDir Analysis directory path\r\n * @param ttl Time to live in milliseconds\r\n */ function scheduleCleanup(analysisDir, ttl) {\n    setTimeout(async ()=>{\n        try {\n            if ((0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir)) {\n                // Remove directory and all contents\n                const { rmSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n                rmSync(analysisDir, {\n                    recursive: true,\n                    force: true\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to cleanup analysis directory ${analysisDir}: ${error}`);\n        }\n    }, ttl);\n}\n/**\r\n * Get stored analysis report\r\n * @param analysisId Analysis ID\r\n * @param format Format (json or csv)\r\n * @param baseDir Base directory for storage\r\n * @returns Report content or null if not found\r\n */ async function getStoredAnalysis(analysisId, format = 'json', baseDir = process.env.VERCEL ? '/tmp/analysis' : (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    try {\n        const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n        const filePath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(analysisDir, `report.${format}`);\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(filePath)) {\n            return null;\n        }\n        const { readFileSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const content = readFileSync(filePath, 'utf8');\n        return content;\n    } catch (error) {\n        console.warn(`Failed to read stored analysis ${analysisId}: ${error}`);\n        return null;\n    }\n}\n/**\r\n * Check if analysis exists\r\n * @param analysisId Analysis ID\r\n * @param baseDir Base directory for storage\r\n * @returns True if analysis exists\r\n */ function analysisExists(analysisId, baseDir = process.env.VERCEL ? '/tmp/analysis' : (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n    return (0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir);\n}\n/**\r\n * Clean up old analysis files\r\n * @param baseDir Base directory for storage\r\n * @param maxAge Maximum age in milliseconds\r\n * @returns Number of cleaned up analyses\r\n */ async function cleanupOldAnalyses(baseDir = process.env.VERCEL ? '/tmp/analysis' : (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis'), maxAge = 24 * 60 * 60 * 1000 // 24 hours\n) {\n    let cleanedCount = 0;\n    try {\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(baseDir)) {\n            return 0;\n        }\n        const { readdirSync, statSync, rmSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const entries = readdirSync(baseDir, {\n            withFileTypes: true\n        });\n        for (const entry of entries){\n            if (entry.isDirectory()) {\n                const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, entry.name);\n                const stats = statSync(analysisDir);\n                const age = Date.now() - stats.mtime.getTime();\n                if (age > maxAge) {\n                    try {\n                        rmSync(analysisDir, {\n                            recursive: true,\n                            force: true\n                        });\n                        cleanedCount++;\n                    } catch (error) {\n                        console.warn(`Failed to cleanup ${analysisDir}: ${error}`);\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        console.warn(`Failed to cleanup old analyses: ${error}`);\n    }\n    return cleanedCount;\n}\n/**\r\n * Get analysis metadata\r\n * @param analysisId Analysis ID\r\n * @param baseDir Base directory for storage\r\n * @returns Analysis metadata or null\r\n */ async function getAnalysisMetadata(analysisId, baseDir = process.env.VERCEL ? '/tmp/analysis' : (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    try {\n        const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir)) {\n            return null;\n        }\n        const { statSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const stats = statSync(analysisDir);\n        return {\n            createdAt: stats.birthtime,\n            size: stats.size\n        };\n    } catch (error) {\n        console.warn(`Failed to get metadata for ${analysisId}: ${error}`);\n        return null;\n    }\n}\n/**\r\n * List all stored analyses\r\n * @param baseDir Base directory for storage\r\n * @returns Array of analysis IDs\r\n */ async function listStoredAnalyses(baseDir = process.env.VERCEL ? '/tmp/analysis' : (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    try {\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(baseDir)) {\n            return [];\n        }\n        const { readdirSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const entries = readdirSync(baseDir, {\n            withFileTypes: true\n        });\n        return entries.filter((entry)=>entry.isDirectory()).map((entry)=>entry.name);\n    } catch (error) {\n        console.warn(`Failed to list stored analyses: ${error}`);\n        return [];\n    }\n}\n/**\r\n * Delete specific analysis\r\n * @param analysisId Analysis ID\r\n * @param baseDir Base directory for storage\r\n * @returns True if deleted successfully\r\n */ async function deleteAnalysis(analysisId, baseDir = process.env.VERCEL ? '/tmp/analysis' : (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    try {\n        const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir)) {\n            return false;\n        }\n        const { rmSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        rmSync(analysisDir, {\n            recursive: true,\n            force: true\n        });\n        return true;\n    } catch (error) {\n        console.warn(`Failed to delete analysis ${analysisId}: ${error}`);\n        return false;\n    }\n}\n/**\r\n * Get storage statistics\r\n * @param baseDir Base directory for storage\r\n * @returns Storage statistics\r\n */ async function getStorageStats(baseDir = process.env.VERCEL ? '/tmp/analysis' : (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    try {\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(baseDir)) {\n            return {\n                totalAnalyses: 0,\n                totalSize: 0,\n                oldestAnalysis: null,\n                newestAnalysis: null\n            };\n        }\n        const { readdirSync, statSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const entries = readdirSync(baseDir, {\n            withFileTypes: true\n        });\n        const analyses = entries.filter((entry)=>entry.isDirectory());\n        let totalSize = 0;\n        let oldestDate = null;\n        let newestDate = null;\n        for (const analysis of analyses){\n            const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysis.name);\n            const stats = statSync(analysisDir);\n            totalSize += stats.size;\n            if (!oldestDate || stats.birthtime < oldestDate) {\n                oldestDate = stats.birthtime;\n            }\n            if (!newestDate || stats.birthtime > newestDate) {\n                newestDate = stats.birthtime;\n            }\n        }\n        return {\n            totalAnalyses: analyses.length,\n            totalSize,\n            oldestAnalysis: oldestDate,\n            newestAnalysis: newestDate\n        };\n    } catch (error) {\n        console.warn(`Failed to get storage stats: ${error}`);\n        return {\n            totalAnalyses: 0,\n            totalSize: 0,\n            oldestAnalysis: null,\n            newestAnalysis: null\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVN1RixTQUFTdkIsSUFBSTtZQUMvQyxNQUFNQyxRQUFRTixTQUFTbEQ7WUFFdkJ3RSxhQUFhaEIsTUFBTVMsSUFBSTtZQUV2QixJQUFJLENBQUNXLGNBQWNwQixNQUFNUSxTQUFTLEdBQUdZLFlBQVk7Z0JBQy9DQSxhQUFhcEIsTUFBTVEsU0FBUztZQUM5QjtZQUVBLElBQUksQ0FBQ2EsY0FBY3JCLE1BQU1RLFNBQVMsR0FBR2EsWUFBWTtnQkFDL0NBLGFBQWFyQixNQUFNUSxTQUFTO1lBQzlCO1FBQ0Y7UUFFQSxPQUFPO1lBQ0xPLGVBQWVJLFNBQVNJLE1BQU07WUFDOUJQO1lBQ0FDLGdCQUFnQkc7WUFDaEJGLGdCQUFnQkc7UUFDbEI7SUFDRixFQUFFLE9BQU94QyxPQUFPO1FBQ2RDLFFBQVFDLElBQUksQ0FBQyxDQUFDLDZCQUE2QixFQUFFRixPQUFPO1FBQ3BELE9BQU87WUFDTGtDLGVBQWU7WUFDZkMsV0FBVztZQUNYQyxnQkFBZ0I7WUFDaEJDLGdCQUFnQjtRQUNsQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcZmlsZXNcXHN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdyaXRlRmlsZVN5bmMsIG1rZGlyU3luYywgZXhpc3RzU3luYyB9IGZyb20gJ2ZzJztcclxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgeyByYW5kb21VVUlEIH0gZnJvbSAnY3J5cHRvJztcclxuaW1wb3J0IFBhcGEgZnJvbSAncGFwYXBhcnNlJztcclxuaW1wb3J0IHsgUmVwb3J0LCBDU1ZSb3cgfSBmcm9tICcuLi9hbmFseXNpcy9iYXNlbGluZS50eXBlcyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0b3JlZEFydGlmYWN0cyB7XHJcbiAganNvblVybDogc3RyaW5nO1xyXG4gIGNzdlVybDogc3RyaW5nO1xyXG4gIGFuYWx5c2lzSWQ6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdG9yYWdlT3B0aW9ucyB7XHJcbiAgYmFzZURpcj86IHN0cmluZztcclxuICBwdWJsaWNVcmw/OiBzdHJpbmc7XHJcbiAgdHRsPzogbnVtYmVyOyAvLyBUaW1lIHRvIGxpdmUgaW4gbWlsbGlzZWNvbmRzXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdG9yZSBhbmFseXNpcyByZXN1bHRzIGFuZCByZXR1cm4gcHVibGljIFVSTHNcclxuICogQHBhcmFtIHJlcG9ydCBBbmFseXNpcyByZXBvcnRcclxuICogQHBhcmFtIG9wdGlvbnMgU3RvcmFnZSBvcHRpb25zXHJcbiAqIEByZXR1cm5zIFN0b3JlZCBhcnRpZmFjdHMgd2l0aCBwdWJsaWMgVVJMc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlQW5hbHlzaXNSZXN1bHRzKFxyXG4gIHJlcG9ydDogUmVwb3J0LFxyXG4gIG9wdGlvbnM6IFN0b3JhZ2VPcHRpb25zID0ge31cclxuKTogU3RvcmVkQXJ0aWZhY3RzIHtcclxuICBjb25zdCB7XHJcbiAgICBiYXNlRGlyID0gcHJvY2Vzcy5lbnYuVkVSQ0VMID8gJy90bXAvYW5hbHlzaXMnIDogam9pbihwcm9jZXNzLmN3ZCgpLCAndG1wJywgJ2FuYWx5c2lzJyksXHJcbiAgICBwdWJsaWNVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyxcclxuICAgIHR0bCA9IDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDI0IGhvdXJzXHJcbiAgfSA9IG9wdGlvbnM7XHJcblxyXG4gIGNvbnN0IGFuYWx5c2lzSWQgPSByYW5kb21VVUlEKCk7XHJcbiAgXHJcbiAgLy8gRW5zdXJlIGJhc2UgZGlyZWN0b3J5IGV4aXN0c1xyXG4gIGlmICghZXhpc3RzU3luYyhiYXNlRGlyKSkge1xyXG4gICAgbWtkaXJTeW5jKGJhc2VEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIGFuYWx5c2lzIGRpcmVjdG9yeVxyXG4gIGNvbnN0IGFuYWx5c2lzRGlyID0gam9pbihiYXNlRGlyLCBhbmFseXNpc0lkKTtcclxuICBpZiAoIWV4aXN0c1N5bmMoYW5hbHlzaXNEaXIpKSB7XHJcbiAgICBta2RpclN5bmMoYW5hbHlzaXNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gU3RvcmUgSlNPTiByZXBvcnRcclxuICBjb25zdCBqc29uUGF0aCA9IGpvaW4oYW5hbHlzaXNEaXIsICdyZXBvcnQuanNvbicpO1xyXG4gIHdyaXRlRmlsZVN5bmMoanNvblBhdGgsIEpTT04uc3RyaW5naWZ5KHJlcG9ydCwgbnVsbCwgMikpO1xyXG5cclxuICAvLyBTdG9yZSBDU1YgcmVwb3J0XHJcbiAgY29uc3QgY3N2UGF0aCA9IGpvaW4oYW5hbHlzaXNEaXIsICdyZXBvcnQuY3N2Jyk7XHJcbiAgY29uc3QgY3N2Q29udGVudCA9IGdlbmVyYXRlQ1NWKHJlcG9ydCk7XHJcbiAgd3JpdGVGaWxlU3luYyhjc3ZQYXRoLCBjc3ZDb250ZW50KTtcclxuXHJcbiAgLy8gU2NoZWR1bGUgY2xlYW51cFxyXG4gIHNjaGVkdWxlQ2xlYW51cChhbmFseXNpc0RpciwgdHRsKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGpzb25Vcmw6IGAke3B1YmxpY1VybH0vYXBpL2FuYWx5emUvJHthbmFseXNpc0lkfT9mb3JtYXQ9anNvbmAsXHJcbiAgICBjc3ZVcmw6IGAke3B1YmxpY1VybH0vYXBpL2FuYWx5emUvJHthbmFseXNpc0lkfT9mb3JtYXQ9Y3N2YCxcclxuICAgIGFuYWx5c2lzSWQsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIENTViBjb250ZW50IGZyb20gcmVwb3J0XHJcbiAqIEBwYXJhbSByZXBvcnQgQW5hbHlzaXMgcmVwb3J0XHJcbiAqIEByZXR1cm5zIENTViBjb250ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNTVihyZXBvcnQ6IFJlcG9ydCk6IHN0cmluZyB7XHJcbiAgY29uc3Qgcm93czogQ1NWUm93W10gPSBbXTtcclxuXHJcbiAgZm9yIChjb25zdCBmaW5kaW5nIG9mIHJlcG9ydC5maW5kaW5ncykge1xyXG4gICAgaWYgKGZpbmRpbmcua2luZCA9PT0gJ2RlcGVuZGVuY3knKSB7XHJcbiAgICAgIHJvd3MucHVzaCh7XHJcbiAgICAgICAgS2luZDogJ0RlcGVuZGVuY3knLFxyXG4gICAgICAgIExhbmd1YWdlOiBmaW5kaW5nLmxhbmcsXHJcbiAgICAgICAgQ29tcG9uZW50OiBmaW5kaW5nLmNvbXBvbmVudCxcclxuICAgICAgICBGaWxlOiBmaW5kaW5nLmZpbGUsXHJcbiAgICAgICAgTGluZTogJycsXHJcbiAgICAgICAgU3RhdHVzOiBmaW5kaW5nLnN0YXR1cyxcclxuICAgICAgICBSZWFzb246IGZpbmRpbmcucmVhc29uLFxyXG4gICAgICAgICdRdWljayBGaXgnOiBmaW5kaW5nLnF1aWNrRml4IHx8ICcnLFxyXG4gICAgICAgICdGb3VuZCBWZXJzaW9uJzogZmluZGluZy5mb3VuZFZlcnNpb24gfHwgJycsXHJcbiAgICAgICAgJ1JlcXVpcmVkIFZlcnNpb24nOiBmaW5kaW5nLmJhc2VsaW5lUmVxdWlyZWQgfHwgJycsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChmaW5kaW5nLmtpbmQgPT09ICdwYXR0ZXJuJykge1xyXG4gICAgICByb3dzLnB1c2goe1xyXG4gICAgICAgIEtpbmQ6ICdQYXR0ZXJuJyxcclxuICAgICAgICBMYW5ndWFnZTogZmluZGluZy5sYW5nLFxyXG4gICAgICAgIENvbXBvbmVudDogJycsXHJcbiAgICAgICAgRmlsZTogZmluZGluZy5maWxlLFxyXG4gICAgICAgIExpbmU6IGZpbmRpbmcubGluZS50b1N0cmluZygpLFxyXG4gICAgICAgIFN0YXR1czogZmluZGluZy5zdGF0dXMsXHJcbiAgICAgICAgUmVhc29uOiBmaW5kaW5nLmlzc3VlLFxyXG4gICAgICAgICdRdWljayBGaXgnOiBmaW5kaW5nLnF1aWNrRml4IHx8ICcnLFxyXG4gICAgICAgICdGb3VuZCBWZXJzaW9uJzogJycsXHJcbiAgICAgICAgJ1JlcXVpcmVkIFZlcnNpb24nOiAnJyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gUGFwYS51bnBhcnNlKHJvd3MpO1xyXG59XHJcblxyXG4vKipcclxuICogU2NoZWR1bGUgY2xlYW51cCBvZiBhbmFseXNpcyBmaWxlc1xyXG4gKiBAcGFyYW0gYW5hbHlzaXNEaXIgQW5hbHlzaXMgZGlyZWN0b3J5IHBhdGhcclxuICogQHBhcmFtIHR0bCBUaW1lIHRvIGxpdmUgaW4gbWlsbGlzZWNvbmRzXHJcbiAqL1xyXG5mdW5jdGlvbiBzY2hlZHVsZUNsZWFudXAoYW5hbHlzaXNEaXI6IHN0cmluZywgdHRsOiBudW1iZXIpOiB2b2lkIHtcclxuICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChleGlzdHNTeW5jKGFuYWx5c2lzRGlyKSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBkaXJlY3RvcnkgYW5kIGFsbCBjb250ZW50c1xyXG4gICAgICAgIGNvbnN0IHsgcm1TeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2ZzJyk7XHJcbiAgICAgICAgcm1TeW5jKGFuYWx5c2lzRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGNsZWFudXAgYW5hbHlzaXMgZGlyZWN0b3J5ICR7YW5hbHlzaXNEaXJ9OiAke2Vycm9yfWApO1xyXG4gICAgfVxyXG4gIH0sIHR0bCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgc3RvcmVkIGFuYWx5c2lzIHJlcG9ydFxyXG4gKiBAcGFyYW0gYW5hbHlzaXNJZCBBbmFseXNpcyBJRFxyXG4gKiBAcGFyYW0gZm9ybWF0IEZvcm1hdCAoanNvbiBvciBjc3YpXHJcbiAqIEBwYXJhbSBiYXNlRGlyIEJhc2UgZGlyZWN0b3J5IGZvciBzdG9yYWdlXHJcbiAqIEByZXR1cm5zIFJlcG9ydCBjb250ZW50IG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmVkQW5hbHlzaXMoXHJcbiAgYW5hbHlzaXNJZDogc3RyaW5nLFxyXG4gIGZvcm1hdDogJ2pzb24nIHwgJ2NzdicgPSAnanNvbicsXHJcbiAgYmFzZURpcjogc3RyaW5nID0gcHJvY2Vzcy5lbnYuVkVSQ0VMID8gJy90bXAvYW5hbHlzaXMnIDogam9pbihwcm9jZXNzLmN3ZCgpLCAndG1wJywgJ2FuYWx5c2lzJylcclxuKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGFuYWx5c2lzRGlyID0gam9pbihiYXNlRGlyLCBhbmFseXNpc0lkKTtcclxuICAgIGNvbnN0IGZpbGVQYXRoID0gam9pbihhbmFseXNpc0RpciwgYHJlcG9ydC4ke2Zvcm1hdH1gKTtcclxuICAgIFxyXG4gICAgaWYgKCFleGlzdHNTeW5jKGZpbGVQYXRoKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHJlYWRGaWxlU3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgY29uc3QgY29udGVudCA9IHJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byByZWFkIHN0b3JlZCBhbmFseXNpcyAke2FuYWx5c2lzSWR9OiAke2Vycm9yfWApO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYW5hbHlzaXMgZXhpc3RzXHJcbiAqIEBwYXJhbSBhbmFseXNpc0lkIEFuYWx5c2lzIElEXHJcbiAqIEBwYXJhbSBiYXNlRGlyIEJhc2UgZGlyZWN0b3J5IGZvciBzdG9yYWdlXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgYW5hbHlzaXMgZXhpc3RzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYW5hbHlzaXNFeGlzdHMoXHJcbiAgYW5hbHlzaXNJZDogc3RyaW5nLFxyXG4gIGJhc2VEaXI6IHN0cmluZyA9IHByb2Nlc3MuZW52LlZFUkNFTCA/ICcvdG1wL2FuYWx5c2lzJyA6IGpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdhbmFseXNpcycpXHJcbik6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IGFuYWx5c2lzRGlyID0gam9pbihiYXNlRGlyLCBhbmFseXNpc0lkKTtcclxuICByZXR1cm4gZXhpc3RzU3luYyhhbmFseXNpc0Rpcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhbiB1cCBvbGQgYW5hbHlzaXMgZmlsZXNcclxuICogQHBhcmFtIGJhc2VEaXIgQmFzZSBkaXJlY3RvcnkgZm9yIHN0b3JhZ2VcclxuICogQHBhcmFtIG1heEFnZSBNYXhpbXVtIGFnZSBpbiBtaWxsaXNlY29uZHNcclxuICogQHJldHVybnMgTnVtYmVyIG9mIGNsZWFuZWQgdXAgYW5hbHlzZXNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhbnVwT2xkQW5hbHlzZXMoXHJcbiAgYmFzZURpcjogc3RyaW5nID0gcHJvY2Vzcy5lbnYuVkVSQ0VMID8gJy90bXAvYW5hbHlzaXMnIDogam9pbihwcm9jZXNzLmN3ZCgpLCAndG1wJywgJ2FuYWx5c2lzJyksXHJcbiAgbWF4QWdlOiBudW1iZXIgPSAyNCAqIDYwICogNjAgKiAxMDAwIC8vIDI0IGhvdXJzXHJcbik6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgbGV0IGNsZWFuZWRDb3VudCA9IDA7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBpZiAoIWV4aXN0c1N5bmMoYmFzZURpcikpIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyByZWFkZGlyU3luYywgc3RhdFN5bmMsIHJtU3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgY29uc3QgZW50cmllcyA9IHJlYWRkaXJTeW5jKGJhc2VEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KCkpIHtcclxuICAgICAgICBjb25zdCBhbmFseXNpc0RpciA9IGpvaW4oYmFzZURpciwgZW50cnkubmFtZSk7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhhbmFseXNpc0Rpcik7XHJcbiAgICAgICAgY29uc3QgYWdlID0gRGF0ZS5ub3coKSAtIHN0YXRzLm10aW1lLmdldFRpbWUoKTtcclxuXHJcbiAgICAgICAgaWYgKGFnZSA+IG1heEFnZSkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcm1TeW5jKGFuYWx5c2lzRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIGNsZWFuZWRDb3VudCsrO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY2xlYW51cCAke2FuYWx5c2lzRGlyfTogJHtlcnJvcn1gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY2xlYW51cCBvbGQgYW5hbHlzZXM6ICR7ZXJyb3J9YCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY2xlYW5lZENvdW50O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGFuYWx5c2lzIG1ldGFkYXRhXHJcbiAqIEBwYXJhbSBhbmFseXNpc0lkIEFuYWx5c2lzIElEXHJcbiAqIEBwYXJhbSBiYXNlRGlyIEJhc2UgZGlyZWN0b3J5IGZvciBzdG9yYWdlXHJcbiAqIEByZXR1cm5zIEFuYWx5c2lzIG1ldGFkYXRhIG9yIG51bGxcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbmFseXNpc01ldGFkYXRhKFxyXG4gIGFuYWx5c2lzSWQ6IHN0cmluZyxcclxuICBiYXNlRGlyOiBzdHJpbmcgPSBwcm9jZXNzLmVudi5WRVJDRUwgPyAnL3RtcC9hbmFseXNpcycgOiBqb2luKHByb2Nlc3MuY3dkKCksICd0bXAnLCAnYW5hbHlzaXMnKVxyXG4pOiBQcm9taXNlPHsgY3JlYXRlZEF0OiBEYXRlOyBzaXplOiBudW1iZXIgfSB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgYW5hbHlzaXNEaXIgPSBqb2luKGJhc2VEaXIsIGFuYWx5c2lzSWQpO1xyXG4gICAgXHJcbiAgICBpZiAoIWV4aXN0c1N5bmMoYW5hbHlzaXNEaXIpKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgc3RhdFN5bmMgfSA9IGF3YWl0IGltcG9ydCgnZnMnKTtcclxuICAgIGNvbnN0IHN0YXRzID0gc3RhdFN5bmMoYW5hbHlzaXNEaXIpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNyZWF0ZWRBdDogc3RhdHMuYmlydGh0aW1lLFxyXG4gICAgICBzaXplOiBzdGF0cy5zaXplLFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZ2V0IG1ldGFkYXRhIGZvciAke2FuYWx5c2lzSWR9OiAke2Vycm9yfWApO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTGlzdCBhbGwgc3RvcmVkIGFuYWx5c2VzXHJcbiAqIEBwYXJhbSBiYXNlRGlyIEJhc2UgZGlyZWN0b3J5IGZvciBzdG9yYWdlXHJcbiAqIEByZXR1cm5zIEFycmF5IG9mIGFuYWx5c2lzIElEc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpc3RTdG9yZWRBbmFseXNlcyhcclxuICBiYXNlRGlyOiBzdHJpbmcgPSBwcm9jZXNzLmVudi5WRVJDRUwgPyAnL3RtcC9hbmFseXNpcycgOiBqb2luKHByb2Nlc3MuY3dkKCksICd0bXAnLCAnYW5hbHlzaXMnKVxyXG4pOiBQcm9taXNlPHN0cmluZ1tdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghZXhpc3RzU3luYyhiYXNlRGlyKSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyByZWFkZGlyU3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgY29uc3QgZW50cmllcyA9IHJlYWRkaXJTeW5jKGJhc2VEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcclxuXHJcbiAgICByZXR1cm4gZW50cmllc1xyXG4gICAgICAuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LmlzRGlyZWN0b3J5KCkpXHJcbiAgICAgIC5tYXAoZW50cnkgPT4gZW50cnkubmFtZSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGxpc3Qgc3RvcmVkIGFuYWx5c2VzOiAke2Vycm9yfWApO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERlbGV0ZSBzcGVjaWZpYyBhbmFseXNpc1xyXG4gKiBAcGFyYW0gYW5hbHlzaXNJZCBBbmFseXNpcyBJRFxyXG4gKiBAcGFyYW0gYmFzZURpciBCYXNlIGRpcmVjdG9yeSBmb3Igc3RvcmFnZVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQW5hbHlzaXMoXHJcbiAgYW5hbHlzaXNJZDogc3RyaW5nLFxyXG4gIGJhc2VEaXI6IHN0cmluZyA9IHByb2Nlc3MuZW52LlZFUkNFTCA/ICcvdG1wL2FuYWx5c2lzJyA6IGpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdhbmFseXNpcycpXHJcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBhbmFseXNpc0RpciA9IGpvaW4oYmFzZURpciwgYW5hbHlzaXNJZCk7XHJcbiAgICBcclxuICAgIGlmICghZXhpc3RzU3luYyhhbmFseXNpc0RpcikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgcm1TeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2ZzJyk7XHJcbiAgICBybVN5bmMoYW5hbHlzaXNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBkZWxldGUgYW5hbHlzaXMgJHthbmFseXNpc0lkfTogJHtlcnJvcn1gKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgc3RvcmFnZSBzdGF0aXN0aWNzXHJcbiAqIEBwYXJhbSBiYXNlRGlyIEJhc2UgZGlyZWN0b3J5IGZvciBzdG9yYWdlXHJcbiAqIEByZXR1cm5zIFN0b3JhZ2Ugc3RhdGlzdGljc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2VTdGF0cyhcclxuICBiYXNlRGlyOiBzdHJpbmcgPSBwcm9jZXNzLmVudi5WRVJDRUwgPyAnL3RtcC9hbmFseXNpcycgOiBqb2luKHByb2Nlc3MuY3dkKCksICd0bXAnLCAnYW5hbHlzaXMnKVxyXG4pOiBQcm9taXNlPHtcclxuICB0b3RhbEFuYWx5c2VzOiBudW1iZXI7XHJcbiAgdG90YWxTaXplOiBudW1iZXI7XHJcbiAgb2xkZXN0QW5hbHlzaXM6IERhdGUgfCBudWxsO1xyXG4gIG5ld2VzdEFuYWx5c2lzOiBEYXRlIHwgbnVsbDtcclxufT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIWV4aXN0c1N5bmMoYmFzZURpcikpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbEFuYWx5c2VzOiAwLFxyXG4gICAgICAgIHRvdGFsU2l6ZTogMCxcclxuICAgICAgICBvbGRlc3RBbmFseXNpczogbnVsbCxcclxuICAgICAgICBuZXdlc3RBbmFseXNpczogbnVsbCxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHJlYWRkaXJTeW5jLCBzdGF0U3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgY29uc3QgZW50cmllcyA9IHJlYWRkaXJTeW5jKGJhc2VEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcclxuICAgIGNvbnN0IGFuYWx5c2VzID0gZW50cmllcy5maWx0ZXIoZW50cnkgPT4gZW50cnkuaXNEaXJlY3RvcnkoKSk7XHJcblxyXG4gICAgbGV0IHRvdGFsU2l6ZSA9IDA7XHJcbiAgICBsZXQgb2xkZXN0RGF0ZTogRGF0ZSB8IG51bGwgPSBudWxsO1xyXG4gICAgbGV0IG5ld2VzdERhdGU6IERhdGUgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGFuYWx5c2lzIG9mIGFuYWx5c2VzKSB7XHJcbiAgICAgIGNvbnN0IGFuYWx5c2lzRGlyID0gam9pbihiYXNlRGlyLCBhbmFseXNpcy5uYW1lKTtcclxuICAgICAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhhbmFseXNpc0Rpcik7XHJcbiAgICAgIFxyXG4gICAgICB0b3RhbFNpemUgKz0gc3RhdHMuc2l6ZTtcclxuICAgICAgXHJcbiAgICAgIGlmICghb2xkZXN0RGF0ZSB8fCBzdGF0cy5iaXJ0aHRpbWUgPCBvbGRlc3REYXRlKSB7XHJcbiAgICAgICAgb2xkZXN0RGF0ZSA9IHN0YXRzLmJpcnRodGltZTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKCFuZXdlc3REYXRlIHx8IHN0YXRzLmJpcnRodGltZSA+IG5ld2VzdERhdGUpIHtcclxuICAgICAgICBuZXdlc3REYXRlID0gc3RhdHMuYmlydGh0aW1lO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxBbmFseXNlczogYW5hbHlzZXMubGVuZ3RoLFxyXG4gICAgICB0b3RhbFNpemUsXHJcbiAgICAgIG9sZGVzdEFuYWx5c2lzOiBvbGRlc3REYXRlLFxyXG4gICAgICBuZXdlc3RBbmFseXNpczogbmV3ZXN0RGF0ZSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGdldCBzdG9yYWdlIHN0YXRzOiAke2Vycm9yfWApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxBbmFseXNlczogMCxcclxuICAgICAgdG90YWxTaXplOiAwLFxyXG4gICAgICBvbGRlc3RBbmFseXNpczogbnVsbCxcclxuICAgICAgbmV3ZXN0QW5hbHlzaXM6IG51bGwsXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsid3JpdGVGaWxlU3luYyIsIm1rZGlyU3luYyIsImV4aXN0c1N5bmMiLCJqb2luIiwicmFuZG9tVVVJRCIsIlBhcGEiLCJzdG9yZUFuYWx5c2lzUmVzdWx0cyIsInJlcG9ydCIsIm9wdGlvbnMiLCJiYXNlRGlyIiwicHJvY2VzcyIsImVudiIsIlZFUkNFTCIsImN3ZCIsInB1YmxpY1VybCIsInR0bCIsImFuYWx5c2lzSWQiLCJyZWN1cnNpdmUiLCJhbmFseXNpc0RpciIsImpzb25QYXRoIiwiSlNPTiIsInN0cmluZ2lmeSIsImNzdlBhdGgiLCJjc3ZDb250ZW50IiwiZ2VuZXJhdGVDU1YiLCJzY2hlZHVsZUNsZWFudXAiLCJqc29uVXJsIiwiY3N2VXJsIiwicm93cyIsImZpbmRpbmciLCJmaW5kaW5ncyIsImtpbmQiLCJwdXNoIiwiS2luZCIsIkxhbmd1YWdlIiwibGFuZyIsIkNvbXBvbmVudCIsImNvbXBvbmVudCIsIkZpbGUiLCJmaWxlIiwiTGluZSIsIlN0YXR1cyIsInN0YXR1cyIsIlJlYXNvbiIsInJlYXNvbiIsInF1aWNrRml4IiwiZm91bmRWZXJzaW9uIiwiYmFzZWxpbmVSZXF1aXJlZCIsImxpbmUiLCJ0b1N0cmluZyIsImlzc3VlIiwidW5wYXJzZSIsInNldFRpbWVvdXQiLCJybVN5bmMiLCJmb3JjZSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJnZXRTdG9yZWRBbmFseXNpcyIsImZvcm1hdCIsImZpbGVQYXRoIiwicmVhZEZpbGVTeW5jIiwiY29udGVudCIsImFuYWx5c2lzRXhpc3RzIiwiY2xlYW51cE9sZEFuYWx5c2VzIiwibWF4QWdlIiwiY2xlYW5lZENvdW50IiwicmVhZGRpclN5bmMiLCJzdGF0U3luYyIsImVudHJpZXMiLCJ3aXRoRmlsZVR5cGVzIiwiZW50cnkiLCJpc0RpcmVjdG9yeSIsIm5hbWUiLCJzdGF0cyIsImFnZSIsIkRhdGUiLCJub3ciLCJtdGltZSIsImdldFRpbWUiLCJnZXRBbmFseXNpc01ldGFkYXRhIiwiY3JlYXRlZEF0IiwiYmlydGh0aW1lIiwic2l6ZSIsImxpc3RTdG9yZWRBbmFseXNlcyIsImZpbHRlciIsIm1hcCIsImRlbGV0ZUFuYWx5c2lzIiwiZ2V0U3RvcmFnZVN0YXRzIiwidG90YWxBbmFseXNlcyIsInRvdGFsU2l6ZSIsIm9sZGVzdEFuYWx5c2lzIiwibmV3ZXN0QW5hbHlzaXMiLCJhbmFseXNlcyIsIm9sZGVzdERhdGUiLCJuZXdlc3REYXRlIiwiYW5hbHlzaXMiLCJsZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/files/store.ts\n");

/***/ }),

/***/ "(rsc)/./lib/files/unzip.ts":
/*!****************************!*\
  !*** ./lib/files/unzip.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractZip: () => (/* binding */ extractZip),\n/* harmony export */   extractZipToMemory: () => (/* binding */ extractZipToMemory),\n/* harmony export */   getZipInfo: () => (/* binding */ getZipInfo),\n/* harmony export */   validateZip: () => (/* binding */ validateZip)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var stream_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream/promises */ \"stream/promises\");\n/* harmony import */ var stream_promises__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(stream_promises__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var unzipper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unzipper */ \"(rsc)/./node_modules/unzipper/unzip.js\");\n\n\n\n\n/**\r\n * Securely extract ZIP file contents\r\n * @param zipPath Path to ZIP file\r\n * @param extractPath Path to extract to\r\n * @param options Extraction options\r\n * @returns Extraction result\r\n */ async function extractZip(zipPath, extractPath, options = {}) {\n    const { maxFiles = 50000, maxFileSize = 10 * 1024 * 1024, allowedExtensions = [\n        '.py',\n        '.js',\n        '.ts',\n        '.tsx',\n        '.jsx',\n        '.java',\n        '.go',\n        '.cs',\n        '.fs',\n        '.vb'\n    ], ignorePaths = [\n        '/node_modules/',\n        '/.venv/',\n        '/venv/',\n        '/dist/',\n        '/build/',\n        '/.git/',\n        '/.next/'\n    ] } = options;\n    const files = [];\n    const errors = [];\n    let totalFiles = 0;\n    let skippedFiles = 0;\n    try {\n        // Create extract directory\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(extractPath)) {\n            (0,fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync)(extractPath, {\n                recursive: true\n            });\n        }\n        // Open ZIP file\n        const zip = unzipper__WEBPACK_IMPORTED_MODULE_3__.Open.file(zipPath);\n        const directory = await zip;\n        // Process each entry\n        for (const entry of directory.files){\n            totalFiles++;\n            // Check file count limit\n            if (totalFiles > maxFiles) {\n                errors.push(`Too many files in archive (limit: ${maxFiles})`);\n                break;\n            }\n            // Skip directories\n            if (entry.type === 'Directory') {\n                continue;\n            }\n            // Validate file path\n            const filePath = (0,path__WEBPACK_IMPORTED_MODULE_1__.normalize)(entry.path);\n            if (!isValidPath(filePath, extractPath)) {\n                errors.push(`Invalid file path: ${filePath}`);\n                skippedFiles++;\n                continue;\n            }\n            // Check if path should be ignored\n            if (shouldIgnorePath(filePath, ignorePaths)) {\n                skippedFiles++;\n                continue;\n            }\n            // Check file extension\n            const extension = getFileExtension(filePath);\n            if (allowedExtensions.length > 0 && !allowedExtensions.includes(extension)) {\n                skippedFiles++;\n                continue;\n            }\n            // Check file size\n            if (entry.uncompressedSize > maxFileSize) {\n                errors.push(`File too large: ${filePath} (${entry.uncompressedSize} bytes)`);\n                skippedFiles++;\n                continue;\n            }\n            try {\n                // Extract file\n                const fullPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(extractPath, filePath);\n                const dir = (0,path__WEBPACK_IMPORTED_MODULE_1__.dirname)(fullPath);\n                if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(dir)) {\n                    (0,fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync)(dir, {\n                        recursive: true\n                    });\n                }\n                await (0,stream_promises__WEBPACK_IMPORTED_MODULE_2__.pipeline)(entry.stream(), (0,fs__WEBPACK_IMPORTED_MODULE_0__.createWriteStream)(fullPath));\n                // Read file content for analysis\n                const content = await readFileContent(fullPath);\n                if (content !== null) {\n                    files.push({\n                        path: filePath,\n                        content,\n                        size: content.length,\n                        language: detectLanguageFromExtension(extension)\n                    });\n                }\n            } catch (error) {\n                errors.push(`Failed to extract ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n                skippedFiles++;\n            }\n        }\n    } catch (error) {\n        errors.push(`Failed to open ZIP file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n    return {\n        files,\n        totalFiles,\n        skippedFiles,\n        errors\n    };\n}\n/**\r\n * Validate file path for security\r\n * @param filePath File path\r\n * @param extractPath Base extraction path\r\n * @returns True if path is valid\r\n */ function isValidPath(filePath, extractPath) {\n    try {\n        // Normalize path\n        const normalized = (0,path__WEBPACK_IMPORTED_MODULE_1__.normalize)(filePath);\n        // Check for path traversal\n        if (normalized.includes('..') || normalized.startsWith('/')) {\n            return false;\n        }\n        // Check if path is within extract directory\n        const fullPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.resolve)(extractPath, normalized);\n        const basePath = (0,path__WEBPACK_IMPORTED_MODULE_1__.resolve)(extractPath);\n        return fullPath.startsWith(basePath);\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Check if path should be ignored\r\n * @param filePath File path\r\n * @param ignorePaths Array of paths to ignore\r\n * @returns True if should be ignored\r\n */ function shouldIgnorePath(filePath, ignorePaths) {\n    return ignorePaths.some((ignorePath)=>filePath.includes(ignorePath) || filePath.startsWith(ignorePath));\n}\n/**\r\n * Get file extension from path\r\n * @param filePath File path\r\n * @returns File extension with dot\r\n */ function getFileExtension(filePath) {\n    const lastDot = filePath.lastIndexOf('.');\n    if (lastDot === -1) return '';\n    return filePath.substring(lastDot);\n}\n/**\r\n * Detect language from file extension\r\n * @param extension File extension\r\n * @returns Language or undefined\r\n */ function detectLanguageFromExtension(extension) {\n    const languageMap = {\n        '.js': 'node',\n        '.jsx': 'node',\n        '.ts': 'node',\n        '.tsx': 'node',\n        '.py': 'python',\n        '.java': 'java',\n        '.go': 'go',\n        '.cs': 'dotnet',\n        '.fs': 'dotnet',\n        '.vb': 'dotnet'\n    };\n    return languageMap[extension];\n}\n/**\r\n * Read file content safely\r\n * @param filePath File path\r\n * @returns File content or null if error\r\n */ async function readFileContent(filePath) {\n    try {\n        const stats = (0,fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(filePath);\n        // Skip very large files\n        if (stats.size > 2 * 1024 * 1024) {\n            return null;\n        }\n        // Read file content\n        const content = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23)).then((fs)=>fs.promises.readFile(filePath, 'utf8'));\n        return content;\n    } catch (error) {\n        console.warn(`Failed to read file ${filePath}: ${error}`);\n        return null;\n    }\n}\n/**\r\n * Extract ZIP to memory (for small archives)\r\n * @param zipPath Path to ZIP file\r\n * @param options Extraction options\r\n * @returns Extraction result\r\n */ async function extractZipToMemory(zipPath, options = {}) {\n    const { maxFiles = 50000, maxFileSize = 2 * 1024 * 1024, allowedExtensions = [\n        '.py',\n        '.js',\n        '.ts',\n        '.tsx',\n        '.jsx',\n        '.java',\n        '.go',\n        '.cs',\n        '.fs',\n        '.vb'\n    ], ignorePaths = [\n        '/node_modules/',\n        '/.venv/',\n        '/venv/',\n        '/dist/',\n        '/build/',\n        '/.git/',\n        '/.next/'\n    ] } = options;\n    const files = [];\n    const errors = [];\n    let totalFiles = 0;\n    let skippedFiles = 0;\n    try {\n        // Open ZIP file\n        const zip = unzipper__WEBPACK_IMPORTED_MODULE_3__.Open.file(zipPath);\n        const directory = await zip;\n        // Process each entry\n        for (const entry of directory.files){\n            totalFiles++;\n            // Check file count limit\n            if (totalFiles > maxFiles) {\n                errors.push(`Too many files in archive (limit: ${maxFiles})`);\n                break;\n            }\n            // Skip directories\n            if (entry.type === 'Directory') {\n                continue;\n            }\n            // Validate file path\n            const filePath = (0,path__WEBPACK_IMPORTED_MODULE_1__.normalize)(entry.path);\n            if (!isValidPath(filePath, '/')) {\n                errors.push(`Invalid file path: ${filePath}`);\n                skippedFiles++;\n                continue;\n            }\n            // Check if path should be ignored\n            if (shouldIgnorePath(filePath, ignorePaths)) {\n                skippedFiles++;\n                continue;\n            }\n            // Check file extension\n            const extension = getFileExtension(filePath);\n            if (allowedExtensions.length > 0 && !allowedExtensions.includes(extension)) {\n                skippedFiles++;\n                continue;\n            }\n            // Check file size\n            if (entry.uncompressedSize > maxFileSize) {\n                errors.push(`File too large: ${filePath} (${entry.uncompressedSize} bytes)`);\n                skippedFiles++;\n                continue;\n            }\n            try {\n                // Read file content\n                const content = await entry.buffer();\n                const contentString = content.toString('utf8');\n                files.push({\n                    path: filePath,\n                    content: contentString,\n                    size: contentString.length,\n                    language: detectLanguageFromExtension(extension)\n                });\n            } catch (error) {\n                errors.push(`Failed to read ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n                skippedFiles++;\n            }\n        }\n    } catch (error) {\n        errors.push(`Failed to open ZIP file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n    return {\n        files,\n        totalFiles,\n        skippedFiles,\n        errors\n    };\n}\n/**\r\n * Get ZIP file information\r\n * @param zipPath Path to ZIP file\r\n * @returns ZIP file info\r\n */ async function getZipInfo(zipPath) {\n    try {\n        const zip = unzipper__WEBPACK_IMPORTED_MODULE_3__.Open.file(zipPath);\n        const directory = await zip;\n        let totalSize = 0;\n        let compressedSize = 0;\n        const files = [];\n        for (const entry of directory.files){\n            if (entry.type !== 'Directory') {\n                totalSize += entry.uncompressedSize;\n                compressedSize += entry.compressedSize;\n                files.push({\n                    path: entry.path,\n                    size: entry.uncompressedSize,\n                    compressedSize: entry.compressedSize\n                });\n            }\n        }\n        return {\n            totalFiles: files.length,\n            totalSize,\n            compressedSize,\n            files\n        };\n    } catch (error) {\n        throw new Error(`Failed to read ZIP info: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\r\n * Validate ZIP file\r\n * @param zipPath Path to ZIP file\r\n * @returns True if valid ZIP\r\n */ async function validateZip(zipPath) {\n    try {\n        const zip = unzipper__WEBPACK_IMPORTED_MODULE_3__.Open.file(zipPath);\n        await zip;\n        return true;\n    } catch  {\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWlCQyxRQUFRRCxNQUFNRSxPQUFPLEdBQUcsaUJBQWlCO0lBQ3hHO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sZUFBZXdCLFlBQVk5RCxPQUFlO0lBQy9DLElBQUk7UUFDRixNQUFNWSxNQUFNZCwrQ0FBa0IsQ0FBQ0U7UUFDL0IsTUFBTVk7UUFDTixPQUFPO0lBQ1QsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcZmlsZXNcXHVuemlwLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVdyaXRlU3RyZWFtLCBta2RpclN5bmMsIHN0YXRTeW5jLCBleGlzdHNTeW5jIH0gZnJvbSAnZnMnO1xyXG5pbXBvcnQgeyBqb2luLCBkaXJuYW1lLCByZXNvbHZlLCBub3JtYWxpemUgfSBmcm9tICdwYXRoJztcclxuaW1wb3J0IHsgcGlwZWxpbmUgfSBmcm9tICdzdHJlYW0vcHJvbWlzZXMnO1xyXG5pbXBvcnQgdW56aXBwZXIgZnJvbSAndW56aXBwZXInO1xyXG5pbXBvcnQgeyBFeHRyYWN0ZWRGaWxlIH0gZnJvbSAnLi4vYW5hbHlzaXMvYmFzZWxpbmUudHlwZXMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVbnppcE9wdGlvbnMge1xyXG4gIG1heEZpbGVzPzogbnVtYmVyO1xyXG4gIG1heEZpbGVTaXplPzogbnVtYmVyO1xyXG4gIGFsbG93ZWRFeHRlbnNpb25zPzogc3RyaW5nW107XHJcbiAgaWdub3JlUGF0aHM/OiBzdHJpbmdbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVbnppcFJlc3VsdCB7XHJcbiAgZmlsZXM6IEV4dHJhY3RlZEZpbGVbXTtcclxuICB0b3RhbEZpbGVzOiBudW1iZXI7XHJcbiAgc2tpcHBlZEZpbGVzOiBudW1iZXI7XHJcbiAgZXJyb3JzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlY3VyZWx5IGV4dHJhY3QgWklQIGZpbGUgY29udGVudHNcclxuICogQHBhcmFtIHppcFBhdGggUGF0aCB0byBaSVAgZmlsZVxyXG4gKiBAcGFyYW0gZXh0cmFjdFBhdGggUGF0aCB0byBleHRyYWN0IHRvXHJcbiAqIEBwYXJhbSBvcHRpb25zIEV4dHJhY3Rpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyBFeHRyYWN0aW9uIHJlc3VsdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RaaXAoXHJcbiAgemlwUGF0aDogc3RyaW5nLFxyXG4gIGV4dHJhY3RQYXRoOiBzdHJpbmcsXHJcbiAgb3B0aW9uczogVW56aXBPcHRpb25zID0ge31cclxuKTogUHJvbWlzZTxVbnppcFJlc3VsdD4ge1xyXG4gIGNvbnN0IHtcclxuICAgIG1heEZpbGVzID0gNTAwMDAsXHJcbiAgICBtYXhGaWxlU2l6ZSA9IDEwICogMTAyNCAqIDEwMjQsIC8vIDEwTUJcclxuICAgIGFsbG93ZWRFeHRlbnNpb25zID0gWycucHknLCAnLmpzJywgJy50cycsICcudHN4JywgJy5qc3gnLCAnLmphdmEnLCAnLmdvJywgJy5jcycsICcuZnMnLCAnLnZiJ10sXHJcbiAgICBpZ25vcmVQYXRocyA9IFsnL25vZGVfbW9kdWxlcy8nLCAnLy52ZW52LycsICcvdmVudi8nLCAnL2Rpc3QvJywgJy9idWlsZC8nLCAnLy5naXQvJywgJy8ubmV4dC8nXVxyXG4gIH0gPSBvcHRpb25zO1xyXG5cclxuICBjb25zdCBmaWxlczogRXh0cmFjdGVkRmlsZVtdID0gW107XHJcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGxldCB0b3RhbEZpbGVzID0gMDtcclxuICBsZXQgc2tpcHBlZEZpbGVzID0gMDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIENyZWF0ZSBleHRyYWN0IGRpcmVjdG9yeVxyXG4gICAgaWYgKCFleGlzdHNTeW5jKGV4dHJhY3RQYXRoKSkge1xyXG4gICAgICBta2RpclN5bmMoZXh0cmFjdFBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9wZW4gWklQIGZpbGVcclxuICAgIGNvbnN0IHppcCA9IHVuemlwcGVyLk9wZW4uZmlsZSh6aXBQYXRoKTtcclxuICAgIGNvbnN0IGRpcmVjdG9yeSA9IGF3YWl0IHppcDtcclxuXHJcbiAgICAvLyBQcm9jZXNzIGVhY2ggZW50cnlcclxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZGlyZWN0b3J5LmZpbGVzKSB7XHJcbiAgICAgIHRvdGFsRmlsZXMrKztcclxuXHJcbiAgICAgIC8vIENoZWNrIGZpbGUgY291bnQgbGltaXRcclxuICAgICAgaWYgKHRvdGFsRmlsZXMgPiBtYXhGaWxlcykge1xyXG4gICAgICAgIGVycm9ycy5wdXNoKGBUb28gbWFueSBmaWxlcyBpbiBhcmNoaXZlIChsaW1pdDogJHttYXhGaWxlc30pYCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNraXAgZGlyZWN0b3JpZXNcclxuICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdEaXJlY3RvcnknKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFZhbGlkYXRlIGZpbGUgcGF0aFxyXG4gICAgICBjb25zdCBmaWxlUGF0aCA9IG5vcm1hbGl6ZShlbnRyeS5wYXRoKTtcclxuICAgICAgaWYgKCFpc1ZhbGlkUGF0aChmaWxlUGF0aCwgZXh0cmFjdFBhdGgpKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYEludmFsaWQgZmlsZSBwYXRoOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICAgIHNraXBwZWRGaWxlcysrO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBwYXRoIHNob3VsZCBiZSBpZ25vcmVkXHJcbiAgICAgIGlmIChzaG91bGRJZ25vcmVQYXRoKGZpbGVQYXRoLCBpZ25vcmVQYXRocykpIHtcclxuICAgICAgICBza2lwcGVkRmlsZXMrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZmlsZSBleHRlbnNpb25cclxuICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XHJcbiAgICAgIGlmIChhbGxvd2VkRXh0ZW5zaW9ucy5sZW5ndGggPiAwICYmICFhbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhleHRlbnNpb24pKSB7XHJcbiAgICAgICAgc2tpcHBlZEZpbGVzKys7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZpbGUgc2l6ZVxyXG4gICAgICBpZiAoZW50cnkudW5jb21wcmVzc2VkU2l6ZSA+IG1heEZpbGVTaXplKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYEZpbGUgdG9vIGxhcmdlOiAke2ZpbGVQYXRofSAoJHtlbnRyeS51bmNvbXByZXNzZWRTaXplfSBieXRlcylgKTtcclxuICAgICAgICBza2lwcGVkRmlsZXMrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBFeHRyYWN0IGZpbGVcclxuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IGpvaW4oZXh0cmFjdFBhdGgsIGZpbGVQYXRoKTtcclxuICAgICAgICBjb25zdCBkaXIgPSBkaXJuYW1lKGZ1bGxQYXRoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWV4aXN0c1N5bmMoZGlyKSkge1xyXG4gICAgICAgICAgbWtkaXJTeW5jKGRpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhd2FpdCBwaXBlbGluZShcclxuICAgICAgICAgIGVudHJ5LnN0cmVhbSgpLFxyXG4gICAgICAgICAgY3JlYXRlV3JpdGVTdHJlYW0oZnVsbFBhdGgpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gUmVhZCBmaWxlIGNvbnRlbnQgZm9yIGFuYWx5c2lzXHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlYWRGaWxlQ29udGVudChmdWxsUGF0aCk7XHJcbiAgICAgICAgaWYgKGNvbnRlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgIGZpbGVzLnB1c2goe1xyXG4gICAgICAgICAgICBwYXRoOiBmaWxlUGF0aCxcclxuICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgc2l6ZTogY29udGVudC5sZW5ndGgsXHJcbiAgICAgICAgICAgIGxhbmd1YWdlOiBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBlcnJvcnMucHVzaChgRmFpbGVkIHRvIGV4dHJhY3QgJHtmaWxlUGF0aH06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgICAgICAgc2tpcHBlZEZpbGVzKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgZXJyb3JzLnB1c2goYEZhaWxlZCB0byBvcGVuIFpJUCBmaWxlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGZpbGVzLFxyXG4gICAgdG90YWxGaWxlcyxcclxuICAgIHNraXBwZWRGaWxlcyxcclxuICAgIGVycm9ycyxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgZmlsZSBwYXRoIGZvciBzZWN1cml0eVxyXG4gKiBAcGFyYW0gZmlsZVBhdGggRmlsZSBwYXRoXHJcbiAqIEBwYXJhbSBleHRyYWN0UGF0aCBCYXNlIGV4dHJhY3Rpb24gcGF0aFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHBhdGggaXMgdmFsaWRcclxuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRQYXRoKGZpbGVQYXRoOiBzdHJpbmcsIGV4dHJhY3RQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICB0cnkge1xyXG4gICAgLy8gTm9ybWFsaXplIHBhdGhcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemUoZmlsZVBhdGgpO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBmb3IgcGF0aCB0cmF2ZXJzYWxcclxuICAgIGlmIChub3JtYWxpemVkLmluY2x1ZGVzKCcuLicpIHx8IG5vcm1hbGl6ZWQuc3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgcGF0aCBpcyB3aXRoaW4gZXh0cmFjdCBkaXJlY3RvcnlcclxuICAgIGNvbnN0IGZ1bGxQYXRoID0gcmVzb2x2ZShleHRyYWN0UGF0aCwgbm9ybWFsaXplZCk7XHJcbiAgICBjb25zdCBiYXNlUGF0aCA9IHJlc29sdmUoZXh0cmFjdFBhdGgpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZnVsbFBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgcGF0aCBzaG91bGQgYmUgaWdub3JlZFxyXG4gKiBAcGFyYW0gZmlsZVBhdGggRmlsZSBwYXRoXHJcbiAqIEBwYXJhbSBpZ25vcmVQYXRocyBBcnJheSBvZiBwYXRocyB0byBpZ25vcmVcclxuICogQHJldHVybnMgVHJ1ZSBpZiBzaG91bGQgYmUgaWdub3JlZFxyXG4gKi9cclxuZnVuY3Rpb24gc2hvdWxkSWdub3JlUGF0aChmaWxlUGF0aDogc3RyaW5nLCBpZ25vcmVQYXRoczogc3RyaW5nW10pOiBib29sZWFuIHtcclxuICByZXR1cm4gaWdub3JlUGF0aHMuc29tZShpZ25vcmVQYXRoID0+IFxyXG4gICAgZmlsZVBhdGguaW5jbHVkZXMoaWdub3JlUGF0aCkgfHwgZmlsZVBhdGguc3RhcnRzV2l0aChpZ25vcmVQYXRoKVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZmlsZSBleHRlbnNpb24gZnJvbSBwYXRoXHJcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcclxuICogQHJldHVybnMgRmlsZSBleHRlbnNpb24gd2l0aCBkb3RcclxuICovXHJcbmZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgbGFzdERvdCA9IGZpbGVQYXRoLmxhc3RJbmRleE9mKCcuJyk7XHJcbiAgaWYgKGxhc3REb3QgPT09IC0xKSByZXR1cm4gJyc7XHJcbiAgcmV0dXJuIGZpbGVQYXRoLnN1YnN0cmluZyhsYXN0RG90KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVjdCBsYW5ndWFnZSBmcm9tIGZpbGUgZXh0ZW5zaW9uXHJcbiAqIEBwYXJhbSBleHRlbnNpb24gRmlsZSBleHRlbnNpb25cclxuICogQHJldHVybnMgTGFuZ3VhZ2Ugb3IgdW5kZWZpbmVkXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uOiBzdHJpbmcpOiAncHl0aG9uJyB8ICdub2RlJyB8ICdqYXZhJyB8ICdnbycgfCAnZG90bmV0JyB8IHVuZGVmaW5lZCB7XHJcbiAgY29uc3QgbGFuZ3VhZ2VNYXA6IFJlY29yZDxzdHJpbmcsICdweXRob24nIHwgJ25vZGUnIHwgJ2phdmEnIHwgJ2dvJyB8ICdkb3RuZXQnPiA9IHtcclxuICAgICcuanMnOiAnbm9kZScsXHJcbiAgICAnLmpzeCc6ICdub2RlJyxcclxuICAgICcudHMnOiAnbm9kZScsXHJcbiAgICAnLnRzeCc6ICdub2RlJyxcclxuICAgICcucHknOiAncHl0aG9uJyxcclxuICAgICcuamF2YSc6ICdqYXZhJyxcclxuICAgICcuZ28nOiAnZ28nLFxyXG4gICAgJy5jcyc6ICdkb3RuZXQnLFxyXG4gICAgJy5mcyc6ICdkb3RuZXQnLFxyXG4gICAgJy52Yic6ICdkb3RuZXQnLFxyXG4gIH07XHJcbiAgXHJcbiAgcmV0dXJuIGxhbmd1YWdlTWFwW2V4dGVuc2lvbl07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWFkIGZpbGUgY29udGVudCBzYWZlbHlcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aFxyXG4gKiBAcmV0dXJucyBGaWxlIGNvbnRlbnQgb3IgbnVsbCBpZiBlcnJvclxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGVDb250ZW50KGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhmaWxlUGF0aCk7XHJcbiAgICBcclxuICAgIC8vIFNraXAgdmVyeSBsYXJnZSBmaWxlc1xyXG4gICAgaWYgKHN0YXRzLnNpemUgPiAyICogMTAyNCAqIDEwMjQpIHsgLy8gMk1CXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBSZWFkIGZpbGUgY29udGVudFxyXG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IGltcG9ydCgnZnMnKS50aGVuKGZzID0+IGZzLnByb21pc2VzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpKTtcclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byByZWFkIGZpbGUgJHtmaWxlUGF0aH06ICR7ZXJyb3J9YCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IFpJUCB0byBtZW1vcnkgKGZvciBzbWFsbCBhcmNoaXZlcylcclxuICogQHBhcmFtIHppcFBhdGggUGF0aCB0byBaSVAgZmlsZVxyXG4gKiBAcGFyYW0gb3B0aW9ucyBFeHRyYWN0aW9uIG9wdGlvbnNcclxuICogQHJldHVybnMgRXh0cmFjdGlvbiByZXN1bHRcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHRyYWN0WmlwVG9NZW1vcnkoXHJcbiAgemlwUGF0aDogc3RyaW5nLFxyXG4gIG9wdGlvbnM6IFVuemlwT3B0aW9ucyA9IHt9XHJcbik6IFByb21pc2U8VW56aXBSZXN1bHQ+IHtcclxuICBjb25zdCB7XHJcbiAgICBtYXhGaWxlcyA9IDUwMDAwLFxyXG4gICAgbWF4RmlsZVNpemUgPSAyICogMTAyNCAqIDEwMjQsIC8vIDJNQlxyXG4gICAgYWxsb3dlZEV4dGVuc2lvbnMgPSBbJy5weScsICcuanMnLCAnLnRzJywgJy50c3gnLCAnLmpzeCcsICcuamF2YScsICcuZ28nLCAnLmNzJywgJy5mcycsICcudmInXSxcclxuICAgIGlnbm9yZVBhdGhzID0gWycvbm9kZV9tb2R1bGVzLycsICcvLnZlbnYvJywgJy92ZW52LycsICcvZGlzdC8nLCAnL2J1aWxkLycsICcvLmdpdC8nLCAnLy5uZXh0LyddXHJcbiAgfSA9IG9wdGlvbnM7XHJcblxyXG4gIGNvbnN0IGZpbGVzOiBFeHRyYWN0ZWRGaWxlW10gPSBbXTtcclxuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XHJcbiAgbGV0IHRvdGFsRmlsZXMgPSAwO1xyXG4gIGxldCBza2lwcGVkRmlsZXMgPSAwO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gT3BlbiBaSVAgZmlsZVxyXG4gICAgY29uc3QgemlwID0gdW56aXBwZXIuT3Blbi5maWxlKHppcFBhdGgpO1xyXG4gICAgY29uc3QgZGlyZWN0b3J5ID0gYXdhaXQgemlwO1xyXG5cclxuICAgIC8vIFByb2Nlc3MgZWFjaCBlbnRyeVxyXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBkaXJlY3RvcnkuZmlsZXMpIHtcclxuICAgICAgdG90YWxGaWxlcysrO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgZmlsZSBjb3VudCBsaW1pdFxyXG4gICAgICBpZiAodG90YWxGaWxlcyA+IG1heEZpbGVzKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYFRvbyBtYW55IGZpbGVzIGluIGFyY2hpdmUgKGxpbWl0OiAke21heEZpbGVzfSlgKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2tpcCBkaXJlY3Rvcmllc1xyXG4gICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ0RpcmVjdG9yeScpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVmFsaWRhdGUgZmlsZSBwYXRoXHJcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gbm9ybWFsaXplKGVudHJ5LnBhdGgpO1xyXG4gICAgICBpZiAoIWlzVmFsaWRQYXRoKGZpbGVQYXRoLCAnLycpKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYEludmFsaWQgZmlsZSBwYXRoOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICAgIHNraXBwZWRGaWxlcysrO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBwYXRoIHNob3VsZCBiZSBpZ25vcmVkXHJcbiAgICAgIGlmIChzaG91bGRJZ25vcmVQYXRoKGZpbGVQYXRoLCBpZ25vcmVQYXRocykpIHtcclxuICAgICAgICBza2lwcGVkRmlsZXMrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZmlsZSBleHRlbnNpb25cclxuICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XHJcbiAgICAgIGlmIChhbGxvd2VkRXh0ZW5zaW9ucy5sZW5ndGggPiAwICYmICFhbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhleHRlbnNpb24pKSB7XHJcbiAgICAgICAgc2tpcHBlZEZpbGVzKys7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZpbGUgc2l6ZVxyXG4gICAgICBpZiAoZW50cnkudW5jb21wcmVzc2VkU2l6ZSA+IG1heEZpbGVTaXplKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYEZpbGUgdG9vIGxhcmdlOiAke2ZpbGVQYXRofSAoJHtlbnRyeS51bmNvbXByZXNzZWRTaXplfSBieXRlcylgKTtcclxuICAgICAgICBza2lwcGVkRmlsZXMrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBSZWFkIGZpbGUgY29udGVudFxyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBlbnRyeS5idWZmZXIoKTtcclxuICAgICAgICBjb25zdCBjb250ZW50U3RyaW5nID0gY29udGVudC50b1N0cmluZygndXRmOCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZpbGVzLnB1c2goe1xyXG4gICAgICAgICAgcGF0aDogZmlsZVBhdGgsXHJcbiAgICAgICAgICBjb250ZW50OiBjb250ZW50U3RyaW5nLFxyXG4gICAgICAgICAgc2l6ZTogY29udGVudFN0cmluZy5sZW5ndGgsXHJcbiAgICAgICAgICBsYW5ndWFnZTogZGV0ZWN0TGFuZ3VhZ2VGcm9tRXh0ZW5zaW9uKGV4dGVuc2lvbiksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goYEZhaWxlZCB0byByZWFkICR7ZmlsZVBhdGh9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gICAgICAgIHNraXBwZWRGaWxlcysrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGVycm9ycy5wdXNoKGBGYWlsZWQgdG8gb3BlbiBaSVAgZmlsZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBmaWxlcyxcclxuICAgIHRvdGFsRmlsZXMsXHJcbiAgICBza2lwcGVkRmlsZXMsXHJcbiAgICBlcnJvcnMsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBaSVAgZmlsZSBpbmZvcm1hdGlvblxyXG4gKiBAcGFyYW0gemlwUGF0aCBQYXRoIHRvIFpJUCBmaWxlXHJcbiAqIEByZXR1cm5zIFpJUCBmaWxlIGluZm9cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRaaXBJbmZvKHppcFBhdGg6IHN0cmluZyk6IFByb21pc2U8e1xyXG4gIHRvdGFsRmlsZXM6IG51bWJlcjtcclxuICB0b3RhbFNpemU6IG51bWJlcjtcclxuICBjb21wcmVzc2VkU2l6ZTogbnVtYmVyO1xyXG4gIGZpbGVzOiBBcnJheTx7IHBhdGg6IHN0cmluZzsgc2l6ZTogbnVtYmVyOyBjb21wcmVzc2VkU2l6ZTogbnVtYmVyIH0+O1xyXG59PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHppcCA9IHVuemlwcGVyLk9wZW4uZmlsZSh6aXBQYXRoKTtcclxuICAgIGNvbnN0IGRpcmVjdG9yeSA9IGF3YWl0IHppcDtcclxuICAgIFxyXG4gICAgbGV0IHRvdGFsU2l6ZSA9IDA7XHJcbiAgICBsZXQgY29tcHJlc3NlZFNpemUgPSAwO1xyXG4gICAgY29uc3QgZmlsZXM6IEFycmF5PHsgcGF0aDogc3RyaW5nOyBzaXplOiBudW1iZXI7IGNvbXByZXNzZWRTaXplOiBudW1iZXIgfT4gPSBbXTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBkaXJlY3RvcnkuZmlsZXMpIHtcclxuICAgICAgaWYgKGVudHJ5LnR5cGUgIT09ICdEaXJlY3RvcnknKSB7XHJcbiAgICAgICAgdG90YWxTaXplICs9IGVudHJ5LnVuY29tcHJlc3NlZFNpemU7XHJcbiAgICAgICAgY29tcHJlc3NlZFNpemUgKz0gZW50cnkuY29tcHJlc3NlZFNpemU7XHJcbiAgICAgICAgZmlsZXMucHVzaCh7XHJcbiAgICAgICAgICBwYXRoOiBlbnRyeS5wYXRoLFxyXG4gICAgICAgICAgc2l6ZTogZW50cnkudW5jb21wcmVzc2VkU2l6ZSxcclxuICAgICAgICAgIGNvbXByZXNzZWRTaXplOiBlbnRyeS5jb21wcmVzc2VkU2l6ZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbEZpbGVzOiBmaWxlcy5sZW5ndGgsXHJcbiAgICAgIHRvdGFsU2l6ZSxcclxuICAgICAgY29tcHJlc3NlZFNpemUsXHJcbiAgICAgIGZpbGVzLFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVhZCBaSVAgaW5mbzogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBaSVAgZmlsZVxyXG4gKiBAcGFyYW0gemlwUGF0aCBQYXRoIHRvIFpJUCBmaWxlXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdmFsaWQgWklQXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVaaXAoemlwUGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHppcCA9IHVuemlwcGVyLk9wZW4uZmlsZSh6aXBQYXRoKTtcclxuICAgIGF3YWl0IHppcDtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiY3JlYXRlV3JpdGVTdHJlYW0iLCJta2RpclN5bmMiLCJzdGF0U3luYyIsImV4aXN0c1N5bmMiLCJqb2luIiwiZGlybmFtZSIsInJlc29sdmUiLCJub3JtYWxpemUiLCJwaXBlbGluZSIsInVuemlwcGVyIiwiZXh0cmFjdFppcCIsInppcFBhdGgiLCJleHRyYWN0UGF0aCIsIm9wdGlvbnMiLCJtYXhGaWxlcyIsIm1heEZpbGVTaXplIiwiYWxsb3dlZEV4dGVuc2lvbnMiLCJpZ25vcmVQYXRocyIsImZpbGVzIiwiZXJyb3JzIiwidG90YWxGaWxlcyIsInNraXBwZWRGaWxlcyIsInJlY3Vyc2l2ZSIsInppcCIsIk9wZW4iLCJmaWxlIiwiZGlyZWN0b3J5IiwiZW50cnkiLCJwdXNoIiwidHlwZSIsImZpbGVQYXRoIiwicGF0aCIsImlzVmFsaWRQYXRoIiwic2hvdWxkSWdub3JlUGF0aCIsImV4dGVuc2lvbiIsImdldEZpbGVFeHRlbnNpb24iLCJsZW5ndGgiLCJpbmNsdWRlcyIsInVuY29tcHJlc3NlZFNpemUiLCJmdWxsUGF0aCIsImRpciIsInN0cmVhbSIsImNvbnRlbnQiLCJyZWFkRmlsZUNvbnRlbnQiLCJzaXplIiwibGFuZ3VhZ2UiLCJkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24iLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsIm5vcm1hbGl6ZWQiLCJzdGFydHNXaXRoIiwiYmFzZVBhdGgiLCJzb21lIiwiaWdub3JlUGF0aCIsImxhc3REb3QiLCJsYXN0SW5kZXhPZiIsInN1YnN0cmluZyIsImxhbmd1YWdlTWFwIiwic3RhdHMiLCJ0aGVuIiwiZnMiLCJwcm9taXNlcyIsInJlYWRGaWxlIiwiY29uc29sZSIsIndhcm4iLCJleHRyYWN0WmlwVG9NZW1vcnkiLCJidWZmZXIiLCJjb250ZW50U3RyaW5nIiwidG9TdHJpbmciLCJnZXRaaXBJbmZvIiwidG90YWxTaXplIiwiY29tcHJlc3NlZFNpemUiLCJ2YWxpZGF0ZVppcCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/files/unzip.ts\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fanalyze%2Froute&page=%2Fapi%2Fanalyze%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze%2Froute.ts&appDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fanalyze%2Froute&page=%2Fapi%2Fanalyze%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze%2Froute.ts&appDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/./node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/./node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var C_Users_Ckhadar_Downloads_AI_Baseline_Map_app_api_analyze_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./app/api/analyze/route.ts */ \"(rsc)/./app/api/analyze/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/analyze/route\",\n        pathname: \"/api/analyze\",\n        filename: \"route\",\n        bundlePath: \"app/api/analyze/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"C:\\\\Users\\\\Ckhadar\\\\Downloads\\\\AI_Baseline_Map\\\\app\\\\api\\\\analyze\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_Ckhadar_Downloads_AI_Baseline_Map_app_api_analyze_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/analyze/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZhbmFseXplJTJGcm91dGUmcGFnZT0lMkZhcGklMkZhbmFseXplJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGYW5hbHl6ZSUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNDa2hhZGFyJTVDRG93bmxvYWRzJTVDQUlfQmFzZWxpbmVfTWFwJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1DJTNBJTVDVXNlcnMlNUNDa2hhZGFyJTVDRG93bmxvYWRzJTVDQUlfQmFzZWxpbmVfTWFwJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEJmlzR2xvYmFsTm90Rm91bmRFbmFibGVkPSEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0Y7QUFDdkM7QUFDcUI7QUFDZDtBQUNTO0FBQ087QUFDSztBQUNtQztBQUNqRDtBQUNPO0FBQ2Y7QUFDc0M7QUFDekI7QUFDTTtBQUNDO0FBQ2hCO0FBQ3NDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5R0FBbUI7QUFDM0M7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWEsT0FBb0MsSUFBSSxDQUFFO0FBQ3ZELHdCQUF3QixNQUF1QztBQUMvRDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7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Q0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZFQUE2RSxnRkFBYztBQUMzRixpQ0FBaUMsUUFBUSxFQUFFLFFBQVE7QUFDbkQsMEJBQTBCLHVFQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOLDZCQUE2Qiw2RkFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyRkFBbUI7QUFDckQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkVBQVk7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0IHsgZ2V0UmVxdWVzdE1ldGEgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0LW1ldGFcIjtcbmltcG9ydCB7IGdldFRyYWNlciwgU3BhbktpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvdHJhY2VyXCI7XG5pbXBvcnQgeyBub3JtYWxpemVBcHBQYXRoIH0gZnJvbSBcIm5leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hcHAtcGF0aHNcIjtcbmltcG9ydCB7IE5vZGVOZXh0UmVxdWVzdCwgTm9kZU5leHRSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Jhc2UtaHR0cC9ub2RlXCI7XG5pbXBvcnQgeyBOZXh0UmVxdWVzdEFkYXB0ZXIsIHNpZ25hbEZyb21Ob2RlUmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvbmV4dC1yZXF1ZXN0XCI7XG5pbXBvcnQgeyBCYXNlU2VydmVyU3BhbiB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS9jb25zdGFudHNcIjtcbmltcG9ydCB7IGdldFJldmFsaWRhdGVSZWFzb24gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9pbnN0cnVtZW50YXRpb24vdXRpbHNcIjtcbmltcG9ydCB7IHNlbmRSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3NlbmQtcmVzcG9uc2VcIjtcbmltcG9ydCB7IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycywgdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3dlYi91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0Q2FjaGVDb250cm9sSGVhZGVyIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL2NhY2hlLWNvbnRyb2xcIjtcbmltcG9ydCB7IElORklOSVRFX0NBQ0hFLCBORVhUX0NBQ0hFX1RBR1NfSEVBREVSIH0gZnJvbSBcIm5leHQvZGlzdC9saWIvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBOb0ZhbGxiYWNrRXJyb3IgfSBmcm9tIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvbm8tZmFsbGJhY2stZXJyb3IuZXh0ZXJuYWxcIjtcbmltcG9ydCB7IENhY2hlZFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3Jlc3BvbnNlLWNhY2hlXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiQzpcXFxcVXNlcnNcXFxcQ2toYWRhclxcXFxEb3dubG9hZHNcXFxcQUlfQmFzZWxpbmVfTWFwXFxcXGFwcFxcXFxhcGlcXFxcYW5hbHl6ZVxcXFxyb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvYW5hbHl6ZS9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2FuYWx5emVcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL2FuYWx5emUvcm91dGVcIlxuICAgIH0sXG4gICAgZGlzdERpcjogcHJvY2Vzcy5lbnYuX19ORVhUX1JFTEFUSVZFX0RJU1RfRElSIHx8ICcnLFxuICAgIHJlbGF0aXZlUHJvamVjdERpcjogcHJvY2Vzcy5lbnYuX19ORVhUX1JFTEFUSVZFX1BST0pFQ1RfRElSIHx8ICcnLFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiQzpcXFxcVXNlcnNcXFxcQ2toYWRhclxcXFxEb3dubG9hZHNcXFxcQUlfQmFzZWxpbmVfTWFwXFxcXGFwcFxcXFxhcGlcXFxcYW5hbHl6ZVxcXFxyb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHdvcmtBc3luY1N0b3JhZ2UsIHdvcmtVbml0QXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHdvcmtBc3luY1N0b3JhZ2UsXG4gICAgICAgIHdvcmtVbml0QXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBwYXRjaEZldGNoLCAgfTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzLCBjdHgpIHtcbiAgICB2YXIgX25leHRDb25maWdfZXhwZXJpbWVudGFsO1xuICAgIGxldCBzcmNQYWdlID0gXCIvYXBpL2FuYWx5emUvcm91dGVcIjtcbiAgICAvLyB0dXJib3BhY2sgZG9lc24ndCBub3JtYWxpemUgYC9pbmRleGAgaW4gdGhlIHBhZ2UgbmFtZVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gdG8gcHJvY2VzcyBkeW5hbWljIHJvdXRlcyBwcm9wZXJseVxuICAgIC8vIFRPRE86IGZpeCB0dXJib3BhY2sgcHJvdmlkaW5nIGRpZmZlcmluZyB2YWx1ZSBmcm9tIHdlYnBhY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIHNyY1BhZ2UgPSBzcmNQYWdlLnJlcGxhY2UoL1xcL2luZGV4JC8sICcnKSB8fCAnLyc7XG4gICAgfSBlbHNlIGlmIChzcmNQYWdlID09PSAnL2luZGV4Jykge1xuICAgICAgICAvLyB3ZSBhbHdheXMgbm9ybWFsaXplIC9pbmRleCBzcGVjaWZpY2FsbHlcbiAgICAgICAgc3JjUGFnZSA9ICcvJztcbiAgICB9XG4gICAgY29uc3QgbXVsdGlab25lRHJhZnRNb2RlID0gcHJvY2Vzcy5lbnYuX19ORVhUX01VTFRJX1pPTkVfRFJBRlRfTU9ERTtcbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlLFxuICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGVcbiAgICB9KTtcbiAgICBpZiAoIXByZXBhcmVSZXN1bHQpIHtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgIHJlcy5lbmQoJ0JhZCBSZXF1ZXN0Jyk7XG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVpbGRJZCwgcGFyYW1zLCBuZXh0Q29uZmlnLCBpc0RyYWZ0TW9kZSwgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQsIGlzT25EZW1hbmRSZXZhbGlkYXRlLCByZXZhbGlkYXRlT25seUdlbmVyYXRlZCwgcmVzb2x2ZWRQYXRobmFtZSB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICBjb25zdCBub3JtYWxpemVkU3JjUGFnZSA9IG5vcm1hbGl6ZUFwcFBhdGgoc3JjUGFnZSk7XG4gICAgbGV0IGlzSXNyID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSB8fCBwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgIGlmIChpc0lzciAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY29uc3QgaXNQcmVyZW5kZXJlZCA9IEJvb2xlYW4ocHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW3Jlc29sdmVkUGF0aG5hbWVdKTtcbiAgICAgICAgY29uc3QgcHJlcmVuZGVySW5mbyA9IHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdO1xuICAgICAgICBpZiAocHJlcmVuZGVySW5mbykge1xuICAgICAgICAgICAgaWYgKHByZXJlbmRlckluZm8uZmFsbGJhY2sgPT09IGZhbHNlICYmICFpc1ByZXJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vRmFsbGJhY2tFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjYWNoZUtleSA9IG51bGw7XG4gICAgaWYgKGlzSXNyICYmICFyb3V0ZU1vZHVsZS5pc0RldiAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY2FjaGVLZXkgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAvLyBlbnN1cmUgL2luZGV4IGFuZCAvIGlzIG5vcm1hbGl6ZWQgdG8gb25lIGtleVxuICAgICAgICBjYWNoZUtleSA9IGNhY2hlS2V5ID09PSAnL2luZGV4JyA/ICcvJyA6IGNhY2hlS2V5O1xuICAgIH1cbiAgICBjb25zdCBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSA9IC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50LCB3ZSBhbHdheXMgc3VwcG9ydCBkeW5hbWljIEhUTUxcbiAgICByb3V0ZU1vZHVsZS5pc0RldiA9PT0gdHJ1ZSB8fCAvLyBJZiB0aGlzIGlzIG5vdCBTU0cgb3IgZG9lcyBub3QgaGF2ZSBzdGF0aWMgcGF0aHMsIHRoZW4gaXQgc3VwcG9ydHNcbiAgICAvLyBkeW5hbWljIEhUTUwuXG4gICAgIWlzSXNyO1xuICAgIC8vIFRoaXMgaXMgYSByZXZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWNcbiAgICAvLyBwYWdlIGFuZCBpdCBpcyBub3QgYmVpbmcgcmVzdW1lZCBmcm9tIGEgcG9zdHBvbmVkIHJlbmRlciBhbmRcbiAgICAvLyBpdCBpcyBub3QgYSBkeW5hbWljIFJTQyByZXF1ZXN0IHRoZW4gaXQgaXMgYSByZXZhbGlkYXRpb25cbiAgICAvLyByZXF1ZXN0LlxuICAgIGNvbnN0IGlzUmV2YWxpZGF0ZSA9IGlzSXNyICYmICFzdXBwb3J0c0R5bmFtaWNSZXNwb25zZTtcbiAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsOiB7XG4gICAgICAgICAgICAgICAgY2FjaGVDb21wb25lbnRzOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmNhY2hlQ29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgYXV0aEludGVycnVwdHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuYXV0aEludGVycnVwdHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2UsXG4gICAgICAgICAgICBpbmNyZW1lbnRhbENhY2hlOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbmNyZW1lbnRhbENhY2hlJyksXG4gICAgICAgICAgICBjYWNoZUxpZmVQcm9maWxlczogKF9uZXh0Q29uZmlnX2V4cGVyaW1lbnRhbCA9IG5leHRDb25maWcuZXhwZXJpbWVudGFsKSA9PSBudWxsID8gdm9pZCAwIDogX25leHRDb25maWdfZXhwZXJpbWVudGFsLmNhY2hlTGlmZSxcbiAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbCxcbiAgICAgICAgICAgIG9uQ2xvc2U6IChjYik9PntcbiAgICAgICAgICAgICAgICByZXMub24oJ2Nsb3NlJywgY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQWZ0ZXJUYXNrRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uSW5zdHJ1bWVudGF0aW9uUmVxdWVzdEVycm9yOiAoZXJyb3IsIF9yZXF1ZXN0LCBlcnJvckNvbnRleHQpPT5yb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVycm9yLCBlcnJvckNvbnRleHQsIHJvdXRlclNlcnZlckNvbnRleHQpXG4gICAgICAgIH0sXG4gICAgICAgIHNoYXJlZENvbnRleHQ6IHtcbiAgICAgICAgICAgIGJ1aWxkSWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9kZU5leHRSZXEgPSBuZXcgTm9kZU5leHRSZXF1ZXN0KHJlcSk7XG4gICAgY29uc3Qgbm9kZU5leHRSZXMgPSBuZXcgTm9kZU5leHRSZXNwb25zZShyZXMpO1xuICAgIGNvbnN0IG5leHRSZXEgPSBOZXh0UmVxdWVzdEFkYXB0ZXIuZnJvbU5vZGVOZXh0UmVxdWVzdChub2RlTmV4dFJlcSwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZShyZXMpKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnZva2VSb3V0ZU1vZHVsZSA9IGFzeW5jIChzcGFuKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlTW9kdWxlLmhhbmRsZShuZXh0UmVxLCBjb250ZXh0KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gYXN5bmMgKGN1cnJlbnRTcGFuKT0+e1xuICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VHZW5lcmF0b3IgPSBhc3luYyAoeyBwcmV2aW91c0NhY2hlRW50cnkgfSk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiYgaXNPbkRlbWFuZFJldmFsaWRhdGUgJiYgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQgJiYgIXByZXZpb3VzQ2FjaGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbi1kZW1hbmQgcmV2YWxpZGF0ZSBhbHdheXMgc2V0cyB0aGlzIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCAnUkVWQUxJREFURUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW52b2tlUm91dGVNb2R1bGUoY3VycmVudFNwYW4pO1xuICAgICAgICAgICAgICAgICAgICByZXEuZmV0Y2hNZXRyaWNzID0gY29udGV4dC5yZW5kZXJPcHRzLmZldGNoTWV0cmljcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlbmRpbmdXYWl0VW50aWwgPSBjb250ZXh0LnJlbmRlck9wdHMucGVuZGluZ1dhaXRVbnRpbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB1c2luZyBwcm92aWRlZCB3YWl0VW50aWwgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHdlIGZhbGxiYWNrIHRvIHNlbmRSZXNwb25zZSdzIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nV2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LndhaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC53YWl0VW50aWwocGVuZGluZ1dhaXRVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dhaXRVbnRpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZVRhZ3MgPSBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkVGFncztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgZm9yIGEgc3RhdGljIHJlc3BvbnNlLCB3ZSBjYW4gY2FjaGUgaXQgc28gbG9uZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIG5vdCBlZGdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJc3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBoZWFkZXJzIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tORVhUX0NBQ0hFX1RBR1NfSEVBREVSXSA9IGNhY2hlVGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyc1snY29udGVudC10eXBlJ10gJiYgYmxvYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBibG9iLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gdHlwZW9mIGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZSA+PSBJTkZJTklURV9DQUNIRSA/IGZhbHNlIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA+PSBJTkZJTklURV9DQUNIRSA/IHVuZGVmaW5lZCA6IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRFeHBpcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNhY2hlIGVudHJ5IGZvciB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBCdWZmZXIuZnJvbShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCByZXNwb25zZSB3aXRob3V0IGNhY2hpbmcgaWYgbm90IElTUlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VuZFJlc3BvbnNlKG5vZGVOZXh0UmVxLCBub2RlTmV4dFJlcywgcmVzcG9uc2UsIGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBiYWNrZ3JvdW5kIHJldmFsaWRhdGUgd2UgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgZXJyb3IgaGVyZSBhcyBpdCB3b24ndCBiZSBidWJibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NhY2hlRW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzQ2FjaGVFbnRyeS5pc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVyciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcktpbmQ6ICdBcHAgUm91dGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVBhdGg6IHNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJvdXRlclNlcnZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGF3YWl0IHJvdXRlTW9kdWxlLmhhbmRsZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlR2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjcmVhdGUgYSBjYWNoZUVudHJ5IGZvciBJU1JcbiAgICAgICAgICAgIGlmICghaXNJc3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlLmtpbmQpICE9PSBDYWNoZWRSb3V0ZUtpbmQuQVBQX1JPVVRFKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlMTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhcmlhbnQ6IGFwcC1yb3V0ZSByZWNlaXZlZCBpbnZhbGlkIGNhY2hlIGVudHJ5ICR7Y2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlMSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZTEua2luZH1gKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU3MDFcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCBpc09uRGVtYW5kUmV2YWxpZGF0ZSA/ICdSRVZBTElEQVRFRCcgOiBjYWNoZUVudHJ5LmlzTWlzcyA/ICdNSVNTJyA6IGNhY2hlRW50cnkuaXNTdGFsZSA/ICdTVEFMRScgOiAnSElUJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcmFmdCBtb2RlIHNob3VsZCBuZXZlciBiZSBjYWNoZWRcbiAgICAgICAgICAgIGlmIChpc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCAncHJpdmF0ZSwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtYXgtYWdlPTAsIG11c3QtcmV2YWxpZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhjYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKCEoZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc0lzcikpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmRlbGV0ZShORVhUX0NBQ0hFX1RBR1NfSEVBREVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGNhY2hlIGNvbnRyb2wgaXMgYWxyZWFkeSBzZXQgb24gdGhlIHJlc3BvbnNlIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBvdmVycmlkZSBpdCB0byBhbGxvdyB1c2VycyB0byBjdXN0b21pemUgaXQgdmlhIG5leHQuY29uZmlnXG4gICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wgJiYgIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSAmJiAhaGVhZGVycy5nZXQoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdDYWNoZS1Db250cm9sJywgZ2V0Q2FjaGVDb250cm9sSGVhZGVyKGNhY2hlRW50cnkuY2FjaGVDb250cm9sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UoY2FjaGVFbnRyeS52YWx1ZS5ib2R5LCB7XG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlRW50cnkudmFsdWUuc3RhdHVzIHx8IDIwMFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVSZXNwb25zZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVSZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIE5vRmFsbGJhY2tFcnJvcikpIHtcbiAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogbm9ybWFsaXplZFNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldGhyb3cgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHNlcnZpbmcgZXJyb3IgcGFnZVxuICAgICAgICAvLyBJZiB0aGlzIGlzIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbiwgdGhyb3cgdGhlIGVycm9yIGFnYWluLlxuICAgICAgICBpZiAoaXNJc3IpIHRocm93IGVycjtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZW5kIGEgNTAwIHJlc3BvbnNlLlxuICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fanalyze%2Froute&page=%2Fapi%2Fanalyze%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze%2Froute.ts&appDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "./work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ "rimraf":
/*!*************************!*\
  !*** external "rimraf" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("rimraf");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "stream/promises":
/*!**********************************!*\
  !*** external "stream/promises" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream/promises");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/zod","vendor-chunks/papaparse","vendor-chunks/yaml","vendor-chunks/semver","vendor-chunks/bluebird","vendor-chunks/fstream","vendor-chunks/unzipper","vendor-chunks/readable-stream","vendor-chunks/graceful-fs","vendor-chunks/string_decoder","vendor-chunks/inherits","vendor-chunks/buffer-indexof-polyfill","vendor-chunks/binary","vendor-chunks/util-deprecate","vendor-chunks/traverse","vendor-chunks/process-nextick-args","vendor-chunks/mkdirp","vendor-chunks/listenercount","vendor-chunks/isarray","vendor-chunks/duplexer2","vendor-chunks/core-util-is","vendor-chunks/chainsaw","vendor-chunks/buffers","vendor-chunks/big-integer"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fanalyze%2Froute&page=%2Fapi%2Fanalyze%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze%2Froute.ts&appDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();