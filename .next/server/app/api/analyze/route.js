/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/analyze/route";
exports.ids = ["app/api/analyze/route"];
exports.modules = {

/***/ "(rsc)/./app/api/analyze/route.ts":
/*!**********************************!*\
  !*** ./app/api/analyze/route.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../lib/analysis/run */ \"(rsc)/./lib/analysis/run.ts\");\n/* harmony import */ var _lib_files_single_file__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../lib/files/single-file */ \"(rsc)/./lib/files/single-file.ts\");\n\n\n\n\n\n// ZIP imports removed as per new requirements\n\n// Initialize tempReports if not exists\nif (!global.tempReports) {\n    global.tempReports = new Map();\n}\nconst runtime = \"nodejs\";\nconst dynamic = \"force-dynamic\";\nasync function POST(request) {\n    console.log('Analyze API called with method: POST');\n    let tempPath;\n    try {\n        // Parse form data using Next.js built-in FormData\n        const formData = await request.formData();\n        const file = formData.get('file');\n        if (!file) {\n            console.error('No file found in request');\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'No file provided'\n            }, {\n                status: 400\n            });\n        }\n        console.log('File found:', {\n            name: file.name,\n            type: file.type,\n            size: file.size\n        });\n        // Create temporary directory - use /tmp for Vercel serverless\n        const tempDir = process.env.VERCEL ? '/tmp/analyzer' : path__WEBPACK_IMPORTED_MODULE_2___default().join(process.cwd(), 'tmp', 'analyzer');\n        await fs__WEBPACK_IMPORTED_MODULE_1__.promises.mkdir(tempDir, {\n            recursive: true\n        });\n        // Save uploaded file\n        const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_3__.randomUUID)();\n        const originalName = file.name || 'uploaded-file';\n        tempPath = path__WEBPACK_IMPORTED_MODULE_2___default().join(tempDir, `${analysisId}-${originalName}`);\n        // Convert File to Buffer and write to disk\n        const bytes = await file.arrayBuffer();\n        const buffer = Buffer.from(bytes);\n        await fs__WEBPACK_IMPORTED_MODULE_1__.promises.writeFile(tempPath, buffer);\n        console.log('File saved successfully');\n        try {\n            // Check if file should be analyzed (early exit for unsupported types)\n            if (!(0,_lib_files_single_file__WEBPACK_IMPORTED_MODULE_5__.shouldAnalyzeFile)(originalName)) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: 'File type not supported for analysis',\n                    details: {\n                        filename: originalName\n                    }\n                }, {\n                    status: 400\n                });\n            }\n            // Check file size\n            const stats = await fs__WEBPACK_IMPORTED_MODULE_1__.promises.stat(tempPath);\n            if (stats.size > 5 * 1024 * 1024) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: 'File too large',\n                    details: {\n                        size: stats.size,\n                        maxSize: 5 * 1024 * 1024\n                    }\n                }, {\n                    status: 400\n                });\n            }\n            // Run analysis\n            console.log('Starting analysis for:', originalName);\n            // Determine public URL - use request headers if on Vercel\n            let publicUrl;\n            if (process.env.VERCEL) {\n                const host = request.headers.get('host');\n                const protocol = request.headers.get('x-forwarded-proto') || 'https';\n                publicUrl = `${protocol}://${host}`;\n                console.log('Constructed Vercel URL from headers:', publicUrl);\n            } else {\n                publicUrl = 'http://localhost:3000';\n            }\n            const analysisOptions = (0,_lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__.validateAnalysisOptions)({\n                maxFiles: 50000,\n                maxFileSize: 5 * 1024 * 1024,\n                allowedExtensions: [\n                    '.html',\n                    '.htm',\n                    '.js',\n                    '.mjs',\n                    '.ts',\n                    '.json',\n                    '.webmanifest',\n                    '.wasm'\n                ],\n                storeResults: true,\n                publicUrl\n            });\n            console.log('Analysis options:', analysisOptions);\n            const result = await (0,_lib_analysis_run__WEBPACK_IMPORTED_MODULE_4__.runBaselineAnalysis)(tempPath, analysisOptions);\n            console.log('Analysis completed successfully');\n            console.log('Is Vercel:', !!process.env.VERCEL);\n            console.log('Public URL:', publicUrl);\n            // For Vercel deployment, include the full report directly in the response\n            let response;\n            if (process.env.VERCEL) {\n                // On Vercel, return the report directly since file storage is not persistent\n                const analysisId = result.artifacts?.analysisId || (0,crypto__WEBPACK_IMPORTED_MODULE_3__.randomUUID)();\n                response = {\n                    analysisId,\n                    summary: result.report.summary,\n                    artifacts: {\n                        jsonUrl: `${publicUrl}/api/analyze/${analysisId}?format=json`,\n                        csvUrl: `${publicUrl}/api/analyze/${analysisId}?format=csv`\n                    },\n                    report: result.report\n                };\n                // Store the report temporarily for the download endpoints\n                try {\n                    global.tempReports.set(analysisId, result.report);\n                    console.log(`Stored report ${analysisId} in temp storage`);\n                } catch (error) {\n                    console.error('Failed to store report in temp storage:', error);\n                // Don't fail the request, but log the error\n                }\n            } else {\n                // On local development, use file storage\n                if (!result.artifacts) {\n                    throw new Error('Failed to store analysis results');\n                }\n                response = {\n                    analysisId: result.artifacts.analysisId,\n                    summary: result.report.summary,\n                    artifacts: {\n                        jsonUrl: result.artifacts.jsonUrl,\n                        csvUrl: result.artifacts.csvUrl\n                    },\n                    report: result.report\n                };\n            }\n            console.log('Analysis response:', {\n                analysisId: response.analysisId,\n                jsonUrl: response.artifacts.jsonUrl,\n                csvUrl: response.artifacts.csvUrl,\n                isVercel: !!process.env.VERCEL\n            });\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(response);\n        } finally{\n            // Clean up temporary file\n            try {\n                await fs__WEBPACK_IMPORTED_MODULE_1__.promises.unlink(tempPath);\n            } catch (error) {\n                console.warn(`Failed to cleanup temp file ${tempPath}: ${error}`);\n            }\n        }\n    } catch (error) {\n        console.error('Analysis API error:', error);\n        // Clean up temporary file on error\n        try {\n            if (typeof tempPath !== 'undefined') {\n                await fs__WEBPACK_IMPORTED_MODULE_1__.promises.unlink(tempPath);\n            }\n        } catch (cleanupError) {\n            console.warn(`Failed to cleanup temp file on error: ${cleanupError}`);\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: 'Analysis failed',\n            message: error instanceof Error ? error.message : 'Unknown error',\n            details: error instanceof Error ? error.stack : undefined\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T29ELGNBQWM7WUFDckJ0RCxRQUFRcUQsSUFBSSxDQUFDLENBQUMsc0NBQXNDLEVBQUVDLGNBQWM7UUFDdEU7UUFFQSxPQUFPckUscURBQVlBLENBQUNzQixJQUFJLENBQUM7WUFDdkJELE9BQU87WUFDUGlELFNBQVNqRCxpQkFBaUI0QyxRQUFRNUMsTUFBTWlELE9BQU8sR0FBRztZQUNsRDNCLFNBQVN0QixpQkFBaUI0QyxRQUFRNUMsTUFBTWtELEtBQUssR0FBR0M7UUFDbEQsR0FBRztZQUFFakQsUUFBUTtRQUFJO0lBQ25CO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGFwcFxcYXBpXFxhbmFseXplXFxyb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHJhbmRvbVVVSUQgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgcnVuQmFzZWxpbmVBbmFseXNpcywgdmFsaWRhdGVBbmFseXNpc09wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9saWIvYW5hbHlzaXMvcnVuJztcbi8vIFpJUCBpbXBvcnRzIHJlbW92ZWQgYXMgcGVyIG5ldyByZXF1aXJlbWVudHNcbmltcG9ydCB7IHNob3VsZEFuYWx5emVGaWxlIH0gZnJvbSAnLi4vLi4vLi4vbGliL2ZpbGVzL3NpbmdsZS1maWxlJztcbmltcG9ydCB7IEFuYWx5emVSZXNwb25zZSwgUmVwb3J0IH0gZnJvbSAnLi4vLi4vLi4vbGliL2FuYWx5c2lzL2Jhc2VsaW5lLnR5cGVzJztcblxuLy8gVGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIFZlcmNlbCAoaW4tbWVtb3J5IG9ubHkpXG5kZWNsYXJlIGdsb2JhbCB7XG4gIHZhciB0ZW1wUmVwb3J0czogTWFwPHN0cmluZywgUmVwb3J0Pjtcbn1cblxuLy8gSW5pdGlhbGl6ZSB0ZW1wUmVwb3J0cyBpZiBub3QgZXhpc3RzXG5pZiAoIWdsb2JhbC50ZW1wUmVwb3J0cykge1xuICBnbG9iYWwudGVtcFJlcG9ydHMgPSBuZXcgTWFwKCk7XG59XG5cbmV4cG9ydCBjb25zdCBydW50aW1lID0gXCJub2RlanNcIjtcbmV4cG9ydCBjb25zdCBkeW5hbWljID0gXCJmb3JjZS1keW5hbWljXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIGNvbnNvbGUubG9nKCdBbmFseXplIEFQSSBjYWxsZWQgd2l0aCBtZXRob2Q6IFBPU1QnKTtcbiAgXG4gIGxldCB0ZW1wUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgLy8gUGFyc2UgZm9ybSBkYXRhIHVzaW5nIE5leHQuanMgYnVpbHQtaW4gRm9ybURhdGFcbiAgICBjb25zdCBmb3JtRGF0YSA9IGF3YWl0IHJlcXVlc3QuZm9ybURhdGEoKTtcbiAgICBjb25zdCBmaWxlID0gZm9ybURhdGEuZ2V0KCdmaWxlJykgYXMgRmlsZTtcblxuICAgIGlmICghZmlsZSkge1xuICAgICAgY29uc29sZS5lcnJvcignTm8gZmlsZSBmb3VuZCBpbiByZXF1ZXN0Jyk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBcbiAgICAgICAgZXJyb3I6ICdObyBmaWxlIHByb3ZpZGVkJ1xuICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnRmlsZSBmb3VuZDonLCB7XG4gICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICBzaXplOiBmaWxlLnNpemVcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSB0ZW1wb3JhcnkgZGlyZWN0b3J5IC0gdXNlIC90bXAgZm9yIFZlcmNlbCBzZXJ2ZXJsZXNzXG4gICAgY29uc3QgdGVtcERpciA9IHByb2Nlc3MuZW52LlZFUkNFTCA/ICcvdG1wL2FuYWx5emVyJyA6IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAndG1wJywgJ2FuYWx5emVyJyk7XG4gICAgYXdhaXQgZnMubWtkaXIodGVtcERpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG5cbiAgICAvLyBTYXZlIHVwbG9hZGVkIGZpbGVcbiAgICBjb25zdCBhbmFseXNpc0lkID0gcmFuZG9tVVVJRCgpO1xuICAgIGNvbnN0IG9yaWdpbmFsTmFtZSA9IGZpbGUubmFtZSB8fCAndXBsb2FkZWQtZmlsZSc7XG4gICAgdGVtcFBhdGggPSBwYXRoLmpvaW4odGVtcERpciwgYCR7YW5hbHlzaXNJZH0tJHtvcmlnaW5hbE5hbWV9YCk7XG4gICAgXG4gICAgLy8gQ29udmVydCBGaWxlIHRvIEJ1ZmZlciBhbmQgd3JpdGUgdG8gZGlza1xuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUodGVtcFBhdGgsIGJ1ZmZlcik7XG4gICAgY29uc29sZS5sb2coJ0ZpbGUgc2F2ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgZmlsZSBzaG91bGQgYmUgYW5hbHl6ZWQgKGVhcmx5IGV4aXQgZm9yIHVuc3VwcG9ydGVkIHR5cGVzKVxuICAgICAgaWYgKCFzaG91bGRBbmFseXplRmlsZShvcmlnaW5hbE5hbWUpKSB7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICAgIGVycm9yOiAnRmlsZSB0eXBlIG5vdCBzdXBwb3J0ZWQgZm9yIGFuYWx5c2lzJyxcbiAgICAgICAgICBkZXRhaWxzOiB7IGZpbGVuYW1lOiBvcmlnaW5hbE5hbWUgfVxuICAgICAgICB9LCB7IHN0YXR1czogNDAwIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmaWxlIHNpemVcbiAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMuc3RhdCh0ZW1wUGF0aCk7XG4gICAgICBpZiAoc3RhdHMuc2l6ZSA+IDUgKiAxMDI0ICogMTAyNCkgeyAvLyA1TUIgbGltaXRcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgXG4gICAgICAgICAgZXJyb3I6ICdGaWxlIHRvbyBsYXJnZScsXG4gICAgICAgICAgZGV0YWlsczogeyBcbiAgICAgICAgICAgIHNpemU6IHN0YXRzLnNpemUsXG4gICAgICAgICAgICBtYXhTaXplOiA1ICogMTAyNCAqIDEwMjRcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJ1biBhbmFseXNpc1xuICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIGFuYWx5c2lzIGZvcjonLCBvcmlnaW5hbE5hbWUpO1xuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgcHVibGljIFVSTCAtIHVzZSByZXF1ZXN0IGhlYWRlcnMgaWYgb24gVmVyY2VsXG4gICAgICBsZXQgcHVibGljVXJsOiBzdHJpbmc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuVkVSQ0VMKSB7XG4gICAgICAgIGNvbnN0IGhvc3QgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdob3N0Jyk7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcmVxdWVzdC5oZWFkZXJzLmdldCgneC1mb3J3YXJkZWQtcHJvdG8nKSB8fCAnaHR0cHMnO1xuICAgICAgICBwdWJsaWNVcmwgPSBgJHtwcm90b2NvbH06Ly8ke2hvc3R9YDtcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbnN0cnVjdGVkIFZlcmNlbCBVUkwgZnJvbSBoZWFkZXJzOicsIHB1YmxpY1VybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdWJsaWNVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDozMDAwJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuYWx5c2lzT3B0aW9ucyA9IHZhbGlkYXRlQW5hbHlzaXNPcHRpb25zKHtcbiAgICAgICAgbWF4RmlsZXM6IDUwMDAwLFxuICAgICAgICBtYXhGaWxlU2l6ZTogNSAqIDEwMjQgKiAxMDI0LCAvLyA1TUJcbiAgICAgICAgYWxsb3dlZEV4dGVuc2lvbnM6IFsnLmh0bWwnLCAnLmh0bScsICcuanMnLCAnLm1qcycsICcudHMnLCAnLmpzb24nLCAnLndlYm1hbmlmZXN0JywgJy53YXNtJ10sXG4gICAgICAgIHN0b3JlUmVzdWx0czogdHJ1ZSxcbiAgICAgICAgcHVibGljVXJsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdBbmFseXNpcyBvcHRpb25zOicsIGFuYWx5c2lzT3B0aW9ucyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBydW5CYXNlbGluZUFuYWx5c2lzKHRlbXBQYXRoLCBhbmFseXNpc09wdGlvbnMpO1xuICAgICAgY29uc29sZS5sb2coJ0FuYWx5c2lzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgIGNvbnNvbGUubG9nKCdJcyBWZXJjZWw6JywgISFwcm9jZXNzLmVudi5WRVJDRUwpO1xuICAgICAgY29uc29sZS5sb2coJ1B1YmxpYyBVUkw6JywgcHVibGljVXJsKTtcblxuICAgICAgLy8gRm9yIFZlcmNlbCBkZXBsb3ltZW50LCBpbmNsdWRlIHRoZSBmdWxsIHJlcG9ydCBkaXJlY3RseSBpbiB0aGUgcmVzcG9uc2VcbiAgICAgIGxldCByZXNwb25zZTogQW5hbHl6ZVJlc3BvbnNlO1xuICAgICAgXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuVkVSQ0VMKSB7XG4gICAgICAgIC8vIE9uIFZlcmNlbCwgcmV0dXJuIHRoZSByZXBvcnQgZGlyZWN0bHkgc2luY2UgZmlsZSBzdG9yYWdlIGlzIG5vdCBwZXJzaXN0ZW50XG4gICAgICAgIGNvbnN0IGFuYWx5c2lzSWQgPSByZXN1bHQuYXJ0aWZhY3RzPy5hbmFseXNpc0lkIHx8IHJhbmRvbVVVSUQoKTtcbiAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgYW5hbHlzaXNJZCxcbiAgICAgICAgICBzdW1tYXJ5OiByZXN1bHQucmVwb3J0LnN1bW1hcnksXG4gICAgICAgICAgYXJ0aWZhY3RzOiB7XG4gICAgICAgICAgICBqc29uVXJsOiBgJHtwdWJsaWNVcmx9L2FwaS9hbmFseXplLyR7YW5hbHlzaXNJZH0/Zm9ybWF0PWpzb25gLFxuICAgICAgICAgICAgY3N2VXJsOiBgJHtwdWJsaWNVcmx9L2FwaS9hbmFseXplLyR7YW5hbHlzaXNJZH0/Zm9ybWF0PWNzdmAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXBvcnQ6IHJlc3VsdC5yZXBvcnQsXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSB0aGUgcmVwb3J0IHRlbXBvcmFyaWx5IGZvciB0aGUgZG93bmxvYWQgZW5kcG9pbnRzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2xvYmFsLnRlbXBSZXBvcnRzLnNldChhbmFseXNpc0lkLCByZXN1bHQucmVwb3J0KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU3RvcmVkIHJlcG9ydCAke2FuYWx5c2lzSWR9IGluIHRlbXAgc3RvcmFnZWApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSByZXBvcnQgaW4gdGVtcCBzdG9yYWdlOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBEb24ndCBmYWlsIHRoZSByZXF1ZXN0LCBidXQgbG9nIHRoZSBlcnJvclxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbiBsb2NhbCBkZXZlbG9wbWVudCwgdXNlIGZpbGUgc3RvcmFnZVxuICAgICAgICBpZiAoIXJlc3VsdC5hcnRpZmFjdHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSBhbmFseXNpcyByZXN1bHRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgIGFuYWx5c2lzSWQ6IHJlc3VsdC5hcnRpZmFjdHMuYW5hbHlzaXNJZCxcbiAgICAgICAgICBzdW1tYXJ5OiByZXN1bHQucmVwb3J0LnN1bW1hcnksXG4gICAgICAgICAgYXJ0aWZhY3RzOiB7XG4gICAgICAgICAgICBqc29uVXJsOiByZXN1bHQuYXJ0aWZhY3RzLmpzb25VcmwsXG4gICAgICAgICAgICBjc3ZVcmw6IHJlc3VsdC5hcnRpZmFjdHMuY3N2VXJsLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVwb3J0OiByZXN1bHQucmVwb3J0LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQW5hbHlzaXMgcmVzcG9uc2U6Jywge1xuICAgICAgICBhbmFseXNpc0lkOiByZXNwb25zZS5hbmFseXNpc0lkLFxuICAgICAgICBqc29uVXJsOiByZXNwb25zZS5hcnRpZmFjdHMuanNvblVybCxcbiAgICAgICAgY3N2VXJsOiByZXNwb25zZS5hcnRpZmFjdHMuY3N2VXJsLFxuICAgICAgICBpc1ZlcmNlbDogISFwcm9jZXNzLmVudi5WRVJDRUxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocmVzcG9uc2UpO1xuXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFuIHVwIHRlbXBvcmFyeSBmaWxlXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmcy51bmxpbmsodGVtcFBhdGgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY2xlYW51cCB0ZW1wIGZpbGUgJHt0ZW1wUGF0aH06ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignQW5hbHlzaXMgQVBJIGVycm9yOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCB0ZW1wb3JhcnkgZmlsZSBvbiBlcnJvclxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBQYXRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhd2FpdCBmcy51bmxpbmsodGVtcFBhdGgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY2xlYW51cCB0ZW1wIGZpbGUgb24gZXJyb3I6ICR7Y2xlYW51cEVycm9yfWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBcbiAgICAgIGVycm9yOiAnQW5hbHlzaXMgZmFpbGVkJyxcbiAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgZGV0YWlsczogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogdW5kZWZpbmVkXG4gICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsInByb21pc2VzIiwiZnMiLCJwYXRoIiwicmFuZG9tVVVJRCIsInJ1bkJhc2VsaW5lQW5hbHlzaXMiLCJ2YWxpZGF0ZUFuYWx5c2lzT3B0aW9ucyIsInNob3VsZEFuYWx5emVGaWxlIiwiZ2xvYmFsIiwidGVtcFJlcG9ydHMiLCJNYXAiLCJydW50aW1lIiwiZHluYW1pYyIsIlBPU1QiLCJyZXF1ZXN0IiwiY29uc29sZSIsImxvZyIsInRlbXBQYXRoIiwiZm9ybURhdGEiLCJmaWxlIiwiZ2V0IiwiZXJyb3IiLCJqc29uIiwic3RhdHVzIiwibmFtZSIsInR5cGUiLCJzaXplIiwidGVtcERpciIsInByb2Nlc3MiLCJlbnYiLCJWRVJDRUwiLCJqb2luIiwiY3dkIiwibWtkaXIiLCJyZWN1cnNpdmUiLCJhbmFseXNpc0lkIiwib3JpZ2luYWxOYW1lIiwiYnl0ZXMiLCJhcnJheUJ1ZmZlciIsImJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJ3cml0ZUZpbGUiLCJkZXRhaWxzIiwiZmlsZW5hbWUiLCJzdGF0cyIsInN0YXQiLCJtYXhTaXplIiwicHVibGljVXJsIiwiaG9zdCIsImhlYWRlcnMiLCJwcm90b2NvbCIsImFuYWx5c2lzT3B0aW9ucyIsIm1heEZpbGVzIiwibWF4RmlsZVNpemUiLCJhbGxvd2VkRXh0ZW5zaW9ucyIsInN0b3JlUmVzdWx0cyIsInJlc3VsdCIsInJlc3BvbnNlIiwiYXJ0aWZhY3RzIiwic3VtbWFyeSIsInJlcG9ydCIsImpzb25VcmwiLCJjc3ZVcmwiLCJzZXQiLCJFcnJvciIsImlzVmVyY2VsIiwidW5saW5rIiwid2FybiIsImNsZWFudXBFcnJvciIsIm1lc3NhZ2UiLCJzdGFjayIsInVuZGVmaW5lZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/api/analyze/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/baseline.loader.ts":
/*!*****************************************!*\
  !*** ./lib/analysis/baseline.loader.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearRulesCache: () => (/* binding */ clearRulesCache),\n/* harmony export */   getCachedBaselineRules: () => (/* binding */ getCachedBaselineRules),\n/* harmony export */   getDefaultBaselineRules: () => (/* binding */ getDefaultBaselineRules),\n/* harmony export */   getDependencyUpgradeTemplate: () => (/* binding */ getDependencyUpgradeTemplate),\n/* harmony export */   getLanguageRules: () => (/* binding */ getLanguageRules),\n/* harmony export */   getPatternQuickFix: () => (/* binding */ getPatternQuickFix),\n/* harmony export */   isRulesCacheValid: () => (/* binding */ isRulesCacheValid),\n/* harmony export */   loadBaselineRules: () => (/* binding */ loadBaselineRules),\n/* harmony export */   loadBaselineRulesWithFallback: () => (/* binding */ loadBaselineRulesWithFallback),\n/* harmony export */   shouldIgnorePath: () => (/* binding */ shouldIgnorePath),\n/* harmony export */   shouldScanFile: () => (/* binding */ shouldScanFile),\n/* harmony export */   validateRulesStructure: () => (/* binding */ validateRulesStructure)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yaml */ \"(rsc)/./node_modules/yaml/dist/index.js\");\n/* harmony import */ var _baseline_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./baseline.types */ \"(rsc)/./lib/analysis/baseline.types.ts\");\n// readFileSync imported dynamically\n\n\n\n// Use process.cwd() for Node.js environment\n// Cache for loaded rules\nlet rulesCache = null;\nlet rulesCacheTimestamp = 0;\n/**\r\n * Load baseline rules from YAML configuration file\r\n * @param configPath Optional path to config file, defaults to config/baseline.rules.yaml\r\n * @returns Parsed and validated baseline rules\r\n */ async function loadBaselineRules(configPath) {\n    const defaultPath = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(process.cwd(), 'config', 'baseline.rules.yaml');\n    const path = configPath || defaultPath;\n    try {\n        // Check if we have cached rules and they're still valid\n        const { statSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const stats = statSync(path);\n        const mtime = stats.mtime.getTime();\n        if (rulesCache && mtime <= rulesCacheTimestamp) {\n            return rulesCache;\n        }\n        // Read and parse YAML file\n        const { readFileSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const yamlContent = readFileSync(path, 'utf8');\n        const rawRules = yaml__WEBPACK_IMPORTED_MODULE_1__.parse(yamlContent);\n        // Validate and parse rules\n        const rules = (0,_baseline_types__WEBPACK_IMPORTED_MODULE_2__.validateBaselineRules)(rawRules);\n        // Update cache\n        rulesCache = rules;\n        rulesCacheTimestamp = mtime;\n        return rules;\n    } catch (error) {\n        throw new Error(`Failed to load baseline rules from ${path}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\r\n * Get cached baseline rules without file system access\r\n * @returns Cached rules or throws if not loaded\r\n */ function getCachedBaselineRules() {\n    if (!rulesCache) {\n        throw new Error('Baseline rules not loaded. Call loadBaselineRules() first.');\n    }\n    return rulesCache;\n}\n/**\r\n * Clear the rules cache (useful for testing)\r\n */ function clearRulesCache() {\n    rulesCache = null;\n    rulesCacheTimestamp = 0;\n}\n/**\r\n * Check if rules are cached and up to date\r\n * @param configPath Optional path to config file\r\n * @returns True if cached rules are valid\r\n */ async function isRulesCacheValid(configPath) {\n    if (!rulesCache) return false;\n    try {\n        const defaultPath = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(process.cwd(), 'config', 'baseline.rules.yaml');\n        const path = configPath || defaultPath;\n        const { statSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const stats = statSync(path);\n        const mtime = stats.mtime.getTime();\n        return mtime <= rulesCacheTimestamp;\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Get default baseline rules (fallback if file loading fails)\r\n * @returns Minimal default rules\r\n */ function getDefaultBaselineRules() {\n    return {\n        language_runtimes: {\n            node: '>=18.0.0',\n            python: '>=3.10.0',\n            java: '>=17.0.0',\n            go: '>=1.21.0',\n            dotnet: '>=6.0.0'\n        },\n        package_mins: {\n            node: {\n                react: '>=18.0.0',\n                next: '>=13.0.0',\n                express: '>=4.18.0'\n            },\n            python: {\n                numpy: '>=1.22.0',\n                pandas: '>=1.4.0',\n                torch: '>=2.0.0'\n            },\n            java: {},\n            go: {},\n            dotnet: {}\n        },\n        deprecated_patterns: {\n            node: [\n                {\n                    pattern: 'fs\\\\.exists\\\\(',\n                    message: 'fs.exists() is deprecated, use fs.access() or fs.stat()',\n                    alternative: 'Use fs.access() or fs.promises.access()'\n                }\n            ],\n            python: [\n                {\n                    pattern: 'numpy\\\\.asscalar',\n                    message: 'numpy.asscalar is deprecated, use item() instead',\n                    alternative: 'Use numpy.item() or direct array indexing'\n                }\n            ],\n            java: [],\n            go: [],\n            dotnet: []\n        },\n        scan_file_exts: [\n            '.py',\n            '.js',\n            '.ts',\n            '.tsx',\n            '.jsx',\n            '.java',\n            '.go',\n            '.cs'\n        ],\n        ignore_paths: [\n            '/node_modules/',\n            '/.venv/',\n            '/venv/',\n            '/dist/',\n            '/build/',\n            '/.git/'\n        ],\n        max_file_size: 2097152,\n        max_files: 50000,\n        quick_fixes: {\n            dependency_upgrade: {\n                node: 'npm install {package}@{version}',\n                python: 'pip install \\'{package}>={version}\\'',\n                java: 'Update {package} to version {version} in pom.xml or build.gradle',\n                go: 'go get {package}@{version}',\n                dotnet: 'dotnet add package {package} --version {version}'\n            },\n            pattern_replacement: {\n                node: {\n                    'fs.exists(': 'Use fs.access() or fs.promises.access()'\n                },\n                python: {\n                    'numpy.asscalar': 'Use .item() method instead'\n                },\n                java: {},\n                go: {},\n                dotnet: {}\n            }\n        }\n    };\n}\n/**\r\n * Load baseline rules with fallback to defaults\r\n * @param configPath Optional path to config file\r\n * @returns Baseline rules (loaded or default)\r\n */ async function loadBaselineRulesWithFallback(configPath) {\n    try {\n        return await loadBaselineRules(configPath);\n    } catch (error) {\n        console.warn(`Failed to load baseline rules: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        console.warn('Using default baseline rules');\n        return getDefaultBaselineRules();\n    }\n}\n/**\r\n * Validate that a rules object has all required fields\r\n * @param rules Rules object to validate\r\n * @returns True if valid\r\n */ async function validateRulesStructure(rules) {\n    try {\n        (0,_baseline_types__WEBPACK_IMPORTED_MODULE_2__.validateBaselineRules)(rules);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Get rules for a specific language\r\n * @param rules Baseline rules\r\n * @param language Language to get rules for\r\n * @returns Rules specific to the language\r\n */ function getLanguageRules(rules, language) {\n    return {\n        packageMins: rules.package_mins[language] || {},\n        deprecatedPatterns: rules.deprecated_patterns[language] || [],\n        runtime: rules.language_runtimes[language]\n    };\n}\n/**\r\n * Check if a file extension should be scanned\r\n * @param rules Baseline rules\r\n * @param extension File extension (with or without dot)\r\n * @returns True if should be scanned\r\n */ function shouldScanFile(rules, extension) {\n    const ext = extension.startsWith('.') ? extension : `.${extension}`;\n    return rules.scan_file_exts.includes(ext);\n}\n/**\r\n * Check if a path should be ignored\r\n * @param rules Baseline rules\r\n * @param filePath File path to check\r\n * @returns True if should be ignored\r\n */ function shouldIgnorePath(rules, filePath) {\n    if (!filePath || !rules.ignore_paths) {\n        return false;\n    }\n    return rules.ignore_paths.some((ignorePath)=>filePath.includes(ignorePath) || filePath.startsWith(ignorePath));\n}\n/**\r\n * Get quick fix template for dependency upgrade\r\n * @param rules Baseline rules\r\n * @param language Language\r\n * @returns Template string\r\n */ function getDependencyUpgradeTemplate(rules, language) {\n    return rules.quick_fixes.dependency_upgrade[language] || 'Update {package} to {version}';\n}\n/**\r\n * Get quick fix for pattern replacement\r\n * @param rules Baseline rules\r\n * @param language Language\r\n * @param pattern Pattern to replace\r\n * @returns Quick fix suggestion or undefined\r\n */ function getPatternQuickFix(rules, language, pattern) {\n    return rules.quick_fixes.pattern_replacement[language]?.[pattern];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvYW5hbHlzaXMvYmFzZWxpbmUubG9hZGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvQ0FBb0M7QUFDUjtBQUNKO0FBQ2dEO0FBRXhFLDRDQUE0QztBQUU1Qyx5QkFBeUI7QUFDekIsSUFBSUcsYUFBbUM7QUFDdkMsSUFBSUMsc0JBQThCO0FBRWxDOzs7O0NBSUMsR0FDTSxlQUFlQyxrQkFBa0JDLFVBQW1CO0lBQ3pELE1BQU1DLGNBQWNQLDBDQUFJQSxDQUFDUSxRQUFRQyxHQUFHLElBQUksVUFBVTtJQUNsRCxNQUFNQyxPQUFPSixjQUFjQztJQUUzQixJQUFJO1FBQ0Ysd0RBQXdEO1FBQ3hELE1BQU0sRUFBRUksUUFBUSxFQUFFLEdBQUcsTUFBTSwwR0FBWTtRQUN2QyxNQUFNQyxRQUFRRCxTQUFTRDtRQUN2QixNQUFNRyxRQUFRRCxNQUFNQyxLQUFLLENBQUNDLE9BQU87UUFFakMsSUFBSVgsY0FBY1UsU0FBU1QscUJBQXFCO1lBQzlDLE9BQU9EO1FBQ1Q7UUFFQSwyQkFBMkI7UUFDM0IsTUFBTSxFQUFFWSxZQUFZLEVBQUUsR0FBRyxNQUFNLDBHQUFZO1FBQzNDLE1BQU1DLGNBQWNELGFBQWFMLE1BQU07UUFDdkMsTUFBTU8sV0FBV2hCLHVDQUFVLENBQUNlO1FBRTVCLDJCQUEyQjtRQUMzQixNQUFNRyxRQUFRakIsc0VBQXFCQSxDQUFDZTtRQUVwQyxlQUFlO1FBQ2ZkLGFBQWFnQjtRQUNiZixzQkFBc0JTO1FBRXRCLE9BQU9NO0lBQ1QsRUFBRSxPQUFPQyxPQUFPO1FBQ2QsTUFBTSxJQUFJQyxNQUFNLENBQUMsbUNBQW1DLEVBQUVYLEtBQUssRUFBRSxFQUFFVSxpQkFBaUJDLFFBQVFELE1BQU1FLE9BQU8sR0FBRyxpQkFBaUI7SUFDM0g7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDO0lBQ2QsSUFBSSxDQUFDcEIsWUFBWTtRQUNmLE1BQU0sSUFBSWtCLE1BQU07SUFDbEI7SUFDQSxPQUFPbEI7QUFD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QW9CLEVBQUV5QyxTQUFpQjtJQUNwRSxNQUFNQyxNQUFNRCxVQUFVRSxVQUFVLENBQUMsT0FBT0YsWUFBWSxDQUFDLENBQUMsRUFBRUEsV0FBVztJQUNuRSxPQUFPekMsTUFBTXdCLGNBQWMsQ0FBQ29CLFFBQVEsQ0FBQ0Y7QUFDdkM7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNHLGlCQUFpQjdDLEtBQW9CLEVBQUU4QyxRQUFnQjtJQUNyRSxJQUFJLENBQUNBLFlBQVksQ0FBQzlDLE1BQU15QixZQUFZLEVBQUU7UUFDcEMsT0FBTztJQUNUO0lBQ0EsT0FBT3pCLE1BQU15QixZQUFZLENBQUNzQixJQUFJLENBQUNDLENBQUFBLGFBQzdCRixTQUFTRixRQUFRLENBQUNJLGVBQWVGLFNBQVNILFVBQVUsQ0FBQ0s7QUFFekQ7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNDLDZCQUE2QmpELEtBQW9CLEVBQUVvQyxRQUFrRTtJQUNuSSxPQUFPcEMsTUFBTTRCLFdBQVcsQ0FBQ0Msa0JBQWtCLENBQUNPLFNBQVMsSUFBSTtBQUMzRDtBQUVBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNjLG1CQUNkbEQsS0FBb0IsRUFDcEJvQyxRQUFtRSxFQUNuRWQsT0FBZTtJQUVmLE9BQU90QixNQUFNNEIsV0FBVyxDQUFDRSxtQkFBbUIsQ0FBQ00sU0FBUyxFQUFFLENBQUNkLFFBQVE7QUFDbkUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcYW5hbHlzaXNcXGJhc2VsaW5lLmxvYWRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZWFkRmlsZVN5bmMgaW1wb3J0ZWQgZHluYW1pY2FsbHlcclxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgWUFNTCBmcm9tICd5YW1sJztcclxuaW1wb3J0IHsgQmFzZWxpbmVSdWxlcywgdmFsaWRhdGVCYXNlbGluZVJ1bGVzIH0gZnJvbSAnLi9iYXNlbGluZS50eXBlcyc7XHJcblxyXG4vLyBVc2UgcHJvY2Vzcy5jd2QoKSBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxyXG5cclxuLy8gQ2FjaGUgZm9yIGxvYWRlZCBydWxlc1xyXG5sZXQgcnVsZXNDYWNoZTogQmFzZWxpbmVSdWxlcyB8IG51bGwgPSBudWxsO1xyXG5sZXQgcnVsZXNDYWNoZVRpbWVzdGFtcDogbnVtYmVyID0gMDtcclxuXHJcbi8qKlxyXG4gKiBMb2FkIGJhc2VsaW5lIHJ1bGVzIGZyb20gWUFNTCBjb25maWd1cmF0aW9uIGZpbGVcclxuICogQHBhcmFtIGNvbmZpZ1BhdGggT3B0aW9uYWwgcGF0aCB0byBjb25maWcgZmlsZSwgZGVmYXVsdHMgdG8gY29uZmlnL2Jhc2VsaW5lLnJ1bGVzLnlhbWxcclxuICogQHJldHVybnMgUGFyc2VkIGFuZCB2YWxpZGF0ZWQgYmFzZWxpbmUgcnVsZXNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkQmFzZWxpbmVSdWxlcyhjb25maWdQYXRoPzogc3RyaW5nKTogUHJvbWlzZTxCYXNlbGluZVJ1bGVzPiB7XHJcbiAgY29uc3QgZGVmYXVsdFBhdGggPSBqb2luKHByb2Nlc3MuY3dkKCksICdjb25maWcnLCAnYmFzZWxpbmUucnVsZXMueWFtbCcpO1xyXG4gIGNvbnN0IHBhdGggPSBjb25maWdQYXRoIHx8IGRlZmF1bHRQYXRoO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGNhY2hlZCBydWxlcyBhbmQgdGhleSdyZSBzdGlsbCB2YWxpZFxyXG4gICAgY29uc3QgeyBzdGF0U3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhwYXRoKTtcclxuICAgIGNvbnN0IG10aW1lID0gc3RhdHMubXRpbWUuZ2V0VGltZSgpO1xyXG4gICAgXHJcbiAgICBpZiAocnVsZXNDYWNoZSAmJiBtdGltZSA8PSBydWxlc0NhY2hlVGltZXN0YW1wKSB7XHJcbiAgICAgIHJldHVybiBydWxlc0NhY2hlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBSZWFkIGFuZCBwYXJzZSBZQU1MIGZpbGVcclxuICAgIGNvbnN0IHsgcmVhZEZpbGVTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2ZzJyk7XHJcbiAgICBjb25zdCB5YW1sQ29udGVudCA9IHJlYWRGaWxlU3luYyhwYXRoLCAndXRmOCcpO1xyXG4gICAgY29uc3QgcmF3UnVsZXMgPSBZQU1MLnBhcnNlKHlhbWxDb250ZW50KTtcclxuICAgIFxyXG4gICAgLy8gVmFsaWRhdGUgYW5kIHBhcnNlIHJ1bGVzXHJcbiAgICBjb25zdCBydWxlcyA9IHZhbGlkYXRlQmFzZWxpbmVSdWxlcyhyYXdSdWxlcyk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjYWNoZVxyXG4gICAgcnVsZXNDYWNoZSA9IHJ1bGVzO1xyXG4gICAgcnVsZXNDYWNoZVRpbWVzdGFtcCA9IG10aW1lO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcnVsZXM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgYmFzZWxpbmUgcnVsZXMgZnJvbSAke3BhdGh9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBjYWNoZWQgYmFzZWxpbmUgcnVsZXMgd2l0aG91dCBmaWxlIHN5c3RlbSBhY2Nlc3NcclxuICogQHJldHVybnMgQ2FjaGVkIHJ1bGVzIG9yIHRocm93cyBpZiBub3QgbG9hZGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVkQmFzZWxpbmVSdWxlcygpOiBCYXNlbGluZVJ1bGVzIHtcclxuICBpZiAoIXJ1bGVzQ2FjaGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQmFzZWxpbmUgcnVsZXMgbm90IGxvYWRlZC4gQ2FsbCBsb2FkQmFzZWxpbmVSdWxlcygpIGZpcnN0LicpO1xyXG4gIH1cclxuICByZXR1cm4gcnVsZXNDYWNoZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFyIHRoZSBydWxlcyBjYWNoZSAodXNlZnVsIGZvciB0ZXN0aW5nKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyUnVsZXNDYWNoZSgpOiB2b2lkIHtcclxuICBydWxlc0NhY2hlID0gbnVsbDtcclxuICBydWxlc0NhY2hlVGltZXN0YW1wID0gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHJ1bGVzIGFyZSBjYWNoZWQgYW5kIHVwIHRvIGRhdGVcclxuICogQHBhcmFtIGNvbmZpZ1BhdGggT3B0aW9uYWwgcGF0aCB0byBjb25maWcgZmlsZVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGNhY2hlZCBydWxlcyBhcmUgdmFsaWRcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc1J1bGVzQ2FjaGVWYWxpZChjb25maWdQYXRoPzogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgaWYgKCFydWxlc0NhY2hlKSByZXR1cm4gZmFsc2U7XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGRlZmF1bHRQYXRoID0gam9pbihwcm9jZXNzLmN3ZCgpLCAnY29uZmlnJywgJ2Jhc2VsaW5lLnJ1bGVzLnlhbWwnKTtcclxuICAgIGNvbnN0IHBhdGggPSBjb25maWdQYXRoIHx8IGRlZmF1bHRQYXRoO1xyXG4gICAgY29uc3QgeyBzdGF0U3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhwYXRoKTtcclxuICAgIGNvbnN0IG10aW1lID0gc3RhdHMubXRpbWUuZ2V0VGltZSgpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gbXRpbWUgPD0gcnVsZXNDYWNoZVRpbWVzdGFtcDtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZGVmYXVsdCBiYXNlbGluZSBydWxlcyAoZmFsbGJhY2sgaWYgZmlsZSBsb2FkaW5nIGZhaWxzKVxyXG4gKiBAcmV0dXJucyBNaW5pbWFsIGRlZmF1bHQgcnVsZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0QmFzZWxpbmVSdWxlcygpOiBCYXNlbGluZVJ1bGVzIHtcclxuICByZXR1cm4ge1xyXG4gICAgbGFuZ3VhZ2VfcnVudGltZXM6IHtcclxuICAgICAgbm9kZTogJz49MTguMC4wJyxcclxuICAgICAgcHl0aG9uOiAnPj0zLjEwLjAnLFxyXG4gICAgICBqYXZhOiAnPj0xNy4wLjAnLFxyXG4gICAgICBnbzogJz49MS4yMS4wJyxcclxuICAgICAgZG90bmV0OiAnPj02LjAuMCcsXHJcbiAgICB9LFxyXG4gICAgcGFja2FnZV9taW5zOiB7XHJcbiAgICAgIG5vZGU6IHtcclxuICAgICAgICByZWFjdDogJz49MTguMC4wJyxcclxuICAgICAgICBuZXh0OiAnPj0xMy4wLjAnLFxyXG4gICAgICAgIGV4cHJlc3M6ICc+PTQuMTguMCcsXHJcbiAgICAgIH0sXHJcbiAgICAgIHB5dGhvbjoge1xyXG4gICAgICAgIG51bXB5OiAnPj0xLjIyLjAnLFxyXG4gICAgICAgIHBhbmRhczogJz49MS40LjAnLFxyXG4gICAgICAgIHRvcmNoOiAnPj0yLjAuMCcsXHJcbiAgICAgIH0sXHJcbiAgICAgIGphdmE6IHt9LFxyXG4gICAgICBnbzoge30sXHJcbiAgICAgIGRvdG5ldDoge30sXHJcbiAgICB9LFxyXG4gICAgZGVwcmVjYXRlZF9wYXR0ZXJuczoge1xyXG4gICAgICBub2RlOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcGF0dGVybjogJ2ZzXFxcXC5leGlzdHNcXFxcKCcsXHJcbiAgICAgICAgICBtZXNzYWdlOiAnZnMuZXhpc3RzKCkgaXMgZGVwcmVjYXRlZCwgdXNlIGZzLmFjY2VzcygpIG9yIGZzLnN0YXQoKScsXHJcbiAgICAgICAgICBhbHRlcm5hdGl2ZTogJ1VzZSBmcy5hY2Nlc3MoKSBvciBmcy5wcm9taXNlcy5hY2Nlc3MoKScsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgcHl0aG9uOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcGF0dGVybjogJ251bXB5XFxcXC5hc3NjYWxhcicsXHJcbiAgICAgICAgICBtZXNzYWdlOiAnbnVtcHkuYXNzY2FsYXIgaXMgZGVwcmVjYXRlZCwgdXNlIGl0ZW0oKSBpbnN0ZWFkJyxcclxuICAgICAgICAgIGFsdGVybmF0aXZlOiAnVXNlIG51bXB5Lml0ZW0oKSBvciBkaXJlY3QgYXJyYXkgaW5kZXhpbmcnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIGphdmE6IFtdLFxyXG4gICAgICBnbzogW10sXHJcbiAgICAgIGRvdG5ldDogW10sXHJcbiAgICB9LFxyXG4gICAgc2Nhbl9maWxlX2V4dHM6IFsnLnB5JywgJy5qcycsICcudHMnLCAnLnRzeCcsICcuanN4JywgJy5qYXZhJywgJy5nbycsICcuY3MnXSxcclxuICAgIGlnbm9yZV9wYXRoczogWycvbm9kZV9tb2R1bGVzLycsICcvLnZlbnYvJywgJy92ZW52LycsICcvZGlzdC8nLCAnL2J1aWxkLycsICcvLmdpdC8nXSxcclxuICAgIG1heF9maWxlX3NpemU6IDIwOTcxNTIsIC8vIDJNQlxyXG4gICAgbWF4X2ZpbGVzOiA1MDAwMCxcclxuICAgIHF1aWNrX2ZpeGVzOiB7XHJcbiAgICAgIGRlcGVuZGVuY3lfdXBncmFkZToge1xyXG4gICAgICAgIG5vZGU6ICducG0gaW5zdGFsbCB7cGFja2FnZX1Ae3ZlcnNpb259JyxcclxuICAgICAgICBweXRob246ICdwaXAgaW5zdGFsbCBcXCd7cGFja2FnZX0+PXt2ZXJzaW9ufVxcJycsXHJcbiAgICAgICAgamF2YTogJ1VwZGF0ZSB7cGFja2FnZX0gdG8gdmVyc2lvbiB7dmVyc2lvbn0gaW4gcG9tLnhtbCBvciBidWlsZC5ncmFkbGUnLFxyXG4gICAgICAgIGdvOiAnZ28gZ2V0IHtwYWNrYWdlfUB7dmVyc2lvbn0nLFxyXG4gICAgICAgIGRvdG5ldDogJ2RvdG5ldCBhZGQgcGFja2FnZSB7cGFja2FnZX0gLS12ZXJzaW9uIHt2ZXJzaW9ufScsXHJcbiAgICAgIH0sXHJcbiAgICAgIHBhdHRlcm5fcmVwbGFjZW1lbnQ6IHtcclxuICAgICAgICBub2RlOiB7XHJcbiAgICAgICAgICAnZnMuZXhpc3RzKCc6ICdVc2UgZnMuYWNjZXNzKCkgb3IgZnMucHJvbWlzZXMuYWNjZXNzKCknLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHl0aG9uOiB7XHJcbiAgICAgICAgICAnbnVtcHkuYXNzY2FsYXInOiAnVXNlIC5pdGVtKCkgbWV0aG9kIGluc3RlYWQnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgamF2YToge30sXHJcbiAgICAgICAgZ286IHt9LFxyXG4gICAgICAgIGRvdG5ldDoge30sXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkIGJhc2VsaW5lIHJ1bGVzIHdpdGggZmFsbGJhY2sgdG8gZGVmYXVsdHNcclxuICogQHBhcmFtIGNvbmZpZ1BhdGggT3B0aW9uYWwgcGF0aCB0byBjb25maWcgZmlsZVxyXG4gKiBAcmV0dXJucyBCYXNlbGluZSBydWxlcyAobG9hZGVkIG9yIGRlZmF1bHQpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEJhc2VsaW5lUnVsZXNXaXRoRmFsbGJhY2soY29uZmlnUGF0aD86IHN0cmluZyk6IFByb21pc2U8QmFzZWxpbmVSdWxlcz4ge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gYXdhaXQgbG9hZEJhc2VsaW5lUnVsZXMoY29uZmlnUGF0aCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGxvYWQgYmFzZWxpbmUgcnVsZXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgICBjb25zb2xlLndhcm4oJ1VzaW5nIGRlZmF1bHQgYmFzZWxpbmUgcnVsZXMnKTtcclxuICAgIHJldHVybiBnZXREZWZhdWx0QmFzZWxpbmVSdWxlcygpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIHRoYXQgYSBydWxlcyBvYmplY3QgaGFzIGFsbCByZXF1aXJlZCBmaWVsZHNcclxuICogQHBhcmFtIHJ1bGVzIFJ1bGVzIG9iamVjdCB0byB2YWxpZGF0ZVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHZhbGlkXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVSdWxlc1N0cnVjdHVyZShydWxlczogdW5rbm93bik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIHRyeSB7XHJcbiAgICB2YWxpZGF0ZUJhc2VsaW5lUnVsZXMocnVsZXMpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHJ1bGVzIGZvciBhIHNwZWNpZmljIGxhbmd1YWdlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgdG8gZ2V0IHJ1bGVzIGZvclxyXG4gKiBAcmV0dXJucyBSdWxlcyBzcGVjaWZpYyB0byB0aGUgbGFuZ3VhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5ndWFnZVJ1bGVzKHJ1bGVzOiBCYXNlbGluZVJ1bGVzLCBsYW5ndWFnZToga2V5b2YgQmFzZWxpbmVSdWxlc1sncGFja2FnZV9taW5zJ10pIHtcclxuICByZXR1cm4ge1xyXG4gICAgcGFja2FnZU1pbnM6IHJ1bGVzLnBhY2thZ2VfbWluc1tsYW5ndWFnZV0gfHwge30sXHJcbiAgICBkZXByZWNhdGVkUGF0dGVybnM6IHJ1bGVzLmRlcHJlY2F0ZWRfcGF0dGVybnNbbGFuZ3VhZ2VdIHx8IFtdLFxyXG4gICAgcnVudGltZTogcnVsZXMubGFuZ3VhZ2VfcnVudGltZXNbbGFuZ3VhZ2VdLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGZpbGUgZXh0ZW5zaW9uIHNob3VsZCBiZSBzY2FubmVkXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gZXh0ZW5zaW9uIEZpbGUgZXh0ZW5zaW9uICh3aXRoIG9yIHdpdGhvdXQgZG90KVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHNob3VsZCBiZSBzY2FubmVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkU2NhbkZpbGUocnVsZXM6IEJhc2VsaW5lUnVsZXMsIGV4dGVuc2lvbjogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgZXh0ID0gZXh0ZW5zaW9uLnN0YXJ0c1dpdGgoJy4nKSA/IGV4dGVuc2lvbiA6IGAuJHtleHRlbnNpb259YDtcclxuICByZXR1cm4gcnVsZXMuc2Nhbl9maWxlX2V4dHMuaW5jbHVkZXMoZXh0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgcGF0aCBzaG91bGQgYmUgaWdub3JlZFxyXG4gKiBAcGFyYW0gcnVsZXMgQmFzZWxpbmUgcnVsZXNcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aCB0byBjaGVja1xyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHNob3VsZCBiZSBpZ25vcmVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkSWdub3JlUGF0aChydWxlczogQmFzZWxpbmVSdWxlcywgZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIGlmICghZmlsZVBhdGggfHwgIXJ1bGVzLmlnbm9yZV9wYXRocykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gcnVsZXMuaWdub3JlX3BhdGhzLnNvbWUoaWdub3JlUGF0aCA9PiBcclxuICAgIGZpbGVQYXRoLmluY2x1ZGVzKGlnbm9yZVBhdGgpIHx8IGZpbGVQYXRoLnN0YXJ0c1dpdGgoaWdub3JlUGF0aClcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHF1aWNrIGZpeCB0ZW1wbGF0ZSBmb3IgZGVwZW5kZW5jeSB1cGdyYWRlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2VcclxuICogQHJldHVybnMgVGVtcGxhdGUgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeVVwZ3JhZGVUZW1wbGF0ZShydWxlczogQmFzZWxpbmVSdWxlcywgbGFuZ3VhZ2U6IGtleW9mIEJhc2VsaW5lUnVsZXNbJ3F1aWNrX2ZpeGVzJ11bJ2RlcGVuZGVuY3lfdXBncmFkZSddKTogc3RyaW5nIHtcclxuICByZXR1cm4gcnVsZXMucXVpY2tfZml4ZXMuZGVwZW5kZW5jeV91cGdyYWRlW2xhbmd1YWdlXSB8fCAnVXBkYXRlIHtwYWNrYWdlfSB0byB7dmVyc2lvbn0nO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHF1aWNrIGZpeCBmb3IgcGF0dGVybiByZXBsYWNlbWVudFxyXG4gKiBAcGFyYW0gcnVsZXMgQmFzZWxpbmUgcnVsZXNcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXHJcbiAqIEBwYXJhbSBwYXR0ZXJuIFBhdHRlcm4gdG8gcmVwbGFjZVxyXG4gKiBAcmV0dXJucyBRdWljayBmaXggc3VnZ2VzdGlvbiBvciB1bmRlZmluZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXR0ZXJuUXVpY2tGaXgoXHJcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXMsIFxyXG4gIGxhbmd1YWdlOiBrZXlvZiBCYXNlbGluZVJ1bGVzWydxdWlja19maXhlcyddWydwYXR0ZXJuX3JlcGxhY2VtZW50J10sIFxyXG4gIHBhdHRlcm46IHN0cmluZ1xyXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gIHJldHVybiBydWxlcy5xdWlja19maXhlcy5wYXR0ZXJuX3JlcGxhY2VtZW50W2xhbmd1YWdlXT8uW3BhdHRlcm5dO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJqb2luIiwiWUFNTCIsInZhbGlkYXRlQmFzZWxpbmVSdWxlcyIsInJ1bGVzQ2FjaGUiLCJydWxlc0NhY2hlVGltZXN0YW1wIiwibG9hZEJhc2VsaW5lUnVsZXMiLCJjb25maWdQYXRoIiwiZGVmYXVsdFBhdGgiLCJwcm9jZXNzIiwiY3dkIiwicGF0aCIsInN0YXRTeW5jIiwic3RhdHMiLCJtdGltZSIsImdldFRpbWUiLCJyZWFkRmlsZVN5bmMiLCJ5YW1sQ29udGVudCIsInJhd1J1bGVzIiwicGFyc2UiLCJydWxlcyIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiZ2V0Q2FjaGVkQmFzZWxpbmVSdWxlcyIsImNsZWFyUnVsZXNDYWNoZSIsImlzUnVsZXNDYWNoZVZhbGlkIiwiZ2V0RGVmYXVsdEJhc2VsaW5lUnVsZXMiLCJsYW5ndWFnZV9ydW50aW1lcyIsIm5vZGUiLCJweXRob24iLCJqYXZhIiwiZ28iLCJkb3RuZXQiLCJwYWNrYWdlX21pbnMiLCJyZWFjdCIsIm5leHQiLCJleHByZXNzIiwibnVtcHkiLCJwYW5kYXMiLCJ0b3JjaCIsImRlcHJlY2F0ZWRfcGF0dGVybnMiLCJwYXR0ZXJuIiwiYWx0ZXJuYXRpdmUiLCJzY2FuX2ZpbGVfZXh0cyIsImlnbm9yZV9wYXRocyIsIm1heF9maWxlX3NpemUiLCJtYXhfZmlsZXMiLCJxdWlja19maXhlcyIsImRlcGVuZGVuY3lfdXBncmFkZSIsInBhdHRlcm5fcmVwbGFjZW1lbnQiLCJsb2FkQmFzZWxpbmVSdWxlc1dpdGhGYWxsYmFjayIsImNvbnNvbGUiLCJ3YXJuIiwidmFsaWRhdGVSdWxlc1N0cnVjdHVyZSIsImdldExhbmd1YWdlUnVsZXMiLCJsYW5ndWFnZSIsInBhY2thZ2VNaW5zIiwiZGVwcmVjYXRlZFBhdHRlcm5zIiwicnVudGltZSIsInNob3VsZFNjYW5GaWxlIiwiZXh0ZW5zaW9uIiwiZXh0Iiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwic2hvdWxkSWdub3JlUGF0aCIsImZpbGVQYXRoIiwic29tZSIsImlnbm9yZVBhdGgiLCJnZXREZXBlbmRlbmN5VXBncmFkZVRlbXBsYXRlIiwiZ2V0UGF0dGVyblF1aWNrRml4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/baseline.loader.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/baseline.types.ts":
/*!****************************************!*\
  !*** ./lib/analysis/baseline.types.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalysisContextSchema: () => (/* binding */ AnalysisContextSchema),\n/* harmony export */   AnalysisErrorSchema: () => (/* binding */ AnalysisErrorSchema),\n/* harmony export */   AnalyzeResponseSchema: () => (/* binding */ AnalyzeResponseSchema),\n/* harmony export */   BaselineRulesSchema: () => (/* binding */ BaselineRulesSchema),\n/* harmony export */   DependencyFindingSchema: () => (/* binding */ DependencyFindingSchema),\n/* harmony export */   DeprecatedPatternSchema: () => (/* binding */ DeprecatedPatternSchema),\n/* harmony export */   ExtractedFileSchema: () => (/* binding */ ExtractedFileSchema),\n/* harmony export */   FindingSchema: () => (/* binding */ FindingSchema),\n/* harmony export */   LanguageRuntimesSchema: () => (/* binding */ LanguageRuntimesSchema),\n/* harmony export */   LanguageSchema: () => (/* binding */ LanguageSchema),\n/* harmony export */   LanguageSummarySchema: () => (/* binding */ LanguageSummarySchema),\n/* harmony export */   PackageMinsSchema: () => (/* binding */ PackageMinsSchema),\n/* harmony export */   PatternFindingSchema: () => (/* binding */ PatternFindingSchema),\n/* harmony export */   ProjectManifestSchema: () => (/* binding */ ProjectManifestSchema),\n/* harmony export */   QuickFixesSchema: () => (/* binding */ QuickFixesSchema),\n/* harmony export */   ReportSchema: () => (/* binding */ ReportSchema),\n/* harmony export */   ReportSummarySchema: () => (/* binding */ ReportSummarySchema),\n/* harmony export */   StatusSchema: () => (/* binding */ StatusSchema),\n/* harmony export */   getStatusBadgeClass: () => (/* binding */ getStatusBadgeClass),\n/* harmony export */   getStatusColor: () => (/* binding */ getStatusColor),\n/* harmony export */   getStatusIcon: () => (/* binding */ getStatusIcon),\n/* harmony export */   isDependencyFinding: () => (/* binding */ isDependencyFinding),\n/* harmony export */   isPatternFinding: () => (/* binding */ isPatternFinding),\n/* harmony export */   validateAnalyzeResponse: () => (/* binding */ validateAnalyzeResponse),\n/* harmony export */   validateBaselineRules: () => (/* binding */ validateBaselineRules),\n/* harmony export */   validateFinding: () => (/* binding */ validateFinding),\n/* harmony export */   validateReport: () => (/* binding */ validateReport)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n\n// Language types\nconst LanguageSchema = zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n    'python',\n    'node',\n    'java',\n    'go',\n    'dotnet'\n]);\n// Status types\nconst StatusSchema = zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n    'ok',\n    'affected',\n    'unknown'\n]);\n// Finding types\nconst DependencyFindingSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    kind: zod__WEBPACK_IMPORTED_MODULE_0__.literal('dependency'),\n    lang: LanguageSchema,\n    component: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    foundVersion: zod__WEBPACK_IMPORTED_MODULE_0__.string().nullable(),\n    baselineRequired: zod__WEBPACK_IMPORTED_MODULE_0__.string().nullable(),\n    status: StatusSchema,\n    reason: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    file: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    quickFix: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n});\nconst PatternFindingSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    kind: zod__WEBPACK_IMPORTED_MODULE_0__.literal('pattern'),\n    lang: LanguageSchema,\n    file: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    line: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    status: zod__WEBPACK_IMPORTED_MODULE_0__.literal('affected'),\n    reason: zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n        'deprecated-api',\n        'code-quality',\n        'security',\n        'performance'\n    ]),\n    issue: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    pattern: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    quickFix: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n});\nconst FindingSchema = zod__WEBPACK_IMPORTED_MODULE_0__.discriminatedUnion('kind', [\n    DependencyFindingSchema,\n    PatternFindingSchema\n]);\n// Summary types\nconst LanguageSummarySchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    ok: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    affected: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    unknown: zod__WEBPACK_IMPORTED_MODULE_0__.number()\n});\nconst ReportSummarySchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    ok: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    affected: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    unknown: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    byLanguage: zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, LanguageSummarySchema)\n});\n// Report type\nconst ReportSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    findings: zod__WEBPACK_IMPORTED_MODULE_0__.array(FindingSchema),\n    summary: ReportSummarySchema,\n    metadata: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        analysisId: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n        timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n        projectName: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n        detectedLanguages: zod__WEBPACK_IMPORTED_MODULE_0__.array(LanguageSchema),\n        totalFiles: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n        scannedFiles: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n        skippedFiles: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n        groqAnalysis: zod__WEBPACK_IMPORTED_MODULE_0__.array(zod__WEBPACK_IMPORTED_MODULE_0__.object({\n            analysis: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n            filename: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n            timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string()\n        })).optional()\n    })\n});\n// Rules configuration types\nconst DeprecatedPatternSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    pattern: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    message: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    alternative: zod__WEBPACK_IMPORTED_MODULE_0__.string()\n});\nconst PackageMinsSchema = zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()));\nconst LanguageRuntimesSchema = zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.string());\nconst QuickFixesSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    dependency_upgrade: zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.string()),\n    pattern_replacement: zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()))\n});\nconst BaselineRulesSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    language_runtimes: LanguageRuntimesSchema,\n    package_mins: PackageMinsSchema,\n    deprecated_patterns: zod__WEBPACK_IMPORTED_MODULE_0__.record(LanguageSchema, zod__WEBPACK_IMPORTED_MODULE_0__.array(DeprecatedPatternSchema)),\n    scan_file_exts: zod__WEBPACK_IMPORTED_MODULE_0__.array(zod__WEBPACK_IMPORTED_MODULE_0__.string()),\n    ignore_paths: zod__WEBPACK_IMPORTED_MODULE_0__.array(zod__WEBPACK_IMPORTED_MODULE_0__.string()),\n    max_file_size: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    max_files: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    quick_fixes: QuickFixesSchema\n});\n// API types\nconst AnalyzeResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    analysisId: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    summary: ReportSummarySchema,\n    artifacts: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        jsonUrl: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n        csvUrl: zod__WEBPACK_IMPORTED_MODULE_0__.string()\n    }),\n    report: ReportSchema.optional()\n});\n// Project detection types\nconst ProjectManifestSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    language: LanguageSchema,\n    file: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    dependencies: zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()).optional(),\n    devDependencies: zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()).optional(),\n    peerDependencies: zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()).optional(),\n    optionalDependencies: zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.string(), zod__WEBPACK_IMPORTED_MODULE_0__.string()).optional()\n});\n// File processing types\nconst ExtractedFileSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    path: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    content: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    size: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    language: LanguageSchema.optional()\n});\n// Analysis context types\nconst AnalysisContextSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    rules: BaselineRulesSchema,\n    extractedFiles: zod__WEBPACK_IMPORTED_MODULE_0__.array(ExtractedFileSchema),\n    manifests: zod__WEBPACK_IMPORTED_MODULE_0__.array(ProjectManifestSchema),\n    detectedLanguages: zod__WEBPACK_IMPORTED_MODULE_0__.array(LanguageSchema)\n});\n// Error types\nconst AnalysisErrorSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    code: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    message: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    details: zod__WEBPACK_IMPORTED_MODULE_0__.any().optional()\n});\n// Validation helpers\nfunction validateFinding(finding) {\n    return FindingSchema.parse(finding);\n}\nfunction validateReport(report) {\n    return ReportSchema.parse(report);\n}\nfunction validateBaselineRules(rules) {\n    return BaselineRulesSchema.parse(rules);\n}\nfunction validateAnalyzeResponse(response) {\n    return AnalyzeResponseSchema.parse(response);\n}\n// Type guards\nfunction isDependencyFinding(finding) {\n    return finding.kind === 'dependency';\n}\nfunction isPatternFinding(finding) {\n    return finding.kind === 'pattern';\n}\n// Status helpers\nfunction getStatusIcon(status) {\n    switch(status){\n        case 'ok':\n            return '✅';\n        case 'affected':\n            return '⚠️';\n        case 'unknown':\n            return '❓';\n        default:\n            return '❓';\n    }\n}\nfunction getStatusColor(status) {\n    switch(status){\n        case 'ok':\n            return 'text-green-600';\n        case 'affected':\n            return 'text-yellow-600';\n        case 'unknown':\n            return 'text-gray-600';\n        default:\n            return 'text-gray-600';\n    }\n}\nfunction getStatusBadgeClass(status) {\n    switch(status){\n        case 'ok':\n            return 'bg-green-100 text-green-800';\n        case 'affected':\n            return 'bg-yellow-100 text-yellow-800';\n        case 'unknown':\n            return 'bg-gray-100 text-gray-800';\n        default:\n            return 'bg-gray-100 text-gray-800';\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvYW5hbHlzaXMvYmFzZWxpbmUudHlwZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUV4QixpQkFBaUI7QUFDVixNQUFNQyxpQkFBaUJELHdDQUFNLENBQUM7SUFBQztJQUFVO0lBQVE7SUFBUTtJQUFNO0NBQVMsRUFBRTtBQUdqRixlQUFlO0FBQ1IsTUFBTUcsZUFBZUgsd0NBQU0sQ0FBQztJQUFDO0lBQU07SUFBWTtDQUFVLEVBQUU7QUFHbEUsZ0JBQWdCO0FBQ1QsTUFBTUksMEJBQTBCSix1Q0FBUSxDQUFDO0lBQzlDTSxNQUFNTix3Q0FBUyxDQUFDO0lBQ2hCUSxNQUFNUDtJQUNOUSxXQUFXVCx1Q0FBUTtJQUNuQlcsY0FBY1gsdUNBQVEsR0FBR1ksUUFBUTtJQUNqQ0Msa0JBQWtCYix1Q0FBUSxHQUFHWSxRQUFRO0lBQ3JDRSxRQUFRWDtJQUNSWSxRQUFRZix1Q0FBUTtJQUNoQmdCLE1BQU1oQix1Q0FBUTtJQUNkaUIsVUFBVWpCLHVDQUFRLEdBQUdrQixRQUFRO0FBQy9CLEdBQUc7QUFFSSxNQUFNQyx1QkFBdUJuQix1Q0FBUSxDQUFDO0lBQzNDTSxNQUFNTix3Q0FBUyxDQUFDO0lBQ2hCUSxNQUFNUDtJQUNOZSxNQUFNaEIsdUNBQVE7SUFDZG9CLE1BQU1wQix1Q0FBUTtJQUNkYyxRQUFRZCx3Q0FBUyxDQUFDO0lBQ2xCZSxRQUFRZix3Q0FBTSxDQUFDO1FBQUM7UUFBa0I7UUFBZ0I7UUFBWTtLQUFjO0lBQzVFc0IsT0FBT3RCLHVDQUFRO0lBQ2Z1QixTQUFTdkIsdUNBQVE7SUFDakJpQixVQUFVakIsdUNBQVEsR0FBR2tCLFFBQVE7QUFDL0IsR0FBRztBQUVJLE1BQU1NLGdCQUFnQnhCLG1EQUFvQixDQUFDLFFBQVE7SUFDeERJO0lBQ0FlO0NBQ0QsRUFBRTtBQU1ILGdCQUFnQjtBQUNULE1BQU1PLHdCQUF3QjFCLHVDQUFRLENBQUM7SUFDNUMyQixJQUFJM0IsdUNBQVE7SUFD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Q0Y7QUFFTyxTQUFTb0YsZUFBZXBGLE1BQWM7SUFDM0MsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUNFLE9BQU87SUFDWDtBQUNGO0FBRU8sU0FBU3FGLG9CQUFvQnJGLE1BQWM7SUFDaEQsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUNFLE9BQU87SUFDWDtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxiYXNlbGluZS50eXBlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcblxuLy8gTGFuZ3VhZ2UgdHlwZXNcbmV4cG9ydCBjb25zdCBMYW5ndWFnZVNjaGVtYSA9IHouZW51bShbJ3B5dGhvbicsICdub2RlJywgJ2phdmEnLCAnZ28nLCAnZG90bmV0J10pO1xuZXhwb3J0IHR5cGUgTGFuZ3VhZ2UgPSB6LmluZmVyPHR5cGVvZiBMYW5ndWFnZVNjaGVtYT47XG5cbi8vIFN0YXR1cyB0eXBlc1xuZXhwb3J0IGNvbnN0IFN0YXR1c1NjaGVtYSA9IHouZW51bShbJ29rJywgJ2FmZmVjdGVkJywgJ3Vua25vd24nXSk7XG5leHBvcnQgdHlwZSBTdGF0dXMgPSB6LmluZmVyPHR5cGVvZiBTdGF0dXNTY2hlbWE+O1xuXG4vLyBGaW5kaW5nIHR5cGVzXG5leHBvcnQgY29uc3QgRGVwZW5kZW5jeUZpbmRpbmdTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGtpbmQ6IHoubGl0ZXJhbCgnZGVwZW5kZW5jeScpLFxuICBsYW5nOiBMYW5ndWFnZVNjaGVtYSxcbiAgY29tcG9uZW50OiB6LnN0cmluZygpLFxuICBmb3VuZFZlcnNpb246IHouc3RyaW5nKCkubnVsbGFibGUoKSxcbiAgYmFzZWxpbmVSZXF1aXJlZDogei5zdHJpbmcoKS5udWxsYWJsZSgpLFxuICBzdGF0dXM6IFN0YXR1c1NjaGVtYSxcbiAgcmVhc29uOiB6LnN0cmluZygpLFxuICBmaWxlOiB6LnN0cmluZygpLFxuICBxdWlja0ZpeDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG5cbmV4cG9ydCBjb25zdCBQYXR0ZXJuRmluZGluZ1NjaGVtYSA9IHoub2JqZWN0KHtcbiAga2luZDogei5saXRlcmFsKCdwYXR0ZXJuJyksXG4gIGxhbmc6IExhbmd1YWdlU2NoZW1hLFxuICBmaWxlOiB6LnN0cmluZygpLFxuICBsaW5lOiB6Lm51bWJlcigpLFxuICBzdGF0dXM6IHoubGl0ZXJhbCgnYWZmZWN0ZWQnKSxcbiAgcmVhc29uOiB6LmVudW0oWydkZXByZWNhdGVkLWFwaScsICdjb2RlLXF1YWxpdHknLCAnc2VjdXJpdHknLCAncGVyZm9ybWFuY2UnXSksXG4gIGlzc3VlOiB6LnN0cmluZygpLFxuICBwYXR0ZXJuOiB6LnN0cmluZygpLFxuICBxdWlja0ZpeDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG5cbmV4cG9ydCBjb25zdCBGaW5kaW5nU2NoZW1hID0gei5kaXNjcmltaW5hdGVkVW5pb24oJ2tpbmQnLCBbXG4gIERlcGVuZGVuY3lGaW5kaW5nU2NoZW1hLFxuICBQYXR0ZXJuRmluZGluZ1NjaGVtYSxcbl0pO1xuXG5leHBvcnQgdHlwZSBEZXBlbmRlbmN5RmluZGluZyA9IHouaW5mZXI8dHlwZW9mIERlcGVuZGVuY3lGaW5kaW5nU2NoZW1hPjtcbmV4cG9ydCB0eXBlIFBhdHRlcm5GaW5kaW5nID0gei5pbmZlcjx0eXBlb2YgUGF0dGVybkZpbmRpbmdTY2hlbWE+O1xuZXhwb3J0IHR5cGUgRmluZGluZyA9IHouaW5mZXI8dHlwZW9mIEZpbmRpbmdTY2hlbWE+O1xuXG4vLyBTdW1tYXJ5IHR5cGVzXG5leHBvcnQgY29uc3QgTGFuZ3VhZ2VTdW1tYXJ5U2NoZW1hID0gei5vYmplY3Qoe1xuICBvazogei5udW1iZXIoKSxcbiAgYWZmZWN0ZWQ6IHoubnVtYmVyKCksXG4gIHVua25vd246IHoubnVtYmVyKCksXG59KTtcblxuZXhwb3J0IGNvbnN0IFJlcG9ydFN1bW1hcnlTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIG9rOiB6Lm51bWJlcigpLFxuICBhZmZlY3RlZDogei5udW1iZXIoKSxcbiAgdW5rbm93bjogei5udW1iZXIoKSxcbiAgYnlMYW5ndWFnZTogei5yZWNvcmQoTGFuZ3VhZ2VTY2hlbWEsIExhbmd1YWdlU3VtbWFyeVNjaGVtYSksXG59KTtcblxuLy8gUmVwb3J0IHR5cGVcbmV4cG9ydCBjb25zdCBSZXBvcnRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGZpbmRpbmdzOiB6LmFycmF5KEZpbmRpbmdTY2hlbWEpLFxuICBzdW1tYXJ5OiBSZXBvcnRTdW1tYXJ5U2NoZW1hLFxuICBtZXRhZGF0YTogei5vYmplY3Qoe1xuICAgIGFuYWx5c2lzSWQ6IHouc3RyaW5nKCksXG4gICAgdGltZXN0YW1wOiB6LnN0cmluZygpLFxuICAgIHByb2plY3ROYW1lOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgZGV0ZWN0ZWRMYW5ndWFnZXM6IHouYXJyYXkoTGFuZ3VhZ2VTY2hlbWEpLFxuICAgIHRvdGFsRmlsZXM6IHoubnVtYmVyKCksXG4gICAgc2Nhbm5lZEZpbGVzOiB6Lm51bWJlcigpLFxuICAgIHNraXBwZWRGaWxlczogei5udW1iZXIoKSxcbiAgICBncm9xQW5hbHlzaXM6IHouYXJyYXkoei5vYmplY3Qoe1xuICAgICAgYW5hbHlzaXM6IHouc3RyaW5nKCksXG4gICAgICBmaWxlbmFtZTogei5zdHJpbmcoKSxcbiAgICAgIHRpbWVzdGFtcDogei5zdHJpbmcoKSxcbiAgICB9KSkub3B0aW9uYWwoKSxcbiAgfSksXG59KTtcblxuZXhwb3J0IHR5cGUgTGFuZ3VhZ2VTdW1tYXJ5ID0gei5pbmZlcjx0eXBlb2YgTGFuZ3VhZ2VTdW1tYXJ5U2NoZW1hPjtcbmV4cG9ydCB0eXBlIFJlcG9ydFN1bW1hcnkgPSB6LmluZmVyPHR5cGVvZiBSZXBvcnRTdW1tYXJ5U2NoZW1hPjtcbmV4cG9ydCB0eXBlIFJlcG9ydCA9IHouaW5mZXI8dHlwZW9mIFJlcG9ydFNjaGVtYT47XG5cbi8vIFJ1bGVzIGNvbmZpZ3VyYXRpb24gdHlwZXNcbmV4cG9ydCBjb25zdCBEZXByZWNhdGVkUGF0dGVyblNjaGVtYSA9IHoub2JqZWN0KHtcbiAgcGF0dGVybjogei5zdHJpbmcoKSxcbiAgbWVzc2FnZTogei5zdHJpbmcoKSxcbiAgYWx0ZXJuYXRpdmU6IHouc3RyaW5nKCksXG59KTtcblxuZXhwb3J0IGNvbnN0IFBhY2thZ2VNaW5zU2NoZW1hID0gei5yZWNvcmQoTGFuZ3VhZ2VTY2hlbWEsIHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpKTtcblxuZXhwb3J0IGNvbnN0IExhbmd1YWdlUnVudGltZXNTY2hlbWEgPSB6LnJlY29yZChMYW5ndWFnZVNjaGVtYSwgei5zdHJpbmcoKSk7XG5cbmV4cG9ydCBjb25zdCBRdWlja0ZpeGVzU2NoZW1hID0gei5vYmplY3Qoe1xuICBkZXBlbmRlbmN5X3VwZ3JhZGU6IHoucmVjb3JkKExhbmd1YWdlU2NoZW1hLCB6LnN0cmluZygpKSxcbiAgcGF0dGVybl9yZXBsYWNlbWVudDogei5yZWNvcmQoTGFuZ3VhZ2VTY2hlbWEsIHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpKSxcbn0pO1xuXG5leHBvcnQgY29uc3QgQmFzZWxpbmVSdWxlc1NjaGVtYSA9IHoub2JqZWN0KHtcbiAgbGFuZ3VhZ2VfcnVudGltZXM6IExhbmd1YWdlUnVudGltZXNTY2hlbWEsXG4gIHBhY2thZ2VfbWluczogUGFja2FnZU1pbnNTY2hlbWEsXG4gIGRlcHJlY2F0ZWRfcGF0dGVybnM6IHoucmVjb3JkKExhbmd1YWdlU2NoZW1hLCB6LmFycmF5KERlcHJlY2F0ZWRQYXR0ZXJuU2NoZW1hKSksXG4gIHNjYW5fZmlsZV9leHRzOiB6LmFycmF5KHouc3RyaW5nKCkpLFxuICBpZ25vcmVfcGF0aHM6IHouYXJyYXkoei5zdHJpbmcoKSksXG4gIG1heF9maWxlX3NpemU6IHoubnVtYmVyKCksXG4gIG1heF9maWxlczogei5udW1iZXIoKSxcbiAgcXVpY2tfZml4ZXM6IFF1aWNrRml4ZXNTY2hlbWEsXG59KTtcblxuZXhwb3J0IHR5cGUgRGVwcmVjYXRlZFBhdHRlcm4gPSB6LmluZmVyPHR5cGVvZiBEZXByZWNhdGVkUGF0dGVyblNjaGVtYT47XG5leHBvcnQgdHlwZSBQYWNrYWdlTWlucyA9IHouaW5mZXI8dHlwZW9mIFBhY2thZ2VNaW5zU2NoZW1hPjtcbmV4cG9ydCB0eXBlIExhbmd1YWdlUnVudGltZXMgPSB6LmluZmVyPHR5cGVvZiBMYW5ndWFnZVJ1bnRpbWVzU2NoZW1hPjtcbmV4cG9ydCB0eXBlIFF1aWNrRml4ZXMgPSB6LmluZmVyPHR5cGVvZiBRdWlja0ZpeGVzU2NoZW1hPjtcbmV4cG9ydCB0eXBlIEJhc2VsaW5lUnVsZXMgPSB6LmluZmVyPHR5cGVvZiBCYXNlbGluZVJ1bGVzU2NoZW1hPjtcblxuLy8gQVBJIHR5cGVzXG5leHBvcnQgY29uc3QgQW5hbHl6ZVJlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xuICBhbmFseXNpc0lkOiB6LnN0cmluZygpLFxuICBzdW1tYXJ5OiBSZXBvcnRTdW1tYXJ5U2NoZW1hLFxuICBhcnRpZmFjdHM6IHoub2JqZWN0KHtcbiAgICBqc29uVXJsOiB6LnN0cmluZygpLFxuICAgIGNzdlVybDogei5zdHJpbmcoKSxcbiAgfSksXG4gIHJlcG9ydDogUmVwb3J0U2NoZW1hLm9wdGlvbmFsKCksXG59KTtcblxuZXhwb3J0IHR5cGUgQW5hbHl6ZVJlc3BvbnNlID0gei5pbmZlcjx0eXBlb2YgQW5hbHl6ZVJlc3BvbnNlU2NoZW1hPjtcblxuLy8gUHJvamVjdCBkZXRlY3Rpb24gdHlwZXNcbmV4cG9ydCBjb25zdCBQcm9qZWN0TWFuaWZlc3RTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGxhbmd1YWdlOiBMYW5ndWFnZVNjaGVtYSxcbiAgZmlsZTogei5zdHJpbmcoKSxcbiAgZGVwZW5kZW5jaWVzOiB6LnJlY29yZCh6LnN0cmluZygpLCB6LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICBkZXZEZXBlbmRlbmNpZXM6IHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gIHBlZXJEZXBlbmRlbmNpZXM6IHoucmVjb3JkKHouc3RyaW5nKCksIHouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gIG9wdGlvbmFsRGVwZW5kZW5jaWVzOiB6LnJlY29yZCh6LnN0cmluZygpLCB6LnN0cmluZygpKS5vcHRpb25hbCgpLFxufSk7XG5cbmV4cG9ydCB0eXBlIFByb2plY3RNYW5pZmVzdCA9IHouaW5mZXI8dHlwZW9mIFByb2plY3RNYW5pZmVzdFNjaGVtYT47XG5cbi8vIEZpbGUgcHJvY2Vzc2luZyB0eXBlc1xuZXhwb3J0IGNvbnN0IEV4dHJhY3RlZEZpbGVTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHBhdGg6IHouc3RyaW5nKCksXG4gIGNvbnRlbnQ6IHouc3RyaW5nKCksXG4gIHNpemU6IHoubnVtYmVyKCksXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVNjaGVtYS5vcHRpb25hbCgpLFxufSk7XG5cbmV4cG9ydCB0eXBlIEV4dHJhY3RlZEZpbGUgPSB6LmluZmVyPHR5cGVvZiBFeHRyYWN0ZWRGaWxlU2NoZW1hPjtcblxuLy8gQW5hbHlzaXMgY29udGV4dCB0eXBlc1xuZXhwb3J0IGNvbnN0IEFuYWx5c2lzQ29udGV4dFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNTY2hlbWEsXG4gIGV4dHJhY3RlZEZpbGVzOiB6LmFycmF5KEV4dHJhY3RlZEZpbGVTY2hlbWEpLFxuICBtYW5pZmVzdHM6IHouYXJyYXkoUHJvamVjdE1hbmlmZXN0U2NoZW1hKSxcbiAgZGV0ZWN0ZWRMYW5ndWFnZXM6IHouYXJyYXkoTGFuZ3VhZ2VTY2hlbWEpLFxufSk7XG5cbmV4cG9ydCB0eXBlIEFuYWx5c2lzQ29udGV4dCA9IHouaW5mZXI8dHlwZW9mIEFuYWx5c2lzQ29udGV4dFNjaGVtYT47XG5cbi8vIEVycm9yIHR5cGVzXG5leHBvcnQgY29uc3QgQW5hbHlzaXNFcnJvclNjaGVtYSA9IHoub2JqZWN0KHtcbiAgY29kZTogei5zdHJpbmcoKSxcbiAgbWVzc2FnZTogei5zdHJpbmcoKSxcbiAgZGV0YWlsczogei5hbnkoKS5vcHRpb25hbCgpLFxufSk7XG5cbmV4cG9ydCB0eXBlIEFuYWx5c2lzRXJyb3IgPSB6LmluZmVyPHR5cGVvZiBBbmFseXNpc0Vycm9yU2NoZW1hPjtcblxuLy8gVXRpbGl0eSB0eXBlcyBmb3IgVUlcbmV4cG9ydCBpbnRlcmZhY2UgRmlsdGVyT3B0aW9ucyB7XG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2U7XG4gIHN0YXR1cz86IFN0YXR1cztcbiAgc2VhcmNoVGV4dD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb3J0T3B0aW9ucyB7XG4gIGZpZWxkOiAnY29tcG9uZW50JyB8ICdmaWxlJyB8ICdzdGF0dXMnIHwgJ3JlYXNvbic7XG4gIGRpcmVjdGlvbjogJ2FzYycgfCAnZGVzYyc7XG59XG5cbi8vIENTViBleHBvcnQgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgQ1NWUm93IHtcbiAgS2luZDogc3RyaW5nO1xuICBMYW5ndWFnZTogc3RyaW5nO1xuICBDb21wb25lbnQ6IHN0cmluZztcbiAgRmlsZTogc3RyaW5nO1xuICBMaW5lOiBzdHJpbmc7XG4gIFN0YXR1czogc3RyaW5nO1xuICBSZWFzb246IHN0cmluZztcbiAgJ1F1aWNrIEZpeCc6IHN0cmluZztcbiAgJ0ZvdW5kIFZlcnNpb24nOiBzdHJpbmc7XG4gICdSZXF1aXJlZCBWZXJzaW9uJzogc3RyaW5nO1xufVxuXG4vLyBWYWxpZGF0aW9uIGhlbHBlcnNcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpbmRpbmcoZmluZGluZzogdW5rbm93bik6IEZpbmRpbmcge1xuICByZXR1cm4gRmluZGluZ1NjaGVtYS5wYXJzZShmaW5kaW5nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVwb3J0KHJlcG9ydDogdW5rbm93bik6IFJlcG9ydCB7XG4gIHJldHVybiBSZXBvcnRTY2hlbWEucGFyc2UocmVwb3J0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzZWxpbmVSdWxlcyhydWxlczogdW5rbm93bik6IEJhc2VsaW5lUnVsZXMge1xuICByZXR1cm4gQmFzZWxpbmVSdWxlc1NjaGVtYS5wYXJzZShydWxlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFuYWx5emVSZXNwb25zZShyZXNwb25zZTogdW5rbm93bik6IEFuYWx5emVSZXNwb25zZSB7XG4gIHJldHVybiBBbmFseXplUmVzcG9uc2VTY2hlbWEucGFyc2UocmVzcG9uc2UpO1xufVxuXG4vLyBUeXBlIGd1YXJkc1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVwZW5kZW5jeUZpbmRpbmcoZmluZGluZzogRmluZGluZyk6IGZpbmRpbmcgaXMgRGVwZW5kZW5jeUZpbmRpbmcge1xuICByZXR1cm4gZmluZGluZy5raW5kID09PSAnZGVwZW5kZW5jeSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdHRlcm5GaW5kaW5nKGZpbmRpbmc6IEZpbmRpbmcpOiBmaW5kaW5nIGlzIFBhdHRlcm5GaW5kaW5nIHtcbiAgcmV0dXJuIGZpbmRpbmcua2luZCA9PT0gJ3BhdHRlcm4nO1xufVxuXG4vLyBTdGF0dXMgaGVscGVyc1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXR1c0ljb24oc3RhdHVzOiBTdGF0dXMpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgJ29rJzpcbiAgICAgIHJldHVybiAn4pyFJztcbiAgICBjYXNlICdhZmZlY3RlZCc6XG4gICAgICByZXR1cm4gJ+KaoO+4jyc7XG4gICAgY2FzZSAndW5rbm93bic6XG4gICAgICByZXR1cm4gJ+Kdkyc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAn4p2TJztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdHVzQ29sb3Ioc3RhdHVzOiBTdGF0dXMpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgJ29rJzpcbiAgICAgIHJldHVybiAndGV4dC1ncmVlbi02MDAnO1xuICAgIGNhc2UgJ2FmZmVjdGVkJzpcbiAgICAgIHJldHVybiAndGV4dC15ZWxsb3ctNjAwJztcbiAgICBjYXNlICd1bmtub3duJzpcbiAgICAgIHJldHVybiAndGV4dC1ncmF5LTYwMCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAndGV4dC1ncmF5LTYwMCc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXR1c0JhZGdlQ2xhc3Moc3RhdHVzOiBTdGF0dXMpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgJ29rJzpcbiAgICAgIHJldHVybiAnYmctZ3JlZW4tMTAwIHRleHQtZ3JlZW4tODAwJztcbiAgICBjYXNlICdhZmZlY3RlZCc6XG4gICAgICByZXR1cm4gJ2JnLXllbGxvdy0xMDAgdGV4dC15ZWxsb3ctODAwJztcbiAgICBjYXNlICd1bmtub3duJzpcbiAgICAgIHJldHVybiAnYmctZ3JheS0xMDAgdGV4dC1ncmF5LTgwMCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnYmctZ3JheS0xMDAgdGV4dC1ncmF5LTgwMCc7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ6IiwiTGFuZ3VhZ2VTY2hlbWEiLCJlbnVtIiwiU3RhdHVzU2NoZW1hIiwiRGVwZW5kZW5jeUZpbmRpbmdTY2hlbWEiLCJvYmplY3QiLCJraW5kIiwibGl0ZXJhbCIsImxhbmciLCJjb21wb25lbnQiLCJzdHJpbmciLCJmb3VuZFZlcnNpb24iLCJudWxsYWJsZSIsImJhc2VsaW5lUmVxdWlyZWQiLCJzdGF0dXMiLCJyZWFzb24iLCJmaWxlIiwicXVpY2tGaXgiLCJvcHRpb25hbCIsIlBhdHRlcm5GaW5kaW5nU2NoZW1hIiwibGluZSIsIm51bWJlciIsImlzc3VlIiwicGF0dGVybiIsIkZpbmRpbmdTY2hlbWEiLCJkaXNjcmltaW5hdGVkVW5pb24iLCJMYW5ndWFnZVN1bW1hcnlTY2hlbWEiLCJvayIsImFmZmVjdGVkIiwidW5rbm93biIsIlJlcG9ydFN1bW1hcnlTY2hlbWEiLCJieUxhbmd1YWdlIiwicmVjb3JkIiwiUmVwb3J0U2NoZW1hIiwiZmluZGluZ3MiLCJhcnJheSIsInN1bW1hcnkiLCJtZXRhZGF0YSIsImFuYWx5c2lzSWQiLCJ0aW1lc3RhbXAiLCJwcm9qZWN0TmFtZSIsImRldGVjdGVkTGFuZ3VhZ2VzIiwidG90YWxGaWxlcyIsInNjYW5uZWRGaWxlcyIsInNraXBwZWRGaWxlcyIsImdyb3FBbmFseXNpcyIsImFuYWx5c2lzIiwiZmlsZW5hbWUiLCJEZXByZWNhdGVkUGF0dGVyblNjaGVtYSIsIm1lc3NhZ2UiLCJhbHRlcm5hdGl2ZSIsIlBhY2thZ2VNaW5zU2NoZW1hIiwiTGFuZ3VhZ2VSdW50aW1lc1NjaGVtYSIsIlF1aWNrRml4ZXNTY2hlbWEiLCJkZXBlbmRlbmN5X3VwZ3JhZGUiLCJwYXR0ZXJuX3JlcGxhY2VtZW50IiwiQmFzZWxpbmVSdWxlc1NjaGVtYSIsImxhbmd1YWdlX3J1bnRpbWVzIiwicGFja2FnZV9taW5zIiwiZGVwcmVjYXRlZF9wYXR0ZXJucyIsInNjYW5fZmlsZV9leHRzIiwiaWdub3JlX3BhdGhzIiwibWF4X2ZpbGVfc2l6ZSIsIm1heF9maWxlcyIsInF1aWNrX2ZpeGVzIiwiQW5hbHl6ZVJlc3BvbnNlU2NoZW1hIiwiYXJ0aWZhY3RzIiwianNvblVybCIsImNzdlVybCIsInJlcG9ydCIsIlByb2plY3RNYW5pZmVzdFNjaGVtYSIsImxhbmd1YWdlIiwiZGVwZW5kZW5jaWVzIiwiZGV2RGVwZW5kZW5jaWVzIiwicGVlckRlcGVuZGVuY2llcyIsIm9wdGlvbmFsRGVwZW5kZW5jaWVzIiwiRXh0cmFjdGVkRmlsZVNjaGVtYSIsInBhdGgiLCJjb250ZW50Iiwic2l6ZSIsIkFuYWx5c2lzQ29udGV4dFNjaGVtYSIsInJ1bGVzIiwiZXh0cmFjdGVkRmlsZXMiLCJtYW5pZmVzdHMiLCJBbmFseXNpc0Vycm9yU2NoZW1hIiwiY29kZSIsImRldGFpbHMiLCJhbnkiLCJ2YWxpZGF0ZUZpbmRpbmciLCJmaW5kaW5nIiwicGFyc2UiLCJ2YWxpZGF0ZVJlcG9ydCIsInZhbGlkYXRlQmFzZWxpbmVSdWxlcyIsInZhbGlkYXRlQW5hbHl6ZVJlc3BvbnNlIiwicmVzcG9uc2UiLCJpc0RlcGVuZGVuY3lGaW5kaW5nIiwiaXNQYXR0ZXJuRmluZGluZyIsImdldFN0YXR1c0ljb24iLCJnZXRTdGF0dXNDb2xvciIsImdldFN0YXR1c0JhZGdlQ2xhc3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/baseline.types.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/compare.ts":
/*!*********************************!*\
  !*** ./lib/analysis/compare.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareVersions: () => (/* binding */ compareVersions),\n/* harmony export */   getLatestStableVersion: () => (/* binding */ getLatestStableVersion),\n/* harmony export */   getVersionDifference: () => (/* binding */ getVersionDifference),\n/* harmony export */   isPreRelease: () => (/* binding */ isPreRelease),\n/* harmony export */   parseVersion: () => (/* binding */ parseVersion),\n/* harmony export */   satisfiesRequirement: () => (/* binding */ satisfiesRequirement)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\r\n * Compare two version strings\r\n * @param version1 First version\r\n * @param version2 Second version (baseline)\r\n * @param language Language context for parsing\r\n * @returns Comparison result\r\n */ function compareVersions(version1, version2, language) {\n    try {\n        const v1 = parseVersion(version1, language);\n        const v2 = parseVersion(version2, language);\n        if (!v1 || !v2) {\n            return 'unknown';\n        }\n        // Use semver for Node.js packages\n        if (language === 'node') {\n            return compareWithSemver(v1, v2);\n        }\n        // Use custom comparison for other languages\n        return compareVersionsCustom(v1, v2, language);\n    } catch (error) {\n        console.warn(`Version comparison failed: ${error}`);\n        return 'unknown';\n    }\n}\n/**\r\n * Compare versions using semver (for Node.js)\r\n * @param version1 First version\r\n * @param version2 Second version\r\n * @returns Comparison result\r\n */ function compareWithSemver(version1, version2) {\n    try {\n        // Clean versions for semver\n        const v1 = cleanVersionForSemver(version1);\n        const v2 = cleanVersionForSemver(version2);\n        if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(v1) || !semver__WEBPACK_IMPORTED_MODULE_0___default().valid(v2)) {\n            return 'unknown';\n        }\n        const result = semver__WEBPACK_IMPORTED_MODULE_0___default().compare(v1, v2);\n        if (result > 0) return 'greater';\n        if (result < 0) return 'less';\n        return 'equal';\n    } catch  {\n        return 'unknown';\n    }\n}\n/**\r\n * Clean version string for semver parsing\r\n * @param version Version string\r\n * @returns Cleaned version\r\n */ function cleanVersionForSemver(version) {\n    // Remove common prefixes and suffixes\n    let cleaned = version.replace(/^v/, '') // Remove v prefix\n    .replace(/^[~^>=<!=]+/, '') // Remove operators\n    .trim();\n    // Handle pre-release versions\n    if (cleaned.includes('-')) {\n        const parts = cleaned.split('-');\n        cleaned = parts[0];\n    }\n    // Handle build metadata\n    if (cleaned.includes('+')) {\n        const parts = cleaned.split('+');\n        cleaned = parts[0];\n    }\n    return cleaned;\n}\n/**\r\n * Custom version comparison for non-Node.js languages\r\n * @param version1 First version\r\n * @param version2 Second version\r\n * @param language Language context\r\n * @returns Comparison result\r\n */ function compareVersionsCustom(version1, version2, language) {\n    try {\n        const v1Parts = parseVersionParts(version1, language);\n        const v2Parts = parseVersionParts(version2, language);\n        if (!v1Parts || !v2Parts) {\n            return 'unknown';\n        }\n        // Compare major, minor, patch\n        for(let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++){\n            const v1Part = v1Parts[i] || 0;\n            const v2Part = v2Parts[i] || 0;\n            if (v1Part > v2Part) return 'greater';\n            if (v1Part < v2Part) return 'less';\n        }\n        return 'equal';\n    } catch  {\n        return 'unknown';\n    }\n}\n/**\r\n * Parse version into numeric parts\r\n * @param version Version string\r\n * @param language Language context\r\n * @returns Array of numeric parts\r\n */ function parseVersionParts(version, language) {\n    try {\n        // Clean version\n        let cleaned = version.replace(/^v/, '').replace(/^[~^>=<!=]+/, '').trim();\n        // Handle different version formats\n        if (language === 'python') {\n            // Python: 1.2.3, 1.2, 1.2.3a1, 1.2.3b1, 1.2.3rc1\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        } else if (language === 'java') {\n            // Java: 1.8.0, 11, 17.0.1\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        } else if (language === 'go') {\n            // Go: v1.21.0, 1.21.0\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        } else if (language === 'dotnet') {\n            // .NET: 6.0.0, 7.0.0-preview.1\n            cleaned = cleaned.replace(/[a-zA-Z].*$/, ''); // Remove pre-release info\n        }\n        // Split by dots and convert to numbers\n        const parts = cleaned.split('.').map((part)=>{\n            const num = parseInt(part, 10);\n            return isNaN(num) ? 0 : num;\n        });\n        return parts.length > 0 ? parts : null;\n    } catch  {\n        return null;\n    }\n}\n/**\r\n * Parse version string and extract version number\r\n * @param versionString Version string (may contain operators)\r\n * @param language Language context\r\n * @returns Clean version string\r\n */ function parseVersion(versionString, language) {\n    if (!versionString || versionString === '*') {\n        return '0.0.0';\n    }\n    // Remove common operators and prefixes\n    let clean = versionString.replace(/^[~^>=<!=]+/, '') // Remove operators\n    .replace(/^v/, '') // Remove v prefix\n    .trim();\n    // Handle special cases\n    if (clean === 'latest' || clean === '') {\n        return '0.0.0';\n    }\n    // Handle Python version specifiers\n    if (language === 'python') {\n        // Remove Python-specific operators\n        clean = clean.replace(/^[~=!<>]+/, '');\n    }\n    // Handle Go version suffixes\n    if (language === 'go') {\n        // Remove +incompatible, +incompatible.20210101, etc.\n        clean = clean.replace(/\\+.*$/, '');\n    }\n    // Handle Java version ranges\n    if (language === 'java') {\n        // Extract version from ranges like [1.0,2.0) or (1.0,2.0]\n        const rangeMatch = clean.match(/[[(]([^,]+),/);\n        if (rangeMatch) {\n            clean = rangeMatch[1];\n        }\n    }\n    return clean;\n}\n/**\r\n * Check if a version satisfies a requirement\r\n * @param version Version to check\r\n * @param requirement Requirement (e.g., \">=1.0.0\", \"~1.2.3\")\r\n * @param language Language context\r\n * @returns True if version satisfies requirement\r\n */ function satisfiesRequirement(version, requirement, language) {\n    try {\n        if (language === 'node') {\n            // Use semver for Node.js\n            const cleanVersion = cleanVersionForSemver(version);\n            if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(cleanVersion)) return false;\n            return semver__WEBPACK_IMPORTED_MODULE_0___default().satisfies(cleanVersion, requirement);\n        }\n        // Custom logic for other languages\n        return satisfiesRequirementCustom(version, requirement, language);\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Custom requirement satisfaction check\r\n * @param version Version to check\r\n * @param requirement Requirement\r\n * @param language Language context\r\n * @returns True if version satisfies requirement\r\n */ function satisfiesRequirementCustom(version, requirement, language) {\n    try {\n        const cleanVersion = parseVersion(version, language);\n        const cleanRequirement = parseVersion(requirement, language);\n        if (!cleanVersion || !cleanRequirement) return false;\n        // Extract operator from requirement\n        const operatorMatch = requirement.match(/^([~^>=<!=]+)/);\n        const operator = operatorMatch ? operatorMatch[1] : '>=';\n        const comparison = compareVersions(cleanVersion, cleanRequirement, language);\n        switch(operator){\n            case '>=':\n                return comparison === 'greater' || comparison === 'equal';\n            case '>':\n                return comparison === 'greater';\n            case '<=':\n                return comparison === 'less' || comparison === 'equal';\n            case '<':\n                return comparison === 'less';\n            case '=':\n            case '==':\n                return comparison === 'equal';\n            case '~':\n                // Tilde: allow patch-level changes\n                return satisfiesTilde(cleanVersion, cleanRequirement, language);\n            case '^':\n                // Caret: allow minor-level changes\n                return satisfiesCaret(cleanVersion, cleanRequirement, language);\n            default:\n                return comparison === 'equal';\n        }\n    } catch  {\n        return false;\n    }\n}\n/**\r\n * Check if version satisfies tilde requirement\r\n * @param version Version to check\r\n * @param requirement Requirement\r\n * @param language Language context\r\n * @returns True if satisfies\r\n */ function satisfiesTilde(version, requirement, language) {\n    const vParts = parseVersionParts(version, language);\n    const rParts = parseVersionParts(requirement, language);\n    if (!vParts || !rParts) return false;\n    // Major and minor must match, patch can be higher\n    if (vParts[0] !== rParts[0]) return false;\n    if (vParts[1] !== rParts[1]) return false;\n    return vParts[2] >= (rParts[2] || 0);\n}\n/**\r\n * Check if version satisfies caret requirement\r\n * @param version Version to check\r\n * @param requirement Requirement\r\n * @param language Language context\r\n * @returns True if satisfies\r\n */ function satisfiesCaret(version, requirement, language) {\n    const vParts = parseVersionParts(version, language);\n    const rParts = parseVersionParts(requirement, language);\n    if (!vParts || !rParts) return false;\n    // Major must match, minor and patch can be higher\n    if (vParts[0] !== rParts[0]) return false;\n    return vParts[1] > (rParts[1] || 0) || vParts[1] === (rParts[1] || 0) && vParts[2] >= (rParts[2] || 0);\n}\n/**\r\n * Get version difference description\r\n * @param version1 First version\r\n * @param version2 Second version\r\n * @param language Language context\r\n * @returns Description of difference\r\n */ function getVersionDifference(version1, version2, language) {\n    const comparison = compareVersions(version1, version2, language);\n    switch(comparison){\n        case 'greater':\n            return `${version1} is newer than ${version2}`;\n        case 'less':\n            return `${version1} is older than ${version2}`;\n        case 'equal':\n            return `${version1} matches ${version2}`;\n        case 'unknown':\n            return `Cannot compare ${version1} with ${version2}`;\n        default:\n            return 'Unknown comparison';\n    }\n}\n/**\r\n * Check if a version is a pre-release\r\n * @param version Version string\r\n * @param language Language context\r\n * @returns True if pre-release\r\n */ function isPreRelease(version, language) {\n    const clean = parseVersion(version, language);\n    // Check for common pre-release indicators\n    return /[a-zA-Z]/.test(clean) || clean.includes('-') || clean.includes('alpha') || clean.includes('beta') || clean.includes('rc') || clean.includes('preview');\n}\n/**\r\n * Get the latest stable version from a list\r\n * @param versions Array of version strings\r\n * @param language Language context\r\n * @returns Latest stable version or null\r\n */ function getLatestStableVersion(versions, language) {\n    const stableVersions = versions.filter((v)=>!isPreRelease(v, language));\n    if (stableVersions.length === 0) return null;\n    let latest = stableVersions[0];\n    for (const version of stableVersions){\n        if (compareVersions(version, latest, language) === 'greater') {\n            latest = version;\n        }\n    }\n    return latest;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWtCLEVBQ2xCdkQsUUFBa0I7SUFFbEIsTUFBTXdELGlCQUFpQkQsU0FBU0UsTUFBTSxDQUFDQyxDQUFBQSxJQUFLLENBQUNOLGFBQWFNLEdBQUcxRDtJQUU3RCxJQUFJd0QsZUFBZTlCLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFFeEMsSUFBSWlDLFNBQVNILGNBQWMsQ0FBQyxFQUFFO0lBRTlCLEtBQUssTUFBTTNDLFdBQVcyQyxlQUFnQjtRQUNwQyxJQUFJM0QsZ0JBQWdCZ0IsU0FBUzhDLFFBQVEzRCxjQUFjLFdBQVc7WUFDNUQyRCxTQUFTOUM7UUFDWDtJQUNGO0lBRUEsT0FBTzhDO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcYW5hbHlzaXNcXGNvbXBhcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xyXG5pbXBvcnQgeyBMYW5ndWFnZSB9IGZyb20gJy4vYmFzZWxpbmUudHlwZXMnO1xyXG5cclxuZXhwb3J0IHR5cGUgQ29tcGFyaXNvblJlc3VsdCA9ICdncmVhdGVyJyB8ICdlcXVhbCcgfCAnbGVzcycgfCAndW5rbm93bic7XHJcblxyXG4vKipcclxuICogQ29tcGFyZSB0d28gdmVyc2lvbiBzdHJpbmdzXHJcbiAqIEBwYXJhbSB2ZXJzaW9uMSBGaXJzdCB2ZXJzaW9uXHJcbiAqIEBwYXJhbSB2ZXJzaW9uMiBTZWNvbmQgdmVyc2lvbiAoYmFzZWxpbmUpXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0IGZvciBwYXJzaW5nXHJcbiAqIEByZXR1cm5zIENvbXBhcmlzb24gcmVzdWx0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVZlcnNpb25zKFxyXG4gIHZlcnNpb24xOiBzdHJpbmcsXHJcbiAgdmVyc2lvbjI6IHN0cmluZyxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2VcclxuKTogQ29tcGFyaXNvblJlc3VsdCB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHYxID0gcGFyc2VWZXJzaW9uKHZlcnNpb24xLCBsYW5ndWFnZSk7XHJcbiAgICBjb25zdCB2MiA9IHBhcnNlVmVyc2lvbih2ZXJzaW9uMiwgbGFuZ3VhZ2UpO1xyXG4gICAgXHJcbiAgICBpZiAoIXYxIHx8ICF2Mikge1xyXG4gICAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBVc2Ugc2VtdmVyIGZvciBOb2RlLmpzIHBhY2thZ2VzXHJcbiAgICBpZiAobGFuZ3VhZ2UgPT09ICdub2RlJykge1xyXG4gICAgICByZXR1cm4gY29tcGFyZVdpdGhTZW12ZXIodjEsIHYyKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVXNlIGN1c3RvbSBjb21wYXJpc29uIGZvciBvdGhlciBsYW5ndWFnZXNcclxuICAgIHJldHVybiBjb21wYXJlVmVyc2lvbnNDdXN0b20odjEsIHYyLCBsYW5ndWFnZSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybihgVmVyc2lvbiBjb21wYXJpc29uIGZhaWxlZDogJHtlcnJvcn1gKTtcclxuICAgIHJldHVybiAndW5rbm93bic7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29tcGFyZSB2ZXJzaW9ucyB1c2luZyBzZW12ZXIgKGZvciBOb2RlLmpzKVxyXG4gKiBAcGFyYW0gdmVyc2lvbjEgRmlyc3QgdmVyc2lvblxyXG4gKiBAcGFyYW0gdmVyc2lvbjIgU2Vjb25kIHZlcnNpb25cclxuICogQHJldHVybnMgQ29tcGFyaXNvbiByZXN1bHRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVXaXRoU2VtdmVyKHZlcnNpb24xOiBzdHJpbmcsIHZlcnNpb24yOiBzdHJpbmcpOiBDb21wYXJpc29uUmVzdWx0IHtcclxuICB0cnkge1xyXG4gICAgLy8gQ2xlYW4gdmVyc2lvbnMgZm9yIHNlbXZlclxyXG4gICAgY29uc3QgdjEgPSBjbGVhblZlcnNpb25Gb3JTZW12ZXIodmVyc2lvbjEpO1xyXG4gICAgY29uc3QgdjIgPSBjbGVhblZlcnNpb25Gb3JTZW12ZXIodmVyc2lvbjIpO1xyXG4gICAgXHJcbiAgICBpZiAoIXNlbXZlci52YWxpZCh2MSkgfHwgIXNlbXZlci52YWxpZCh2MikpIHtcclxuICAgICAgcmV0dXJuICd1bmtub3duJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgcmVzdWx0ID0gc2VtdmVyLmNvbXBhcmUodjEsIHYyKTtcclxuICAgIFxyXG4gICAgaWYgKHJlc3VsdCA+IDApIHJldHVybiAnZ3JlYXRlcic7XHJcbiAgICBpZiAocmVzdWx0IDwgMCkgcmV0dXJuICdsZXNzJztcclxuICAgIHJldHVybiAnZXF1YWwnO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuICd1bmtub3duJztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhbiB2ZXJzaW9uIHN0cmluZyBmb3Igc2VtdmVyIHBhcnNpbmdcclxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiBzdHJpbmdcclxuICogQHJldHVybnMgQ2xlYW5lZCB2ZXJzaW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGVhblZlcnNpb25Gb3JTZW12ZXIodmVyc2lvbjogc3RyaW5nKTogc3RyaW5nIHtcclxuICAvLyBSZW1vdmUgY29tbW9uIHByZWZpeGVzIGFuZCBzdWZmaXhlc1xyXG4gIGxldCBjbGVhbmVkID0gdmVyc2lvblxyXG4gICAgLnJlcGxhY2UoL152LywgJycpIC8vIFJlbW92ZSB2IHByZWZpeFxyXG4gICAgLnJlcGxhY2UoL15bfl4+PTwhPV0rLywgJycpIC8vIFJlbW92ZSBvcGVyYXRvcnNcclxuICAgIC50cmltKCk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHByZS1yZWxlYXNlIHZlcnNpb25zXHJcbiAgaWYgKGNsZWFuZWQuaW5jbHVkZXMoJy0nKSkge1xyXG4gICAgY29uc3QgcGFydHMgPSBjbGVhbmVkLnNwbGl0KCctJyk7XHJcbiAgICBjbGVhbmVkID0gcGFydHNbMF07XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBidWlsZCBtZXRhZGF0YVxyXG4gIGlmIChjbGVhbmVkLmluY2x1ZGVzKCcrJykpIHtcclxuICAgIGNvbnN0IHBhcnRzID0gY2xlYW5lZC5zcGxpdCgnKycpO1xyXG4gICAgY2xlYW5lZCA9IHBhcnRzWzBdO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gY2xlYW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEN1c3RvbSB2ZXJzaW9uIGNvbXBhcmlzb24gZm9yIG5vbi1Ob2RlLmpzIGxhbmd1YWdlc1xyXG4gKiBAcGFyYW0gdmVyc2lvbjEgRmlyc3QgdmVyc2lvblxyXG4gKiBAcGFyYW0gdmVyc2lvbjIgU2Vjb25kIHZlcnNpb25cclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgQ29tcGFyaXNvbiByZXN1bHRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9uc0N1c3RvbShcclxuICB2ZXJzaW9uMTogc3RyaW5nLFxyXG4gIHZlcnNpb24yOiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IENvbXBhcmlzb25SZXN1bHQge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB2MVBhcnRzID0gcGFyc2VWZXJzaW9uUGFydHModmVyc2lvbjEsIGxhbmd1YWdlKTtcclxuICAgIGNvbnN0IHYyUGFydHMgPSBwYXJzZVZlcnNpb25QYXJ0cyh2ZXJzaW9uMiwgbGFuZ3VhZ2UpO1xyXG4gICAgXHJcbiAgICBpZiAoIXYxUGFydHMgfHwgIXYyUGFydHMpIHtcclxuICAgICAgcmV0dXJuICd1bmtub3duJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ29tcGFyZSBtYWpvciwgbWlub3IsIHBhdGNoXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHYxUGFydHMubGVuZ3RoLCB2MlBhcnRzLmxlbmd0aCk7IGkrKykge1xyXG4gICAgICBjb25zdCB2MVBhcnQgPSB2MVBhcnRzW2ldIHx8IDA7XHJcbiAgICAgIGNvbnN0IHYyUGFydCA9IHYyUGFydHNbaV0gfHwgMDtcclxuICAgICAgXHJcbiAgICAgIGlmICh2MVBhcnQgPiB2MlBhcnQpIHJldHVybiAnZ3JlYXRlcic7XHJcbiAgICAgIGlmICh2MVBhcnQgPCB2MlBhcnQpIHJldHVybiAnbGVzcyc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAnZXF1YWwnO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuICd1bmtub3duJztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSB2ZXJzaW9uIGludG8gbnVtZXJpYyBwYXJ0c1xyXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIHN0cmluZ1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBudW1lcmljIHBhcnRzXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVZlcnNpb25QYXJ0cyh2ZXJzaW9uOiBzdHJpbmcsIGxhbmd1YWdlOiBMYW5ndWFnZSk6IG51bWJlcltdIHwgbnVsbCB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIENsZWFuIHZlcnNpb25cclxuICAgIGxldCBjbGVhbmVkID0gdmVyc2lvblxyXG4gICAgICAucmVwbGFjZSgvXnYvLCAnJylcclxuICAgICAgLnJlcGxhY2UoL15bfl4+PTwhPV0rLywgJycpXHJcbiAgICAgIC50cmltKCk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgdmVyc2lvbiBmb3JtYXRzXHJcbiAgICBpZiAobGFuZ3VhZ2UgPT09ICdweXRob24nKSB7XHJcbiAgICAgIC8vIFB5dGhvbjogMS4yLjMsIDEuMiwgMS4yLjNhMSwgMS4yLjNiMSwgMS4yLjNyYzFcclxuICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvW2EtekEtWl0uKiQvLCAnJyk7IC8vIFJlbW92ZSBwcmUtcmVsZWFzZSBpbmZvXHJcbiAgICB9IGVsc2UgaWYgKGxhbmd1YWdlID09PSAnamF2YScpIHtcclxuICAgICAgLy8gSmF2YTogMS44LjAsIDExLCAxNy4wLjFcclxuICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvW2EtekEtWl0uKiQvLCAnJyk7IC8vIFJlbW92ZSBwcmUtcmVsZWFzZSBpbmZvXHJcbiAgICB9IGVsc2UgaWYgKGxhbmd1YWdlID09PSAnZ28nKSB7XHJcbiAgICAgIC8vIEdvOiB2MS4yMS4wLCAxLjIxLjBcclxuICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvW2EtekEtWl0uKiQvLCAnJyk7IC8vIFJlbW92ZSBwcmUtcmVsZWFzZSBpbmZvXHJcbiAgICB9IGVsc2UgaWYgKGxhbmd1YWdlID09PSAnZG90bmV0Jykge1xyXG4gICAgICAvLyAuTkVUOiA2LjAuMCwgNy4wLjAtcHJldmlldy4xXHJcbiAgICAgIGNsZWFuZWQgPSBjbGVhbmVkLnJlcGxhY2UoL1thLXpBLVpdLiokLywgJycpOyAvLyBSZW1vdmUgcHJlLXJlbGVhc2UgaW5mb1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTcGxpdCBieSBkb3RzIGFuZCBjb252ZXJ0IHRvIG51bWJlcnNcclxuICAgIGNvbnN0IHBhcnRzID0gY2xlYW5lZC5zcGxpdCgnLicpLm1hcChwYXJ0ID0+IHtcclxuICAgICAgY29uc3QgbnVtID0gcGFyc2VJbnQocGFydCwgMTApO1xyXG4gICAgICByZXR1cm4gaXNOYU4obnVtKSA/IDAgOiBudW07XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cyA6IG51bGw7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSB2ZXJzaW9uIHN0cmluZyBhbmQgZXh0cmFjdCB2ZXJzaW9uIG51bWJlclxyXG4gKiBAcGFyYW0gdmVyc2lvblN0cmluZyBWZXJzaW9uIHN0cmluZyAobWF5IGNvbnRhaW4gb3BlcmF0b3JzKVxyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBDbGVhbiB2ZXJzaW9uIHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVmVyc2lvbih2ZXJzaW9uU3RyaW5nOiBzdHJpbmcsIGxhbmd1YWdlOiBMYW5ndWFnZSk6IHN0cmluZyB7XHJcbiAgaWYgKCF2ZXJzaW9uU3RyaW5nIHx8IHZlcnNpb25TdHJpbmcgPT09ICcqJykge1xyXG4gICAgcmV0dXJuICcwLjAuMCc7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFJlbW92ZSBjb21tb24gb3BlcmF0b3JzIGFuZCBwcmVmaXhlc1xyXG4gIGxldCBjbGVhbiA9IHZlcnNpb25TdHJpbmdcclxuICAgIC5yZXBsYWNlKC9eW35ePj08IT1dKy8sICcnKSAvLyBSZW1vdmUgb3BlcmF0b3JzXHJcbiAgICAucmVwbGFjZSgvXnYvLCAnJykgLy8gUmVtb3ZlIHYgcHJlZml4XHJcbiAgICAudHJpbSgpO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2VzXHJcbiAgaWYgKGNsZWFuID09PSAnbGF0ZXN0JyB8fCBjbGVhbiA9PT0gJycpIHtcclxuICAgIHJldHVybiAnMC4wLjAnO1xyXG4gIH1cclxuICBcclxuICAvLyBIYW5kbGUgUHl0aG9uIHZlcnNpb24gc3BlY2lmaWVyc1xyXG4gIGlmIChsYW5ndWFnZSA9PT0gJ3B5dGhvbicpIHtcclxuICAgIC8vIFJlbW92ZSBQeXRob24tc3BlY2lmaWMgb3BlcmF0b3JzXHJcbiAgICBjbGVhbiA9IGNsZWFuLnJlcGxhY2UoL15bfj0hPD5dKy8sICcnKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIEdvIHZlcnNpb24gc3VmZml4ZXNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdnbycpIHtcclxuICAgIC8vIFJlbW92ZSAraW5jb21wYXRpYmxlLCAraW5jb21wYXRpYmxlLjIwMjEwMTAxLCBldGMuXHJcbiAgICBjbGVhbiA9IGNsZWFuLnJlcGxhY2UoL1xcKy4qJC8sICcnKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIEphdmEgdmVyc2lvbiByYW5nZXNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdqYXZhJykge1xyXG4gICAgLy8gRXh0cmFjdCB2ZXJzaW9uIGZyb20gcmFuZ2VzIGxpa2UgWzEuMCwyLjApIG9yICgxLjAsMi4wXVxyXG4gICAgY29uc3QgcmFuZ2VNYXRjaCA9IGNsZWFuLm1hdGNoKC9bWyhdKFteLF0rKSwvKTtcclxuICAgIGlmIChyYW5nZU1hdGNoKSB7XHJcbiAgICAgIGNsZWFuID0gcmFuZ2VNYXRjaFsxXTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGNsZWFuO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYSB2ZXJzaW9uIHNhdGlzZmllcyBhIHJlcXVpcmVtZW50XHJcbiAqIEBwYXJhbSB2ZXJzaW9uIFZlcnNpb24gdG8gY2hlY2tcclxuICogQHBhcmFtIHJlcXVpcmVtZW50IFJlcXVpcmVtZW50IChlLmcuLCBcIj49MS4wLjBcIiwgXCJ+MS4yLjNcIilcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgVHJ1ZSBpZiB2ZXJzaW9uIHNhdGlzZmllcyByZXF1aXJlbWVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNhdGlzZmllc1JlcXVpcmVtZW50KFxyXG4gIHZlcnNpb246IHN0cmluZyxcclxuICByZXF1aXJlbWVudDogc3RyaW5nLFxyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxyXG4pOiBib29sZWFuIHtcclxuICB0cnkge1xyXG4gICAgaWYgKGxhbmd1YWdlID09PSAnbm9kZScpIHtcclxuICAgICAgLy8gVXNlIHNlbXZlciBmb3IgTm9kZS5qc1xyXG4gICAgICBjb25zdCBjbGVhblZlcnNpb24gPSBjbGVhblZlcnNpb25Gb3JTZW12ZXIodmVyc2lvbik7XHJcbiAgICAgIGlmICghc2VtdmVyLnZhbGlkKGNsZWFuVmVyc2lvbikpIHJldHVybiBmYWxzZTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKGNsZWFuVmVyc2lvbiwgcmVxdWlyZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDdXN0b20gbG9naWMgZm9yIG90aGVyIGxhbmd1YWdlc1xyXG4gICAgcmV0dXJuIHNhdGlzZmllc1JlcXVpcmVtZW50Q3VzdG9tKHZlcnNpb24sIHJlcXVpcmVtZW50LCBsYW5ndWFnZSk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3VzdG9tIHJlcXVpcmVtZW50IHNhdGlzZmFjdGlvbiBjaGVja1xyXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIHRvIGNoZWNrXHJcbiAqIEBwYXJhbSByZXF1aXJlbWVudCBSZXF1aXJlbWVudFxyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHZlcnNpb24gc2F0aXNmaWVzIHJlcXVpcmVtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBzYXRpc2ZpZXNSZXF1aXJlbWVudEN1c3RvbShcclxuICB2ZXJzaW9uOiBzdHJpbmcsXHJcbiAgcmVxdWlyZW1lbnQ6IHN0cmluZyxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2VcclxuKTogYm9vbGVhbiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNsZWFuVmVyc2lvbiA9IHBhcnNlVmVyc2lvbih2ZXJzaW9uLCBsYW5ndWFnZSk7XHJcbiAgICBjb25zdCBjbGVhblJlcXVpcmVtZW50ID0gcGFyc2VWZXJzaW9uKHJlcXVpcmVtZW50LCBsYW5ndWFnZSk7XHJcbiAgICBcclxuICAgIGlmICghY2xlYW5WZXJzaW9uIHx8ICFjbGVhblJlcXVpcmVtZW50KSByZXR1cm4gZmFsc2U7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3Qgb3BlcmF0b3IgZnJvbSByZXF1aXJlbWVudFxyXG4gICAgY29uc3Qgb3BlcmF0b3JNYXRjaCA9IHJlcXVpcmVtZW50Lm1hdGNoKC9eKFt+Xj49PCE9XSspLyk7XHJcbiAgICBjb25zdCBvcGVyYXRvciA9IG9wZXJhdG9yTWF0Y2ggPyBvcGVyYXRvck1hdGNoWzFdIDogJz49JztcclxuICAgIFxyXG4gICAgY29uc3QgY29tcGFyaXNvbiA9IGNvbXBhcmVWZXJzaW9ucyhjbGVhblZlcnNpb24sIGNsZWFuUmVxdWlyZW1lbnQsIGxhbmd1YWdlKTtcclxuICAgIFxyXG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xyXG4gICAgICBjYXNlICc+PSc6XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPT09ICdncmVhdGVyJyB8fCBjb21wYXJpc29uID09PSAnZXF1YWwnO1xyXG4gICAgICBjYXNlICc+JzpcclxuICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gJ2dyZWF0ZXInO1xyXG4gICAgICBjYXNlICc8PSc6XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPT09ICdsZXNzJyB8fCBjb21wYXJpc29uID09PSAnZXF1YWwnO1xyXG4gICAgICBjYXNlICc8JzpcclxuICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gJ2xlc3MnO1xyXG4gICAgICBjYXNlICc9JzpcclxuICAgICAgY2FzZSAnPT0nOlxyXG4gICAgICAgIHJldHVybiBjb21wYXJpc29uID09PSAnZXF1YWwnO1xyXG4gICAgICBjYXNlICd+JzpcclxuICAgICAgICAvLyBUaWxkZTogYWxsb3cgcGF0Y2gtbGV2ZWwgY2hhbmdlc1xyXG4gICAgICAgIHJldHVybiBzYXRpc2ZpZXNUaWxkZShjbGVhblZlcnNpb24sIGNsZWFuUmVxdWlyZW1lbnQsIGxhbmd1YWdlKTtcclxuICAgICAgY2FzZSAnXic6XHJcbiAgICAgICAgLy8gQ2FyZXQ6IGFsbG93IG1pbm9yLWxldmVsIGNoYW5nZXNcclxuICAgICAgICByZXR1cm4gc2F0aXNmaWVzQ2FyZXQoY2xlYW5WZXJzaW9uLCBjbGVhblJlcXVpcmVtZW50LCBsYW5ndWFnZSk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPT09ICdlcXVhbCc7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdmVyc2lvbiBzYXRpc2ZpZXMgdGlsZGUgcmVxdWlyZW1lbnRcclxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiB0byBjaGVja1xyXG4gKiBAcGFyYW0gcmVxdWlyZW1lbnQgUmVxdWlyZW1lbnRcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcclxuICogQHJldHVybnMgVHJ1ZSBpZiBzYXRpc2ZpZXNcclxuICovXHJcbmZ1bmN0aW9uIHNhdGlzZmllc1RpbGRlKFxyXG4gIHZlcnNpb246IHN0cmluZyxcclxuICByZXF1aXJlbWVudDogc3RyaW5nLFxyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxyXG4pOiBib29sZWFuIHtcclxuICBjb25zdCB2UGFydHMgPSBwYXJzZVZlcnNpb25QYXJ0cyh2ZXJzaW9uLCBsYW5ndWFnZSk7XHJcbiAgY29uc3QgclBhcnRzID0gcGFyc2VWZXJzaW9uUGFydHMocmVxdWlyZW1lbnQsIGxhbmd1YWdlKTtcclxuICBcclxuICBpZiAoIXZQYXJ0cyB8fCAhclBhcnRzKSByZXR1cm4gZmFsc2U7XHJcbiAgXHJcbiAgLy8gTWFqb3IgYW5kIG1pbm9yIG11c3QgbWF0Y2gsIHBhdGNoIGNhbiBiZSBoaWdoZXJcclxuICBpZiAodlBhcnRzWzBdICE9PSByUGFydHNbMF0pIHJldHVybiBmYWxzZTtcclxuICBpZiAodlBhcnRzWzFdICE9PSByUGFydHNbMV0pIHJldHVybiBmYWxzZTtcclxuICBcclxuICByZXR1cm4gdlBhcnRzWzJdID49IChyUGFydHNbMl0gfHwgMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2ZXJzaW9uIHNhdGlzZmllcyBjYXJldCByZXF1aXJlbWVudFxyXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIHRvIGNoZWNrXHJcbiAqIEBwYXJhbSByZXF1aXJlbWVudCBSZXF1aXJlbWVudFxyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHNhdGlzZmllc1xyXG4gKi9cclxuZnVuY3Rpb24gc2F0aXNmaWVzQ2FyZXQoXHJcbiAgdmVyc2lvbjogc3RyaW5nLFxyXG4gIHJlcXVpcmVtZW50OiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IHZQYXJ0cyA9IHBhcnNlVmVyc2lvblBhcnRzKHZlcnNpb24sIGxhbmd1YWdlKTtcclxuICBjb25zdCByUGFydHMgPSBwYXJzZVZlcnNpb25QYXJ0cyhyZXF1aXJlbWVudCwgbGFuZ3VhZ2UpO1xyXG4gIFxyXG4gIGlmICghdlBhcnRzIHx8ICFyUGFydHMpIHJldHVybiBmYWxzZTtcclxuICBcclxuICAvLyBNYWpvciBtdXN0IG1hdGNoLCBtaW5vciBhbmQgcGF0Y2ggY2FuIGJlIGhpZ2hlclxyXG4gIGlmICh2UGFydHNbMF0gIT09IHJQYXJ0c1swXSkgcmV0dXJuIGZhbHNlO1xyXG4gIFxyXG4gIHJldHVybiB2UGFydHNbMV0gPiAoclBhcnRzWzFdIHx8IDApIHx8IFxyXG4gICAgICAgICAodlBhcnRzWzFdID09PSAoclBhcnRzWzFdIHx8IDApICYmIHZQYXJ0c1syXSA+PSAoclBhcnRzWzJdIHx8IDApKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB2ZXJzaW9uIGRpZmZlcmVuY2UgZGVzY3JpcHRpb25cclxuICogQHBhcmFtIHZlcnNpb24xIEZpcnN0IHZlcnNpb25cclxuICogQHBhcmFtIHZlcnNpb24yIFNlY29uZCB2ZXJzaW9uXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIERlc2NyaXB0aW9uIG9mIGRpZmZlcmVuY2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzaW9uRGlmZmVyZW5jZShcclxuICB2ZXJzaW9uMTogc3RyaW5nLFxyXG4gIHZlcnNpb24yOiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IHN0cmluZyB7XHJcbiAgY29uc3QgY29tcGFyaXNvbiA9IGNvbXBhcmVWZXJzaW9ucyh2ZXJzaW9uMSwgdmVyc2lvbjIsIGxhbmd1YWdlKTtcclxuICBcclxuICBzd2l0Y2ggKGNvbXBhcmlzb24pIHtcclxuICAgIGNhc2UgJ2dyZWF0ZXInOlxyXG4gICAgICByZXR1cm4gYCR7dmVyc2lvbjF9IGlzIG5ld2VyIHRoYW4gJHt2ZXJzaW9uMn1gO1xyXG4gICAgY2FzZSAnbGVzcyc6XHJcbiAgICAgIHJldHVybiBgJHt2ZXJzaW9uMX0gaXMgb2xkZXIgdGhhbiAke3ZlcnNpb24yfWA7XHJcbiAgICBjYXNlICdlcXVhbCc6XHJcbiAgICAgIHJldHVybiBgJHt2ZXJzaW9uMX0gbWF0Y2hlcyAke3ZlcnNpb24yfWA7XHJcbiAgICBjYXNlICd1bmtub3duJzpcclxuICAgICAgcmV0dXJuIGBDYW5ub3QgY29tcGFyZSAke3ZlcnNpb24xfSB3aXRoICR7dmVyc2lvbjJ9YDtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiAnVW5rbm93biBjb21wYXJpc29uJztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZlcnNpb24gaXMgYSBwcmUtcmVsZWFzZVxyXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIHN0cmluZ1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgY29udGV4dFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHByZS1yZWxlYXNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQcmVSZWxlYXNlKHZlcnNpb246IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgY2xlYW4gPSBwYXJzZVZlcnNpb24odmVyc2lvbiwgbGFuZ3VhZ2UpO1xyXG4gIFxyXG4gIC8vIENoZWNrIGZvciBjb21tb24gcHJlLXJlbGVhc2UgaW5kaWNhdG9yc1xyXG4gIHJldHVybiAvW2EtekEtWl0vLnRlc3QoY2xlYW4pIHx8IFxyXG4gICAgICAgICBjbGVhbi5pbmNsdWRlcygnLScpIHx8IFxyXG4gICAgICAgICBjbGVhbi5pbmNsdWRlcygnYWxwaGEnKSB8fFxyXG4gICAgICAgICBjbGVhbi5pbmNsdWRlcygnYmV0YScpIHx8XHJcbiAgICAgICAgIGNsZWFuLmluY2x1ZGVzKCdyYycpIHx8XHJcbiAgICAgICAgIGNsZWFuLmluY2x1ZGVzKCdwcmV2aWV3Jyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGxhdGVzdCBzdGFibGUgdmVyc2lvbiBmcm9tIGEgbGlzdFxyXG4gKiBAcGFyYW0gdmVyc2lvbnMgQXJyYXkgb2YgdmVyc2lvbiBzdHJpbmdzXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIExhdGVzdCBzdGFibGUgdmVyc2lvbiBvciBudWxsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF0ZXN0U3RhYmxlVmVyc2lvbihcclxuICB2ZXJzaW9uczogc3RyaW5nW10sXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlXHJcbik6IHN0cmluZyB8IG51bGwge1xyXG4gIGNvbnN0IHN0YWJsZVZlcnNpb25zID0gdmVyc2lvbnMuZmlsdGVyKHYgPT4gIWlzUHJlUmVsZWFzZSh2LCBsYW5ndWFnZSkpO1xyXG4gIFxyXG4gIGlmIChzdGFibGVWZXJzaW9ucy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xyXG4gIFxyXG4gIGxldCBsYXRlc3QgPSBzdGFibGVWZXJzaW9uc1swXTtcclxuICBcclxuICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygc3RhYmxlVmVyc2lvbnMpIHtcclxuICAgIGlmIChjb21wYXJlVmVyc2lvbnModmVyc2lvbiwgbGF0ZXN0LCBsYW5ndWFnZSkgPT09ICdncmVhdGVyJykge1xyXG4gICAgICBsYXRlc3QgPSB2ZXJzaW9uO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gbGF0ZXN0O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJzZW12ZXIiLCJjb21wYXJlVmVyc2lvbnMiLCJ2ZXJzaW9uMSIsInZlcnNpb24yIiwibGFuZ3VhZ2UiLCJ2MSIsInBhcnNlVmVyc2lvbiIsInYyIiwiY29tcGFyZVdpdGhTZW12ZXIiLCJjb21wYXJlVmVyc2lvbnNDdXN0b20iLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiY2xlYW5WZXJzaW9uRm9yU2VtdmVyIiwidmFsaWQiLCJyZXN1bHQiLCJjb21wYXJlIiwidmVyc2lvbiIsImNsZWFuZWQiLCJyZXBsYWNlIiwidHJpbSIsImluY2x1ZGVzIiwicGFydHMiLCJzcGxpdCIsInYxUGFydHMiLCJwYXJzZVZlcnNpb25QYXJ0cyIsInYyUGFydHMiLCJpIiwiTWF0aCIsIm1heCIsImxlbmd0aCIsInYxUGFydCIsInYyUGFydCIsIm1hcCIsInBhcnQiLCJudW0iLCJwYXJzZUludCIsImlzTmFOIiwidmVyc2lvblN0cmluZyIsImNsZWFuIiwicmFuZ2VNYXRjaCIsIm1hdGNoIiwic2F0aXNmaWVzUmVxdWlyZW1lbnQiLCJyZXF1aXJlbWVudCIsImNsZWFuVmVyc2lvbiIsInNhdGlzZmllcyIsInNhdGlzZmllc1JlcXVpcmVtZW50Q3VzdG9tIiwiY2xlYW5SZXF1aXJlbWVudCIsIm9wZXJhdG9yTWF0Y2giLCJvcGVyYXRvciIsImNvbXBhcmlzb24iLCJzYXRpc2ZpZXNUaWxkZSIsInNhdGlzZmllc0NhcmV0IiwidlBhcnRzIiwiclBhcnRzIiwiZ2V0VmVyc2lvbkRpZmZlcmVuY2UiLCJpc1ByZVJlbGVhc2UiLCJ0ZXN0IiwiZ2V0TGF0ZXN0U3RhYmxlVmVyc2lvbiIsInZlcnNpb25zIiwic3RhYmxlVmVyc2lvbnMiLCJmaWx0ZXIiLCJ2IiwibGF0ZXN0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/compare.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/deps.ts":
/*!******************************!*\
  !*** ./lib/analysis/deps.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeDependencies: () => (/* binding */ analyzeDependencies),\n/* harmony export */   filterDependenciesByLanguage: () => (/* binding */ filterDependenciesByLanguage),\n/* harmony export */   getBaselineVersion: () => (/* binding */ getBaselineVersion),\n/* harmony export */   getDependencySummary: () => (/* binding */ getDependencySummary),\n/* harmony export */   groupDependenciesByStatus: () => (/* binding */ groupDependenciesByStatus),\n/* harmony export */   hasBaselineRule: () => (/* binding */ hasBaselineRule),\n/* harmony export */   isValidVersion: () => (/* binding */ isValidVersion),\n/* harmony export */   normalizePackageName: () => (/* binding */ normalizePackageName),\n/* harmony export */   parseVersion: () => (/* binding */ parseVersion),\n/* harmony export */   sortDependencies: () => (/* binding */ sortDependencies)\n/* harmony export */ });\n/* harmony import */ var _compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compare */ \"(rsc)/./lib/analysis/compare.ts\");\n\n/**\r\n * Analyze dependencies from project manifests\r\n * @param manifests Array of project manifests\r\n * @param rules Baseline rules\r\n * @returns Array of dependency findings\r\n */ function analyzeDependencies(manifests, rules) {\n    const findings = [];\n    for (const manifest of manifests){\n        if (!manifest.dependencies) continue;\n        const languageRules = rules.package_mins[manifest.language] || {};\n        for (const [packageName, foundVersion] of Object.entries(manifest.dependencies)){\n            const baselineVersion = languageRules[packageName];\n            if (!baselineVersion) {\n                // No baseline rule for this package\n                findings.push({\n                    kind: 'dependency',\n                    lang: manifest.language,\n                    component: packageName,\n                    foundVersion,\n                    baselineRequired: null,\n                    status: 'unknown',\n                    reason: 'no-baseline-rule',\n                    file: manifest.file\n                });\n                continue;\n            }\n            // Compare versions\n            const comparison = (0,_compare__WEBPACK_IMPORTED_MODULE_0__.compareVersions)(foundVersion, baselineVersion, manifest.language);\n            let status;\n            let reason;\n            switch(comparison){\n                case 'greater':\n                case 'equal':\n                    status = 'ok';\n                    reason = 'meets-baseline';\n                    break;\n                case 'less':\n                    status = 'affected';\n                    reason = 'below-baseline';\n                    break;\n                case 'unknown':\n                    status = 'unknown';\n                    reason = 'version-parse-error';\n                    break;\n                default:\n                    status = 'unknown';\n                    reason = 'unknown-comparison';\n            }\n            findings.push({\n                kind: 'dependency',\n                lang: manifest.language,\n                component: packageName,\n                foundVersion,\n                baselineRequired: baselineVersion,\n                status,\n                reason,\n                file: manifest.file,\n                quickFix: getDependencyQuickFix(rules, manifest.language, packageName, baselineVersion)\n            });\n        }\n    }\n    return findings;\n}\n/**\r\n * Get quick fix for dependency upgrade\r\n * @param rules Baseline rules\r\n * @param language Language\r\n * @param packageName Package name\r\n * @param version Required version\r\n * @returns Quick fix string\r\n */ function getDependencyQuickFix(rules, language, packageName, version) {\n    const template = rules.quick_fixes.dependency_upgrade[language] || 'Update {package} to {version}';\n    return template.replace('{package}', packageName).replace('{version}', version);\n}\n/**\r\n * Parse version string and extract version number\r\n * @param versionString Version string (may contain operators)\r\n * @param language Language context\r\n * @returns Clean version string\r\n */ function parseVersion(versionString, language) {\n    if (!versionString || versionString === '*') {\n        return '0.0.0';\n    }\n    // Remove common operators and prefixes\n    let clean = versionString.replace(/^[~^>=<!=]+/, '') // Remove operators\n    .replace(/^v/, '') // Remove v prefix\n    .trim();\n    // Handle special cases\n    if (clean === 'latest' || clean === '') {\n        return '0.0.0';\n    }\n    // Handle Python version specifiers\n    if (language === 'python') {\n        // Remove Python-specific operators\n        clean = clean.replace(/^[~=!<>]+/, '');\n    }\n    // Handle Go version suffixes\n    if (language === 'go') {\n        // Remove +incompatible, +incompatible.20210101, etc.\n        clean = clean.replace(/\\+.*$/, '');\n    }\n    // Handle Java version ranges\n    if (language === 'java') {\n        // Extract version from ranges like [1.0,2.0) or (1.0,2.0]\n        const rangeMatch = clean.match(/[[(]([^,]+),/);\n        if (rangeMatch) {\n            clean = rangeMatch[1];\n        }\n    }\n    return clean;\n}\n/**\r\n * Check if a version string is valid\r\n * @param versionString Version string\r\n * @param language Language context\r\n * @returns True if valid\r\n */ function isValidVersion(versionString, language) {\n    if (!versionString || versionString === '*') return false;\n    const clean = parseVersion(versionString, language);\n    // Basic version pattern validation\n    const versionPatterns = {\n        node: /^\\d+\\.\\d+\\.\\d+(-[a-zA-Z0-9.-]+)?(\\+[a-zA-Z0-9.-]+)?$/,\n        python: /^\\d+\\.\\d+(\\.\\d+)?([a-zA-Z0-9.-]+)?$/,\n        java: /^\\d+(\\.\\d+)*(-[a-zA-Z0-9.-]+)?$/,\n        go: /^v?\\d+\\.\\d+\\.\\d+(-[a-zA-Z0-9.-]+)?(\\+[a-zA-Z0-9.-]+)?$/,\n        dotnet: /^\\d+\\.\\d+(\\.\\d+)?(-[a-zA-Z0-9.-]+)?$/\n    };\n    const pattern = versionPatterns[language];\n    return pattern ? pattern.test(clean) : false;\n}\n/**\r\n * Normalize package name for comparison\r\n * @param packageName Package name\r\n * @param language Language context\r\n * @returns Normalized package name\r\n */ function normalizePackageName(packageName, language) {\n    let normalized = packageName.toLowerCase().trim();\n    // Handle scoped packages (Node.js)\n    if (language === 'node' && normalized.startsWith('@')) {\n        // Keep @scope/package format\n        return normalized;\n    }\n    // Handle Java group:artifact format\n    if (language === 'java' && normalized.includes(':')) {\n        return normalized;\n    }\n    // Handle Go modules\n    if (language === 'go') {\n        // Remove common prefixes\n        normalized = normalized.replace(/^github\\.com\\//, '');\n        normalized = normalized.replace(/^golang\\.org\\/x\\//, '');\n    }\n    // Handle .NET packages\n    if (language === 'dotnet') {\n        // Remove common prefixes\n        normalized = normalized.replace(/^microsoft\\./, '');\n        normalized = normalized.replace(/^system\\./, '');\n    }\n    return normalized;\n}\n/**\r\n * Check if a package is in the baseline rules\r\n * @param packageName Package name\r\n * @param language Language\r\n * @param rules Baseline rules\r\n * @returns True if package has baseline rules\r\n */ function hasBaselineRule(packageName, language, rules) {\n    const languageRules = rules.package_mins[language] || {};\n    const normalized = normalizePackageName(packageName, language);\n    // Check exact match first\n    if (languageRules[packageName]) return true;\n    if (languageRules[normalized]) return true;\n    // Check for partial matches (for scoped packages, etc.)\n    for (const [rulePackage] of Object.entries(languageRules)){\n        if (normalizePackageName(rulePackage, language) === normalized) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\r\n * Get baseline version for a package\r\n * @param packageName Package name\r\n * @param language Language\r\n * @param rules Baseline rules\r\n * @returns Baseline version or null\r\n */ function getBaselineVersion(packageName, language, rules) {\n    const languageRules = rules.package_mins[language] || {};\n    const normalized = normalizePackageName(packageName, language);\n    // Check exact match first\n    if (languageRules[packageName]) return languageRules[packageName];\n    if (languageRules[normalized]) return languageRules[normalized];\n    // Check for partial matches\n    for (const [rulePackage, version] of Object.entries(languageRules)){\n        if (normalizePackageName(rulePackage, language) === normalized) {\n            return version;\n        }\n    }\n    return null;\n}\n/**\r\n * Group dependencies by status\r\n * @param findings Dependency findings\r\n * @returns Grouped findings\r\n */ function groupDependenciesByStatus(findings) {\n    return {\n        ok: findings.filter((f)=>f.status === 'ok'),\n        affected: findings.filter((f)=>f.status === 'affected'),\n        unknown: findings.filter((f)=>f.status === 'unknown')\n    };\n}\n/**\r\n * Get dependency summary statistics\r\n * @param findings Dependency findings\r\n * @returns Summary statistics\r\n */ function getDependencySummary(findings) {\n    const total = findings.length;\n    const ok = findings.filter((f)=>f.status === 'ok').length;\n    const affected = findings.filter((f)=>f.status === 'affected').length;\n    const unknown = findings.filter((f)=>f.status === 'unknown').length;\n    return {\n        total,\n        ok,\n        affected,\n        unknown,\n        okPercentage: total > 0 ? ok / total * 100 : 0,\n        affectedPercentage: total > 0 ? affected / total * 100 : 0,\n        unknownPercentage: total > 0 ? unknown / total * 100 : 0\n    };\n}\n/**\r\n * Filter dependencies by language\r\n * @param findings Dependency findings\r\n * @param language Language to filter by\r\n * @returns Filtered findings\r\n */ function filterDependenciesByLanguage(findings, language) {\n    return findings.filter((f)=>f.lang === language);\n}\n/**\r\n * Sort dependencies by status and name\r\n * @param findings Dependency findings\r\n * @returns Sorted findings\r\n */ function sortDependencies(findings) {\n    const statusOrder = {\n        affected: 0,\n        unknown: 1,\n        ok: 2\n    };\n    return [\n        ...findings\n    ].sort((a, b)=>{\n        // First by status\n        const statusDiff = statusOrder[a.status] - statusOrder[b.status];\n        if (statusDiff !== 0) return statusDiff;\n        // Then by language\n        const langDiff = a.lang.localeCompare(b.lang);\n        if (langDiff !== 0) return langDiff;\n        // Finally by component name\n        return a.component.localeCompare(b.component);\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0tBQVMsQ0FBQ2lFLElBQUksQ0FBQyxDQUFDQyxHQUFHQztRQUM1QixrQkFBa0I7UUFDbEIsTUFBTUMsYUFBYUosV0FBVyxDQUFDRSxFQUFFbEQsTUFBTSxDQUFDLEdBQUdnRCxXQUFXLENBQUNHLEVBQUVuRCxNQUFNLENBQUM7UUFDaEUsSUFBSW9ELGVBQWUsR0FBRyxPQUFPQTtRQUU3QixtQkFBbUI7UUFDbkIsTUFBTUMsV0FBV0gsRUFBRXJELElBQUksQ0FBQ3lELGFBQWEsQ0FBQ0gsRUFBRXRELElBQUk7UUFDNUMsSUFBSXdELGFBQWEsR0FBRyxPQUFPQTtRQUUzQiw0QkFBNEI7UUFDNUIsT0FBT0gsRUFBRXBELFNBQVMsQ0FBQ3dELGFBQWEsQ0FBQ0gsRUFBRXJELFNBQVM7SUFDOUM7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxDa2hhZGFyXFxEb3dubG9hZHNcXEFJX0Jhc2VsaW5lX01hcFxcbGliXFxhbmFseXNpc1xcZGVwcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5ndWFnZSwgRGVwZW5kZW5jeUZpbmRpbmcsIFN0YXR1cyB9IGZyb20gJy4vYmFzZWxpbmUudHlwZXMnO1xyXG5pbXBvcnQgeyBCYXNlbGluZVJ1bGVzIH0gZnJvbSAnLi9iYXNlbGluZS50eXBlcyc7XHJcbmltcG9ydCB7IGNvbXBhcmVWZXJzaW9ucyB9IGZyb20gJy4vY29tcGFyZSc7XHJcblxyXG4vKipcclxuICogQW5hbHl6ZSBkZXBlbmRlbmNpZXMgZnJvbSBwcm9qZWN0IG1hbmlmZXN0c1xyXG4gKiBAcGFyYW0gbWFuaWZlc3RzIEFycmF5IG9mIHByb2plY3QgbWFuaWZlc3RzXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBkZXBlbmRlbmN5IGZpbmRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYW5hbHl6ZURlcGVuZGVuY2llcyhcclxuICBtYW5pZmVzdHM6IEFycmF5PHsgbGFuZ3VhZ2U6IExhbmd1YWdlOyBmaWxlOiBzdHJpbmc7IGRlcGVuZGVuY2llcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfT4sXHJcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNcclxuKTogRGVwZW5kZW5jeUZpbmRpbmdbXSB7XHJcbiAgY29uc3QgZmluZGluZ3M6IERlcGVuZGVuY3lGaW5kaW5nW10gPSBbXTtcclxuICBcclxuICBmb3IgKGNvbnN0IG1hbmlmZXN0IG9mIG1hbmlmZXN0cykge1xyXG4gICAgaWYgKCFtYW5pZmVzdC5kZXBlbmRlbmNpZXMpIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICBjb25zdCBsYW5ndWFnZVJ1bGVzID0gcnVsZXMucGFja2FnZV9taW5zW21hbmlmZXN0Lmxhbmd1YWdlXSB8fCB7fTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBbcGFja2FnZU5hbWUsIGZvdW5kVmVyc2lvbl0gb2YgT2JqZWN0LmVudHJpZXMobWFuaWZlc3QuZGVwZW5kZW5jaWVzKSkge1xyXG4gICAgICBjb25zdCBiYXNlbGluZVZlcnNpb24gPSBsYW5ndWFnZVJ1bGVzW3BhY2thZ2VOYW1lXTtcclxuICAgICAgXHJcbiAgICAgIGlmICghYmFzZWxpbmVWZXJzaW9uKSB7XHJcbiAgICAgICAgLy8gTm8gYmFzZWxpbmUgcnVsZSBmb3IgdGhpcyBwYWNrYWdlXHJcbiAgICAgICAgZmluZGluZ3MucHVzaCh7XHJcbiAgICAgICAgICBraW5kOiAnZGVwZW5kZW5jeScsXHJcbiAgICAgICAgICBsYW5nOiBtYW5pZmVzdC5sYW5ndWFnZSxcclxuICAgICAgICAgIGNvbXBvbmVudDogcGFja2FnZU5hbWUsXHJcbiAgICAgICAgICBmb3VuZFZlcnNpb24sXHJcbiAgICAgICAgICBiYXNlbGluZVJlcXVpcmVkOiBudWxsLFxyXG4gICAgICAgICAgc3RhdHVzOiAndW5rbm93bicsXHJcbiAgICAgICAgICByZWFzb246ICduby1iYXNlbGluZS1ydWxlJyxcclxuICAgICAgICAgIGZpbGU6IG1hbmlmZXN0LmZpbGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIENvbXBhcmUgdmVyc2lvbnNcclxuICAgICAgY29uc3QgY29tcGFyaXNvbiA9IGNvbXBhcmVWZXJzaW9ucyhmb3VuZFZlcnNpb24sIGJhc2VsaW5lVmVyc2lvbiwgbWFuaWZlc3QubGFuZ3VhZ2UpO1xyXG4gICAgICBcclxuICAgICAgbGV0IHN0YXR1czogU3RhdHVzO1xyXG4gICAgICBsZXQgcmVhc29uOiBzdHJpbmc7XHJcbiAgICAgIFxyXG4gICAgICBzd2l0Y2ggKGNvbXBhcmlzb24pIHtcclxuICAgICAgICBjYXNlICdncmVhdGVyJzpcclxuICAgICAgICBjYXNlICdlcXVhbCc6XHJcbiAgICAgICAgICBzdGF0dXMgPSAnb2snO1xyXG4gICAgICAgICAgcmVhc29uID0gJ21lZXRzLWJhc2VsaW5lJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2xlc3MnOlxyXG4gICAgICAgICAgc3RhdHVzID0gJ2FmZmVjdGVkJztcclxuICAgICAgICAgIHJlYXNvbiA9ICdiZWxvdy1iYXNlbGluZSc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd1bmtub3duJzpcclxuICAgICAgICAgIHN0YXR1cyA9ICd1bmtub3duJztcclxuICAgICAgICAgIHJlYXNvbiA9ICd2ZXJzaW9uLXBhcnNlLWVycm9yJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBzdGF0dXMgPSAndW5rbm93bic7XHJcbiAgICAgICAgICByZWFzb24gPSAndW5rbm93bi1jb21wYXJpc29uJztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgZmluZGluZ3MucHVzaCh7XHJcbiAgICAgICAga2luZDogJ2RlcGVuZGVuY3knLFxyXG4gICAgICAgIGxhbmc6IG1hbmlmZXN0Lmxhbmd1YWdlLFxyXG4gICAgICAgIGNvbXBvbmVudDogcGFja2FnZU5hbWUsXHJcbiAgICAgICAgZm91bmRWZXJzaW9uLFxyXG4gICAgICAgIGJhc2VsaW5lUmVxdWlyZWQ6IGJhc2VsaW5lVmVyc2lvbixcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgcmVhc29uLFxyXG4gICAgICAgIGZpbGU6IG1hbmlmZXN0LmZpbGUsXHJcbiAgICAgICAgcXVpY2tGaXg6IGdldERlcGVuZGVuY3lRdWlja0ZpeChydWxlcywgbWFuaWZlc3QubGFuZ3VhZ2UsIHBhY2thZ2VOYW1lLCBiYXNlbGluZVZlcnNpb24pLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGZpbmRpbmdzO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHF1aWNrIGZpeCBmb3IgZGVwZW5kZW5jeSB1cGdyYWRlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2VcclxuICogQHBhcmFtIHBhY2thZ2VOYW1lIFBhY2thZ2UgbmFtZVxyXG4gKiBAcGFyYW0gdmVyc2lvbiBSZXF1aXJlZCB2ZXJzaW9uXHJcbiAqIEByZXR1cm5zIFF1aWNrIGZpeCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGdldERlcGVuZGVuY3lRdWlja0ZpeChcclxuICBydWxlczogQmFzZWxpbmVSdWxlcyxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2UsXHJcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcclxuICB2ZXJzaW9uOiBzdHJpbmdcclxuKTogc3RyaW5nIHtcclxuICBjb25zdCB0ZW1wbGF0ZSA9IHJ1bGVzLnF1aWNrX2ZpeGVzLmRlcGVuZGVuY3lfdXBncmFkZVtsYW5ndWFnZV0gfHwgJ1VwZGF0ZSB7cGFja2FnZX0gdG8ge3ZlcnNpb259JztcclxuICBcclxuICByZXR1cm4gdGVtcGxhdGVcclxuICAgIC5yZXBsYWNlKCd7cGFja2FnZX0nLCBwYWNrYWdlTmFtZSlcclxuICAgIC5yZXBsYWNlKCd7dmVyc2lvbn0nLCB2ZXJzaW9uKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHZlcnNpb24gc3RyaW5nIGFuZCBleHRyYWN0IHZlcnNpb24gbnVtYmVyXHJcbiAqIEBwYXJhbSB2ZXJzaW9uU3RyaW5nIFZlcnNpb24gc3RyaW5nIChtYXkgY29udGFpbiBvcGVyYXRvcnMpXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIENsZWFuIHZlcnNpb24gc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VWZXJzaW9uKHZlcnNpb25TdHJpbmc6IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogc3RyaW5nIHtcclxuICBpZiAoIXZlcnNpb25TdHJpbmcgfHwgdmVyc2lvblN0cmluZyA9PT0gJyonKSB7XHJcbiAgICByZXR1cm4gJzAuMC4wJztcclxuICB9XHJcbiAgXHJcbiAgLy8gUmVtb3ZlIGNvbW1vbiBvcGVyYXRvcnMgYW5kIHByZWZpeGVzXHJcbiAgbGV0IGNsZWFuID0gdmVyc2lvblN0cmluZ1xyXG4gICAgLnJlcGxhY2UoL15bfl4+PTwhPV0rLywgJycpIC8vIFJlbW92ZSBvcGVyYXRvcnNcclxuICAgIC5yZXBsYWNlKC9edi8sICcnKSAvLyBSZW1vdmUgdiBwcmVmaXhcclxuICAgIC50cmltKCk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcclxuICBpZiAoY2xlYW4gPT09ICdsYXRlc3QnIHx8IGNsZWFuID09PSAnJykge1xyXG4gICAgcmV0dXJuICcwLjAuMCc7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBQeXRob24gdmVyc2lvbiBzcGVjaWZpZXJzXHJcbiAgaWYgKGxhbmd1YWdlID09PSAncHl0aG9uJykge1xyXG4gICAgLy8gUmVtb3ZlIFB5dGhvbi1zcGVjaWZpYyBvcGVyYXRvcnNcclxuICAgIGNsZWFuID0gY2xlYW4ucmVwbGFjZSgvXlt+PSE8Pl0rLywgJycpO1xyXG4gIH1cclxuICBcclxuICAvLyBIYW5kbGUgR28gdmVyc2lvbiBzdWZmaXhlc1xyXG4gIGlmIChsYW5ndWFnZSA9PT0gJ2dvJykge1xyXG4gICAgLy8gUmVtb3ZlICtpbmNvbXBhdGlibGUsICtpbmNvbXBhdGlibGUuMjAyMTAxMDEsIGV0Yy5cclxuICAgIGNsZWFuID0gY2xlYW4ucmVwbGFjZSgvXFwrLiokLywgJycpO1xyXG4gIH1cclxuICBcclxuICAvLyBIYW5kbGUgSmF2YSB2ZXJzaW9uIHJhbmdlc1xyXG4gIGlmIChsYW5ndWFnZSA9PT0gJ2phdmEnKSB7XHJcbiAgICAvLyBFeHRyYWN0IHZlcnNpb24gZnJvbSByYW5nZXMgbGlrZSBbMS4wLDIuMCkgb3IgKDEuMCwyLjBdXHJcbiAgICBjb25zdCByYW5nZU1hdGNoID0gY2xlYW4ubWF0Y2goL1tbKF0oW14sXSspLC8pO1xyXG4gICAgaWYgKHJhbmdlTWF0Y2gpIHtcclxuICAgICAgY2xlYW4gPSByYW5nZU1hdGNoWzFdO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gY2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZlcnNpb24gc3RyaW5nIGlzIHZhbGlkXHJcbiAqIEBwYXJhbSB2ZXJzaW9uU3RyaW5nIFZlcnNpb24gc3RyaW5nXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdmFsaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkVmVyc2lvbih2ZXJzaW9uU3RyaW5nOiBzdHJpbmcsIGxhbmd1YWdlOiBMYW5ndWFnZSk6IGJvb2xlYW4ge1xyXG4gIGlmICghdmVyc2lvblN0cmluZyB8fCB2ZXJzaW9uU3RyaW5nID09PSAnKicpIHJldHVybiBmYWxzZTtcclxuICBcclxuICBjb25zdCBjbGVhbiA9IHBhcnNlVmVyc2lvbih2ZXJzaW9uU3RyaW5nLCBsYW5ndWFnZSk7XHJcbiAgXHJcbiAgLy8gQmFzaWMgdmVyc2lvbiBwYXR0ZXJuIHZhbGlkYXRpb25cclxuICBjb25zdCB2ZXJzaW9uUGF0dGVybnMgPSB7XHJcbiAgICBub2RlOiAvXlxcZCtcXC5cXGQrXFwuXFxkKygtW2EtekEtWjAtOS4tXSspPyhcXCtbYS16QS1aMC05Li1dKyk/JC8sXHJcbiAgICBweXRob246IC9eXFxkK1xcLlxcZCsoXFwuXFxkKyk/KFthLXpBLVowLTkuLV0rKT8kLyxcclxuICAgIGphdmE6IC9eXFxkKyhcXC5cXGQrKSooLVthLXpBLVowLTkuLV0rKT8kLyxcclxuICAgIGdvOiAvXnY/XFxkK1xcLlxcZCtcXC5cXGQrKC1bYS16QS1aMC05Li1dKyk/KFxcK1thLXpBLVowLTkuLV0rKT8kLyxcclxuICAgIGRvdG5ldDogL15cXGQrXFwuXFxkKyhcXC5cXGQrKT8oLVthLXpBLVowLTkuLV0rKT8kLyxcclxuICB9O1xyXG4gIFxyXG4gIGNvbnN0IHBhdHRlcm4gPSB2ZXJzaW9uUGF0dGVybnNbbGFuZ3VhZ2VdO1xyXG4gIHJldHVybiBwYXR0ZXJuID8gcGF0dGVybi50ZXN0KGNsZWFuKSA6IGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIHBhY2thZ2UgbmFtZSBmb3IgY29tcGFyaXNvblxyXG4gKiBAcGFyYW0gcGFja2FnZU5hbWUgUGFja2FnZSBuYW1lXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgcGFja2FnZSBuYW1lXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUGFja2FnZU5hbWUocGFja2FnZU5hbWU6IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogc3RyaW5nIHtcclxuICBsZXQgbm9ybWFsaXplZCA9IHBhY2thZ2VOYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSBzY29wZWQgcGFja2FnZXMgKE5vZGUuanMpXHJcbiAgaWYgKGxhbmd1YWdlID09PSAnbm9kZScgJiYgbm9ybWFsaXplZC5zdGFydHNXaXRoKCdAJykpIHtcclxuICAgIC8vIEtlZXAgQHNjb3BlL3BhY2thZ2UgZm9ybWF0XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIEphdmEgZ3JvdXA6YXJ0aWZhY3QgZm9ybWF0XHJcbiAgaWYgKGxhbmd1YWdlID09PSAnamF2YScgJiYgbm9ybWFsaXplZC5pbmNsdWRlcygnOicpKSB7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIEdvIG1vZHVsZXNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdnbycpIHtcclxuICAgIC8vIFJlbW92ZSBjb21tb24gcHJlZml4ZXNcclxuICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLnJlcGxhY2UoL15naXRodWJcXC5jb21cXC8vLCAnJyk7XHJcbiAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9eZ29sYW5nXFwub3JnXFwveFxcLy8sICcnKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIC5ORVQgcGFja2FnZXNcclxuICBpZiAobGFuZ3VhZ2UgPT09ICdkb3RuZXQnKSB7XHJcbiAgICAvLyBSZW1vdmUgY29tbW9uIHByZWZpeGVzXHJcbiAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9ebWljcm9zb2Z0XFwuLywgJycpO1xyXG4gICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXnN5c3RlbVxcLi8sICcnKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHBhY2thZ2UgaXMgaW4gdGhlIGJhc2VsaW5lIHJ1bGVzXHJcbiAqIEBwYXJhbSBwYWNrYWdlTmFtZSBQYWNrYWdlIG5hbWVcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHBhY2thZ2UgaGFzIGJhc2VsaW5lIHJ1bGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzQmFzZWxpbmVSdWxlKFxyXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmcsXHJcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlLFxyXG4gIHJ1bGVzOiBCYXNlbGluZVJ1bGVzXHJcbik6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IGxhbmd1YWdlUnVsZXMgPSBydWxlcy5wYWNrYWdlX21pbnNbbGFuZ3VhZ2VdIHx8IHt9O1xyXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQYWNrYWdlTmFtZShwYWNrYWdlTmFtZSwgbGFuZ3VhZ2UpO1xyXG4gIFxyXG4gIC8vIENoZWNrIGV4YWN0IG1hdGNoIGZpcnN0XHJcbiAgaWYgKGxhbmd1YWdlUnVsZXNbcGFja2FnZU5hbWVdKSByZXR1cm4gdHJ1ZTtcclxuICBpZiAobGFuZ3VhZ2VSdWxlc1tub3JtYWxpemVkXSkgcmV0dXJuIHRydWU7XHJcbiAgXHJcbiAgLy8gQ2hlY2sgZm9yIHBhcnRpYWwgbWF0Y2hlcyAoZm9yIHNjb3BlZCBwYWNrYWdlcywgZXRjLilcclxuICBmb3IgKGNvbnN0IFtydWxlUGFja2FnZV0gb2YgT2JqZWN0LmVudHJpZXMobGFuZ3VhZ2VSdWxlcykpIHtcclxuICAgIGlmIChub3JtYWxpemVQYWNrYWdlTmFtZShydWxlUGFja2FnZSwgbGFuZ3VhZ2UpID09PSBub3JtYWxpemVkKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYmFzZWxpbmUgdmVyc2lvbiBmb3IgYSBwYWNrYWdlXHJcbiAqIEBwYXJhbSBwYWNrYWdlTmFtZSBQYWNrYWdlIG5hbWVcclxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXHJcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xyXG4gKiBAcmV0dXJucyBCYXNlbGluZSB2ZXJzaW9uIG9yIG51bGxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXNlbGluZVZlcnNpb24oXHJcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcclxuICBsYW5ndWFnZTogTGFuZ3VhZ2UsXHJcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNcclxuKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgY29uc3QgbGFuZ3VhZ2VSdWxlcyA9IHJ1bGVzLnBhY2thZ2VfbWluc1tsYW5ndWFnZV0gfHwge307XHJcbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVBhY2thZ2VOYW1lKHBhY2thZ2VOYW1lLCBsYW5ndWFnZSk7XHJcbiAgXHJcbiAgLy8gQ2hlY2sgZXhhY3QgbWF0Y2ggZmlyc3RcclxuICBpZiAobGFuZ3VhZ2VSdWxlc1twYWNrYWdlTmFtZV0pIHJldHVybiBsYW5ndWFnZVJ1bGVzW3BhY2thZ2VOYW1lXTtcclxuICBpZiAobGFuZ3VhZ2VSdWxlc1tub3JtYWxpemVkXSkgcmV0dXJuIGxhbmd1YWdlUnVsZXNbbm9ybWFsaXplZF07XHJcbiAgXHJcbiAgLy8gQ2hlY2sgZm9yIHBhcnRpYWwgbWF0Y2hlc1xyXG4gIGZvciAoY29uc3QgW3J1bGVQYWNrYWdlLCB2ZXJzaW9uXSBvZiBPYmplY3QuZW50cmllcyhsYW5ndWFnZVJ1bGVzKSkge1xyXG4gICAgaWYgKG5vcm1hbGl6ZVBhY2thZ2VOYW1lKHJ1bGVQYWNrYWdlLCBsYW5ndWFnZSkgPT09IG5vcm1hbGl6ZWQpIHtcclxuICAgICAgcmV0dXJuIHZlcnNpb247XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogR3JvdXAgZGVwZW5kZW5jaWVzIGJ5IHN0YXR1c1xyXG4gKiBAcGFyYW0gZmluZGluZ3MgRGVwZW5kZW5jeSBmaW5kaW5nc1xyXG4gKiBAcmV0dXJucyBHcm91cGVkIGZpbmRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBEZXBlbmRlbmNpZXNCeVN0YXR1cyhmaW5kaW5nczogRGVwZW5kZW5jeUZpbmRpbmdbXSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBvazogZmluZGluZ3MuZmlsdGVyKGYgPT4gZi5zdGF0dXMgPT09ICdvaycpLFxyXG4gICAgYWZmZWN0ZWQ6IGZpbmRpbmdzLmZpbHRlcihmID0+IGYuc3RhdHVzID09PSAnYWZmZWN0ZWQnKSxcclxuICAgIHVua25vd246IGZpbmRpbmdzLmZpbHRlcihmID0+IGYuc3RhdHVzID09PSAndW5rbm93bicpLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZGVwZW5kZW5jeSBzdW1tYXJ5IHN0YXRpc3RpY3NcclxuICogQHBhcmFtIGZpbmRpbmdzIERlcGVuZGVuY3kgZmluZGluZ3NcclxuICogQHJldHVybnMgU3VtbWFyeSBzdGF0aXN0aWNzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeVN1bW1hcnkoZmluZGluZ3M6IERlcGVuZGVuY3lGaW5kaW5nW10pIHtcclxuICBjb25zdCB0b3RhbCA9IGZpbmRpbmdzLmxlbmd0aDtcclxuICBjb25zdCBvayA9IGZpbmRpbmdzLmZpbHRlcihmID0+IGYuc3RhdHVzID09PSAnb2snKS5sZW5ndGg7XHJcbiAgY29uc3QgYWZmZWN0ZWQgPSBmaW5kaW5ncy5maWx0ZXIoZiA9PiBmLnN0YXR1cyA9PT0gJ2FmZmVjdGVkJykubGVuZ3RoO1xyXG4gIGNvbnN0IHVua25vd24gPSBmaW5kaW5ncy5maWx0ZXIoZiA9PiBmLnN0YXR1cyA9PT0gJ3Vua25vd24nKS5sZW5ndGg7XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIHRvdGFsLFxyXG4gICAgb2ssXHJcbiAgICBhZmZlY3RlZCxcclxuICAgIHVua25vd24sXHJcbiAgICBva1BlcmNlbnRhZ2U6IHRvdGFsID4gMCA/IChvayAvIHRvdGFsKSAqIDEwMCA6IDAsXHJcbiAgICBhZmZlY3RlZFBlcmNlbnRhZ2U6IHRvdGFsID4gMCA/IChhZmZlY3RlZCAvIHRvdGFsKSAqIDEwMCA6IDAsXHJcbiAgICB1bmtub3duUGVyY2VudGFnZTogdG90YWwgPiAwID8gKHVua25vd24gLyB0b3RhbCkgKiAxMDAgOiAwLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaWx0ZXIgZGVwZW5kZW5jaWVzIGJ5IGxhbmd1YWdlXHJcbiAqIEBwYXJhbSBmaW5kaW5ncyBEZXBlbmRlbmN5IGZpbmRpbmdzXHJcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSB0byBmaWx0ZXIgYnlcclxuICogQHJldHVybnMgRmlsdGVyZWQgZmluZGluZ3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJEZXBlbmRlbmNpZXNCeUxhbmd1YWdlKFxyXG4gIGZpbmRpbmdzOiBEZXBlbmRlbmN5RmluZGluZ1tdLFxyXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxyXG4pOiBEZXBlbmRlbmN5RmluZGluZ1tdIHtcclxuICByZXR1cm4gZmluZGluZ3MuZmlsdGVyKGYgPT4gZi5sYW5nID09PSBsYW5ndWFnZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTb3J0IGRlcGVuZGVuY2llcyBieSBzdGF0dXMgYW5kIG5hbWVcclxuICogQHBhcmFtIGZpbmRpbmdzIERlcGVuZGVuY3kgZmluZGluZ3NcclxuICogQHJldHVybnMgU29ydGVkIGZpbmRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29ydERlcGVuZGVuY2llcyhmaW5kaW5nczogRGVwZW5kZW5jeUZpbmRpbmdbXSk6IERlcGVuZGVuY3lGaW5kaW5nW10ge1xyXG4gIGNvbnN0IHN0YXR1c09yZGVyID0geyBhZmZlY3RlZDogMCwgdW5rbm93bjogMSwgb2s6IDIgfTtcclxuICBcclxuICByZXR1cm4gWy4uLmZpbmRpbmdzXS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAvLyBGaXJzdCBieSBzdGF0dXNcclxuICAgIGNvbnN0IHN0YXR1c0RpZmYgPSBzdGF0dXNPcmRlclthLnN0YXR1c10gLSBzdGF0dXNPcmRlcltiLnN0YXR1c107XHJcbiAgICBpZiAoc3RhdHVzRGlmZiAhPT0gMCkgcmV0dXJuIHN0YXR1c0RpZmY7XHJcbiAgICBcclxuICAgIC8vIFRoZW4gYnkgbGFuZ3VhZ2VcclxuICAgIGNvbnN0IGxhbmdEaWZmID0gYS5sYW5nLmxvY2FsZUNvbXBhcmUoYi5sYW5nKTtcclxuICAgIGlmIChsYW5nRGlmZiAhPT0gMCkgcmV0dXJuIGxhbmdEaWZmO1xyXG4gICAgXHJcbiAgICAvLyBGaW5hbGx5IGJ5IGNvbXBvbmVudCBuYW1lXHJcbiAgICByZXR1cm4gYS5jb21wb25lbnQubG9jYWxlQ29tcGFyZShiLmNvbXBvbmVudCk7XHJcbiAgfSk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNvbXBhcmVWZXJzaW9ucyIsImFuYWx5emVEZXBlbmRlbmNpZXMiLCJtYW5pZmVzdHMiLCJydWxlcyIsImZpbmRpbmdzIiwibWFuaWZlc3QiLCJkZXBlbmRlbmNpZXMiLCJsYW5ndWFnZVJ1bGVzIiwicGFja2FnZV9taW5zIiwibGFuZ3VhZ2UiLCJwYWNrYWdlTmFtZSIsImZvdW5kVmVyc2lvbiIsIk9iamVjdCIsImVudHJpZXMiLCJiYXNlbGluZVZlcnNpb24iLCJwdXNoIiwia2luZCIsImxhbmciLCJjb21wb25lbnQiLCJiYXNlbGluZVJlcXVpcmVkIiwic3RhdHVzIiwicmVhc29uIiwiZmlsZSIsImNvbXBhcmlzb24iLCJxdWlja0ZpeCIsImdldERlcGVuZGVuY3lRdWlja0ZpeCIsInZlcnNpb24iLCJ0ZW1wbGF0ZSIsInF1aWNrX2ZpeGVzIiwiZGVwZW5kZW5jeV91cGdyYWRlIiwicmVwbGFjZSIsInBhcnNlVmVyc2lvbiIsInZlcnNpb25TdHJpbmciLCJjbGVhbiIsInRyaW0iLCJyYW5nZU1hdGNoIiwibWF0Y2giLCJpc1ZhbGlkVmVyc2lvbiIsInZlcnNpb25QYXR0ZXJucyIsIm5vZGUiLCJweXRob24iLCJqYXZhIiwiZ28iLCJkb3RuZXQiLCJwYXR0ZXJuIiwidGVzdCIsIm5vcm1hbGl6ZVBhY2thZ2VOYW1lIiwibm9ybWFsaXplZCIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwiaGFzQmFzZWxpbmVSdWxlIiwicnVsZVBhY2thZ2UiLCJnZXRCYXNlbGluZVZlcnNpb24iLCJncm91cERlcGVuZGVuY2llc0J5U3RhdHVzIiwib2siLCJmaWx0ZXIiLCJmIiwiYWZmZWN0ZWQiLCJ1bmtub3duIiwiZ2V0RGVwZW5kZW5jeVN1bW1hcnkiLCJ0b3RhbCIsImxlbmd0aCIsIm9rUGVyY2VudGFnZSIsImFmZmVjdGVkUGVyY2VudGFnZSIsInVua25vd25QZXJjZW50YWdlIiwiZmlsdGVyRGVwZW5kZW5jaWVzQnlMYW5ndWFnZSIsInNvcnREZXBlbmRlbmNpZXMiLCJzdGF0dXNPcmRlciIsInNvcnQiLCJhIiwiYiIsInN0YXR1c0RpZmYiLCJsYW5nRGlmZiIsImxvY2FsZUNvbXBhcmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/deps.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/detect.ts":
/*!********************************!*\
  !*** ./lib/analysis/detect.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectLanguagesFromFiles: () => (/* binding */ detectLanguagesFromFiles),\n/* harmony export */   detectProjectManifests: () => (/* binding */ detectProjectManifests),\n/* harmony export */   getManifestType: () => (/* binding */ getManifestType),\n/* harmony export */   getPrimaryLanguage: () => (/* binding */ getPrimaryLanguage),\n/* harmony export */   isManifestFile: () => (/* binding */ isManifestFile)\n/* harmony export */ });\n/**\r\n * Detect project languages and manifests from extracted files\r\n * @param files Array of extracted files\r\n * @returns Array of detected project manifests\r\n */ function detectProjectManifests(files) {\n    const manifests = [];\n    // Look for package.json (Node.js)\n    const packageJson = files.find((f)=>(f.path || f.name)?.endsWith('package.json'));\n    if (packageJson) {\n        try {\n            const pkg = JSON.parse(packageJson.content);\n            manifests.push({\n                language: 'node',\n                file: packageJson.path || packageJson.name || 'package.json',\n                dependencies: pkg.dependencies,\n                devDependencies: pkg.devDependencies,\n                peerDependencies: pkg.peerDependencies,\n                optionalDependencies: pkg.optionalDependencies\n            });\n        } catch (error) {\n            console.warn(`Failed to parse package.json: ${error}`);\n        }\n    }\n    // Look for requirements.txt (Python)\n    const requirementsTxt = files.find((f)=>(f.path || f.name)?.endsWith('requirements.txt'));\n    if (requirementsTxt) {\n        manifests.push({\n            language: 'python',\n            file: requirementsTxt.path || requirementsTxt.name || 'requirements.txt',\n            dependencies: parseRequirementsTxt(requirementsTxt.content)\n        });\n    }\n    // Look for pyproject.toml (Python)\n    const pyprojectToml = files.find((f)=>(f.path || f.name)?.endsWith('pyproject.toml'));\n    if (pyprojectToml) {\n        try {\n            const deps = parsePyprojectToml(pyprojectToml.content);\n            if (deps) {\n                manifests.push({\n                    language: 'python',\n                    file: pyprojectToml.path || pyprojectToml.name || 'pyproject.toml',\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse pyproject.toml: ${error}`);\n        }\n    }\n    // Look for pom.xml (Java Maven)\n    const pomXml = files.find((f)=>(f.path || f.name)?.endsWith('pom.xml'));\n    if (pomXml) {\n        try {\n            const deps = parsePomXml(pomXml.content);\n            if (deps) {\n                manifests.push({\n                    language: 'java',\n                    file: pomXml.path || pomXml.name || 'pom.xml',\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse pom.xml: ${error}`);\n        }\n    }\n    // Look for build.gradle (Java Gradle)\n    const buildGradle = files.find((f)=>{\n        const path = f.path || f.name;\n        return path?.endsWith('build.gradle') || path?.endsWith('build.gradle.kts');\n    });\n    if (buildGradle) {\n        try {\n            const deps = parseBuildGradle(buildGradle.content);\n            if (deps) {\n                manifests.push({\n                    language: 'java',\n                    file: buildGradle.path || buildGradle.name || 'build.gradle',\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse build.gradle: ${error}`);\n        }\n    }\n    // Look for go.mod (Go)\n    const goMod = files.find((f)=>(f.path || f.name)?.endsWith('go.mod'));\n    if (goMod) {\n        try {\n            const deps = parseGoMod(goMod.content);\n            if (deps) {\n                manifests.push({\n                    language: 'go',\n                    file: goMod.path || goMod.name || 'go.mod',\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse go.mod: ${error}`);\n        }\n    }\n    // Look for .csproj files (.NET)\n    const csprojFiles = files.filter((f)=>(f.path || f.name)?.endsWith('.csproj'));\n    for (const csproj of csprojFiles){\n        try {\n            const deps = parseCsproj(csproj.content);\n            if (deps) {\n                manifests.push({\n                    language: 'dotnet',\n                    file: csproj.path || csproj.name || 'project.csproj',\n                    dependencies: deps\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to parse ${csproj.path || csproj.name || 'project.csproj'}: ${error}`);\n        }\n    }\n    return manifests;\n}\n/**\r\n * Parse requirements.txt content\r\n * @param content requirements.txt content\r\n * @returns Dependencies object\r\n */ function parseRequirementsTxt(content) {\n    const deps = {};\n    const lines = content.split('\\n');\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (!trimmed || trimmed.startsWith('#')) continue;\n        // Handle various requirement formats\n        // package==1.0.0\n        // package>=1.0.0\n        // package~=1.0.0\n        // package\n        const match = trimmed.match(/^([a-zA-Z0-9_-]+)(.*)$/);\n        if (match) {\n            const [, name, version] = match;\n            deps[name] = version || '*';\n        }\n    }\n    return deps;\n}\n/**\r\n * Parse pyproject.toml content (basic parsing)\r\n * @param content pyproject.toml content\r\n * @returns Dependencies object or null\r\n */ function parsePyprojectToml(content) {\n    const deps = {};\n    // Simple TOML parsing for dependencies\n    const lines = content.split('\\n');\n    let inDependencies = false;\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (trimmed.startsWith('[tool.poetry.dependencies]') || trimmed.startsWith('[project.dependencies]') || trimmed.startsWith('[dependencies]')) {\n            inDependencies = true;\n            continue;\n        }\n        if (trimmed.startsWith('[') && inDependencies) {\n            break;\n        }\n        if (inDependencies && trimmed && !trimmed.startsWith('#')) {\n            const match = trimmed.match(/^([a-zA-Z0-9_-]+)\\s*=\\s*[\"']?([^\"']+)[\"']?/);\n            if (match) {\n                const [, name, version] = match;\n                deps[name] = version;\n            }\n        }\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse pom.xml content (basic XML parsing)\r\n * @param content pom.xml content\r\n * @returns Dependencies object or null\r\n */ function parsePomXml(content) {\n    const deps = {};\n    // Simple XML parsing for dependencies\n    const dependencyRegex = /<dependency>\\s*<groupId>([^<]+)<\\/groupId>\\s*<artifactId>([^<]+)<\\/artifactId>\\s*<version>([^<]+)<\\/version>/g;\n    let match;\n    while((match = dependencyRegex.exec(content)) !== null){\n        const [, groupId, artifactId, version] = match;\n        const fullName = `${groupId}:${artifactId}`;\n        deps[fullName] = version;\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse build.gradle content (basic parsing)\r\n * @param content build.gradle content\r\n * @returns Dependencies object or null\r\n */ function parseBuildGradle(content) {\n    const deps = {};\n    // Simple Gradle parsing for dependencies\n    const lines = content.split('\\n');\n    let inDependencies = false;\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (trimmed.includes('dependencies') && trimmed.includes('{')) {\n            inDependencies = true;\n            continue;\n        }\n        if (trimmed === '}' && inDependencies) {\n            break;\n        }\n        if (inDependencies && trimmed.includes('implementation') || trimmed.includes('compile')) {\n            // implementation 'group:artifact:version'\n            // implementation(\"group:artifact:version\")\n            const match = trimmed.match(/(?:implementation|compile)\\s*[(\"]?([^:)]+):([^:)]+):([^:)]+)/);\n            if (match) {\n                const [, group, artifact, version] = match;\n                const fullName = `${group}:${artifact}`;\n                deps[fullName] = version;\n            }\n        }\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse go.mod content\r\n * @param content go.mod content\r\n * @returns Dependencies object or null\r\n */ function parseGoMod(content) {\n    const deps = {};\n    const lines = content.split('\\n');\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (trimmed.startsWith('require')) {\n            continue;\n        }\n        if (trimmed.startsWith('require ')) {\n            // require module v1.0.0\n            const match = trimmed.match(/require\\s+([^\\s]+)\\s+([^\\s]+)/);\n            if (match) {\n                const [, module, version] = match;\n                deps[module] = version;\n            }\n        } else if (trimmed && !trimmed.startsWith('go ') && !trimmed.startsWith('module ') && !trimmed.startsWith('//')) {\n            // Module version line\n            const match = trimmed.match(/^([^\\s]+)\\s+([^\\s]+)/);\n            if (match) {\n                const [, module, version] = match;\n                deps[module] = version;\n            }\n        }\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Parse .csproj content (basic XML parsing)\r\n * @param content .csproj content\r\n * @returns Dependencies object or null\r\n */ function parseCsproj(content) {\n    const deps = {};\n    // Simple XML parsing for PackageReference\n    const packageRefRegex = /<PackageReference\\s+Include=\"([^\"]+)\"\\s+Version=\"([^\"]+)\"\\s*\\/?>/g;\n    let match;\n    while((match = packageRefRegex.exec(content)) !== null){\n        const [, packageName, version] = match;\n        deps[packageName] = version;\n    }\n    return Object.keys(deps).length > 0 ? deps : null;\n}\n/**\r\n * Detect languages from file extensions\r\n * @param files Array of extracted files\r\n * @returns Array of detected languages\r\n */ function detectLanguagesFromFiles(files) {\n    const languageMap = {\n        '.js': 'node',\n        '.jsx': 'node',\n        '.ts': 'node',\n        '.tsx': 'node',\n        '.py': 'python',\n        '.java': 'java',\n        '.go': 'go',\n        '.cs': 'dotnet',\n        '.fs': 'dotnet',\n        '.vb': 'dotnet'\n    };\n    const detectedLanguages = new Set();\n    for (const file of files){\n        const filePath = file.path || file.name;\n        if (filePath) {\n            const ext = getFileExtension(filePath);\n            const language = languageMap[ext];\n            if (language) {\n                detectedLanguages.add(language);\n            }\n        }\n    }\n    return Array.from(detectedLanguages);\n}\n/**\r\n * Get file extension from path\r\n * @param filePath File path\r\n * @returns File extension with dot\r\n */ function getFileExtension(filePath) {\n    const lastDot = filePath.lastIndexOf('.');\n    if (lastDot === -1) return '';\n    return filePath.substring(lastDot);\n}\n/**\r\n * Get primary language from manifests\r\n * @param manifests Array of project manifests\r\n * @returns Primary language or null\r\n */ function getPrimaryLanguage(manifests) {\n    if (manifests.length === 0) return null;\n    // Priority order: node, python, java, go, dotnet\n    const priority = [\n        'node',\n        'python',\n        'java',\n        'go',\n        'dotnet'\n    ];\n    for (const lang of priority){\n        if (manifests.some((m)=>m.language === lang)) {\n            return lang;\n        }\n    }\n    return manifests[0].language;\n}\n/**\r\n * Check if a file is a manifest file\r\n * @param filePath File path\r\n * @returns True if it's a manifest file\r\n */ function isManifestFile(filePath) {\n    const manifestFiles = [\n        'package.json',\n        'requirements.txt',\n        'pyproject.toml',\n        'pom.xml',\n        'build.gradle',\n        'build.gradle.kts',\n        'go.mod',\n        '.csproj'\n    ];\n    return manifestFiles.some((manifest)=>filePath.endsWith(manifest));\n}\n/**\r\n * Get manifest file type from path\r\n * @param filePath File path\r\n * @returns Manifest type or null\r\n */ function getManifestType(filePath) {\n    if (filePath.endsWith('package.json')) {\n        return {\n            language: 'node',\n            type: 'package.json'\n        };\n    }\n    if (filePath.endsWith('requirements.txt')) {\n        return {\n            language: 'python',\n            type: 'requirements.txt'\n        };\n    }\n    if (filePath.endsWith('pyproject.toml')) {\n        return {\n            language: 'python',\n            type: 'pyproject.toml'\n        };\n    }\n    if (filePath.endsWith('pom.xml')) {\n        return {\n            language: 'java',\n            type: 'pom.xml'\n        };\n    }\n    if (filePath.endsWith('build.gradle') || filePath.endsWith('build.gradle.kts')) {\n        return {\n            language: 'java',\n            type: 'build.gradle'\n        };\n    }\n    if (filePath.endsWith('go.mod')) {\n        return {\n            language: 'go',\n            type: 'go.mod'\n        };\n    }\n    if (filePath.endsWith('.csproj')) {\n        return {\n            language: 'dotnet',\n            type: '.csproj'\n        };\n    }\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFVO1lBQVFxRSxNQUFNO1FBQVU7SUFDN0M7SUFDQSxJQUFJbEIsU0FBU3pELFFBQVEsQ0FBQyxtQkFBbUJ5RCxTQUFTekQsUUFBUSxDQUFDLHFCQUFxQjtRQUM5RSxPQUFPO1lBQUVNLFVBQVU7WUFBUXFFLE1BQU07UUFBZTtJQUNsRDtJQUNBLElBQUlsQixTQUFTekQsUUFBUSxDQUFDLFdBQVc7UUFDL0IsT0FBTztZQUFFTSxVQUFVO1lBQU1xRSxNQUFNO1FBQVM7SUFDMUM7SUFDQSxJQUFJbEIsU0FBU3pELFFBQVEsQ0FBQyxZQUFZO1FBQ2hDLE9BQU87WUFBRU0sVUFBVTtZQUFVcUUsTUFBTTtRQUFVO0lBQy9DO0lBRUEsT0FBTztBQUNUIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxkZXRlY3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTGFuZ3VhZ2UsIFByb2plY3RNYW5pZmVzdCB9IGZyb20gJy4vYmFzZWxpbmUudHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIERldGVjdCBwcm9qZWN0IGxhbmd1YWdlcyBhbmQgbWFuaWZlc3RzIGZyb20gZXh0cmFjdGVkIGZpbGVzXHJcbiAqIEBwYXJhbSBmaWxlcyBBcnJheSBvZiBleHRyYWN0ZWQgZmlsZXNcclxuICogQHJldHVybnMgQXJyYXkgb2YgZGV0ZWN0ZWQgcHJvamVjdCBtYW5pZmVzdHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RQcm9qZWN0TWFuaWZlc3RzKGZpbGVzOiB7IHBhdGg/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZyB9W10pOiBQcm9qZWN0TWFuaWZlc3RbXSB7XHJcbiAgY29uc3QgbWFuaWZlc3RzOiBQcm9qZWN0TWFuaWZlc3RbXSA9IFtdO1xyXG4gIFxyXG4gIC8vIExvb2sgZm9yIHBhY2thZ2UuanNvbiAoTm9kZS5qcylcclxuICBjb25zdCBwYWNrYWdlSnNvbiA9IGZpbGVzLmZpbmQoZiA9PiAoZi5wYXRoIHx8IGYubmFtZSk/LmVuZHNXaXRoKCdwYWNrYWdlLmpzb24nKSk7XHJcbiAgaWYgKHBhY2thZ2VKc29uKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwa2cgPSBKU09OLnBhcnNlKHBhY2thZ2VKc29uLmNvbnRlbnQpO1xyXG4gICAgICBtYW5pZmVzdHMucHVzaCh7XHJcbiAgICAgICAgbGFuZ3VhZ2U6ICdub2RlJyxcclxuICAgICAgICBmaWxlOiBwYWNrYWdlSnNvbi5wYXRoIHx8IHBhY2thZ2VKc29uLm5hbWUgfHwgJ3BhY2thZ2UuanNvbicsXHJcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBwa2cuZGVwZW5kZW5jaWVzLFxyXG4gICAgICAgIGRldkRlcGVuZGVuY2llczogcGtnLmRldkRlcGVuZGVuY2llcyxcclxuICAgICAgICBwZWVyRGVwZW5kZW5jaWVzOiBwa2cucGVlckRlcGVuZGVuY2llcyxcclxuICAgICAgICBvcHRpb25hbERlcGVuZGVuY2llczogcGtnLm9wdGlvbmFsRGVwZW5kZW5jaWVzLFxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHBhcnNlIHBhY2thZ2UuanNvbjogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgcmVxdWlyZW1lbnRzLnR4dCAoUHl0aG9uKVxyXG4gIGNvbnN0IHJlcXVpcmVtZW50c1R4dCA9IGZpbGVzLmZpbmQoZiA9PiAoZi5wYXRoIHx8IGYubmFtZSk/LmVuZHNXaXRoKCdyZXF1aXJlbWVudHMudHh0JykpO1xyXG4gIGlmIChyZXF1aXJlbWVudHNUeHQpIHtcclxuICAgIG1hbmlmZXN0cy5wdXNoKHtcclxuICAgICAgbGFuZ3VhZ2U6ICdweXRob24nLFxyXG4gICAgICAgIGZpbGU6IHJlcXVpcmVtZW50c1R4dC5wYXRoIHx8IHJlcXVpcmVtZW50c1R4dC5uYW1lIHx8ICdyZXF1aXJlbWVudHMudHh0JyxcclxuICAgICAgZGVwZW5kZW5jaWVzOiBwYXJzZVJlcXVpcmVtZW50c1R4dChyZXF1aXJlbWVudHNUeHQuY29udGVudCksXHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgcHlwcm9qZWN0LnRvbWwgKFB5dGhvbilcclxuICBjb25zdCBweXByb2plY3RUb21sID0gZmlsZXMuZmluZChmID0+IChmLnBhdGggfHwgZi5uYW1lKT8uZW5kc1dpdGgoJ3B5cHJvamVjdC50b21sJykpO1xyXG4gIGlmIChweXByb2plY3RUb21sKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkZXBzID0gcGFyc2VQeXByb2plY3RUb21sKHB5cHJvamVjdFRvbWwuY29udGVudCk7XHJcbiAgICAgIGlmIChkZXBzKSB7XHJcbiAgICAgICAgbWFuaWZlc3RzLnB1c2goe1xyXG4gICAgICAgICAgbGFuZ3VhZ2U6ICdweXRob24nLFxyXG4gICAgICAgICAgZmlsZTogcHlwcm9qZWN0VG9tbC5wYXRoIHx8IHB5cHJvamVjdFRvbWwubmFtZSB8fCAncHlwcm9qZWN0LnRvbWwnLFxyXG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBkZXBzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBwYXJzZSBweXByb2plY3QudG9tbDogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgcG9tLnhtbCAoSmF2YSBNYXZlbilcclxuICBjb25zdCBwb21YbWwgPSBmaWxlcy5maW5kKGYgPT4gKGYucGF0aCB8fCBmLm5hbWUpPy5lbmRzV2l0aCgncG9tLnhtbCcpKTtcclxuICBpZiAocG9tWG1sKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkZXBzID0gcGFyc2VQb21YbWwocG9tWG1sLmNvbnRlbnQpO1xyXG4gICAgICBpZiAoZGVwcykge1xyXG4gICAgICAgIG1hbmlmZXN0cy5wdXNoKHtcclxuICAgICAgICAgIGxhbmd1YWdlOiAnamF2YScsXHJcbiAgICAgICAgICBmaWxlOiBwb21YbWwucGF0aCB8fCBwb21YbWwubmFtZSB8fCAncG9tLnhtbCcsXHJcbiAgICAgICAgICBkZXBlbmRlbmNpZXM6IGRlcHMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHBhcnNlIHBvbS54bWw6ICR7ZXJyb3J9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIExvb2sgZm9yIGJ1aWxkLmdyYWRsZSAoSmF2YSBHcmFkbGUpXHJcbiAgY29uc3QgYnVpbGRHcmFkbGUgPSBmaWxlcy5maW5kKGYgPT4ge1xyXG4gICAgY29uc3QgcGF0aCA9IGYucGF0aCB8fCBmLm5hbWU7XHJcbiAgICByZXR1cm4gcGF0aD8uZW5kc1dpdGgoJ2J1aWxkLmdyYWRsZScpIHx8IHBhdGg/LmVuZHNXaXRoKCdidWlsZC5ncmFkbGUua3RzJyk7XHJcbiAgfSk7XHJcbiAgaWYgKGJ1aWxkR3JhZGxlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkZXBzID0gcGFyc2VCdWlsZEdyYWRsZShidWlsZEdyYWRsZS5jb250ZW50KTtcclxuICAgICAgaWYgKGRlcHMpIHtcclxuICAgICAgICBtYW5pZmVzdHMucHVzaCh7XHJcbiAgICAgICAgICBsYW5ndWFnZTogJ2phdmEnLFxyXG4gICAgICAgICAgZmlsZTogYnVpbGRHcmFkbGUucGF0aCB8fCBidWlsZEdyYWRsZS5uYW1lIHx8ICdidWlsZC5ncmFkbGUnLFxyXG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBkZXBzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBwYXJzZSBidWlsZC5ncmFkbGU6ICR7ZXJyb3J9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIExvb2sgZm9yIGdvLm1vZCAoR28pXHJcbiAgY29uc3QgZ29Nb2QgPSBmaWxlcy5maW5kKGYgPT4gKGYucGF0aCB8fCBmLm5hbWUpPy5lbmRzV2l0aCgnZ28ubW9kJykpO1xyXG4gIGlmIChnb01vZCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGVwcyA9IHBhcnNlR29Nb2QoZ29Nb2QuY29udGVudCk7XHJcbiAgICAgIGlmIChkZXBzKSB7XHJcbiAgICAgICAgbWFuaWZlc3RzLnB1c2goe1xyXG4gICAgICAgICAgbGFuZ3VhZ2U6ICdnbycsXHJcbiAgICAgICAgICBmaWxlOiBnb01vZC5wYXRoIHx8IGdvTW9kLm5hbWUgfHwgJ2dvLm1vZCcsXHJcbiAgICAgICAgICBkZXBlbmRlbmNpZXM6IGRlcHMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHBhcnNlIGdvLm1vZDogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gTG9vayBmb3IgLmNzcHJvaiBmaWxlcyAoLk5FVClcclxuICBjb25zdCBjc3Byb2pGaWxlcyA9IGZpbGVzLmZpbHRlcihmID0+IChmLnBhdGggfHwgZi5uYW1lKT8uZW5kc1dpdGgoJy5jc3Byb2onKSk7XHJcbiAgZm9yIChjb25zdCBjc3Byb2ogb2YgY3Nwcm9qRmlsZXMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRlcHMgPSBwYXJzZUNzcHJvaihjc3Byb2ouY29udGVudCk7XHJcbiAgICAgIGlmIChkZXBzKSB7XHJcbiAgICAgICAgbWFuaWZlc3RzLnB1c2goe1xyXG4gICAgICAgICAgbGFuZ3VhZ2U6ICdkb3RuZXQnLFxyXG4gICAgICAgICAgZmlsZTogY3Nwcm9qLnBhdGggfHwgY3Nwcm9qLm5hbWUgfHwgJ3Byb2plY3QuY3Nwcm9qJyxcclxuICAgICAgICAgIGRlcGVuZGVuY2llczogZGVwcyxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gcGFyc2UgJHtjc3Byb2oucGF0aCB8fCBjc3Byb2oubmFtZSB8fCAncHJvamVjdC5jc3Byb2onfTogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIG1hbmlmZXN0cztcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHJlcXVpcmVtZW50cy50eHQgY29udGVudFxyXG4gKiBAcGFyYW0gY29udGVudCByZXF1aXJlbWVudHMudHh0IGNvbnRlbnRcclxuICogQHJldHVybnMgRGVwZW5kZW5jaWVzIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VSZXF1aXJlbWVudHNUeHQoY29udGVudDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XHJcbiAgY29uc3QgZGVwczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xyXG4gIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XHJcbiAgXHJcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XHJcbiAgICBpZiAoIXRyaW1tZWQgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCcjJykpIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgdmFyaW91cyByZXF1aXJlbWVudCBmb3JtYXRzXHJcbiAgICAvLyBwYWNrYWdlPT0xLjAuMFxyXG4gICAgLy8gcGFja2FnZT49MS4wLjBcclxuICAgIC8vIHBhY2thZ2V+PTEuMC4wXHJcbiAgICAvLyBwYWNrYWdlXHJcbiAgICBjb25zdCBtYXRjaCA9IHRyaW1tZWQubWF0Y2goL14oW2EtekEtWjAtOV8tXSspKC4qKSQvKTtcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICBjb25zdCBbLCBuYW1lLCB2ZXJzaW9uXSA9IG1hdGNoO1xyXG4gICAgICBkZXBzW25hbWVdID0gdmVyc2lvbiB8fCAnKic7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBkZXBzO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgcHlwcm9qZWN0LnRvbWwgY29udGVudCAoYmFzaWMgcGFyc2luZylcclxuICogQHBhcmFtIGNvbnRlbnQgcHlwcm9qZWN0LnRvbWwgY29udGVudFxyXG4gKiBAcmV0dXJucyBEZXBlbmRlbmNpZXMgb2JqZWN0IG9yIG51bGxcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlUHlwcm9qZWN0VG9tbChjb250ZW50OiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbCB7XHJcbiAgY29uc3QgZGVwczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xyXG4gIFxyXG4gIC8vIFNpbXBsZSBUT01MIHBhcnNpbmcgZm9yIGRlcGVuZGVuY2llc1xyXG4gIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XHJcbiAgbGV0IGluRGVwZW5kZW5jaWVzID0gZmFsc2U7XHJcbiAgXHJcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XHJcbiAgICBcclxuICAgIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoJ1t0b29sLnBvZXRyeS5kZXBlbmRlbmNpZXNdJykgfHwgXHJcbiAgICAgICAgdHJpbW1lZC5zdGFydHNXaXRoKCdbcHJvamVjdC5kZXBlbmRlbmNpZXNdJykgfHxcclxuICAgICAgICB0cmltbWVkLnN0YXJ0c1dpdGgoJ1tkZXBlbmRlbmNpZXNdJykpIHtcclxuICAgICAgaW5EZXBlbmRlbmNpZXMgPSB0cnVlO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRyaW1tZWQuc3RhcnRzV2l0aCgnWycpICYmIGluRGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoaW5EZXBlbmRlbmNpZXMgJiYgdHJpbW1lZCAmJiAhdHJpbW1lZC5zdGFydHNXaXRoKCcjJykpIHtcclxuICAgICAgY29uc3QgbWF0Y2ggPSB0cmltbWVkLm1hdGNoKC9eKFthLXpBLVowLTlfLV0rKVxccyo9XFxzKltcIiddPyhbXlwiJ10rKVtcIiddPy8pO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBbLCBuYW1lLCB2ZXJzaW9uXSA9IG1hdGNoO1xyXG4gICAgICAgIGRlcHNbbmFtZV0gPSB2ZXJzaW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBPYmplY3Qua2V5cyhkZXBzKS5sZW5ndGggPiAwID8gZGVwcyA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBwb20ueG1sIGNvbnRlbnQgKGJhc2ljIFhNTCBwYXJzaW5nKVxyXG4gKiBAcGFyYW0gY29udGVudCBwb20ueG1sIGNvbnRlbnRcclxuICogQHJldHVybnMgRGVwZW5kZW5jaWVzIG9iamVjdCBvciBudWxsXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVBvbVhtbChjb250ZW50OiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbCB7XHJcbiAgY29uc3QgZGVwczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xyXG4gIFxyXG4gIC8vIFNpbXBsZSBYTUwgcGFyc2luZyBmb3IgZGVwZW5kZW5jaWVzXHJcbiAgY29uc3QgZGVwZW5kZW5jeVJlZ2V4ID0gLzxkZXBlbmRlbmN5Plxccyo8Z3JvdXBJZD4oW148XSspPFxcL2dyb3VwSWQ+XFxzKjxhcnRpZmFjdElkPihbXjxdKyk8XFwvYXJ0aWZhY3RJZD5cXHMqPHZlcnNpb24+KFtePF0rKTxcXC92ZXJzaW9uPi9nO1xyXG4gIGxldCBtYXRjaDtcclxuICBcclxuICB3aGlsZSAoKG1hdGNoID0gZGVwZW5kZW5jeVJlZ2V4LmV4ZWMoY29udGVudCkpICE9PSBudWxsKSB7XHJcbiAgICBjb25zdCBbLCBncm91cElkLCBhcnRpZmFjdElkLCB2ZXJzaW9uXSA9IG1hdGNoO1xyXG4gICAgY29uc3QgZnVsbE5hbWUgPSBgJHtncm91cElkfToke2FydGlmYWN0SWR9YDtcclxuICAgIGRlcHNbZnVsbE5hbWVdID0gdmVyc2lvbjtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRlcHMpLmxlbmd0aCA+IDAgPyBkZXBzIDogbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIGJ1aWxkLmdyYWRsZSBjb250ZW50IChiYXNpYyBwYXJzaW5nKVxyXG4gKiBAcGFyYW0gY29udGVudCBidWlsZC5ncmFkbGUgY29udGVudFxyXG4gKiBAcmV0dXJucyBEZXBlbmRlbmNpZXMgb2JqZWN0IG9yIG51bGxcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlQnVpbGRHcmFkbGUoY29udGVudDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IG51bGwge1xyXG4gIGNvbnN0IGRlcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcclxuICBcclxuICAvLyBTaW1wbGUgR3JhZGxlIHBhcnNpbmcgZm9yIGRlcGVuZGVuY2llc1xyXG4gIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XHJcbiAgbGV0IGluRGVwZW5kZW5jaWVzID0gZmFsc2U7XHJcbiAgXHJcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XHJcbiAgICBcclxuICAgIGlmICh0cmltbWVkLmluY2x1ZGVzKCdkZXBlbmRlbmNpZXMnKSAmJiB0cmltbWVkLmluY2x1ZGVzKCd7JykpIHtcclxuICAgICAgaW5EZXBlbmRlbmNpZXMgPSB0cnVlO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRyaW1tZWQgPT09ICd9JyAmJiBpbkRlcGVuZGVuY2llcykge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKGluRGVwZW5kZW5jaWVzICYmIHRyaW1tZWQuaW5jbHVkZXMoJ2ltcGxlbWVudGF0aW9uJykgfHwgdHJpbW1lZC5pbmNsdWRlcygnY29tcGlsZScpKSB7XHJcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uICdncm91cDphcnRpZmFjdDp2ZXJzaW9uJ1xyXG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbihcImdyb3VwOmFydGlmYWN0OnZlcnNpb25cIilcclxuICAgICAgY29uc3QgbWF0Y2ggPSB0cmltbWVkLm1hdGNoKC8oPzppbXBsZW1lbnRhdGlvbnxjb21waWxlKVxccypbKFwiXT8oW146KV0rKTooW146KV0rKTooW146KV0rKS8pO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBbLCBncm91cCwgYXJ0aWZhY3QsIHZlcnNpb25dID0gbWF0Y2g7XHJcbiAgICAgICAgY29uc3QgZnVsbE5hbWUgPSBgJHtncm91cH06JHthcnRpZmFjdH1gO1xyXG4gICAgICAgIGRlcHNbZnVsbE5hbWVdID0gdmVyc2lvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gT2JqZWN0LmtleXMoZGVwcykubGVuZ3RoID4gMCA/IGRlcHMgOiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgZ28ubW9kIGNvbnRlbnRcclxuICogQHBhcmFtIGNvbnRlbnQgZ28ubW9kIGNvbnRlbnRcclxuICogQHJldHVybnMgRGVwZW5kZW5jaWVzIG9iamVjdCBvciBudWxsXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUdvTW9kKGNvbnRlbnQ6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBudWxsIHtcclxuICBjb25zdCBkZXBzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XHJcbiAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcclxuICBcclxuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcclxuICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcclxuICAgIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoJ3JlcXVpcmUnKSkge1xyXG4gICAgICAvLyByZXF1aXJlIChcclxuICAgICAgLy8gICBtb2R1bGUgdjEuMC4wXHJcbiAgICAgIC8vIClcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoJ3JlcXVpcmUgJykpIHtcclxuICAgICAgLy8gcmVxdWlyZSBtb2R1bGUgdjEuMC4wXHJcbiAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaCgvcmVxdWlyZVxccysoW15cXHNdKylcXHMrKFteXFxzXSspLyk7XHJcbiAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IFssIG1vZHVsZSwgdmVyc2lvbl0gPSBtYXRjaDtcclxuICAgICAgICBkZXBzW21vZHVsZV0gPSB2ZXJzaW9uO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRyaW1tZWQgJiYgIXRyaW1tZWQuc3RhcnRzV2l0aCgnZ28gJykgJiYgIXRyaW1tZWQuc3RhcnRzV2l0aCgnbW9kdWxlICcpICYmICF0cmltbWVkLnN0YXJ0c1dpdGgoJy8vJykpIHtcclxuICAgICAgLy8gTW9kdWxlIHZlcnNpb24gbGluZVxyXG4gICAgICBjb25zdCBtYXRjaCA9IHRyaW1tZWQubWF0Y2goL14oW15cXHNdKylcXHMrKFteXFxzXSspLyk7XHJcbiAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IFssIG1vZHVsZSwgdmVyc2lvbl0gPSBtYXRjaDtcclxuICAgICAgICBkZXBzW21vZHVsZV0gPSB2ZXJzaW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBPYmplY3Qua2V5cyhkZXBzKS5sZW5ndGggPiAwID8gZGVwcyA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSAuY3Nwcm9qIGNvbnRlbnQgKGJhc2ljIFhNTCBwYXJzaW5nKVxyXG4gKiBAcGFyYW0gY29udGVudCAuY3Nwcm9qIGNvbnRlbnRcclxuICogQHJldHVybnMgRGVwZW5kZW5jaWVzIG9iamVjdCBvciBudWxsXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUNzcHJvaihjb250ZW50OiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbCB7XHJcbiAgY29uc3QgZGVwczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xyXG4gIFxyXG4gIC8vIFNpbXBsZSBYTUwgcGFyc2luZyBmb3IgUGFja2FnZVJlZmVyZW5jZVxyXG4gIGNvbnN0IHBhY2thZ2VSZWZSZWdleCA9IC88UGFja2FnZVJlZmVyZW5jZVxccytJbmNsdWRlPVwiKFteXCJdKylcIlxccytWZXJzaW9uPVwiKFteXCJdKylcIlxccypcXC8/Pi9nO1xyXG4gIGxldCBtYXRjaDtcclxuICBcclxuICB3aGlsZSAoKG1hdGNoID0gcGFja2FnZVJlZlJlZ2V4LmV4ZWMoY29udGVudCkpICE9PSBudWxsKSB7XHJcbiAgICBjb25zdCBbLCBwYWNrYWdlTmFtZSwgdmVyc2lvbl0gPSBtYXRjaDtcclxuICAgIGRlcHNbcGFja2FnZU5hbWVdID0gdmVyc2lvbjtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRlcHMpLmxlbmd0aCA+IDAgPyBkZXBzIDogbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVjdCBsYW5ndWFnZXMgZnJvbSBmaWxlIGV4dGVuc2lvbnNcclxuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBkZXRlY3RlZCBsYW5ndWFnZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RMYW5ndWFnZXNGcm9tRmlsZXMoZmlsZXM6IHsgcGF0aD86IHN0cmluZzsgbmFtZT86IHN0cmluZyB9W10pOiBMYW5ndWFnZVtdIHtcclxuICBjb25zdCBsYW5ndWFnZU1hcDogUmVjb3JkPHN0cmluZywgTGFuZ3VhZ2U+ID0ge1xyXG4gICAgJy5qcyc6ICdub2RlJyxcclxuICAgICcuanN4JzogJ25vZGUnLFxyXG4gICAgJy50cyc6ICdub2RlJyxcclxuICAgICcudHN4JzogJ25vZGUnLFxyXG4gICAgJy5weSc6ICdweXRob24nLFxyXG4gICAgJy5qYXZhJzogJ2phdmEnLFxyXG4gICAgJy5nbyc6ICdnbycsXHJcbiAgICAnLmNzJzogJ2RvdG5ldCcsXHJcbiAgICAnLmZzJzogJ2RvdG5ldCcsXHJcbiAgICAnLnZiJzogJ2RvdG5ldCcsXHJcbiAgfTtcclxuICBcclxuICBjb25zdCBkZXRlY3RlZExhbmd1YWdlcyA9IG5ldyBTZXQ8TGFuZ3VhZ2U+KCk7XHJcbiAgXHJcbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aCB8fCBmaWxlLm5hbWU7XHJcbiAgICBpZiAoZmlsZVBhdGgpIHtcclxuICAgICAgY29uc3QgZXh0ID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XHJcbiAgICAgIGNvbnN0IGxhbmd1YWdlID0gbGFuZ3VhZ2VNYXBbZXh0XTtcclxuICAgICAgaWYgKGxhbmd1YWdlKSB7XHJcbiAgICAgICAgZGV0ZWN0ZWRMYW5ndWFnZXMuYWRkKGxhbmd1YWdlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gQXJyYXkuZnJvbShkZXRlY3RlZExhbmd1YWdlcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZmlsZSBleHRlbnNpb24gZnJvbSBwYXRoXHJcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcclxuICogQHJldHVybnMgRmlsZSBleHRlbnNpb24gd2l0aCBkb3RcclxuICovXHJcbmZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgbGFzdERvdCA9IGZpbGVQYXRoLmxhc3RJbmRleE9mKCcuJyk7XHJcbiAgaWYgKGxhc3REb3QgPT09IC0xKSByZXR1cm4gJyc7XHJcbiAgcmV0dXJuIGZpbGVQYXRoLnN1YnN0cmluZyhsYXN0RG90KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBwcmltYXJ5IGxhbmd1YWdlIGZyb20gbWFuaWZlc3RzXHJcbiAqIEBwYXJhbSBtYW5pZmVzdHMgQXJyYXkgb2YgcHJvamVjdCBtYW5pZmVzdHNcclxuICogQHJldHVybnMgUHJpbWFyeSBsYW5ndWFnZSBvciBudWxsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJpbWFyeUxhbmd1YWdlKG1hbmlmZXN0czogUHJvamVjdE1hbmlmZXN0W10pOiBMYW5ndWFnZSB8IG51bGwge1xyXG4gIGlmIChtYW5pZmVzdHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuICBcclxuICAvLyBQcmlvcml0eSBvcmRlcjogbm9kZSwgcHl0aG9uLCBqYXZhLCBnbywgZG90bmV0XHJcbiAgY29uc3QgcHJpb3JpdHk6IExhbmd1YWdlW10gPSBbJ25vZGUnLCAncHl0aG9uJywgJ2phdmEnLCAnZ28nLCAnZG90bmV0J107XHJcbiAgXHJcbiAgZm9yIChjb25zdCBsYW5nIG9mIHByaW9yaXR5KSB7XHJcbiAgICBpZiAobWFuaWZlc3RzLnNvbWUobSA9PiBtLmxhbmd1YWdlID09PSBsYW5nKSkge1xyXG4gICAgICByZXR1cm4gbGFuZztcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIG1hbmlmZXN0c1swXS5sYW5ndWFnZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgZmlsZSBpcyBhIG1hbmlmZXN0IGZpbGVcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aFxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGl0J3MgYSBtYW5pZmVzdCBmaWxlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNNYW5pZmVzdEZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IG1hbmlmZXN0RmlsZXMgPSBbXHJcbiAgICAncGFja2FnZS5qc29uJyxcclxuICAgICdyZXF1aXJlbWVudHMudHh0JyxcclxuICAgICdweXByb2plY3QudG9tbCcsXHJcbiAgICAncG9tLnhtbCcsXHJcbiAgICAnYnVpbGQuZ3JhZGxlJyxcclxuICAgICdidWlsZC5ncmFkbGUua3RzJyxcclxuICAgICdnby5tb2QnLFxyXG4gICAgJy5jc3Byb2onLFxyXG4gIF07XHJcbiAgXHJcbiAgcmV0dXJuIG1hbmlmZXN0RmlsZXMuc29tZShtYW5pZmVzdCA9PiBmaWxlUGF0aC5lbmRzV2l0aChtYW5pZmVzdCkpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IG1hbmlmZXN0IGZpbGUgdHlwZSBmcm9tIHBhdGhcclxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aFxyXG4gKiBAcmV0dXJucyBNYW5pZmVzdCB0eXBlIG9yIG51bGxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYW5pZmVzdFR5cGUoZmlsZVBhdGg6IHN0cmluZyk6IHsgbGFuZ3VhZ2U6IExhbmd1YWdlOyB0eXBlOiBzdHJpbmcgfSB8IG51bGwge1xyXG4gIGlmIChmaWxlUGF0aC5lbmRzV2l0aCgncGFja2FnZS5qc29uJykpIHtcclxuICAgIHJldHVybiB7IGxhbmd1YWdlOiAnbm9kZScsIHR5cGU6ICdwYWNrYWdlLmpzb24nIH07XHJcbiAgfVxyXG4gIGlmIChmaWxlUGF0aC5lbmRzV2l0aCgncmVxdWlyZW1lbnRzLnR4dCcpKSB7XHJcbiAgICByZXR1cm4geyBsYW5ndWFnZTogJ3B5dGhvbicsIHR5cGU6ICdyZXF1aXJlbWVudHMudHh0JyB9O1xyXG4gIH1cclxuICBpZiAoZmlsZVBhdGguZW5kc1dpdGgoJ3B5cHJvamVjdC50b21sJykpIHtcclxuICAgIHJldHVybiB7IGxhbmd1YWdlOiAncHl0aG9uJywgdHlwZTogJ3B5cHJvamVjdC50b21sJyB9O1xyXG4gIH1cclxuICBpZiAoZmlsZVBhdGguZW5kc1dpdGgoJ3BvbS54bWwnKSkge1xyXG4gICAgcmV0dXJuIHsgbGFuZ3VhZ2U6ICdqYXZhJywgdHlwZTogJ3BvbS54bWwnIH07XHJcbiAgfVxyXG4gIGlmIChmaWxlUGF0aC5lbmRzV2l0aCgnYnVpbGQuZ3JhZGxlJykgfHwgZmlsZVBhdGguZW5kc1dpdGgoJ2J1aWxkLmdyYWRsZS5rdHMnKSkge1xyXG4gICAgcmV0dXJuIHsgbGFuZ3VhZ2U6ICdqYXZhJywgdHlwZTogJ2J1aWxkLmdyYWRsZScgfTtcclxuICB9XHJcbiAgaWYgKGZpbGVQYXRoLmVuZHNXaXRoKCdnby5tb2QnKSkge1xyXG4gICAgcmV0dXJuIHsgbGFuZ3VhZ2U6ICdnbycsIHR5cGU6ICdnby5tb2QnIH07XHJcbiAgfVxyXG4gIGlmIChmaWxlUGF0aC5lbmRzV2l0aCgnLmNzcHJvaicpKSB7XHJcbiAgICByZXR1cm4geyBsYW5ndWFnZTogJ2RvdG5ldCcsIHR5cGU6ICcuY3Nwcm9qJyB9O1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gbnVsbDtcclxufVxyXG4iXSwibmFtZXMiOlsiZGV0ZWN0UHJvamVjdE1hbmlmZXN0cyIsImZpbGVzIiwibWFuaWZlc3RzIiwicGFja2FnZUpzb24iLCJmaW5kIiwiZiIsInBhdGgiLCJuYW1lIiwiZW5kc1dpdGgiLCJwa2ciLCJKU09OIiwicGFyc2UiLCJjb250ZW50IiwicHVzaCIsImxhbmd1YWdlIiwiZmlsZSIsImRlcGVuZGVuY2llcyIsImRldkRlcGVuZGVuY2llcyIsInBlZXJEZXBlbmRlbmNpZXMiLCJvcHRpb25hbERlcGVuZGVuY2llcyIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJyZXF1aXJlbWVudHNUeHQiLCJwYXJzZVJlcXVpcmVtZW50c1R4dCIsInB5cHJvamVjdFRvbWwiLCJkZXBzIiwicGFyc2VQeXByb2plY3RUb21sIiwicG9tWG1sIiwicGFyc2VQb21YbWwiLCJidWlsZEdyYWRsZSIsInBhcnNlQnVpbGRHcmFkbGUiLCJnb01vZCIsInBhcnNlR29Nb2QiLCJjc3Byb2pGaWxlcyIsImZpbHRlciIsImNzcHJvaiIsInBhcnNlQ3Nwcm9qIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJ0cmltbWVkIiwidHJpbSIsInN0YXJ0c1dpdGgiLCJtYXRjaCIsInZlcnNpb24iLCJpbkRlcGVuZGVuY2llcyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJkZXBlbmRlbmN5UmVnZXgiLCJleGVjIiwiZ3JvdXBJZCIsImFydGlmYWN0SWQiLCJmdWxsTmFtZSIsImluY2x1ZGVzIiwiZ3JvdXAiLCJhcnRpZmFjdCIsIm1vZHVsZSIsInBhY2thZ2VSZWZSZWdleCIsInBhY2thZ2VOYW1lIiwiZGV0ZWN0TGFuZ3VhZ2VzRnJvbUZpbGVzIiwibGFuZ3VhZ2VNYXAiLCJkZXRlY3RlZExhbmd1YWdlcyIsIlNldCIsImZpbGVQYXRoIiwiZXh0IiwiZ2V0RmlsZUV4dGVuc2lvbiIsImFkZCIsIkFycmF5IiwiZnJvbSIsImxhc3REb3QiLCJsYXN0SW5kZXhPZiIsInN1YnN0cmluZyIsImdldFByaW1hcnlMYW5ndWFnZSIsInByaW9yaXR5IiwibGFuZyIsInNvbWUiLCJtIiwiaXNNYW5pZmVzdEZpbGUiLCJtYW5pZmVzdEZpbGVzIiwibWFuaWZlc3QiLCJnZXRNYW5pZmVzdFR5cGUiLCJ0eXBlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/detect.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/run.ts":
/*!*****************************!*\
  !*** ./lib/analysis/run.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkAnalysisFeasibility: () => (/* binding */ checkAnalysisFeasibility),\n/* harmony export */   estimateAnalysisTime: () => (/* binding */ estimateAnalysisTime),\n/* harmony export */   getAnalysisProgress: () => (/* binding */ getAnalysisProgress),\n/* harmony export */   runAnalysisOnFiles: () => (/* binding */ runAnalysisOnFiles),\n/* harmony export */   runBaselineAnalysis: () => (/* binding */ runBaselineAnalysis),\n/* harmony export */   validateAnalysisOptions: () => (/* binding */ validateAnalysisOptions)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _baseline_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./baseline.loader */ \"(rsc)/./lib/analysis/baseline.loader.ts\");\n/* harmony import */ var _detect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detect */ \"(rsc)/./lib/analysis/detect.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deps */ \"(rsc)/./lib/analysis/deps.ts\");\n/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scan */ \"(rsc)/./lib/analysis/scan.ts\");\n/* harmony import */ var _files_single_file__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../files/single-file */ \"(rsc)/./lib/files/single-file.ts\");\n/* harmony import */ var _files_store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../files/store */ \"(rsc)/./lib/files/store.ts\");\n\n\n\n\n\n\n\n/**\n * Run complete baseline analysis on a ZIP file\n * @param zipPath Path to ZIP file\n * @param options Analysis options\n * @returns Analysis result with report and artifacts\n */ async function analyzeWithGroq(files, projectType, dependencies) {\n    const results = [];\n    // Skip Groq analysis if no GROQ_API_KEY is available\n    if (!process.env.GROQ_API_KEY) {\n        console.log('Skipping Groq analysis: GROQ_API_KEY not configured');\n        return results;\n    }\n    // Analyze up to 5 key files to avoid rate limits\n    const keyFiles = files.filter((file)=>{\n        const fileName = file.name || file.path || 'unknown';\n        const ext = fileName.split('.').pop()?.toLowerCase();\n        return [\n            'js',\n            'ts',\n            'jsx',\n            'tsx',\n            'css',\n            'html',\n            'vue',\n            'svelte',\n            'py',\n            'java',\n            'go',\n            'cs'\n        ].includes(ext || '');\n    }).slice(0, 5);\n    for (const file of keyFiles){\n        try {\n            // Use absolute URL for server-side fetch\n            const baseUrl = process.env.PUBLIC_URL || 'http://localhost:3000';\n            const response = await fetch(`${baseUrl}/api/analyze/groq`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    code: file.content,\n                    filename: file.name || file.path || 'unknown',\n                    projectType,\n                    dependencies\n                })\n            });\n            if (response.ok) {\n                const result = await response.json();\n                results.push(result);\n            } else {\n                console.error(`Groq analysis failed for ${file.name || file.path}: ${response.status} ${response.statusText}`);\n            }\n        } catch (error) {\n            console.error(`Groq analysis failed for ${file.name || file.path}:`, error);\n        }\n    }\n    return results;\n}\nasync function runBaselineAnalysis(filePath, options = {}) {\n    const { maxFiles = 50000, maxFileSize = 2 * 1024 * 1024, allowedExtensions = [\n        '.html',\n        '.htm',\n        '.css',\n        '.js',\n        '.mjs',\n        '.ts',\n        '.svg',\n        '.wasm',\n        '.json',\n        '.webmanifest'\n    ], ignorePaths = [\n        '/node_modules/',\n        '/.venv/',\n        '/venv/',\n        '/dist/',\n        '/build/',\n        '/.git/',\n        '/.next/'\n    ], storeResults = true, publicUrl = 'http://localhost:3000' } = options;\n    const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomUUID)();\n    const startTime = Date.now();\n    try {\n        // Load baseline rules\n        const rules = await (0,_baseline_loader__WEBPACK_IMPORTED_MODULE_1__.loadBaselineRules)();\n        // Process single file\n        const fs = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const content = fs.readFileSync(filePath, 'utf8');\n        if (!(0,_files_single_file__WEBPACK_IMPORTED_MODULE_5__.shouldAnalyzeFile)(filePath)) {\n            throw new Error(`File type not supported for analysis: ${filePath}`);\n        }\n        const extractResult = (0,_files_single_file__WEBPACK_IMPORTED_MODULE_5__.processSingleFile)(filePath, content, maxFileSize);\n        // Detect project manifests and languages\n        const manifests = (0,_detect__WEBPACK_IMPORTED_MODULE_2__.detectProjectManifests)(extractResult.files);\n        const detectedLanguages = (0,_detect__WEBPACK_IMPORTED_MODULE_2__.detectLanguagesFromFiles)(extractResult.files);\n        // Create analysis context\n        const context = {\n            rules,\n            extractedFiles: extractResult.files,\n            manifests,\n            detectedLanguages\n        };\n        // Run analysis\n        const findings = await runAnalysis(context);\n        // Add additional analysis findings\n        const additionalFindings = await runAdditionalAnalysis(context);\n        findings.push(...additionalFindings);\n        // Generate summary\n        const summary = generateSummary(findings, detectedLanguages);\n        // Run Groq AI analysis\n        const groqResults = await analyzeWithGroq(extractResult.files, detectedLanguages.join(', '), context.manifests.flatMap((m)=>Object.keys(m.dependencies || {})));\n        // Create report\n        const report = {\n            findings,\n            summary,\n            metadata: {\n                analysisId,\n                timestamp: new Date().toISOString(),\n                projectName: getProjectName(filePath),\n                detectedLanguages,\n                totalFiles: extractResult.totalFiles,\n                scannedFiles: extractResult.files.length,\n                skippedFiles: extractResult.skippedFiles,\n                groqAnalysis: groqResults\n            }\n        };\n        // Store results if requested\n        let artifacts;\n        if (storeResults) {\n            artifacts = (0,_files_store__WEBPACK_IMPORTED_MODULE_6__.storeAnalysisResults)(report, {\n                publicUrl\n            });\n        }\n        const endTime = Date.now();\n        console.log(`Analysis completed in ${endTime - startTime}ms`);\n        return {\n            report,\n            artifacts\n        };\n    } catch (error) {\n        console.error('Analysis failed:', error);\n        throw new Error(`Analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\n * Run analysis on extracted files and manifests\n * @param context Analysis context\n * @returns Array of findings\n */ async function runAnalysis(context) {\n    const findings = [];\n    // Analyze dependencies\n    const dependencyFindings = (0,_deps__WEBPACK_IMPORTED_MODULE_3__.analyzeDependencies)(context.manifests, context.rules);\n    findings.push(...dependencyFindings);\n    // Scan source files for deprecated patterns\n    const patternFindings = (0,_scan__WEBPACK_IMPORTED_MODULE_4__.scanSourceFiles)(context.extractedFiles, context.rules);\n    findings.push(...patternFindings);\n    return findings;\n}\n/**\n * Run additional analysis for enhanced detection\n * @param context Analysis context\n * @returns Array of additional findings\n */ async function runAdditionalAnalysis(context) {\n    const findings = [];\n    // Analyze code quality and best practices\n    const qualityFindings = analyzeCodeQuality(context.extractedFiles);\n    findings.push(...qualityFindings);\n    // Analyze security vulnerabilities\n    const securityFindings = analyzeSecurityVulnerabilities(context.extractedFiles);\n    findings.push(...securityFindings);\n    // Analyze performance issues\n    const performanceFindings = analyzePerformanceIssues(context.extractedFiles);\n    findings.push(...performanceFindings);\n    return findings;\n}\n/**\n * Analyze code quality and best practices\n * @param files Array of extracted files\n * @returns Array of quality findings\n */ function analyzeCodeQuality(files) {\n    const findings = [];\n    for (const file of files){\n        const filePath = file.path || file.name || 'unknown';\n        const extension = getFileExtension(filePath);\n        const language = detectLanguageFromExtension(extension);\n        if (!language) continue;\n        const lines = file.content.split('\\n');\n        // Check for code quality issues\n        for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n            const line = lines[lineIndex];\n            const lineNumber = lineIndex + 1;\n            // Skip empty lines and comments\n            if (isCommentLine(line, language) || line.trim() === '') {\n                continue;\n            }\n            // Check for long lines\n            if (line.length > 120) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'Line is too long (>120 characters)',\n                    pattern: 'long-line',\n                    quickFix: 'Break long lines for better readability'\n                });\n            }\n            // Check for trailing whitespace\n            if (line.endsWith(' ') || line.endsWith('\\t')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'Trailing whitespace detected',\n                    pattern: 'trailing-whitespace',\n                    quickFix: 'Remove trailing whitespace'\n                });\n            }\n            // Check for mixed tabs and spaces\n            if (line.includes('\\t') && line.includes(' ')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'Mixed tabs and spaces for indentation',\n                    pattern: 'mixed-indentation',\n                    quickFix: 'Use consistent indentation (prefer spaces)'\n                });\n            }\n            // Check for TODO/FIXME comments\n            if (line.toLowerCase().includes('todo') || line.toLowerCase().includes('fixme')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'TODO/FIXME comment found',\n                    pattern: 'todo-comment',\n                    quickFix: 'Address TODO/FIXME items before production'\n                });\n            }\n            // Check for console.log in production code\n            if (language === 'node' && line.includes('console.log')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'console.log should be removed in production',\n                    pattern: 'console-log',\n                    quickFix: 'Use proper logging library or remove debug statements'\n                });\n            }\n            // Check for print statements in Python\n            if (language === 'python' && line.includes('print(')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'code-quality',\n                    issue: 'print() should be removed in production',\n                    pattern: 'print-statement',\n                    quickFix: 'Use proper logging library or remove debug statements'\n                });\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Analyze security vulnerabilities\n * @param files Array of extracted files\n * @returns Array of security findings\n */ function analyzeSecurityVulnerabilities(files) {\n    const findings = [];\n    for (const file of files){\n        const filePath = file.path || file.name || 'unknown';\n        const extension = getFileExtension(filePath);\n        const language = detectLanguageFromExtension(extension);\n        if (!language) continue;\n        const lines = file.content.split('\\n');\n        // Check for security vulnerabilities\n        for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n            const line = lines[lineIndex];\n            const lineNumber = lineIndex + 1;\n            // Skip empty lines and comments\n            if (isCommentLine(line, language) || line.trim() === '') {\n                continue;\n            }\n            // Check for hardcoded passwords\n            if (line.toLowerCase().includes('password') && line.includes('=') && !line.includes('input(')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'security',\n                    issue: 'Potential hardcoded password detected',\n                    pattern: 'hardcoded-password',\n                    quickFix: 'Use environment variables or secure credential storage'\n                });\n            }\n            // Check for hardcoded API keys\n            if (line.toLowerCase().includes('api') && line.toLowerCase().includes('key') && line.includes('=')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'security',\n                    issue: 'Potential hardcoded API key detected',\n                    pattern: 'hardcoded-api-key',\n                    quickFix: 'Use environment variables or secure credential storage'\n                });\n            }\n            // Check for SQL injection vulnerabilities\n            if (line.includes('SELECT') || line.includes('INSERT') || line.includes('UPDATE') || line.includes('DELETE')) {\n                if (line.includes('+') || line.includes('${') || line.includes('%s')) {\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: filePath,\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'security',\n                        issue: 'Potential SQL injection vulnerability',\n                        pattern: 'sql-injection',\n                        quickFix: 'Use parameterized queries or prepared statements'\n                    });\n                }\n            }\n            // Check for XSS vulnerabilities\n            if (line.includes('innerHTML') || line.includes('outerHTML') || line.includes('document.write')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'security',\n                    issue: 'Potential XSS vulnerability',\n                    pattern: 'xss-vulnerability',\n                    quickFix: 'Use textContent or sanitize HTML content'\n                });\n            }\n            // Check for unsafe deserialization\n            if (line.includes('pickle.load') || line.includes('unpickle') || line.includes('deserialize')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'security',\n                    issue: 'Unsafe deserialization detected',\n                    pattern: 'unsafe-deserialization',\n                    quickFix: 'Use safe serialization formats like JSON'\n                });\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Analyze performance issues\n * @param files Array of extracted files\n * @returns Array of performance findings\n */ function analyzePerformanceIssues(files) {\n    const findings = [];\n    for (const file of files){\n        const filePath = file.path || file.name || 'unknown';\n        const extension = getFileExtension(filePath);\n        const language = detectLanguageFromExtension(extension);\n        if (!language) continue;\n        const lines = file.content.split('\\n');\n        // Check for performance issues\n        for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n            const line = lines[lineIndex];\n            const lineNumber = lineIndex + 1;\n            // Skip empty lines and comments\n            if (isCommentLine(line, language) || line.trim() === '') {\n                continue;\n            }\n            // Check for synchronous file operations\n            if (language === 'node' && (line.includes('fs.readFileSync') || line.includes('fs.writeFileSync'))) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'performance',\n                    issue: 'Synchronous file operation can block the event loop',\n                    pattern: 'sync-file-operation',\n                    quickFix: 'Use asynchronous file operations (fs.promises)'\n                });\n            }\n            // Check for blocking operations\n            if (line.includes('sleep(') || line.includes('time.sleep(')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'performance',\n                    issue: 'Blocking sleep operation detected',\n                    pattern: 'blocking-sleep',\n                    quickFix: 'Use asynchronous alternatives or reduce sleep time'\n                });\n            }\n            // Check for inefficient loops\n            if (line.includes('for') && line.includes('in') && line.includes('range(')) {\n                if (line.includes('len(') || line.includes('.length')) {\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: filePath,\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'performance',\n                        issue: 'Inefficient loop with len()/length call',\n                        pattern: 'inefficient-loop',\n                        quickFix: 'Cache length or use enumerate()/entries()'\n                    });\n                }\n            }\n            // Check for string concatenation in loops\n            if (line.includes('+=') && line.includes('str') || line.includes('+=') && line.includes('string')) {\n                findings.push({\n                    kind: 'pattern',\n                    lang: language,\n                    file: filePath,\n                    line: lineNumber,\n                    status: 'affected',\n                    reason: 'performance',\n                    issue: 'String concatenation in loop is inefficient',\n                    pattern: 'string-concatenation',\n                    quickFix: 'Use join() or StringBuilder for better performance'\n                });\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Get file extension from path\n * @param filePath File path\n * @returns File extension with dot\n */ function getFileExtension(filePath) {\n    const lastDot = filePath.lastIndexOf('.');\n    if (lastDot === -1) return '';\n    return filePath.substring(lastDot);\n}\n/**\n * Detect language from file extension\n * @param extension File extension\n * @returns Language or null\n */ function detectLanguageFromExtension(extension) {\n    const languageMap = {\n        '.html': 'node',\n        '.htm': 'node',\n        '.css': 'node',\n        '.js': 'node',\n        '.jsx': 'node',\n        '.mjs': 'node',\n        '.ts': 'node',\n        '.tsx': 'node',\n        '.svg': 'node',\n        '.wasm': 'node',\n        '.json': 'node',\n        '.webmanifest': 'node',\n        '.py': 'python',\n        '.java': 'java',\n        '.go': 'go',\n        '.cs': 'dotnet',\n        '.fs': 'dotnet',\n        '.vb': 'dotnet'\n    };\n    return languageMap[extension] || null;\n}\n/**\n * Check if a line is a comment\n * @param line Line content\n * @param language Language context\n * @returns True if comment line\n */ function isCommentLine(line, language) {\n    const trimmed = line.trim();\n    switch(language){\n        case 'node':\n        case 'java':\n        case 'go':\n        case 'dotnet':\n            return trimmed.startsWith('//') || trimmed.startsWith('/*') || trimmed.startsWith('*') || trimmed.startsWith('<!--');\n        case 'python':\n            return trimmed.startsWith('#');\n        default:\n            return false;\n    }\n}\n/**\n * Generate summary from findings\n * @param findings Array of findings\n * @param detectedLanguages Array of detected languages\n * @returns Report summary\n */ function generateSummary(findings, detectedLanguages) {\n    const summary = {\n        ok: 0,\n        affected: 0,\n        unknown: 0,\n        byLanguage: {}\n    };\n    // Initialize language summaries\n    for (const language of detectedLanguages){\n        summary.byLanguage[language] = {\n            ok: 0,\n            affected: 0,\n            unknown: 0\n        };\n    }\n    // Count findings by status and language\n    for (const finding of findings){\n        if (finding.kind === 'dependency') {\n            summary[finding.status]++;\n            if (summary.byLanguage[finding.lang]) {\n                summary.byLanguage[finding.lang][finding.status]++;\n            }\n        } else if (finding.kind === 'pattern') {\n            summary.affected++;\n            if (summary.byLanguage[finding.lang]) {\n                summary.byLanguage[finding.lang].affected++;\n            }\n        }\n    }\n    return summary;\n}\n/**\n * Get project name from ZIP path\n * @param zipPath ZIP file path\n * @returns Project name\n */ function getProjectName(zipPath) {\n    const pathParts = zipPath.split('/');\n    const fileName = pathParts[pathParts.length - 1];\n    return fileName.replace(/\\.zip$/i, '');\n}\n/**\n * Run analysis on extracted files (for testing)\n * @param files Array of extracted files\n * @param manifests Array of project manifests\n * @param rules Baseline rules\n * @returns Analysis result\n */ async function runAnalysisOnFiles(files, manifests, rules) {\n    const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomUUID)();\n    const detectedLanguages = (0,_detect__WEBPACK_IMPORTED_MODULE_2__.detectLanguagesFromFiles)(files);\n    const context = {\n        rules,\n        extractedFiles: files,\n        manifests,\n        detectedLanguages\n    };\n    const findings = await runAnalysis(context);\n    const summary = generateSummary(findings, detectedLanguages);\n    const report = {\n        findings,\n        summary,\n        metadata: {\n            analysisId,\n            timestamp: new Date().toISOString(),\n            projectName: 'test-project',\n            detectedLanguages,\n            totalFiles: files.length,\n            scannedFiles: files.length,\n            skippedFiles: 0\n        }\n    };\n    return {\n        report\n    };\n}\n/**\n * Validate analysis options\n * @param options Analysis options\n * @returns Validated options\n */ function validateAnalysisOptions(options) {\n    return {\n        maxFiles: Math.min(options.maxFiles || 50000, 100000),\n        maxFileSize: Math.min(options.maxFileSize || 2 * 1024 * 1024, 10 * 1024 * 1024),\n        allowedExtensions: options.allowedExtensions || [\n            '.html',\n            '.htm',\n            '.css',\n            '.js',\n            '.mjs',\n            '.ts',\n            '.svg',\n            '.wasm',\n            '.json',\n            '.webmanifest'\n        ],\n        ignorePaths: options.ignorePaths || [\n            '/node_modules/',\n            '/.venv/',\n            '/venv/',\n            '/dist/',\n            '/build/',\n            '/.git/',\n            '/.next/'\n        ],\n        storeResults: options.storeResults !== false,\n        publicUrl: options.publicUrl || 'http://localhost:3000'\n    };\n}\n/**\n * Get analysis progress (for long-running analyses)\n * @param context Analysis context\n * @param currentStep Current step\n * @param totalSteps Total steps\n * @returns Progress information\n */ function getAnalysisProgress(context, currentStep, totalSteps) {\n    const steps = [\n        'Loading baseline rules',\n        'Extracting ZIP file',\n        'Detecting project manifests',\n        'Analyzing dependencies',\n        'Scanning source files',\n        'Generating report'\n    ];\n    const step = steps[currentStep] || 'Unknown';\n    const progress = currentStep / totalSteps * 100;\n    let details = '';\n    if (currentStep === 1) {\n        details = `Extracted ${context.extractedFiles.length} files`;\n    } else if (currentStep === 2) {\n        details = `Found ${context.manifests.length} manifests, ${context.detectedLanguages.length} languages`;\n    } else if (currentStep === 3) {\n        details = `Analyzing ${context.manifests.length} dependency manifests`;\n    } else if (currentStep === 4) {\n        details = `Scanning ${context.extractedFiles.length} source files`;\n    }\n    return {\n        step,\n        progress,\n        details\n    };\n}\n/**\n * Estimate analysis time\n * @param fileCount Number of files\n * @param manifestCount Number of manifests\n * @returns Estimated time in milliseconds\n */ function estimateAnalysisTime(fileCount, manifestCount) {\n    // Base time: 1 second\n    let estimated = 1000;\n    // Add time for file processing: 10ms per file\n    estimated += fileCount * 10;\n    // Add time for manifest processing: 50ms per manifest\n    estimated += manifestCount * 50;\n    // Add time for pattern scanning: 5ms per file\n    estimated += fileCount * 5;\n    return Math.min(estimated, 30000); // Cap at 30 seconds\n}\n/**\n * Check if analysis is feasible\n * @param fileCount Number of files\n * @param totalSize Total size in bytes\n * @returns Feasibility check result\n */ function checkAnalysisFeasibility(fileCount, totalSize) {\n    const warnings = [];\n    let feasible = true;\n    // Check file count\n    if (fileCount > 50000) {\n        feasible = false;\n        warnings.push(`Too many files: ${fileCount} (limit: 50,000)`);\n    } else if (fileCount > 10000) {\n        warnings.push(`Large number of files: ${fileCount} (analysis may take longer)`);\n    }\n    // Check total size\n    if (totalSize > 100 * 1024 * 1024) {\n        feasible = false;\n        warnings.push(`Archive too large: ${Math.round(totalSize / 1024 / 1024)}MB (limit: 100MB)`);\n    } else if (totalSize > 50 * 1024 * 1024) {\n        warnings.push(`Large archive: ${Math.round(totalSize / 1024 / 1024)}MB (analysis may take longer)`);\n    }\n    const estimatedTimeMs = estimateAnalysisTime(fileCount, Math.min(fileCount / 100, 50));\n    const estimatedTime = `${Math.round(estimatedTimeMs / 1000)}s`;\n    return {\n        feasible,\n        warnings,\n        estimatedTime\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxDQUFDLG1CQUFtQixFQUFFNEYsS0FBS2lCLEtBQUssQ0FBQ0gsWUFBWSxPQUFPLE1BQU0saUJBQWlCLENBQUM7SUFDNUYsT0FBTyxJQUFJQSxZQUFZLEtBQUssT0FBTyxNQUFNO1FBQ3ZDQyxTQUFTM0csSUFBSSxDQUFDLENBQUMsZUFBZSxFQUFFNEYsS0FBS2lCLEtBQUssQ0FBQ0gsWUFBWSxPQUFPLE1BQU0sNkJBQTZCLENBQUM7SUFDcEc7SUFFQSxNQUFNSSxrQkFBa0JULHFCQUFxQkMsV0FBV1YsS0FBS0MsR0FBRyxDQUFDUyxZQUFZLEtBQUs7SUFDbEYsTUFBTVMsZ0JBQWdCLEdBQUduQixLQUFLaUIsS0FBSyxDQUFDQyxrQkFBa0IsTUFBTSxDQUFDLENBQUM7SUFFOUQsT0FBTztRQUNMRjtRQUNBRDtRQUNBSTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcYW5hbHlzaXNcXHJ1bi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByYW5kb21VVUlEIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGxvYWRCYXNlbGluZVJ1bGVzIH0gZnJvbSAnLi9iYXNlbGluZS5sb2FkZXInO1xuaW1wb3J0IHsgZGV0ZWN0UHJvamVjdE1hbmlmZXN0cywgZGV0ZWN0TGFuZ3VhZ2VzRnJvbUZpbGVzIH0gZnJvbSAnLi9kZXRlY3QnO1xuaW1wb3J0IHsgYW5hbHl6ZURlcGVuZGVuY2llcyB9IGZyb20gJy4vZGVwcyc7XG5pbXBvcnQgeyBzY2FuU291cmNlRmlsZXMgfSBmcm9tICcuL3NjYW4nO1xuaW1wb3J0IHsgcHJvY2Vzc1NpbmdsZUZpbGUsIHNob3VsZEFuYWx5emVGaWxlIH0gZnJvbSAnLi4vZmlsZXMvc2luZ2xlLWZpbGUnO1xuaW1wb3J0IHsgc3RvcmVBbmFseXNpc1Jlc3VsdHMgfSBmcm9tICcuLi9maWxlcy9zdG9yZSc7XG5pbXBvcnQge1xuICBSZXBvcnQsXG4gIEZpbmRpbmcsXG4gIExhbmd1YWdlLFxuICBSZXBvcnRTdW1tYXJ5LFxuICBBbmFseXNpc0NvbnRleHQsXG4gIEV4dHJhY3RlZEZpbGUsXG4gIFByb2plY3RNYW5pZmVzdCxcbiAgQmFzZWxpbmVSdWxlc1xufSBmcm9tICcuL2Jhc2VsaW5lLnR5cGVzJztcblxuaW50ZXJmYWNlIEdyb3FBbmFseXNpc1Jlc3VsdCB7XG4gIGFuYWx5c2lzOiBzdHJpbmc7XG4gIGZpbGVuYW1lOiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5c2lzT3B0aW9ucyB7XG4gIG1heEZpbGVzPzogbnVtYmVyO1xuICBtYXhGaWxlU2l6ZT86IG51bWJlcjtcbiAgYWxsb3dlZEV4dGVuc2lvbnM/OiBzdHJpbmdbXTtcbiAgaWdub3JlUGF0aHM/OiBzdHJpbmdbXTtcbiAgc3RvcmVSZXN1bHRzPzogYm9vbGVhbjtcbiAgcHVibGljVXJsPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5c2lzUmVzdWx0IHtcbiAgcmVwb3J0OiBSZXBvcnQ7XG4gIGFydGlmYWN0cz86IHtcbiAgICBqc29uVXJsOiBzdHJpbmc7XG4gICAgY3N2VXJsOiBzdHJpbmc7XG4gICAgYW5hbHlzaXNJZDogc3RyaW5nO1xuICB9O1xufVxuXG4vKipcbiAqIFJ1biBjb21wbGV0ZSBiYXNlbGluZSBhbmFseXNpcyBvbiBhIFpJUCBmaWxlXG4gKiBAcGFyYW0gemlwUGF0aCBQYXRoIHRvIFpJUCBmaWxlXG4gKiBAcGFyYW0gb3B0aW9ucyBBbmFseXNpcyBvcHRpb25zXG4gKiBAcmV0dXJucyBBbmFseXNpcyByZXN1bHQgd2l0aCByZXBvcnQgYW5kIGFydGlmYWN0c1xuICovXG5hc3luYyBmdW5jdGlvbiBhbmFseXplV2l0aEdyb3EoXG4gIGZpbGVzOiBFeHRyYWN0ZWRGaWxlW10sXG4gIHByb2plY3RUeXBlOiBzdHJpbmcsXG4gIGRlcGVuZGVuY2llczogc3RyaW5nW11cbik6IFByb21pc2U8R3JvcUFuYWx5c2lzUmVzdWx0W10+IHtcbiAgY29uc3QgcmVzdWx0czogR3JvcUFuYWx5c2lzUmVzdWx0W10gPSBbXTtcbiAgXG4gIC8vIFNraXAgR3JvcSBhbmFseXNpcyBpZiBubyBHUk9RX0FQSV9LRVkgaXMgYXZhaWxhYmxlXG4gIGlmICghcHJvY2Vzcy5lbnYuR1JPUV9BUElfS0VZKSB7XG4gICAgY29uc29sZS5sb2coJ1NraXBwaW5nIEdyb3EgYW5hbHlzaXM6IEdST1FfQVBJX0tFWSBub3QgY29uZmlndXJlZCcpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIFxuICAvLyBBbmFseXplIHVwIHRvIDUga2V5IGZpbGVzIHRvIGF2b2lkIHJhdGUgbGltaXRzXG4gIGNvbnN0IGtleUZpbGVzID0gZmlsZXNcbiAgICAuZmlsdGVyKGZpbGUgPT4ge1xuICAgICAgY29uc3QgZmlsZU5hbWUgPSAoZmlsZSBhcyB7IG5hbWU/OiBzdHJpbmc7IHBhdGg6IHN0cmluZyB9KS5uYW1lIHx8IGZpbGUucGF0aCB8fCAndW5rbm93bic7XG4gICAgICBjb25zdCBleHQgPSBmaWxlTmFtZS5zcGxpdCgnLicpLnBvcCgpPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIFsnanMnLCAndHMnLCAnanN4JywgJ3RzeCcsICdjc3MnLCAnaHRtbCcsICd2dWUnLCAnc3ZlbHRlJywgJ3B5JywgJ2phdmEnLCAnZ28nLCAnY3MnXS5pbmNsdWRlcyhleHQgfHwgJycpO1xuICAgIH0pXG4gICAgLnNsaWNlKDAsIDUpO1xuXG4gIGZvciAoY29uc3QgZmlsZSBvZiBrZXlGaWxlcykge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgYWJzb2x1dGUgVVJMIGZvciBzZXJ2ZXItc2lkZSBmZXRjaFxuICAgICAgY29uc3QgYmFzZVVybCA9IHByb2Nlc3MuZW52LlBVQkxJQ19VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCc7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2Jhc2VVcmx9L2FwaS9hbmFseXplL2dyb3FgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNvZGU6IGZpbGUuY29udGVudCxcbiAgICAgICAgICBmaWxlbmFtZTogKGZpbGUgYXMgeyBuYW1lPzogc3RyaW5nOyBwYXRoOiBzdHJpbmcgfSkubmFtZSB8fCBmaWxlLnBhdGggfHwgJ3Vua25vd24nLFxuICAgICAgICAgIHByb2plY3RUeXBlLFxuICAgICAgICAgIGRlcGVuZGVuY2llc1xuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgR3JvcSBhbmFseXNpcyBmYWlsZWQgZm9yICR7KGZpbGUgYXMgeyBuYW1lPzogc3RyaW5nOyBwYXRoOiBzdHJpbmcgfSkubmFtZSB8fCBmaWxlLnBhdGh9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBHcm9xIGFuYWx5c2lzIGZhaWxlZCBmb3IgJHsoZmlsZSBhcyB7IG5hbWU/OiBzdHJpbmc7IHBhdGg6IHN0cmluZyB9KS5uYW1lIHx8IGZpbGUucGF0aH06YCwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuQmFzZWxpbmVBbmFseXNpcyhcbiAgZmlsZVBhdGg6IHN0cmluZyxcbiAgb3B0aW9uczogQW5hbHlzaXNPcHRpb25zID0ge31cbik6IFByb21pc2U8QW5hbHlzaXNSZXN1bHQ+IHtcbiAgY29uc3Qge1xuICAgIG1heEZpbGVzID0gNTAwMDAsXG4gICAgbWF4RmlsZVNpemUgPSAyICogMTAyNCAqIDEwMjQsIC8vIDJNQlxuICAgIGFsbG93ZWRFeHRlbnNpb25zID0gWycuaHRtbCcsICcuaHRtJywgJy5jc3MnLCAnLmpzJywgJy5tanMnLCAnLnRzJywgJy5zdmcnLCAnLndhc20nLCAnLmpzb24nLCAnLndlYm1hbmlmZXN0J10sXG4gICAgaWdub3JlUGF0aHMgPSBbJy9ub2RlX21vZHVsZXMvJywgJy8udmVudi8nLCAnL3ZlbnYvJywgJy9kaXN0LycsICcvYnVpbGQvJywgJy8uZ2l0LycsICcvLm5leHQvJ10sXG4gICAgc3RvcmVSZXN1bHRzID0gdHJ1ZSxcbiAgICBwdWJsaWNVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgYW5hbHlzaXNJZCA9IHJhbmRvbVVVSUQoKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICB0cnkge1xuICAgICAgICAgICAgLy8gTG9hZCBiYXNlbGluZSBydWxlc1xuICAgICAgICAgICAgY29uc3QgcnVsZXMgPSBhd2FpdCBsb2FkQmFzZWxpbmVSdWxlcygpO1xuICAgIFxuICAgIC8vIFByb2Nlc3Mgc2luZ2xlIGZpbGVcbiAgICBjb25zdCBmcyA9IGF3YWl0IGltcG9ydCgnZnMnKTtcbiAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgIFxuICAgIGlmICghc2hvdWxkQW5hbHl6ZUZpbGUoZmlsZVBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgdHlwZSBub3Qgc3VwcG9ydGVkIGZvciBhbmFseXNpczogJHtmaWxlUGF0aH1gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZXh0cmFjdFJlc3VsdCA9IHByb2Nlc3NTaW5nbGVGaWxlKGZpbGVQYXRoLCBjb250ZW50LCBtYXhGaWxlU2l6ZSk7XG5cbiAgICAvLyBEZXRlY3QgcHJvamVjdCBtYW5pZmVzdHMgYW5kIGxhbmd1YWdlc1xuICAgIGNvbnN0IG1hbmlmZXN0cyA9IGRldGVjdFByb2plY3RNYW5pZmVzdHMoZXh0cmFjdFJlc3VsdC5maWxlcyk7XG4gICAgY29uc3QgZGV0ZWN0ZWRMYW5ndWFnZXMgPSBkZXRlY3RMYW5ndWFnZXNGcm9tRmlsZXMoZXh0cmFjdFJlc3VsdC5maWxlcyk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGFuYWx5c2lzIGNvbnRleHRcbiAgICBjb25zdCBjb250ZXh0OiBBbmFseXNpc0NvbnRleHQgPSB7XG4gICAgICBydWxlcyxcbiAgICAgIGV4dHJhY3RlZEZpbGVzOiBleHRyYWN0UmVzdWx0LmZpbGVzLFxuICAgICAgbWFuaWZlc3RzLFxuICAgICAgZGV0ZWN0ZWRMYW5ndWFnZXMsXG4gICAgfTtcblxuICAgIC8vIFJ1biBhbmFseXNpc1xuICAgIGNvbnN0IGZpbmRpbmdzID0gYXdhaXQgcnVuQW5hbHlzaXMoY29udGV4dCk7XG4gICAgXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgYW5hbHlzaXMgZmluZGluZ3NcbiAgICBjb25zdCBhZGRpdGlvbmFsRmluZGluZ3MgPSBhd2FpdCBydW5BZGRpdGlvbmFsQW5hbHlzaXMoY29udGV4dCk7XG4gICAgZmluZGluZ3MucHVzaCguLi5hZGRpdGlvbmFsRmluZGluZ3MpO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHN1bW1hcnlcbiAgICBjb25zdCBzdW1tYXJ5ID0gZ2VuZXJhdGVTdW1tYXJ5KGZpbmRpbmdzLCBkZXRlY3RlZExhbmd1YWdlcyk7XG4gICAgXG4gICAgLy8gUnVuIEdyb3EgQUkgYW5hbHlzaXNcbiAgICBjb25zdCBncm9xUmVzdWx0cyA9IGF3YWl0IGFuYWx5emVXaXRoR3JvcShcbiAgICAgIGV4dHJhY3RSZXN1bHQuZmlsZXMsXG4gICAgICBkZXRlY3RlZExhbmd1YWdlcy5qb2luKCcsICcpLFxuICAgICAgY29udGV4dC5tYW5pZmVzdHMuZmxhdE1hcChtID0+IE9iamVjdC5rZXlzKG0uZGVwZW5kZW5jaWVzIHx8IHt9KSlcbiAgICApO1xuICAgIFxuICAgIC8vIENyZWF0ZSByZXBvcnRcbiAgICBjb25zdCByZXBvcnQ6IFJlcG9ydCA9IHtcbiAgICAgIGZpbmRpbmdzLFxuICAgICAgc3VtbWFyeSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIGFuYWx5c2lzSWQsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBwcm9qZWN0TmFtZTogZ2V0UHJvamVjdE5hbWUoZmlsZVBhdGgpLFxuICAgICAgICBkZXRlY3RlZExhbmd1YWdlcyxcbiAgICAgICAgdG90YWxGaWxlczogZXh0cmFjdFJlc3VsdC50b3RhbEZpbGVzLFxuICAgICAgICBzY2FubmVkRmlsZXM6IGV4dHJhY3RSZXN1bHQuZmlsZXMubGVuZ3RoLFxuICAgICAgICBza2lwcGVkRmlsZXM6IGV4dHJhY3RSZXN1bHQuc2tpcHBlZEZpbGVzLFxuICAgICAgICBncm9xQW5hbHlzaXM6IGdyb3FSZXN1bHRzLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gU3RvcmUgcmVzdWx0cyBpZiByZXF1ZXN0ZWRcbiAgICBsZXQgYXJ0aWZhY3RzO1xuICAgIGlmIChzdG9yZVJlc3VsdHMpIHtcbiAgICAgIGFydGlmYWN0cyA9IHN0b3JlQW5hbHlzaXNSZXN1bHRzKHJlcG9ydCwgeyBwdWJsaWNVcmwgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coYEFuYWx5c2lzIGNvbXBsZXRlZCBpbiAke2VuZFRpbWUgLSBzdGFydFRpbWV9bXNgKTtcblxuICAgIHJldHVybiB7XG4gICAgICByZXBvcnQsXG4gICAgICBhcnRpZmFjdHMsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdBbmFseXNpcyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQW5hbHlzaXMgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICB9XG59XG5cbi8qKlxuICogUnVuIGFuYWx5c2lzIG9uIGV4dHJhY3RlZCBmaWxlcyBhbmQgbWFuaWZlc3RzXG4gKiBAcGFyYW0gY29udGV4dCBBbmFseXNpcyBjb250ZXh0XG4gKiBAcmV0dXJucyBBcnJheSBvZiBmaW5kaW5nc1xuICovXG5hc3luYyBmdW5jdGlvbiBydW5BbmFseXNpcyhjb250ZXh0OiBBbmFseXNpc0NvbnRleHQpOiBQcm9taXNlPEZpbmRpbmdbXT4ge1xuICBjb25zdCBmaW5kaW5nczogRmluZGluZ1tdID0gW107XG5cbiAgLy8gQW5hbHl6ZSBkZXBlbmRlbmNpZXNcbiAgY29uc3QgZGVwZW5kZW5jeUZpbmRpbmdzID0gYW5hbHl6ZURlcGVuZGVuY2llcyhjb250ZXh0Lm1hbmlmZXN0cywgY29udGV4dC5ydWxlcyk7XG4gIGZpbmRpbmdzLnB1c2goLi4uZGVwZW5kZW5jeUZpbmRpbmdzKTtcblxuICAvLyBTY2FuIHNvdXJjZSBmaWxlcyBmb3IgZGVwcmVjYXRlZCBwYXR0ZXJuc1xuICBjb25zdCBwYXR0ZXJuRmluZGluZ3MgPSBzY2FuU291cmNlRmlsZXMoY29udGV4dC5leHRyYWN0ZWRGaWxlcywgY29udGV4dC5ydWxlcyk7XG4gIGZpbmRpbmdzLnB1c2goLi4ucGF0dGVybkZpbmRpbmdzKTtcblxuICByZXR1cm4gZmluZGluZ3M7XG59XG5cbi8qKlxuICogUnVuIGFkZGl0aW9uYWwgYW5hbHlzaXMgZm9yIGVuaGFuY2VkIGRldGVjdGlvblxuICogQHBhcmFtIGNvbnRleHQgQW5hbHlzaXMgY29udGV4dFxuICogQHJldHVybnMgQXJyYXkgb2YgYWRkaXRpb25hbCBmaW5kaW5nc1xuICovXG5hc3luYyBmdW5jdGlvbiBydW5BZGRpdGlvbmFsQW5hbHlzaXMoY29udGV4dDogQW5hbHlzaXNDb250ZXh0KTogUHJvbWlzZTxGaW5kaW5nW10+IHtcbiAgY29uc3QgZmluZGluZ3M6IEZpbmRpbmdbXSA9IFtdO1xuXG4gIC8vIEFuYWx5emUgY29kZSBxdWFsaXR5IGFuZCBiZXN0IHByYWN0aWNlc1xuICBjb25zdCBxdWFsaXR5RmluZGluZ3MgPSBhbmFseXplQ29kZVF1YWxpdHkoY29udGV4dC5leHRyYWN0ZWRGaWxlcyk7XG4gIGZpbmRpbmdzLnB1c2goLi4ucXVhbGl0eUZpbmRpbmdzKTtcblxuICAvLyBBbmFseXplIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllc1xuICBjb25zdCBzZWN1cml0eUZpbmRpbmdzID0gYW5hbHl6ZVNlY3VyaXR5VnVsbmVyYWJpbGl0aWVzKGNvbnRleHQuZXh0cmFjdGVkRmlsZXMpO1xuICBmaW5kaW5ncy5wdXNoKC4uLnNlY3VyaXR5RmluZGluZ3MpO1xuXG4gIC8vIEFuYWx5emUgcGVyZm9ybWFuY2UgaXNzdWVzXG4gIGNvbnN0IHBlcmZvcm1hbmNlRmluZGluZ3MgPSBhbmFseXplUGVyZm9ybWFuY2VJc3N1ZXMoY29udGV4dC5leHRyYWN0ZWRGaWxlcyk7XG4gIGZpbmRpbmdzLnB1c2goLi4ucGVyZm9ybWFuY2VGaW5kaW5ncyk7XG5cbiAgcmV0dXJuIGZpbmRpbmdzO1xufVxuXG4vKipcbiAqIEFuYWx5emUgY29kZSBxdWFsaXR5IGFuZCBiZXN0IHByYWN0aWNlc1xuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xuICogQHJldHVybnMgQXJyYXkgb2YgcXVhbGl0eSBmaW5kaW5nc1xuICovXG5mdW5jdGlvbiBhbmFseXplQ29kZVF1YWxpdHkoZmlsZXM6IEFycmF5PHsgcGF0aD86IHN0cmluZzsgbmFtZT86IHN0cmluZzsgY29udGVudDogc3RyaW5nOyBzaXplOiBudW1iZXIgfT4pOiBGaW5kaW5nW10ge1xuICBjb25zdCBmaW5kaW5nczogRmluZGluZ1tdID0gW107XG5cbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGggfHwgZmlsZS5uYW1lIHx8ICd1bmtub3duJztcbiAgICBjb25zdCBleHRlbnNpb24gPSBnZXRGaWxlRXh0ZW5zaW9uKGZpbGVQYXRoKTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IGRldGVjdExhbmd1YWdlRnJvbUV4dGVuc2lvbihleHRlbnNpb24pO1xuICAgIFxuICAgIGlmICghbGFuZ3VhZ2UpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgbGluZXMgPSBmaWxlLmNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBjb2RlIHF1YWxpdHkgaXNzdWVzXG4gICAgZm9yIChsZXQgbGluZUluZGV4ID0gMDsgbGluZUluZGV4IDwgbGluZXMubGVuZ3RoOyBsaW5lSW5kZXgrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2xpbmVJbmRleF07XG4gICAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBhbmQgY29tbWVudHNcbiAgICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBsb25nIGxpbmVzXG4gICAgICBpZiAobGluZS5sZW5ndGggPiAxMjApIHtcbiAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxuICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgIGZpbGU6IGZpbGVQYXRoLFxuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogJ2NvZGUtcXVhbGl0eScsXG4gICAgICAgICAgaXNzdWU6ICdMaW5lIGlzIHRvbyBsb25nICg+MTIwIGNoYXJhY3RlcnMpJyxcbiAgICAgICAgICBwYXR0ZXJuOiAnbG9uZy1saW5lJyxcbiAgICAgICAgICBxdWlja0ZpeDogJ0JyZWFrIGxvbmcgbGluZXMgZm9yIGJldHRlciByZWFkYWJpbGl0eScsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgaWYgKGxpbmUuZW5kc1dpdGgoJyAnKSB8fCBsaW5lLmVuZHNXaXRoKCdcXHQnKSkge1xuICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICBraW5kOiAncGF0dGVybicsXG4gICAgICAgICAgbGFuZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBzdGF0dXM6ICdhZmZlY3RlZCcsXG4gICAgICAgICAgcmVhc29uOiAnY29kZS1xdWFsaXR5JyxcbiAgICAgICAgICBpc3N1ZTogJ1RyYWlsaW5nIHdoaXRlc3BhY2UgZGV0ZWN0ZWQnLFxuICAgICAgICAgIHBhdHRlcm46ICd0cmFpbGluZy13aGl0ZXNwYWNlJyxcbiAgICAgICAgICBxdWlja0ZpeDogJ1JlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBtaXhlZCB0YWJzIGFuZCBzcGFjZXNcbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdcXHQnKSAmJiBsaW5lLmluY2x1ZGVzKCcgJykpIHtcbiAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxuICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgIGZpbGU6IGZpbGVQYXRoLFxuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogJ2NvZGUtcXVhbGl0eScsXG4gICAgICAgICAgaXNzdWU6ICdNaXhlZCB0YWJzIGFuZCBzcGFjZXMgZm9yIGluZGVudGF0aW9uJyxcbiAgICAgICAgICBwYXR0ZXJuOiAnbWl4ZWQtaW5kZW50YXRpb24nLFxuICAgICAgICAgIHF1aWNrRml4OiAnVXNlIGNvbnNpc3RlbnQgaW5kZW50YXRpb24gKHByZWZlciBzcGFjZXMpJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBUT0RPL0ZJWE1FIGNvbW1lbnRzXG4gICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd0b2RvJykgfHwgbGluZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmaXhtZScpKSB7XG4gICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBmaWxlOiBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICByZWFzb246ICdjb2RlLXF1YWxpdHknLFxuICAgICAgICAgIGlzc3VlOiAnVE9ETy9GSVhNRSBjb21tZW50IGZvdW5kJyxcbiAgICAgICAgICBwYXR0ZXJuOiAndG9kby1jb21tZW50JyxcbiAgICAgICAgICBxdWlja0ZpeDogJ0FkZHJlc3MgVE9ETy9GSVhNRSBpdGVtcyBiZWZvcmUgcHJvZHVjdGlvbicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgY29uc29sZS5sb2cgaW4gcHJvZHVjdGlvbiBjb2RlXG4gICAgICBpZiAobGFuZ3VhZ2UgPT09ICdub2RlJyAmJiBsaW5lLmluY2x1ZGVzKCdjb25zb2xlLmxvZycpKSB7XG4gICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBmaWxlOiBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICByZWFzb246ICdjb2RlLXF1YWxpdHknLFxuICAgICAgICAgIGlzc3VlOiAnY29uc29sZS5sb2cgc2hvdWxkIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbicsXG4gICAgICAgICAgcGF0dGVybjogJ2NvbnNvbGUtbG9nJyxcbiAgICAgICAgICBxdWlja0ZpeDogJ1VzZSBwcm9wZXIgbG9nZ2luZyBsaWJyYXJ5IG9yIHJlbW92ZSBkZWJ1ZyBzdGF0ZW1lbnRzJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBwcmludCBzdGF0ZW1lbnRzIGluIFB5dGhvblxuICAgICAgaWYgKGxhbmd1YWdlID09PSAncHl0aG9uJyAmJiBsaW5lLmluY2x1ZGVzKCdwcmludCgnKSkge1xuICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICBraW5kOiAncGF0dGVybicsXG4gICAgICAgICAgbGFuZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBzdGF0dXM6ICdhZmZlY3RlZCcsXG4gICAgICAgICAgcmVhc29uOiAnY29kZS1xdWFsaXR5JyxcbiAgICAgICAgICBpc3N1ZTogJ3ByaW50KCkgc2hvdWxkIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbicsXG4gICAgICAgICAgcGF0dGVybjogJ3ByaW50LXN0YXRlbWVudCcsXG4gICAgICAgICAgcXVpY2tGaXg6ICdVc2UgcHJvcGVyIGxvZ2dpbmcgbGlicmFyeSBvciByZW1vdmUgZGVidWcgc3RhdGVtZW50cycsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5kaW5ncztcbn1cblxuLyoqXG4gKiBBbmFseXplIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllc1xuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xuICogQHJldHVybnMgQXJyYXkgb2Ygc2VjdXJpdHkgZmluZGluZ3NcbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZVNlY3VyaXR5VnVsbmVyYWJpbGl0aWVzKGZpbGVzOiBBcnJheTx7IHBhdGg/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZzsgc2l6ZTogbnVtYmVyIH0+KTogRmluZGluZ1tdIHtcbiAgY29uc3QgZmluZGluZ3M6IEZpbmRpbmdbXSA9IFtdO1xuXG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoIHx8IGZpbGUubmFtZSB8fCAndW5rbm93bic7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKTtcbiAgICBcbiAgICBpZiAoIWxhbmd1YWdlKSBjb250aW51ZTtcblxuICAgIGNvbnN0IGxpbmVzID0gZmlsZS5jb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3Igc2VjdXJpdHkgdnVsbmVyYWJpbGl0aWVzXG4gICAgZm9yIChsZXQgbGluZUluZGV4ID0gMDsgbGluZUluZGV4IDwgbGluZXMubGVuZ3RoOyBsaW5lSW5kZXgrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2xpbmVJbmRleF07XG4gICAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBhbmQgY29tbWVudHNcbiAgICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBoYXJkY29kZWQgcGFzc3dvcmRzXG4gICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdwYXNzd29yZCcpICYmIGxpbmUuaW5jbHVkZXMoJz0nKSAmJiAhbGluZS5pbmNsdWRlcygnaW5wdXQoJykpIHtcbiAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxuICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgIGZpbGU6IGZpbGVQYXRoLFxuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogJ3NlY3VyaXR5JyxcbiAgICAgICAgICBpc3N1ZTogJ1BvdGVudGlhbCBoYXJkY29kZWQgcGFzc3dvcmQgZGV0ZWN0ZWQnLFxuICAgICAgICAgIHBhdHRlcm46ICdoYXJkY29kZWQtcGFzc3dvcmQnLFxuICAgICAgICAgIHF1aWNrRml4OiAnVXNlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvciBzZWN1cmUgY3JlZGVudGlhbCBzdG9yYWdlJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBoYXJkY29kZWQgQVBJIGtleXNcbiAgICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2FwaScpICYmIGxpbmUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygna2V5JykgJiYgbGluZS5pbmNsdWRlcygnPScpKSB7XG4gICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBmaWxlOiBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICByZWFzb246ICdzZWN1cml0eScsXG4gICAgICAgICAgaXNzdWU6ICdQb3RlbnRpYWwgaGFyZGNvZGVkIEFQSSBrZXkgZGV0ZWN0ZWQnLFxuICAgICAgICAgIHBhdHRlcm46ICdoYXJkY29kZWQtYXBpLWtleScsXG4gICAgICAgICAgcXVpY2tGaXg6ICdVc2UgZW52aXJvbm1lbnQgdmFyaWFibGVzIG9yIHNlY3VyZSBjcmVkZW50aWFsIHN0b3JhZ2UnLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIFNRTCBpbmplY3Rpb24gdnVsbmVyYWJpbGl0aWVzXG4gICAgICBpZiAobGluZS5pbmNsdWRlcygnU0VMRUNUJykgfHwgbGluZS5pbmNsdWRlcygnSU5TRVJUJykgfHwgbGluZS5pbmNsdWRlcygnVVBEQVRFJykgfHwgbGluZS5pbmNsdWRlcygnREVMRVRFJykpIHtcbiAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJysnKSB8fCBsaW5lLmluY2x1ZGVzKCckeycpIHx8IGxpbmUuaW5jbHVkZXMoJyVzJykpIHtcbiAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgICAgcmVhc29uOiAnc2VjdXJpdHknLFxuICAgICAgICAgICAgaXNzdWU6ICdQb3RlbnRpYWwgU1FMIGluamVjdGlvbiB2dWxuZXJhYmlsaXR5JyxcbiAgICAgICAgICAgIHBhdHRlcm46ICdzcWwtaW5qZWN0aW9uJyxcbiAgICAgICAgICAgIHF1aWNrRml4OiAnVXNlIHBhcmFtZXRlcml6ZWQgcXVlcmllcyBvciBwcmVwYXJlZCBzdGF0ZW1lbnRzJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgWFNTIHZ1bG5lcmFiaWxpdGllc1xuICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJ2lubmVySFRNTCcpIHx8IGxpbmUuaW5jbHVkZXMoJ291dGVySFRNTCcpIHx8IGxpbmUuaW5jbHVkZXMoJ2RvY3VtZW50LndyaXRlJykpIHtcbiAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxuICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgIGZpbGU6IGZpbGVQYXRoLFxuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogJ3NlY3VyaXR5JyxcbiAgICAgICAgICBpc3N1ZTogJ1BvdGVudGlhbCBYU1MgdnVsbmVyYWJpbGl0eScsXG4gICAgICAgICAgcGF0dGVybjogJ3hzcy12dWxuZXJhYmlsaXR5JyxcbiAgICAgICAgICBxdWlja0ZpeDogJ1VzZSB0ZXh0Q29udGVudCBvciBzYW5pdGl6ZSBIVE1MIGNvbnRlbnQnLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIHVuc2FmZSBkZXNlcmlhbGl6YXRpb25cbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdwaWNrbGUubG9hZCcpIHx8IGxpbmUuaW5jbHVkZXMoJ3VucGlja2xlJykgfHwgbGluZS5pbmNsdWRlcygnZGVzZXJpYWxpemUnKSkge1xuICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICBraW5kOiAncGF0dGVybicsXG4gICAgICAgICAgbGFuZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBzdGF0dXM6ICdhZmZlY3RlZCcsXG4gICAgICAgICAgcmVhc29uOiAnc2VjdXJpdHknLFxuICAgICAgICAgIGlzc3VlOiAnVW5zYWZlIGRlc2VyaWFsaXphdGlvbiBkZXRlY3RlZCcsXG4gICAgICAgICAgcGF0dGVybjogJ3Vuc2FmZS1kZXNlcmlhbGl6YXRpb24nLFxuICAgICAgICAgIHF1aWNrRml4OiAnVXNlIHNhZmUgc2VyaWFsaXphdGlvbiBmb3JtYXRzIGxpa2UgSlNPTicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5kaW5ncztcbn1cblxuLyoqXG4gKiBBbmFseXplIHBlcmZvcm1hbmNlIGlzc3Vlc1xuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xuICogQHJldHVybnMgQXJyYXkgb2YgcGVyZm9ybWFuY2UgZmluZGluZ3NcbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZVBlcmZvcm1hbmNlSXNzdWVzKGZpbGVzOiBBcnJheTx7IHBhdGg/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZzsgc2l6ZTogbnVtYmVyIH0+KTogRmluZGluZ1tdIHtcbiAgY29uc3QgZmluZGluZ3M6IEZpbmRpbmdbXSA9IFtdO1xuXG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoIHx8IGZpbGUubmFtZSB8fCAndW5rbm93bic7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKTtcbiAgICBcbiAgICBpZiAoIWxhbmd1YWdlKSBjb250aW51ZTtcblxuICAgIGNvbnN0IGxpbmVzID0gZmlsZS5jb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgcGVyZm9ybWFuY2UgaXNzdWVzXG4gICAgZm9yIChsZXQgbGluZUluZGV4ID0gMDsgbGluZUluZGV4IDwgbGluZXMubGVuZ3RoOyBsaW5lSW5kZXgrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2xpbmVJbmRleF07XG4gICAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBhbmQgY29tbWVudHNcbiAgICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBzeW5jaHJvbm91cyBmaWxlIG9wZXJhdGlvbnNcbiAgICAgIGlmIChsYW5ndWFnZSA9PT0gJ25vZGUnICYmIChsaW5lLmluY2x1ZGVzKCdmcy5yZWFkRmlsZVN5bmMnKSB8fCBsaW5lLmluY2x1ZGVzKCdmcy53cml0ZUZpbGVTeW5jJykpKSB7XG4gICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBmaWxlOiBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICByZWFzb246ICdwZXJmb3JtYW5jZScsXG4gICAgICAgICAgaXNzdWU6ICdTeW5jaHJvbm91cyBmaWxlIG9wZXJhdGlvbiBjYW4gYmxvY2sgdGhlIGV2ZW50IGxvb3AnLFxuICAgICAgICAgIHBhdHRlcm46ICdzeW5jLWZpbGUtb3BlcmF0aW9uJyxcbiAgICAgICAgICBxdWlja0ZpeDogJ1VzZSBhc3luY2hyb25vdXMgZmlsZSBvcGVyYXRpb25zIChmcy5wcm9taXNlcyknLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIGJsb2NraW5nIG9wZXJhdGlvbnNcbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdzbGVlcCgnKSB8fCBsaW5lLmluY2x1ZGVzKCd0aW1lLnNsZWVwKCcpKSB7XG4gICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBmaWxlOiBmaWxlUGF0aCxcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICByZWFzb246ICdwZXJmb3JtYW5jZScsXG4gICAgICAgICAgaXNzdWU6ICdCbG9ja2luZyBzbGVlcCBvcGVyYXRpb24gZGV0ZWN0ZWQnLFxuICAgICAgICAgIHBhdHRlcm46ICdibG9ja2luZy1zbGVlcCcsXG4gICAgICAgICAgcXVpY2tGaXg6ICdVc2UgYXN5bmNocm9ub3VzIGFsdGVybmF0aXZlcyBvciByZWR1Y2Ugc2xlZXAgdGltZScsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgaW5lZmZpY2llbnQgbG9vcHNcbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdmb3InKSAmJiBsaW5lLmluY2x1ZGVzKCdpbicpICYmIGxpbmUuaW5jbHVkZXMoJ3JhbmdlKCcpKSB7XG4gICAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdsZW4oJykgfHwgbGluZS5pbmNsdWRlcygnLmxlbmd0aCcpKSB7XG4gICAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICBraW5kOiAncGF0dGVybicsXG4gICAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICAgIGZpbGU6IGZpbGVQYXRoLFxuICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICAgIHJlYXNvbjogJ3BlcmZvcm1hbmNlJyxcbiAgICAgICAgICAgIGlzc3VlOiAnSW5lZmZpY2llbnQgbG9vcCB3aXRoIGxlbigpL2xlbmd0aCBjYWxsJyxcbiAgICAgICAgICAgIHBhdHRlcm46ICdpbmVmZmljaWVudC1sb29wJyxcbiAgICAgICAgICAgIHF1aWNrRml4OiAnQ2FjaGUgbGVuZ3RoIG9yIHVzZSBlbnVtZXJhdGUoKS9lbnRyaWVzKCknLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBzdHJpbmcgY29uY2F0ZW5hdGlvbiBpbiBsb29wc1xuICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJys9JykgJiYgbGluZS5pbmNsdWRlcygnc3RyJykgfHwgbGluZS5pbmNsdWRlcygnKz0nKSAmJiBsaW5lLmluY2x1ZGVzKCdzdHJpbmcnKSkge1xuICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICBraW5kOiAncGF0dGVybicsXG4gICAgICAgICAgbGFuZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBzdGF0dXM6ICdhZmZlY3RlZCcsXG4gICAgICAgICAgcmVhc29uOiAncGVyZm9ybWFuY2UnLFxuICAgICAgICAgIGlzc3VlOiAnU3RyaW5nIGNvbmNhdGVuYXRpb24gaW4gbG9vcCBpcyBpbmVmZmljaWVudCcsXG4gICAgICAgICAgcGF0dGVybjogJ3N0cmluZy1jb25jYXRlbmF0aW9uJyxcbiAgICAgICAgICBxdWlja0ZpeDogJ1VzZSBqb2luKCkgb3IgU3RyaW5nQnVpbGRlciBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmRpbmdzO1xufVxuXG4vKipcbiAqIEdldCBmaWxlIGV4dGVuc2lvbiBmcm9tIHBhdGhcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcbiAqIEByZXR1cm5zIEZpbGUgZXh0ZW5zaW9uIHdpdGggZG90XG4gKi9cbmZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGxhc3REb3QgPSBmaWxlUGF0aC5sYXN0SW5kZXhPZignLicpO1xuICBpZiAobGFzdERvdCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIGZpbGVQYXRoLnN1YnN0cmluZyhsYXN0RG90KTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgbGFuZ3VhZ2UgZnJvbSBmaWxlIGV4dGVuc2lvblxuICogQHBhcmFtIGV4dGVuc2lvbiBGaWxlIGV4dGVuc2lvblxuICogQHJldHVybnMgTGFuZ3VhZ2Ugb3IgbnVsbFxuICovXG5mdW5jdGlvbiBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uOiBzdHJpbmcpOiBMYW5ndWFnZSB8IG51bGwge1xuICBjb25zdCBsYW5ndWFnZU1hcDogUmVjb3JkPHN0cmluZywgTGFuZ3VhZ2U+ID0ge1xuICAgICcuaHRtbCc6ICdub2RlJyxcbiAgICAnLmh0bSc6ICdub2RlJyxcbiAgICAnLmNzcyc6ICdub2RlJyxcbiAgICAnLmpzJzogJ25vZGUnLFxuICAgICcuanN4JzogJ25vZGUnLFxuICAgICcubWpzJzogJ25vZGUnLFxuICAgICcudHMnOiAnbm9kZScsXG4gICAgJy50c3gnOiAnbm9kZScsXG4gICAgJy5zdmcnOiAnbm9kZScsXG4gICAgJy53YXNtJzogJ25vZGUnLFxuICAgICcuanNvbic6ICdub2RlJyxcbiAgICAnLndlYm1hbmlmZXN0JzogJ25vZGUnLFxuICAgICcucHknOiAncHl0aG9uJyxcbiAgICAnLmphdmEnOiAnamF2YScsXG4gICAgJy5nbyc6ICdnbycsXG4gICAgJy5jcyc6ICdkb3RuZXQnLFxuICAgICcuZnMnOiAnZG90bmV0JyxcbiAgICAnLnZiJzogJ2RvdG5ldCcsXG4gIH07XG4gIFxuICByZXR1cm4gbGFuZ3VhZ2VNYXBbZXh0ZW5zaW9uXSB8fCBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbGluZSBpcyBhIGNvbW1lbnRcbiAqIEBwYXJhbSBsaW5lIExpbmUgY29udGVudFxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcbiAqIEByZXR1cm5zIFRydWUgaWYgY29tbWVudCBsaW5lXG4gKi9cbmZ1bmN0aW9uIGlzQ29tbWVudExpbmUobGluZTogc3RyaW5nLCBsYW5ndWFnZTogTGFuZ3VhZ2UpOiBib29sZWFuIHtcbiAgY29uc3QgdHJpbW1lZCA9IGxpbmUudHJpbSgpO1xuICBcbiAgc3dpdGNoIChsYW5ndWFnZSkge1xuICAgIGNhc2UgJ25vZGUnOlxuICAgIGNhc2UgJ2phdmEnOlxuICAgIGNhc2UgJ2dvJzpcbiAgICBjYXNlICdkb3RuZXQnOlxuICAgICAgcmV0dXJuIHRyaW1tZWQuc3RhcnRzV2l0aCgnLy8nKSB8fCB0cmltbWVkLnN0YXJ0c1dpdGgoJy8qJykgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCcqJykgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCc8IS0tJyk7XG4gICAgXG4gICAgY2FzZSAncHl0aG9uJzpcbiAgICAgIHJldHVybiB0cmltbWVkLnN0YXJ0c1dpdGgoJyMnKTtcbiAgICBcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgc3VtbWFyeSBmcm9tIGZpbmRpbmdzXG4gKiBAcGFyYW0gZmluZGluZ3MgQXJyYXkgb2YgZmluZGluZ3NcbiAqIEBwYXJhbSBkZXRlY3RlZExhbmd1YWdlcyBBcnJheSBvZiBkZXRlY3RlZCBsYW5ndWFnZXNcbiAqIEByZXR1cm5zIFJlcG9ydCBzdW1tYXJ5XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU3VtbWFyeShmaW5kaW5nczogRmluZGluZ1tdLCBkZXRlY3RlZExhbmd1YWdlczogTGFuZ3VhZ2VbXSk6IFJlcG9ydFN1bW1hcnkge1xuICBjb25zdCBzdW1tYXJ5OiBSZXBvcnRTdW1tYXJ5ID0ge1xuICAgIG9rOiAwLFxuICAgIGFmZmVjdGVkOiAwLFxuICAgIHVua25vd246IDAsXG4gICAgYnlMYW5ndWFnZToge30sXG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYW5ndWFnZSBzdW1tYXJpZXNcbiAgZm9yIChjb25zdCBsYW5ndWFnZSBvZiBkZXRlY3RlZExhbmd1YWdlcykge1xuICAgIHN1bW1hcnkuYnlMYW5ndWFnZVtsYW5ndWFnZV0gPSB7XG4gICAgICBvazogMCxcbiAgICAgIGFmZmVjdGVkOiAwLFxuICAgICAgdW5rbm93bjogMCxcbiAgICB9O1xuICB9XG5cbiAgLy8gQ291bnQgZmluZGluZ3MgYnkgc3RhdHVzIGFuZCBsYW5ndWFnZVxuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgZmluZGluZ3MpIHtcbiAgICBpZiAoZmluZGluZy5raW5kID09PSAnZGVwZW5kZW5jeScpIHtcbiAgICAgIHN1bW1hcnlbZmluZGluZy5zdGF0dXNdKys7XG4gICAgICBpZiAoc3VtbWFyeS5ieUxhbmd1YWdlW2ZpbmRpbmcubGFuZ10pIHtcbiAgICAgICAgc3VtbWFyeS5ieUxhbmd1YWdlW2ZpbmRpbmcubGFuZ10hW2ZpbmRpbmcuc3RhdHVzXSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmluZGluZy5raW5kID09PSAncGF0dGVybicpIHtcbiAgICAgIHN1bW1hcnkuYWZmZWN0ZWQrKztcbiAgICAgIGlmIChzdW1tYXJ5LmJ5TGFuZ3VhZ2VbZmluZGluZy5sYW5nXSkge1xuICAgICAgICBzdW1tYXJ5LmJ5TGFuZ3VhZ2VbZmluZGluZy5sYW5nXSEuYWZmZWN0ZWQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VtbWFyeTtcbn1cblxuLyoqXG4gKiBHZXQgcHJvamVjdCBuYW1lIGZyb20gWklQIHBhdGhcbiAqIEBwYXJhbSB6aXBQYXRoIFpJUCBmaWxlIHBhdGhcbiAqIEByZXR1cm5zIFByb2plY3QgbmFtZVxuICovXG5mdW5jdGlvbiBnZXRQcm9qZWN0TmFtZSh6aXBQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYXRoUGFydHMgPSB6aXBQYXRoLnNwbGl0KCcvJyk7XG4gIGNvbnN0IGZpbGVOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGZpbGVOYW1lLnJlcGxhY2UoL1xcLnppcCQvaSwgJycpO1xufVxuXG4vKipcbiAqIFJ1biBhbmFseXNpcyBvbiBleHRyYWN0ZWQgZmlsZXMgKGZvciB0ZXN0aW5nKVxuICogQHBhcmFtIGZpbGVzIEFycmF5IG9mIGV4dHJhY3RlZCBmaWxlc1xuICogQHBhcmFtIG1hbmlmZXN0cyBBcnJheSBvZiBwcm9qZWN0IG1hbmlmZXN0c1xuICogQHBhcmFtIHJ1bGVzIEJhc2VsaW5lIHJ1bGVzXG4gKiBAcmV0dXJucyBBbmFseXNpcyByZXN1bHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bkFuYWx5c2lzT25GaWxlcyhcbiAgZmlsZXM6IEV4dHJhY3RlZEZpbGVbXSxcbiAgbWFuaWZlc3RzOiBQcm9qZWN0TWFuaWZlc3RbXSxcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNcbik6IFByb21pc2U8QW5hbHlzaXNSZXN1bHQ+IHtcbiAgY29uc3QgYW5hbHlzaXNJZCA9IHJhbmRvbVVVSUQoKTtcbiAgY29uc3QgZGV0ZWN0ZWRMYW5ndWFnZXMgPSBkZXRlY3RMYW5ndWFnZXNGcm9tRmlsZXMoZmlsZXMpO1xuICBcbiAgY29uc3QgY29udGV4dDogQW5hbHlzaXNDb250ZXh0ID0ge1xuICAgIHJ1bGVzLFxuICAgIGV4dHJhY3RlZEZpbGVzOiBmaWxlcyxcbiAgICBtYW5pZmVzdHMsXG4gICAgZGV0ZWN0ZWRMYW5ndWFnZXMsXG4gIH07XG5cbiAgY29uc3QgZmluZGluZ3MgPSBhd2FpdCBydW5BbmFseXNpcyhjb250ZXh0KTtcbiAgY29uc3Qgc3VtbWFyeSA9IGdlbmVyYXRlU3VtbWFyeShmaW5kaW5ncywgZGV0ZWN0ZWRMYW5ndWFnZXMpO1xuICBcbiAgY29uc3QgcmVwb3J0OiBSZXBvcnQgPSB7XG4gICAgZmluZGluZ3MsXG4gICAgc3VtbWFyeSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgYW5hbHlzaXNJZCxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgcHJvamVjdE5hbWU6ICd0ZXN0LXByb2plY3QnLFxuICAgICAgZGV0ZWN0ZWRMYW5ndWFnZXMsXG4gICAgICB0b3RhbEZpbGVzOiBmaWxlcy5sZW5ndGgsXG4gICAgICBzY2FubmVkRmlsZXM6IGZpbGVzLmxlbmd0aCxcbiAgICAgIHNraXBwZWRGaWxlczogMCxcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiB7IHJlcG9ydCB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuYWx5c2lzIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zIEFuYWx5c2lzIG9wdGlvbnNcbiAqIEByZXR1cm5zIFZhbGlkYXRlZCBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFuYWx5c2lzT3B0aW9ucyhvcHRpb25zOiBBbmFseXNpc09wdGlvbnMpOiBBbmFseXNpc09wdGlvbnMge1xuICByZXR1cm4ge1xuICAgIG1heEZpbGVzOiBNYXRoLm1pbihvcHRpb25zLm1heEZpbGVzIHx8IDUwMDAwLCAxMDAwMDApLCAvLyBDYXAgYXQgMTAwa1xuICAgIG1heEZpbGVTaXplOiBNYXRoLm1pbihvcHRpb25zLm1heEZpbGVTaXplIHx8IDIgKiAxMDI0ICogMTAyNCwgMTAgKiAxMDI0ICogMTAyNCksIC8vIENhcCBhdCAxME1CXG4gICAgYWxsb3dlZEV4dGVuc2lvbnM6IG9wdGlvbnMuYWxsb3dlZEV4dGVuc2lvbnMgfHwgWycuaHRtbCcsICcuaHRtJywgJy5jc3MnLCAnLmpzJywgJy5tanMnLCAnLnRzJywgJy5zdmcnLCAnLndhc20nLCAnLmpzb24nLCAnLndlYm1hbmlmZXN0J10sXG4gICAgaWdub3JlUGF0aHM6IG9wdGlvbnMuaWdub3JlUGF0aHMgfHwgWycvbm9kZV9tb2R1bGVzLycsICcvLnZlbnYvJywgJy92ZW52LycsICcvZGlzdC8nLCAnL2J1aWxkLycsICcvLmdpdC8nLCAnLy5uZXh0LyddLFxuICAgIHN0b3JlUmVzdWx0czogb3B0aW9ucy5zdG9yZVJlc3VsdHMgIT09IGZhbHNlLFxuICAgIHB1YmxpY1VybDogb3B0aW9ucy5wdWJsaWNVcmwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcsXG4gIH07XG59XG5cbi8qKlxuICogR2V0IGFuYWx5c2lzIHByb2dyZXNzIChmb3IgbG9uZy1ydW5uaW5nIGFuYWx5c2VzKVxuICogQHBhcmFtIGNvbnRleHQgQW5hbHlzaXMgY29udGV4dFxuICogQHBhcmFtIGN1cnJlbnRTdGVwIEN1cnJlbnQgc3RlcFxuICogQHBhcmFtIHRvdGFsU3RlcHMgVG90YWwgc3RlcHNcbiAqIEByZXR1cm5zIFByb2dyZXNzIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmFseXNpc1Byb2dyZXNzKFxuICBjb250ZXh0OiBBbmFseXNpc0NvbnRleHQsXG4gIGN1cnJlbnRTdGVwOiBudW1iZXIsXG4gIHRvdGFsU3RlcHM6IG51bWJlclxuKToge1xuICBzdGVwOiBzdHJpbmc7XG4gIHByb2dyZXNzOiBudW1iZXI7XG4gIGRldGFpbHM6IHN0cmluZztcbn0ge1xuICBjb25zdCBzdGVwcyA9IFtcbiAgICAnTG9hZGluZyBiYXNlbGluZSBydWxlcycsXG4gICAgJ0V4dHJhY3RpbmcgWklQIGZpbGUnLFxuICAgICdEZXRlY3RpbmcgcHJvamVjdCBtYW5pZmVzdHMnLFxuICAgICdBbmFseXppbmcgZGVwZW5kZW5jaWVzJyxcbiAgICAnU2Nhbm5pbmcgc291cmNlIGZpbGVzJyxcbiAgICAnR2VuZXJhdGluZyByZXBvcnQnLFxuICBdO1xuXG4gIGNvbnN0IHN0ZXAgPSBzdGVwc1tjdXJyZW50U3RlcF0gfHwgJ1Vua25vd24nO1xuICBjb25zdCBwcm9ncmVzcyA9IChjdXJyZW50U3RlcCAvIHRvdGFsU3RlcHMpICogMTAwO1xuICBcbiAgbGV0IGRldGFpbHMgPSAnJztcbiAgaWYgKGN1cnJlbnRTdGVwID09PSAxKSB7XG4gICAgZGV0YWlscyA9IGBFeHRyYWN0ZWQgJHtjb250ZXh0LmV4dHJhY3RlZEZpbGVzLmxlbmd0aH0gZmlsZXNgO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRTdGVwID09PSAyKSB7XG4gICAgZGV0YWlscyA9IGBGb3VuZCAke2NvbnRleHQubWFuaWZlc3RzLmxlbmd0aH0gbWFuaWZlc3RzLCAke2NvbnRleHQuZGV0ZWN0ZWRMYW5ndWFnZXMubGVuZ3RofSBsYW5ndWFnZXNgO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRTdGVwID09PSAzKSB7XG4gICAgZGV0YWlscyA9IGBBbmFseXppbmcgJHtjb250ZXh0Lm1hbmlmZXN0cy5sZW5ndGh9IGRlcGVuZGVuY3kgbWFuaWZlc3RzYDtcbiAgfSBlbHNlIGlmIChjdXJyZW50U3RlcCA9PT0gNCkge1xuICAgIGRldGFpbHMgPSBgU2Nhbm5pbmcgJHtjb250ZXh0LmV4dHJhY3RlZEZpbGVzLmxlbmd0aH0gc291cmNlIGZpbGVzYDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RlcCxcbiAgICBwcm9ncmVzcyxcbiAgICBkZXRhaWxzLFxuICB9O1xufVxuXG4vKipcbiAqIEVzdGltYXRlIGFuYWx5c2lzIHRpbWVcbiAqIEBwYXJhbSBmaWxlQ291bnQgTnVtYmVyIG9mIGZpbGVzXG4gKiBAcGFyYW0gbWFuaWZlc3RDb3VudCBOdW1iZXIgb2YgbWFuaWZlc3RzXG4gKiBAcmV0dXJucyBFc3RpbWF0ZWQgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzdGltYXRlQW5hbHlzaXNUaW1lKGZpbGVDb3VudDogbnVtYmVyLCBtYW5pZmVzdENvdW50OiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBCYXNlIHRpbWU6IDEgc2Vjb25kXG4gIGxldCBlc3RpbWF0ZWQgPSAxMDAwO1xuICBcbiAgLy8gQWRkIHRpbWUgZm9yIGZpbGUgcHJvY2Vzc2luZzogMTBtcyBwZXIgZmlsZVxuICBlc3RpbWF0ZWQgKz0gZmlsZUNvdW50ICogMTA7XG4gIFxuICAvLyBBZGQgdGltZSBmb3IgbWFuaWZlc3QgcHJvY2Vzc2luZzogNTBtcyBwZXIgbWFuaWZlc3RcbiAgZXN0aW1hdGVkICs9IG1hbmlmZXN0Q291bnQgKiA1MDtcbiAgXG4gIC8vIEFkZCB0aW1lIGZvciBwYXR0ZXJuIHNjYW5uaW5nOiA1bXMgcGVyIGZpbGVcbiAgZXN0aW1hdGVkICs9IGZpbGVDb3VudCAqIDU7XG4gIFxuICByZXR1cm4gTWF0aC5taW4oZXN0aW1hdGVkLCAzMDAwMCk7IC8vIENhcCBhdCAzMCBzZWNvbmRzXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW5hbHlzaXMgaXMgZmVhc2libGVcbiAqIEBwYXJhbSBmaWxlQ291bnQgTnVtYmVyIG9mIGZpbGVzXG4gKiBAcGFyYW0gdG90YWxTaXplIFRvdGFsIHNpemUgaW4gYnl0ZXNcbiAqIEByZXR1cm5zIEZlYXNpYmlsaXR5IGNoZWNrIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tBbmFseXNpc0ZlYXNpYmlsaXR5KFxuICBmaWxlQ291bnQ6IG51bWJlcixcbiAgdG90YWxTaXplOiBudW1iZXJcbik6IHtcbiAgZmVhc2libGU6IGJvb2xlYW47XG4gIHdhcm5pbmdzOiBzdHJpbmdbXTtcbiAgZXN0aW1hdGVkVGltZTogc3RyaW5nO1xufSB7XG4gIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgZmVhc2libGUgPSB0cnVlO1xuXG4gIC8vIENoZWNrIGZpbGUgY291bnRcbiAgaWYgKGZpbGVDb3VudCA+IDUwMDAwKSB7XG4gICAgZmVhc2libGUgPSBmYWxzZTtcbiAgICB3YXJuaW5ncy5wdXNoKGBUb28gbWFueSBmaWxlczogJHtmaWxlQ291bnR9IChsaW1pdDogNTAsMDAwKWApO1xuICB9IGVsc2UgaWYgKGZpbGVDb3VudCA+IDEwMDAwKSB7XG4gICAgd2FybmluZ3MucHVzaChgTGFyZ2UgbnVtYmVyIG9mIGZpbGVzOiAke2ZpbGVDb3VudH0gKGFuYWx5c2lzIG1heSB0YWtlIGxvbmdlcilgKTtcbiAgfVxuXG4gIC8vIENoZWNrIHRvdGFsIHNpemVcbiAgaWYgKHRvdGFsU2l6ZSA+IDEwMCAqIDEwMjQgKiAxMDI0KSB7IC8vIDEwME1CXG4gICAgZmVhc2libGUgPSBmYWxzZTtcbiAgICB3YXJuaW5ncy5wdXNoKGBBcmNoaXZlIHRvbyBsYXJnZTogJHtNYXRoLnJvdW5kKHRvdGFsU2l6ZSAvIDEwMjQgLyAxMDI0KX1NQiAobGltaXQ6IDEwME1CKWApO1xuICB9IGVsc2UgaWYgKHRvdGFsU2l6ZSA+IDUwICogMTAyNCAqIDEwMjQpIHsgLy8gNTBNQlxuICAgIHdhcm5pbmdzLnB1c2goYExhcmdlIGFyY2hpdmU6ICR7TWF0aC5yb3VuZCh0b3RhbFNpemUgLyAxMDI0IC8gMTAyNCl9TUIgKGFuYWx5c2lzIG1heSB0YWtlIGxvbmdlcilgKTtcbiAgfVxuXG4gIGNvbnN0IGVzdGltYXRlZFRpbWVNcyA9IGVzdGltYXRlQW5hbHlzaXNUaW1lKGZpbGVDb3VudCwgTWF0aC5taW4oZmlsZUNvdW50IC8gMTAwLCA1MCkpO1xuICBjb25zdCBlc3RpbWF0ZWRUaW1lID0gYCR7TWF0aC5yb3VuZChlc3RpbWF0ZWRUaW1lTXMgLyAxMDAwKX1zYDtcblxuICByZXR1cm4ge1xuICAgIGZlYXNpYmxlLFxuICAgIHdhcm5pbmdzLFxuICAgIGVzdGltYXRlZFRpbWUsXG4gIH07XG59XG4iXSwibmFtZXMiOlsicmFuZG9tVVVJRCIsImxvYWRCYXNlbGluZVJ1bGVzIiwiZGV0ZWN0UHJvamVjdE1hbmlmZXN0cyIsImRldGVjdExhbmd1YWdlc0Zyb21GaWxlcyIsImFuYWx5emVEZXBlbmRlbmNpZXMiLCJzY2FuU291cmNlRmlsZXMiLCJwcm9jZXNzU2luZ2xlRmlsZSIsInNob3VsZEFuYWx5emVGaWxlIiwic3RvcmVBbmFseXNpc1Jlc3VsdHMiLCJhbmFseXplV2l0aEdyb3EiLCJmaWxlcyIsInByb2plY3RUeXBlIiwiZGVwZW5kZW5jaWVzIiwicmVzdWx0cyIsInByb2Nlc3MiLCJlbnYiLCJHUk9RX0FQSV9LRVkiLCJjb25zb2xlIiwibG9nIiwia2V5RmlsZXMiLCJmaWx0ZXIiLCJmaWxlIiwiZmlsZU5hbWUiLCJuYW1lIiwicGF0aCIsImV4dCIsInNwbGl0IiwicG9wIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInNsaWNlIiwiYmFzZVVybCIsIlBVQkxJQ19VUkwiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiY29kZSIsImNvbnRlbnQiLCJmaWxlbmFtZSIsIm9rIiwicmVzdWx0IiwianNvbiIsInB1c2giLCJlcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJydW5CYXNlbGluZUFuYWx5c2lzIiwiZmlsZVBhdGgiLCJvcHRpb25zIiwibWF4RmlsZXMiLCJtYXhGaWxlU2l6ZSIsImFsbG93ZWRFeHRlbnNpb25zIiwiaWdub3JlUGF0aHMiLCJzdG9yZVJlc3VsdHMiLCJwdWJsaWNVcmwiLCJhbmFseXNpc0lkIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJ1bGVzIiwiZnMiLCJyZWFkRmlsZVN5bmMiLCJFcnJvciIsImV4dHJhY3RSZXN1bHQiLCJtYW5pZmVzdHMiLCJkZXRlY3RlZExhbmd1YWdlcyIsImNvbnRleHQiLCJleHRyYWN0ZWRGaWxlcyIsImZpbmRpbmdzIiwicnVuQW5hbHlzaXMiLCJhZGRpdGlvbmFsRmluZGluZ3MiLCJydW5BZGRpdGlvbmFsQW5hbHlzaXMiLCJzdW1tYXJ5IiwiZ2VuZXJhdGVTdW1tYXJ5IiwiZ3JvcVJlc3VsdHMiLCJqb2luIiwiZmxhdE1hcCIsIm0iLCJPYmplY3QiLCJrZXlzIiwicmVwb3J0IiwibWV0YWRhdGEiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsInByb2plY3ROYW1lIiwiZ2V0UHJvamVjdE5hbWUiLCJ0b3RhbEZpbGVzIiwic2Nhbm5lZEZpbGVzIiwibGVuZ3RoIiwic2tpcHBlZEZpbGVzIiwiZ3JvcUFuYWx5c2lzIiwiYXJ0aWZhY3RzIiwiZW5kVGltZSIsIm1lc3NhZ2UiLCJkZXBlbmRlbmN5RmluZGluZ3MiLCJwYXR0ZXJuRmluZGluZ3MiLCJxdWFsaXR5RmluZGluZ3MiLCJhbmFseXplQ29kZVF1YWxpdHkiLCJzZWN1cml0eUZpbmRpbmdzIiwiYW5hbHl6ZVNlY3VyaXR5VnVsbmVyYWJpbGl0aWVzIiwicGVyZm9ybWFuY2VGaW5kaW5ncyIsImFuYWx5emVQZXJmb3JtYW5jZUlzc3VlcyIsImV4dGVuc2lvbiIsImdldEZpbGVFeHRlbnNpb24iLCJsYW5ndWFnZSIsImRldGVjdExhbmd1YWdlRnJvbUV4dGVuc2lvbiIsImxpbmVzIiwibGluZUluZGV4IiwibGluZSIsImxpbmVOdW1iZXIiLCJpc0NvbW1lbnRMaW5lIiwidHJpbSIsImtpbmQiLCJsYW5nIiwicmVhc29uIiwiaXNzdWUiLCJwYXR0ZXJuIiwicXVpY2tGaXgiLCJlbmRzV2l0aCIsImxhc3REb3QiLCJsYXN0SW5kZXhPZiIsInN1YnN0cmluZyIsImxhbmd1YWdlTWFwIiwidHJpbW1lZCIsInN0YXJ0c1dpdGgiLCJhZmZlY3RlZCIsInVua25vd24iLCJieUxhbmd1YWdlIiwiZmluZGluZyIsInppcFBhdGgiLCJwYXRoUGFydHMiLCJyZXBsYWNlIiwicnVuQW5hbHlzaXNPbkZpbGVzIiwidmFsaWRhdGVBbmFseXNpc09wdGlvbnMiLCJNYXRoIiwibWluIiwiZ2V0QW5hbHlzaXNQcm9ncmVzcyIsImN1cnJlbnRTdGVwIiwidG90YWxTdGVwcyIsInN0ZXBzIiwic3RlcCIsInByb2dyZXNzIiwiZGV0YWlscyIsImVzdGltYXRlQW5hbHlzaXNUaW1lIiwiZmlsZUNvdW50IiwibWFuaWZlc3RDb3VudCIsImVzdGltYXRlZCIsImNoZWNrQW5hbHlzaXNGZWFzaWJpbGl0eSIsInRvdGFsU2l6ZSIsIndhcm5pbmdzIiwiZmVhc2libGUiLCJyb3VuZCIsImVzdGltYXRlZFRpbWVNcyIsImVzdGltYXRlZFRpbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/run.ts\n");

/***/ }),

/***/ "(rsc)/./lib/analysis/scan.ts":
/*!******************************!*\
  !*** ./lib/analysis/scan.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fileHasDeprecatedPatterns: () => (/* binding */ fileHasDeprecatedPatterns),\n/* harmony export */   filterPatternFindingsByFile: () => (/* binding */ filterPatternFindingsByFile),\n/* harmony export */   filterPatternFindingsByLanguage: () => (/* binding */ filterPatternFindingsByLanguage),\n/* harmony export */   getDeprecatedPatternLines: () => (/* binding */ getDeprecatedPatternLines),\n/* harmony export */   getFilesWithDeprecatedPatterns: () => (/* binding */ getFilesWithDeprecatedPatterns),\n/* harmony export */   getMostCommonPatterns: () => (/* binding */ getMostCommonPatterns),\n/* harmony export */   getPatternFrequency: () => (/* binding */ getPatternFrequency),\n/* harmony export */   getPatternQuickFix: () => (/* binding */ getPatternQuickFix),\n/* harmony export */   getPatternSummary: () => (/* binding */ getPatternSummary),\n/* harmony export */   getUniquePatterns: () => (/* binding */ getUniquePatterns),\n/* harmony export */   groupPatternFindingsByFile: () => (/* binding */ groupPatternFindingsByFile),\n/* harmony export */   groupPatternFindingsByLanguage: () => (/* binding */ groupPatternFindingsByLanguage),\n/* harmony export */   scanSourceFiles: () => (/* binding */ scanSourceFiles),\n/* harmony export */   sortPatternFindings: () => (/* binding */ sortPatternFindings)\n/* harmony export */ });\n/* harmony import */ var _baseline_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./baseline.loader */ \"(rsc)/./lib/analysis/baseline.loader.ts\");\n\n/**\n * Scan source files for deprecated patterns\n * @param files Array of extracted files\n * @param rules Baseline rules\n * @returns Array of pattern findings\n */ function scanSourceFiles(files, rules) {\n    const findings = [];\n    for (const file of files){\n        // Skip files that are too large\n        if (file.size > rules.max_file_size) {\n            console.warn(`Skipping large file: ${file.path || file.name} (${file.size} bytes)`);\n            continue;\n        }\n        // Skip ignored paths\n        const filePath = file.path || file.name || 'unknown';\n        if ((0,_baseline_loader__WEBPACK_IMPORTED_MODULE_0__.shouldIgnorePath)(rules, filePath)) {\n            continue;\n        }\n        // Skip files that shouldn't be scanned\n        const extension = getFileExtension(filePath);\n        if (!(0,_baseline_loader__WEBPACK_IMPORTED_MODULE_0__.shouldScanFile)(rules, extension)) {\n            continue;\n        }\n        // Detect language from file extension\n        const language = detectLanguageFromExtension(extension);\n        if (!language) {\n            continue;\n        }\n        // Get deprecated patterns for this language\n        const patterns = rules.deprecated_patterns[language] || [];\n        if (patterns.length === 0) {\n            continue;\n        }\n        // Scan file content\n        const fileFindings = scanFileContent(file, language, patterns);\n        findings.push(...fileFindings);\n        // Add additional analysis for specific file types\n        if (language === 'node' && (extension === '.js' || extension === '.ts' || extension === '.jsx' || extension === '.tsx')) {\n            const jsFindings = analyzeJavaScriptPatterns(file, language);\n            findings.push(...jsFindings);\n        }\n        if (language === 'python' && extension === '.py') {\n            const pyFindings = analyzePythonPatterns(file, language);\n            findings.push(...pyFindings);\n        }\n    }\n    return findings;\n}\n/**\n * Scan a single file for deprecated patterns\n * @param file File to scan\n * @param language Language of the file\n * @param patterns Deprecated patterns to look for\n * @param rules Baseline rules\n * @returns Array of pattern findings\n */ function scanFileContent(file, language, patterns) {\n    const findings = [];\n    const lines = file.content.split('\\n');\n    const filePath = file.path || file.name || 'unknown';\n    for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n        const line = lines[lineIndex];\n        const lineNumber = lineIndex + 1;\n        // Skip empty lines and comments\n        if (isCommentLine(line, language) || line.trim() === '') {\n            continue;\n        }\n        // Check each pattern\n        for (const pattern of patterns){\n            try {\n                const regex = new RegExp(pattern.pattern, 'g');\n                let match;\n                while((match = regex.exec(line)) !== null){\n                    // Avoid infinite loops with zero-length matches\n                    if (match.index === regex.lastIndex) {\n                        regex.lastIndex++;\n                    }\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: filePath,\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'deprecated-api',\n                        issue: pattern.message,\n                        pattern: pattern.pattern,\n                        quickFix: pattern.alternative\n                    });\n                }\n            } catch (error) {\n                console.warn(`Invalid regex pattern: ${pattern.pattern} - ${error}`);\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Get file extension from path\n * @param filePath File path\n * @returns File extension with dot\n */ function getFileExtension(filePath) {\n    const lastDot = filePath.lastIndexOf('.');\n    if (lastDot === -1) return '';\n    return filePath.substring(lastDot);\n}\n/**\n * Detect language from file extension\n * @param extension File extension\n * @returns Language or null\n */ function detectLanguageFromExtension(extension) {\n    const languageMap = {\n        '.js': 'node',\n        '.jsx': 'node',\n        '.ts': 'node',\n        '.tsx': 'node',\n        '.py': 'python',\n        '.java': 'java',\n        '.go': 'go',\n        '.cs': 'dotnet',\n        '.fs': 'dotnet',\n        '.vb': 'dotnet'\n    };\n    return languageMap[extension] || null;\n}\n/**\n * Check if a line is a comment\n * @param line Line content\n * @param language Language context\n * @returns True if comment line\n */ function isCommentLine(line, language) {\n    const trimmed = line.trim();\n    switch(language){\n        case 'node':\n        case 'java':\n        case 'go':\n        case 'dotnet':\n            return trimmed.startsWith('//') || trimmed.startsWith('/*') || trimmed.startsWith('*');\n        case 'python':\n            return trimmed.startsWith('#');\n        default:\n            return false;\n    }\n}\n/**\n * Get quick fix for pattern replacement\n * @param rules Baseline rules\n * @param language Language\n * @param pattern Pattern to replace\n * @returns Quick fix suggestion or undefined\n */ function getPatternQuickFix(rules, language, pattern) {\n    return rules.quick_fixes.pattern_replacement[language]?.[pattern];\n}\n/**\n * Group pattern findings by file\n * @param findings Pattern findings\n * @returns Grouped findings by file\n */ function groupPatternFindingsByFile(findings) {\n    const grouped = {};\n    for (const finding of findings){\n        if (!grouped[finding.file]) {\n            grouped[finding.file] = [];\n        }\n        grouped[finding.file].push(finding);\n    }\n    return grouped;\n}\n/**\n * Group pattern findings by language\n * @param findings Pattern findings\n * @returns Grouped findings by language\n */ function groupPatternFindingsByLanguage(findings) {\n    const grouped = {\n        python: [],\n        node: [],\n        java: [],\n        go: [],\n        dotnet: []\n    };\n    for (const finding of findings){\n        if (!grouped[finding.lang]) {\n            grouped[finding.lang] = [];\n        }\n        grouped[finding.lang].push(finding);\n    }\n    return grouped;\n}\n/**\n * Get pattern summary statistics\n * @param findings Pattern findings\n * @returns Summary statistics\n */ function getPatternSummary(findings) {\n    const total = findings.length;\n    const byLanguage = groupPatternFindingsByLanguage(findings);\n    const byFile = groupPatternFindingsByFile(findings);\n    return {\n        total,\n        affectedFiles: Object.keys(byFile).length,\n        byLanguage: Object.fromEntries(Object.entries(byLanguage).map(([lang, findings])=>[\n                lang,\n                {\n                    count: findings.length,\n                    files: new Set(findings.map((f)=>f.file)).size\n                }\n            ]))\n    };\n}\n/**\n * Filter pattern findings by language\n * @param findings Pattern findings\n * @param language Language to filter by\n * @returns Filtered findings\n */ function filterPatternFindingsByLanguage(findings, language) {\n    return findings.filter((f)=>f.lang === language);\n}\n/**\n * Filter pattern findings by file\n * @param findings Pattern findings\n * @param filePath File path to filter by\n * @returns Filtered findings\n */ function filterPatternFindingsByFile(findings, filePath) {\n    return findings.filter((f)=>f.file === filePath);\n}\n/**\n * Sort pattern findings by file and line\n * @param findings Pattern findings\n * @returns Sorted findings\n */ function sortPatternFindings(findings) {\n    return [\n        ...findings\n    ].sort((a, b)=>{\n        // First by file path\n        const fileDiff = a.file.localeCompare(b.file);\n        if (fileDiff !== 0) return fileDiff;\n        // Then by line number\n        return a.line - b.line;\n    });\n}\n/**\n * Get unique patterns found\n * @param findings Pattern findings\n * @returns Array of unique patterns\n */ function getUniquePatterns(findings) {\n    const patterns = new Set();\n    for (const finding of findings){\n        patterns.add(finding.pattern);\n    }\n    return Array.from(patterns);\n}\n/**\n * Get pattern frequency\n * @param findings Pattern findings\n * @returns Pattern frequency map\n */ function getPatternFrequency(findings) {\n    const frequency = {};\n    for (const finding of findings){\n        frequency[finding.pattern] = (frequency[finding.pattern] || 0) + 1;\n    }\n    return frequency;\n}\n/**\n * Get most common patterns\n * @param findings Pattern findings\n * @param limit Maximum number of patterns to return\n * @returns Array of most common patterns\n */ function getMostCommonPatterns(findings, limit = 10) {\n    const frequency = getPatternFrequency(findings);\n    return Object.entries(frequency).map(([pattern, count])=>({\n            pattern,\n            count\n        })).sort((a, b)=>b.count - a.count).slice(0, limit);\n}\n/**\n * Check if a file contains any deprecated patterns\n * @param filePath File path\n * @param findings Pattern findings\n * @returns True if file has deprecated patterns\n */ function fileHasDeprecatedPatterns(filePath, findings) {\n    return findings.some((f)=>f.file === filePath);\n}\n/**\n * Get files with deprecated patterns\n * @param findings Pattern findings\n * @returns Array of file paths\n */ function getFilesWithDeprecatedPatterns(findings) {\n    const files = new Set();\n    for (const finding of findings){\n        files.add(finding.file);\n    }\n    return Array.from(files);\n}\n/**\n * Analyze JavaScript-specific patterns\n * @param file File to analyze\n * @param language Language context\n * @returns Array of pattern findings\n */ function analyzeJavaScriptPatterns(file, language) {\n    const findings = [];\n    const lines = file.content.split('\\n');\n    const filePath = file.path || file.name || 'unknown';\n    for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n        const line = lines[lineIndex];\n        const lineNumber = lineIndex + 1;\n        // Skip empty lines and comments\n        if (isCommentLine(line, language) || line.trim() === '') {\n            continue;\n        }\n        // Check for common JavaScript issues\n        const jsPatterns = [\n            {\n                pattern: /var\\s+\\w+/g,\n                message: \"var is deprecated, use let or const\",\n                alternative: \"Use let for variables that change, const for constants\"\n            },\n            {\n                pattern: /function\\s+\\w+\\s*\\(/g,\n                message: \"Function declarations are less preferred than arrow functions\",\n                alternative: \"Use arrow functions for better scope handling\"\n            },\n            {\n                pattern: /this\\.\\w+\\s*=/g,\n                message: \"Direct this assignment is discouraged\",\n                alternative: \"Use class properties or bind methods properly\"\n            },\n            {\n                pattern: /\\barguments\\b/g,\n                message: \"arguments object is deprecated, use rest parameters\",\n                alternative: \"Use ...args rest parameter syntax\"\n            },\n            {\n                pattern: /==\\s*\\w+|\\w+\\s*==/g,\n                message: \"== can cause type coercion issues\",\n                alternative: \"Use === for strict equality\"\n            },\n            {\n                pattern: /!=\\s*\\w+|\\w+\\s*!=/g,\n                message: \"!= can cause type coercion issues\",\n                alternative: \"Use !== for strict inequality\"\n            },\n            {\n                pattern: /typeof\\s+\\w+\\s*===\\s*['\"]undefined['\"]/g,\n                message: \"typeof undefined check is verbose\",\n                alternative: \"Use === undefined or optional chaining\"\n            },\n            {\n                pattern: /for\\s*\\(\\s*var\\s+/g,\n                message: \"var in for loops can cause scope issues\",\n                alternative: \"Use let in for loops\"\n            },\n            {\n                pattern: /with\\s*\\(/g,\n                message: \"with statement is deprecated and dangerous\",\n                alternative: \"Use explicit variable references\"\n            },\n            {\n                pattern: /eval\\s*\\(/g,\n                message: \"eval() is dangerous and should be avoided\",\n                alternative: \"Use safer alternatives or refactor code\"\n            },\n            {\n                pattern: /new\\s+Function\\s*\\(/g,\n                message: \"new Function() is dangerous\",\n                alternative: \"Use function declarations or arrow functions\"\n            },\n            {\n                pattern: /setTimeout\\s*\\(\\s*['\"]/g,\n                message: \"setTimeout with string is dangerous\",\n                alternative: \"Use function references instead of strings\"\n            },\n            {\n                pattern: /setInterval\\s*\\(\\s*['\"]/g,\n                message: \"setInterval with string is dangerous\",\n                alternative: \"Use function references instead of strings\"\n            },\n            {\n                pattern: /setImmediate\\s*\\(\\s*['\"]/g,\n                message: \"setImmediate with string is dangerous\",\n                alternative: \"Use function references instead of strings\"\n            },\n            {\n                pattern: /process\\.nextTick\\s*\\(\\s*['\"]/g,\n                message: \"process.nextTick with string is dangerous\",\n                alternative: \"Use function references instead of strings\"\n            },\n            {\n                pattern: /require\\s*\\(\\s*['\"]/g,\n                message: \"Dynamic require() can be dangerous\",\n                alternative: \"Use static imports or proper module loading\"\n            },\n            {\n                pattern: /import\\s*\\(\\s*['\"]/g,\n                message: \"Dynamic import() can be dangerous\",\n                alternative: \"Use static imports or proper module loading\"\n            },\n            {\n                pattern: /new\\s+RegExp\\s*\\(\\s*['\"]/g,\n                message: \"new RegExp() with user input is dangerous\",\n                alternative: \"Use literal regex or sanitize input\"\n            },\n            {\n                pattern: /RegExp\\s*\\(\\s*['\"]/g,\n                message: \"RegExp() with user input is dangerous\",\n                alternative: \"Use literal regex or sanitize input\"\n            },\n            {\n                pattern: /JSON\\.parse\\s*\\(\\s*['\"]/g,\n                message: \"JSON.parse() with untrusted data is dangerous\",\n                alternative: \"Validate and sanitize input before parsing\"\n            },\n            {\n                pattern: /JSON\\.stringify\\s*\\(/g,\n                message: \"JSON.stringify() can expose sensitive data\",\n                alternative: \"Filter sensitive properties before stringifying\"\n            },\n            {\n                pattern: /XMLHttpRequest/g,\n                message: \"XMLHttpRequest is deprecated, use fetch()\",\n                alternative: \"Use fetch() API or axios library\"\n            },\n            {\n                pattern: /ActiveXObject/g,\n                message: \"ActiveXObject is deprecated and insecure\",\n                alternative: \"Use modern alternatives\"\n            },\n            {\n                pattern: /attachEvent/g,\n                message: \"attachEvent is deprecated, use addEventListener\",\n                alternative: \"Use addEventListener() method\"\n            },\n            {\n                pattern: /detachEvent/g,\n                message: \"detachEvent is deprecated, use removeEventListener\",\n                alternative: \"Use removeEventListener() method\"\n            },\n            {\n                pattern: /document\\.write\\s*\\(/g,\n                message: \"document.write() is deprecated and dangerous\",\n                alternative: \"Use DOM manipulation methods\"\n            },\n            {\n                pattern: /innerHTML\\s*=/g,\n                message: \"innerHTML assignment can be dangerous\",\n                alternative: \"Use textContent or proper DOM methods\"\n            },\n            {\n                pattern: /outerHTML\\s*=/g,\n                message: \"outerHTML assignment can be dangerous\",\n                alternative: \"Use proper DOM manipulation methods\"\n            },\n            {\n                pattern: /alert\\s*\\(/g,\n                message: \"alert() should not be used in production\",\n                alternative: \"Use proper user interface components or logging\"\n            },\n            {\n                pattern: /confirm\\s*\\(/g,\n                message: \"confirm() should not be used in production\",\n                alternative: \"Use proper user interface components\"\n            },\n            {\n                pattern: /prompt\\s*\\(/g,\n                message: \"prompt() should not be used in production\",\n                alternative: \"Use proper user interface components\"\n            },\n            {\n                pattern: /debugger\\b/g,\n                message: \"debugger statement should be removed in production\",\n                alternative: \"Remove debugger statements or use proper debugging tools\"\n            },\n            {\n                pattern: /console\\.(log|warn|error|info|debug|trace|dir|table|time|timeEnd|count|countReset|group|groupEnd|groupCollapsed|assert|clear|profile|profileEnd|timeStamp|markTimeline|timeline|timelineEnd|memory|exception)\\s*\\(/g,\n                message: \"console methods should be removed in production\",\n                alternative: \"Use proper logging library or remove debug statements\"\n            }\n        ];\n        for (const pattern of jsPatterns){\n            try {\n                const regex = new RegExp(pattern.pattern.source, 'g');\n                let match;\n                while((match = regex.exec(line)) !== null){\n                    // Avoid infinite loops with zero-length matches\n                    if (match.index === regex.lastIndex) {\n                        regex.lastIndex++;\n                    }\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: filePath,\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'deprecated-api',\n                        issue: pattern.message,\n                        pattern: pattern.pattern.source,\n                        quickFix: pattern.alternative\n                    });\n                }\n            } catch (error) {\n                console.warn(`Invalid regex pattern: ${pattern.pattern} - ${error}`);\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Analyze Python-specific patterns\n * @param file File to analyze\n * @param language Language context\n * @returns Array of pattern findings\n */ function analyzePythonPatterns(file, language) {\n    const findings = [];\n    const lines = file.content.split('\\n');\n    const filePath = file.path || file.name || 'unknown';\n    for(let lineIndex = 0; lineIndex < lines.length; lineIndex++){\n        const line = lines[lineIndex];\n        const lineNumber = lineIndex + 1;\n        // Skip empty lines and comments\n        if (isCommentLine(line, language) || line.trim() === '') {\n            continue;\n        }\n        // Check for common Python issues\n        const pyPatterns = [\n            {\n                pattern: /urllib2\\.|urllib\\.request/g,\n                message: \"urllib2 is deprecated in Python 3, use urllib.request\",\n                alternative: \"Use urllib.request or requests library\"\n            },\n            {\n                pattern: /execfile\\s*\\(/g,\n                message: \"execfile() is deprecated in Python 3\",\n                alternative: \"Use exec(open(filename).read())\"\n            },\n            {\n                pattern: /reload\\s*\\(/g,\n                message: \"reload() is deprecated, use importlib.reload()\",\n                alternative: \"Use importlib.reload(module)\"\n            },\n            {\n                pattern: /file\\s*\\(/g,\n                message: \"file() is deprecated, use open()\",\n                alternative: \"Use open() function instead\"\n            },\n            {\n                pattern: /raw_input\\s*\\(/g,\n                message: \"raw_input() is deprecated in Python 3, use input()\",\n                alternative: \"Use input() function\"\n            },\n            {\n                pattern: /xrange\\s*\\(/g,\n                message: \"xrange() is deprecated in Python 3, use range()\",\n                alternative: \"Use range() function\"\n            },\n            {\n                pattern: /basestring/g,\n                message: \"basestring is deprecated in Python 3\",\n                alternative: \"Use str or bytes directly\"\n            },\n            {\n                pattern: /unicode\\s*\\(/g,\n                message: \"unicode() is deprecated in Python 3\",\n                alternative: \"Use str() function\"\n            },\n            {\n                pattern: /long\\s*\\(/g,\n                message: \"long() is deprecated in Python 3\",\n                alternative: \"Use int() function\"\n            },\n            {\n                pattern: /cmp\\s*\\(/g,\n                message: \"cmp() is deprecated in Python 3\",\n                alternative: \"Use (a > b) - (a < b) or operator functions\"\n            },\n            {\n                pattern: /reduce\\s*\\(/g,\n                message: \"reduce() is deprecated, use functools.reduce()\",\n                alternative: \"Import and use functools.reduce()\"\n            },\n            {\n                pattern: /apply\\s*\\(/g,\n                message: \"apply() is deprecated in Python 3\",\n                alternative: \"Use function(*args, **kwargs) syntax\"\n            },\n            {\n                pattern: /coerce\\s*\\(/g,\n                message: \"coerce() is deprecated in Python 3\",\n                alternative: \"Use explicit type conversion\"\n            },\n            {\n                pattern: /intern\\s*\\(/g,\n                message: \"intern() is deprecated in Python 3\",\n                alternative: \"Use sys.intern() if needed\"\n            },\n            {\n                pattern: /unichr\\s*\\(/g,\n                message: \"unichr() is deprecated in Python 3\",\n                alternative: \"Use chr() function\"\n            },\n            {\n                pattern: /buffer\\s*\\(/g,\n                message: \"buffer() is deprecated in Python 3\",\n                alternative: \"Use memoryview() or bytes()\"\n            },\n            {\n                pattern: /StandardError/g,\n                message: \"StandardError is deprecated in Python 3\",\n                alternative: \"Use Exception or specific exception types\"\n            },\n            {\n                pattern: /exec\\s+\\w+\\s+in\\s+\\w+/g,\n                message: \"exec with 'in' syntax is deprecated\",\n                alternative: \"Use exec(code, globals, locals) syntax\"\n            },\n            {\n                pattern: /print\\s+\\w+/g,\n                message: \"print statement is deprecated in Python 3\",\n                alternative: \"Use print() function\"\n            },\n            {\n                pattern: /raise\\s+\\w+,\\s+\\w+/g,\n                message: \"raise with comma syntax is deprecated\",\n                alternative: \"Use raise Exception('message') syntax\"\n            },\n            {\n                pattern: /except\\s+\\w+,\\s+\\w+/g,\n                message: \"except with comma syntax is deprecated\",\n                alternative: \"Use except Exception as e: syntax\"\n            },\n            {\n                pattern: /def\\s+\\w+\\s*\\([^)]*\\):/g,\n                message: \"Check for Python 2 style function definitions\",\n                alternative: \"Ensure Python 3 compatibility\"\n            },\n            {\n                pattern: /from\\s+\\w+\\s+import\\s+\\*/g,\n                message: \"Wildcard imports are discouraged\",\n                alternative: \"Import specific functions or use qualified names\"\n            },\n            {\n                pattern: /eval\\s*\\(/g,\n                message: \"eval() is dangerous and should be avoided\",\n                alternative: \"Use safer alternatives like ast.literal_eval()\"\n            },\n            {\n                pattern: /exec\\s*\\(/g,\n                message: \"exec() is dangerous and should be avoided\",\n                alternative: \"Use safer alternatives or refactor code\"\n            },\n            {\n                pattern: /subprocess\\.call.*shell=True/g,\n                message: \"shell=True in subprocess is dangerous\",\n                alternative: \"Use shell=False and pass arguments as list\"\n            },\n            {\n                pattern: /os\\.system\\s*\\(/g,\n                message: \"os.system() is deprecated, use subprocess\",\n                alternative: \"Use subprocess.run() or subprocess.Popen()\"\n            },\n            {\n                pattern: /pickle\\.loads\\s*\\(/g,\n                message: \"pickle.loads() is unsafe with untrusted data\",\n                alternative: \"Use json.loads() or other safe serialization\"\n            },\n            {\n                pattern: /pickle\\.load\\s*\\(/g,\n                message: \"pickle.load() is unsafe with untrusted data\",\n                alternative: \"Use json.load() or other safe serialization\"\n            },\n            {\n                pattern: /md5\\.|sha1\\./g,\n                message: \"MD5 and SHA1 are cryptographically broken\",\n                alternative: \"Use hashlib.sha256() or hashlib.sha3_256()\"\n            },\n            {\n                pattern: /random\\.random\\s*\\(/g,\n                message: \"random.random() is not cryptographically secure\",\n                alternative: \"Use secrets module for cryptographic randomness\"\n            },\n            {\n                pattern: /time\\.time\\s*\\(/g,\n                message: \"time.time() is not suitable for timing attacks\",\n                alternative: \"Use time.perf_counter() for timing\"\n            },\n            {\n                pattern: /class\\s+\\w+.*:/g,\n                message: \"Check for old-style class definitions\",\n                alternative: \"Ensure all classes inherit from object or use new-style classes\"\n            },\n            {\n                pattern: /def\\s+\\w+\\s*\\(self,\\s*[^)]*\\):/g,\n                message: \"Check for Python 2 style method definitions\",\n                alternative: \"Ensure Python 3 compatibility\"\n            },\n            {\n                pattern: /import\\s+\\w+\\s*$/g,\n                message: \"Check for Python 2 style imports\",\n                alternative: \"Ensure Python 3 compatibility\"\n            }\n        ];\n        for (const pattern of pyPatterns){\n            try {\n                const regex = new RegExp(pattern.pattern.source, 'g');\n                let match;\n                while((match = regex.exec(line)) !== null){\n                    // Avoid infinite loops with zero-length matches\n                    if (match.index === regex.lastIndex) {\n                        regex.lastIndex++;\n                    }\n                    findings.push({\n                        kind: 'pattern',\n                        lang: language,\n                        file: filePath,\n                        line: lineNumber,\n                        status: 'affected',\n                        reason: 'deprecated-api',\n                        issue: pattern.message,\n                        pattern: pattern.pattern.source,\n                        quickFix: pattern.alternative\n                    });\n                }\n            } catch (error) {\n                console.warn(`Invalid regex pattern: ${pattern.pattern} - ${error}`);\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Get line numbers with deprecated patterns for a file\n * @param filePath File path\n * @param findings Pattern findings\n * @returns Array of line numbers\n */ function getDeprecatedPatternLines(filePath, findings) {\n    return findings.filter((f)=>f.file === filePath).map((f)=>f.line).sort((a, b)=>a - b);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFD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Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VkLFNBQVM7Z0JBQ1RZLFNBQVM7Z0JBQ1RFLGFBQWE7WUFDZjtZQUNBO2dCQUNFZCxTQUFTO2dCQUNUWSxTQUFTO2dCQUNURSxhQUFhO1lBQ2Y7WUFDQTtnQkFDRWQsU0FBUztnQkFDVFksU0FBUztnQkFDVEUsYUFBYTtZQUNmO1NBQ0Q7UUFFRCxLQUFLLE1BQU1kLFdBQVdzRSxXQUFZO1lBQ2hDLElBQUk7Z0JBQ0YsTUFBTXJFLFFBQVEsSUFBSUMsT0FBT0YsUUFBUUEsT0FBTyxDQUFDcUUsTUFBTSxFQUFFO2dCQUNqRCxJQUFJbEU7Z0JBRUosTUFBTyxDQUFDQSxRQUFRRixNQUFNRyxJQUFJLENBQUNSLEtBQUksTUFBTyxLQUFNO29CQUMxQyxnREFBZ0Q7b0JBQ2hELElBQUlPLE1BQU1FLEtBQUssS0FBS0osTUFBTUssU0FBUyxFQUFFO3dCQUNuQ0wsTUFBTUssU0FBUztvQkFDakI7b0JBRUFyQyxTQUFTa0IsSUFBSSxDQUFDO3dCQUNab0IsTUFBTTt3QkFDTkMsTUFBTTVCO3dCQUNOVixNQUFNTzt3QkFDTm1CLE1BQU1DO3dCQUNOWSxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxPQUFPWCxRQUFRWSxPQUFPO3dCQUN0QlosU0FBU0EsUUFBUUEsT0FBTyxDQUFDcUUsTUFBTTt3QkFDL0J4RCxVQUFVYixRQUFRYyxXQUFXO29CQUMvQjtnQkFDRjtZQUNGLEVBQUUsT0FBT0MsT0FBTztnQkFDZDFDLFFBQVFDLElBQUksQ0FBQyxDQUFDLHVCQUF1QixFQUFFMEIsUUFBUUEsT0FBTyxDQUFDLEdBQUcsRUFBRWUsT0FBTztZQUNyRTtRQUNGO0lBQ0Y7SUFFQSxPQUFPOUM7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU3NHLDBCQUNkOUYsUUFBZ0IsRUFDaEJSLFFBQTBCO0lBRTFCLE9BQU9BLFNBQ0orRSxNQUFNLENBQUNGLENBQUFBLElBQUtBLEVBQUU1RSxJQUFJLEtBQUtPLFVBQ3ZCa0UsR0FBRyxDQUFDRyxDQUFBQSxJQUFLQSxFQUFFbEQsSUFBSSxFQUNmdUQsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDO0FBQ3hCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXENraGFkYXJcXERvd25sb2Fkc1xcQUlfQmFzZWxpbmVfTWFwXFxsaWJcXGFuYWx5c2lzXFxzY2FuLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExhbmd1YWdlLCBQYXR0ZXJuRmluZGluZywgQmFzZWxpbmVSdWxlcyB9IGZyb20gJy4vYmFzZWxpbmUudHlwZXMnO1xuaW1wb3J0IHsgc2hvdWxkU2NhbkZpbGUsIHNob3VsZElnbm9yZVBhdGggfSBmcm9tICcuL2Jhc2VsaW5lLmxvYWRlcic7XG5cbi8qKlxuICogU2NhbiBzb3VyY2UgZmlsZXMgZm9yIGRlcHJlY2F0ZWQgcGF0dGVybnNcbiAqIEBwYXJhbSBmaWxlcyBBcnJheSBvZiBleHRyYWN0ZWQgZmlsZXNcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xuICogQHJldHVybnMgQXJyYXkgb2YgcGF0dGVybiBmaW5kaW5nc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhblNvdXJjZUZpbGVzKFxuICBmaWxlczogQXJyYXk8eyBwYXRoPzogc3RyaW5nOyBuYW1lPzogc3RyaW5nOyBjb250ZW50OiBzdHJpbmc7IHNpemU6IG51bWJlciB9PixcbiAgcnVsZXM6IEJhc2VsaW5lUnVsZXNcbik6IFBhdHRlcm5GaW5kaW5nW10ge1xuICBjb25zdCBmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSA9IFtdO1xuICBcbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgLy8gU2tpcCBmaWxlcyB0aGF0IGFyZSB0b28gbGFyZ2VcbiAgICBpZiAoZmlsZS5zaXplID4gcnVsZXMubWF4X2ZpbGVfc2l6ZSkge1xuICAgICAgY29uc29sZS53YXJuKGBTa2lwcGluZyBsYXJnZSBmaWxlOiAke2ZpbGUucGF0aCB8fCBmaWxlLm5hbWV9ICgke2ZpbGUuc2l6ZX0gYnl0ZXMpYCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2tpcCBpZ25vcmVkIHBhdGhzXG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGggfHwgZmlsZS5uYW1lIHx8ICd1bmtub3duJztcbiAgICBpZiAoc2hvdWxkSWdub3JlUGF0aChydWxlcywgZmlsZVBhdGgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2tpcCBmaWxlcyB0aGF0IHNob3VsZG4ndCBiZSBzY2FubmVkXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RmlsZUV4dGVuc2lvbihmaWxlUGF0aCk7XG4gICAgaWYgKCFzaG91bGRTY2FuRmlsZShydWxlcywgZXh0ZW5zaW9uKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIFxuICAgIC8vIERldGVjdCBsYW5ndWFnZSBmcm9tIGZpbGUgZXh0ZW5zaW9uXG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKTtcbiAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IGRlcHJlY2F0ZWQgcGF0dGVybnMgZm9yIHRoaXMgbGFuZ3VhZ2VcbiAgICBjb25zdCBwYXR0ZXJucyA9IHJ1bGVzLmRlcHJlY2F0ZWRfcGF0dGVybnNbbGFuZ3VhZ2VdIHx8IFtdO1xuICAgIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBTY2FuIGZpbGUgY29udGVudFxuICAgIGNvbnN0IGZpbGVGaW5kaW5ncyA9IHNjYW5GaWxlQ29udGVudChmaWxlLCBsYW5ndWFnZSwgcGF0dGVybnMpO1xuICAgIGZpbmRpbmdzLnB1c2goLi4uZmlsZUZpbmRpbmdzKTtcbiAgICBcbiAgICAvLyBBZGQgYWRkaXRpb25hbCBhbmFseXNpcyBmb3Igc3BlY2lmaWMgZmlsZSB0eXBlc1xuICAgIGlmIChsYW5ndWFnZSA9PT0gJ25vZGUnICYmIChleHRlbnNpb24gPT09ICcuanMnIHx8IGV4dGVuc2lvbiA9PT0gJy50cycgfHwgZXh0ZW5zaW9uID09PSAnLmpzeCcgfHwgZXh0ZW5zaW9uID09PSAnLnRzeCcpKSB7XG4gICAgICBjb25zdCBqc0ZpbmRpbmdzID0gYW5hbHl6ZUphdmFTY3JpcHRQYXR0ZXJucyhmaWxlLCBsYW5ndWFnZSk7XG4gICAgICBmaW5kaW5ncy5wdXNoKC4uLmpzRmluZGluZ3MpO1xuICAgIH1cbiAgICBcbiAgICBpZiAobGFuZ3VhZ2UgPT09ICdweXRob24nICYmIGV4dGVuc2lvbiA9PT0gJy5weScpIHtcbiAgICAgIGNvbnN0IHB5RmluZGluZ3MgPSBhbmFseXplUHl0aG9uUGF0dGVybnMoZmlsZSwgbGFuZ3VhZ2UpO1xuICAgICAgZmluZGluZ3MucHVzaCguLi5weUZpbmRpbmdzKTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBmaW5kaW5ncztcbn1cblxuLyoqXG4gKiBTY2FuIGEgc2luZ2xlIGZpbGUgZm9yIGRlcHJlY2F0ZWQgcGF0dGVybnNcbiAqIEBwYXJhbSBmaWxlIEZpbGUgdG8gc2NhblxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0gcGF0dGVybnMgRGVwcmVjYXRlZCBwYXR0ZXJucyB0byBsb29rIGZvclxuICogQHBhcmFtIHJ1bGVzIEJhc2VsaW5lIHJ1bGVzXG4gKiBAcmV0dXJucyBBcnJheSBvZiBwYXR0ZXJuIGZpbmRpbmdzXG4gKi9cbmZ1bmN0aW9uIHNjYW5GaWxlQ29udGVudChcbiAgZmlsZTogeyBwYXRoPzogc3RyaW5nOyBuYW1lPzogc3RyaW5nOyBjb250ZW50OiBzdHJpbmcgfSxcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlLFxuICBwYXR0ZXJuczogQXJyYXk8eyBwYXR0ZXJuOiBzdHJpbmc7IG1lc3NhZ2U6IHN0cmluZzsgYWx0ZXJuYXRpdmU6IHN0cmluZyB9PlxuKTogUGF0dGVybkZpbmRpbmdbXSB7XG4gIGNvbnN0IGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdID0gW107XG4gIGNvbnN0IGxpbmVzID0gZmlsZS5jb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGggfHwgZmlsZS5uYW1lIHx8ICd1bmtub3duJztcbiAgXG4gIGZvciAobGV0IGxpbmVJbmRleCA9IDA7IGxpbmVJbmRleCA8IGxpbmVzLmxlbmd0aDsgbGluZUluZGV4KyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbbGluZUluZGV4XTtcbiAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcbiAgICBcbiAgICAvLyBTa2lwIGVtcHR5IGxpbmVzIGFuZCBjb21tZW50c1xuICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBlYWNoIHBhdHRlcm5cbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnBhdHRlcm4sICdnJyk7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIEF2b2lkIGluZmluaXRlIGxvb3BzIHdpdGggemVyby1sZW5ndGggbWF0Y2hlc1xuICAgICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gcmVnZXgubGFzdEluZGV4KSB7XG4gICAgICAgICAgICByZWdleC5sYXN0SW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ3BhdHRlcm4nLFxuICAgICAgICAgICAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ2FmZmVjdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiAnZGVwcmVjYXRlZC1hcGknLFxuICAgICAgICAgICAgICAgICAgICBpc3N1ZTogcGF0dGVybi5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIHF1aWNrRml4OiBwYXR0ZXJuLmFsdGVybmF0aXZlLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCByZWdleCBwYXR0ZXJuOiAke3BhdHRlcm4ucGF0dGVybn0gLSAke2Vycm9yfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGZpbmRpbmdzO1xufVxuXG4vKipcbiAqIEdldCBmaWxlIGV4dGVuc2lvbiBmcm9tIHBhdGhcbiAqIEBwYXJhbSBmaWxlUGF0aCBGaWxlIHBhdGhcbiAqIEByZXR1cm5zIEZpbGUgZXh0ZW5zaW9uIHdpdGggZG90XG4gKi9cbmZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGxhc3REb3QgPSBmaWxlUGF0aC5sYXN0SW5kZXhPZignLicpO1xuICBpZiAobGFzdERvdCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIGZpbGVQYXRoLnN1YnN0cmluZyhsYXN0RG90KTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgbGFuZ3VhZ2UgZnJvbSBmaWxlIGV4dGVuc2lvblxuICogQHBhcmFtIGV4dGVuc2lvbiBGaWxlIGV4dGVuc2lvblxuICogQHJldHVybnMgTGFuZ3VhZ2Ugb3IgbnVsbFxuICovXG5mdW5jdGlvbiBkZXRlY3RMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uOiBzdHJpbmcpOiBMYW5ndWFnZSB8IG51bGwge1xuICBjb25zdCBsYW5ndWFnZU1hcDogUmVjb3JkPHN0cmluZywgTGFuZ3VhZ2U+ID0ge1xuICAgICcuanMnOiAnbm9kZScsXG4gICAgJy5qc3gnOiAnbm9kZScsXG4gICAgJy50cyc6ICdub2RlJyxcbiAgICAnLnRzeCc6ICdub2RlJyxcbiAgICAnLnB5JzogJ3B5dGhvbicsXG4gICAgJy5qYXZhJzogJ2phdmEnLFxuICAgICcuZ28nOiAnZ28nLFxuICAgICcuY3MnOiAnZG90bmV0JyxcbiAgICAnLmZzJzogJ2RvdG5ldCcsXG4gICAgJy52Yic6ICdkb3RuZXQnLFxuICB9O1xuICBcbiAgcmV0dXJuIGxhbmd1YWdlTWFwW2V4dGVuc2lvbl0gfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGxpbmUgaXMgYSBjb21tZW50XG4gKiBAcGFyYW0gbGluZSBMaW5lIGNvbnRlbnRcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XG4gKiBAcmV0dXJucyBUcnVlIGlmIGNvbW1lbnQgbGluZVxuICovXG5mdW5jdGlvbiBpc0NvbW1lbnRMaW5lKGxpbmU6IHN0cmluZywgbGFuZ3VhZ2U6IExhbmd1YWdlKTogYm9vbGVhbiB7XG4gIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgXG4gIHN3aXRjaCAobGFuZ3VhZ2UpIHtcbiAgICBjYXNlICdub2RlJzpcbiAgICBjYXNlICdqYXZhJzpcbiAgICBjYXNlICdnbyc6XG4gICAgY2FzZSAnZG90bmV0JzpcbiAgICAgIHJldHVybiB0cmltbWVkLnN0YXJ0c1dpdGgoJy8vJykgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCcvKicpIHx8IHRyaW1tZWQuc3RhcnRzV2l0aCgnKicpO1xuICAgIFxuICAgIGNhc2UgJ3B5dGhvbic6XG4gICAgICByZXR1cm4gdHJpbW1lZC5zdGFydHNXaXRoKCcjJyk7XG4gICAgXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBxdWljayBmaXggZm9yIHBhdHRlcm4gcmVwbGFjZW1lbnRcbiAqIEBwYXJhbSBydWxlcyBCYXNlbGluZSBydWxlc1xuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXG4gKiBAcGFyYW0gcGF0dGVybiBQYXR0ZXJuIHRvIHJlcGxhY2VcbiAqIEByZXR1cm5zIFF1aWNrIGZpeCBzdWdnZXN0aW9uIG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0dGVyblF1aWNrRml4KFxuICBydWxlczogQmFzZWxpbmVSdWxlcyxcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlLFxuICBwYXR0ZXJuOiBzdHJpbmdcbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBydWxlcy5xdWlja19maXhlcy5wYXR0ZXJuX3JlcGxhY2VtZW50W2xhbmd1YWdlXT8uW3BhdHRlcm5dO1xufVxuXG4vKipcbiAqIEdyb3VwIHBhdHRlcm4gZmluZGluZ3MgYnkgZmlsZVxuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcbiAqIEByZXR1cm5zIEdyb3VwZWQgZmluZGluZ3MgYnkgZmlsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBQYXR0ZXJuRmluZGluZ3NCeUZpbGUoZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10pOiBSZWNvcmQ8c3RyaW5nLCBQYXR0ZXJuRmluZGluZ1tdPiB7XG4gIGNvbnN0IGdyb3VwZWQ6IFJlY29yZDxzdHJpbmcsIFBhdHRlcm5GaW5kaW5nW10+ID0ge307XG4gIFxuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgZmluZGluZ3MpIHtcbiAgICBpZiAoIWdyb3VwZWRbZmluZGluZy5maWxlXSkge1xuICAgICAgZ3JvdXBlZFtmaW5kaW5nLmZpbGVdID0gW107XG4gICAgfVxuICAgIGdyb3VwZWRbZmluZGluZy5maWxlXS5wdXNoKGZpbmRpbmcpO1xuICB9XG4gIFxuICByZXR1cm4gZ3JvdXBlZDtcbn1cblxuLyoqXG4gKiBHcm91cCBwYXR0ZXJuIGZpbmRpbmdzIGJ5IGxhbmd1YWdlXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHJldHVybnMgR3JvdXBlZCBmaW5kaW5ncyBieSBsYW5ndWFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBQYXR0ZXJuRmluZGluZ3NCeUxhbmd1YWdlKGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdKTogUmVjb3JkPExhbmd1YWdlLCBQYXR0ZXJuRmluZGluZ1tdPiB7XG4gIGNvbnN0IGdyb3VwZWQ6IFJlY29yZDxMYW5ndWFnZSwgUGF0dGVybkZpbmRpbmdbXT4gPSB7XG4gICAgcHl0aG9uOiBbXSxcbiAgICBub2RlOiBbXSxcbiAgICBqYXZhOiBbXSxcbiAgICBnbzogW10sXG4gICAgZG90bmV0OiBbXVxuICB9O1xuICBcbiAgZm9yIChjb25zdCBmaW5kaW5nIG9mIGZpbmRpbmdzKSB7XG4gICAgaWYgKCFncm91cGVkW2ZpbmRpbmcubGFuZ10pIHtcbiAgICAgIGdyb3VwZWRbZmluZGluZy5sYW5nXSA9IFtdO1xuICAgIH1cbiAgICBncm91cGVkW2ZpbmRpbmcubGFuZ10ucHVzaChmaW5kaW5nKTtcbiAgfVxuICBcbiAgcmV0dXJuIGdyb3VwZWQ7XG59XG5cbi8qKlxuICogR2V0IHBhdHRlcm4gc3VtbWFyeSBzdGF0aXN0aWNzXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHJldHVybnMgU3VtbWFyeSBzdGF0aXN0aWNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXR0ZXJuU3VtbWFyeShmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSkge1xuICBjb25zdCB0b3RhbCA9IGZpbmRpbmdzLmxlbmd0aDtcbiAgY29uc3QgYnlMYW5ndWFnZSA9IGdyb3VwUGF0dGVybkZpbmRpbmdzQnlMYW5ndWFnZShmaW5kaW5ncyk7XG4gIGNvbnN0IGJ5RmlsZSA9IGdyb3VwUGF0dGVybkZpbmRpbmdzQnlGaWxlKGZpbmRpbmdzKTtcbiAgXG4gIHJldHVybiB7XG4gICAgdG90YWwsXG4gICAgYWZmZWN0ZWRGaWxlczogT2JqZWN0LmtleXMoYnlGaWxlKS5sZW5ndGgsXG4gICAgYnlMYW5ndWFnZTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMoYnlMYW5ndWFnZSkubWFwKChbbGFuZywgZmluZGluZ3NdKSA9PiBbXG4gICAgICAgIGxhbmcsXG4gICAgICAgIHtcbiAgICAgICAgICBjb3VudDogZmluZGluZ3MubGVuZ3RoLFxuICAgICAgICAgIGZpbGVzOiBuZXcgU2V0KGZpbmRpbmdzLm1hcChmID0+IGYuZmlsZSkpLnNpemUsXG4gICAgICAgIH0sXG4gICAgICBdKVxuICAgICksXG4gIH07XG59XG5cbi8qKlxuICogRmlsdGVyIHBhdHRlcm4gZmluZGluZ3MgYnkgbGFuZ3VhZ2VcbiAqIEBwYXJhbSBmaW5kaW5ncyBQYXR0ZXJuIGZpbmRpbmdzXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgTGFuZ3VhZ2UgdG8gZmlsdGVyIGJ5XG4gKiBAcmV0dXJucyBGaWx0ZXJlZCBmaW5kaW5nc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUGF0dGVybkZpbmRpbmdzQnlMYW5ndWFnZShcbiAgZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10sXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxuKTogUGF0dGVybkZpbmRpbmdbXSB7XG4gIHJldHVybiBmaW5kaW5ncy5maWx0ZXIoZiA9PiBmLmxhbmcgPT09IGxhbmd1YWdlKTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgcGF0dGVybiBmaW5kaW5ncyBieSBmaWxlXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aCB0byBmaWx0ZXIgYnlcbiAqIEByZXR1cm5zIEZpbHRlcmVkIGZpbmRpbmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJQYXR0ZXJuRmluZGluZ3NCeUZpbGUoXG4gIGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdLFxuICBmaWxlUGF0aDogc3RyaW5nXG4pOiBQYXR0ZXJuRmluZGluZ1tdIHtcbiAgcmV0dXJuIGZpbmRpbmdzLmZpbHRlcihmID0+IGYuZmlsZSA9PT0gZmlsZVBhdGgpO1xufVxuXG4vKipcbiAqIFNvcnQgcGF0dGVybiBmaW5kaW5ncyBieSBmaWxlIGFuZCBsaW5lXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHJldHVybnMgU29ydGVkIGZpbmRpbmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0UGF0dGVybkZpbmRpbmdzKGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdKTogUGF0dGVybkZpbmRpbmdbXSB7XG4gIHJldHVybiBbLi4uZmluZGluZ3NdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAvLyBGaXJzdCBieSBmaWxlIHBhdGhcbiAgICBjb25zdCBmaWxlRGlmZiA9IGEuZmlsZS5sb2NhbGVDb21wYXJlKGIuZmlsZSk7XG4gICAgaWYgKGZpbGVEaWZmICE9PSAwKSByZXR1cm4gZmlsZURpZmY7XG4gICAgXG4gICAgLy8gVGhlbiBieSBsaW5lIG51bWJlclxuICAgIHJldHVybiBhLmxpbmUgLSBiLmxpbmU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB1bmlxdWUgcGF0dGVybnMgZm91bmRcbiAqIEBwYXJhbSBmaW5kaW5ncyBQYXR0ZXJuIGZpbmRpbmdzXG4gKiBAcmV0dXJucyBBcnJheSBvZiB1bmlxdWUgcGF0dGVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXF1ZVBhdHRlcm5zKGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdKTogc3RyaW5nW10ge1xuICBjb25zdCBwYXR0ZXJucyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBcbiAgZm9yIChjb25zdCBmaW5kaW5nIG9mIGZpbmRpbmdzKSB7XG4gICAgcGF0dGVybnMuYWRkKGZpbmRpbmcucGF0dGVybik7XG4gIH1cbiAgXG4gIHJldHVybiBBcnJheS5mcm9tKHBhdHRlcm5zKTtcbn1cblxuLyoqXG4gKiBHZXQgcGF0dGVybiBmcmVxdWVuY3lcbiAqIEBwYXJhbSBmaW5kaW5ncyBQYXR0ZXJuIGZpbmRpbmdzXG4gKiBAcmV0dXJucyBQYXR0ZXJuIGZyZXF1ZW5jeSBtYXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdHRlcm5GcmVxdWVuY3koZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10pOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHtcbiAgY29uc3QgZnJlcXVlbmN5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIFxuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgZmluZGluZ3MpIHtcbiAgICBmcmVxdWVuY3lbZmluZGluZy5wYXR0ZXJuXSA9IChmcmVxdWVuY3lbZmluZGluZy5wYXR0ZXJuXSB8fCAwKSArIDE7XG4gIH1cbiAgXG4gIHJldHVybiBmcmVxdWVuY3k7XG59XG5cbi8qKlxuICogR2V0IG1vc3QgY29tbW9uIHBhdHRlcm5zXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHBhcmFtIGxpbWl0IE1heGltdW0gbnVtYmVyIG9mIHBhdHRlcm5zIHRvIHJldHVyblxuICogQHJldHVybnMgQXJyYXkgb2YgbW9zdCBjb21tb24gcGF0dGVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1vc3RDb21tb25QYXR0ZXJucyhcbiAgZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW10sXG4gIGxpbWl0OiBudW1iZXIgPSAxMFxuKTogQXJyYXk8eyBwYXR0ZXJuOiBzdHJpbmc7IGNvdW50OiBudW1iZXIgfT4ge1xuICBjb25zdCBmcmVxdWVuY3kgPSBnZXRQYXR0ZXJuRnJlcXVlbmN5KGZpbmRpbmdzKTtcbiAgXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhmcmVxdWVuY3kpXG4gICAgLm1hcCgoW3BhdHRlcm4sIGNvdW50XSkgPT4gKHsgcGF0dGVybiwgY291bnQgfSkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KVxuICAgIC5zbGljZSgwLCBsaW1pdCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBmaWxlIGNvbnRhaW5zIGFueSBkZXByZWNhdGVkIHBhdHRlcm5zXG4gKiBAcGFyYW0gZmlsZVBhdGggRmlsZSBwYXRoXG4gKiBAcGFyYW0gZmluZGluZ3MgUGF0dGVybiBmaW5kaW5nc1xuICogQHJldHVybnMgVHJ1ZSBpZiBmaWxlIGhhcyBkZXByZWNhdGVkIHBhdHRlcm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWxlSGFzRGVwcmVjYXRlZFBhdHRlcm5zKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXVxuKTogYm9vbGVhbiB7XG4gIHJldHVybiBmaW5kaW5ncy5zb21lKGYgPT4gZi5maWxlID09PSBmaWxlUGF0aCk7XG59XG5cbi8qKlxuICogR2V0IGZpbGVzIHdpdGggZGVwcmVjYXRlZCBwYXR0ZXJuc1xuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcbiAqIEByZXR1cm5zIEFycmF5IG9mIGZpbGUgcGF0aHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVzV2l0aERlcHJlY2F0ZWRQYXR0ZXJucyhmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSk6IHN0cmluZ1tdIHtcbiAgY29uc3QgZmlsZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgXG4gIGZvciAoY29uc3QgZmluZGluZyBvZiBmaW5kaW5ncykge1xuICAgIGZpbGVzLmFkZChmaW5kaW5nLmZpbGUpO1xuICB9XG4gIFxuICByZXR1cm4gQXJyYXkuZnJvbShmaWxlcyk7XG59XG5cbi8qKlxuICogQW5hbHl6ZSBKYXZhU2NyaXB0LXNwZWNpZmljIHBhdHRlcm5zXG4gKiBAcGFyYW0gZmlsZSBGaWxlIHRvIGFuYWx5emVcbiAqIEBwYXJhbSBsYW5ndWFnZSBMYW5ndWFnZSBjb250ZXh0XG4gKiBAcmV0dXJucyBBcnJheSBvZiBwYXR0ZXJuIGZpbmRpbmdzXG4gKi9cbmZ1bmN0aW9uIGFuYWx5emVKYXZhU2NyaXB0UGF0dGVybnMoXG4gIGZpbGU6IHsgcGF0aD86IHN0cmluZzsgbmFtZT86IHN0cmluZzsgY29udGVudDogc3RyaW5nIH0sXG4gIGxhbmd1YWdlOiBMYW5ndWFnZVxuKTogUGF0dGVybkZpbmRpbmdbXSB7XG4gIGNvbnN0IGZpbmRpbmdzOiBQYXR0ZXJuRmluZGluZ1tdID0gW107XG4gIGNvbnN0IGxpbmVzID0gZmlsZS5jb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGggfHwgZmlsZS5uYW1lIHx8ICd1bmtub3duJztcbiAgXG4gIGZvciAobGV0IGxpbmVJbmRleCA9IDA7IGxpbmVJbmRleCA8IGxpbmVzLmxlbmd0aDsgbGluZUluZGV4KyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbbGluZUluZGV4XTtcbiAgICBjb25zdCBsaW5lTnVtYmVyID0gbGluZUluZGV4ICsgMTtcbiAgICBcbiAgICAvLyBTa2lwIGVtcHR5IGxpbmVzIGFuZCBjb21tZW50c1xuICAgIGlmIChpc0NvbW1lbnRMaW5lKGxpbmUsIGxhbmd1YWdlKSB8fCBsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBmb3IgY29tbW9uIEphdmFTY3JpcHQgaXNzdWVzXG4gICAgY29uc3QganNQYXR0ZXJucyA9IFtcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3ZhclxccytcXHcrL2csXG4gICAgICAgIG1lc3NhZ2U6IFwidmFyIGlzIGRlcHJlY2F0ZWQsIHVzZSBsZXQgb3IgY29uc3RcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGxldCBmb3IgdmFyaWFibGVzIHRoYXQgY2hhbmdlLCBjb25zdCBmb3IgY29uc3RhbnRzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9mdW5jdGlvblxccytcXHcrXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcIkZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmUgbGVzcyBwcmVmZXJyZWQgdGhhbiBhcnJvdyBmdW5jdGlvbnNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGFycm93IGZ1bmN0aW9ucyBmb3IgYmV0dGVyIHNjb3BlIGhhbmRsaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC90aGlzXFwuXFx3K1xccyo9L2csXG4gICAgICAgIG1lc3NhZ2U6IFwiRGlyZWN0IHRoaXMgYXNzaWdubWVudCBpcyBkaXNjb3VyYWdlZFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgY2xhc3MgcHJvcGVydGllcyBvciBiaW5kIG1ldGhvZHMgcHJvcGVybHlcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL1xcYmFyZ3VtZW50c1xcYi9nLFxuICAgICAgICBtZXNzYWdlOiBcImFyZ3VtZW50cyBvYmplY3QgaXMgZGVwcmVjYXRlZCwgdXNlIHJlc3QgcGFyYW1ldGVyc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgLi4uYXJncyByZXN0IHBhcmFtZXRlciBzeW50YXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogLz09XFxzKlxcdyt8XFx3K1xccyo9PS9nLFxuICAgICAgICBtZXNzYWdlOiBcIj09IGNhbiBjYXVzZSB0eXBlIGNvZXJjaW9uIGlzc3Vlc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgPT09IGZvciBzdHJpY3QgZXF1YWxpdHlcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogLyE9XFxzKlxcdyt8XFx3K1xccyohPS9nLFxuICAgICAgICBtZXNzYWdlOiBcIiE9IGNhbiBjYXVzZSB0eXBlIGNvZXJjaW9uIGlzc3Vlc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgIT09IGZvciBzdHJpY3QgaW5lcXVhbGl0eVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvdHlwZW9mXFxzK1xcdytcXHMqPT09XFxzKlsnXCJddW5kZWZpbmVkWydcIl0vZyxcbiAgICAgICAgbWVzc2FnZTogXCJ0eXBlb2YgdW5kZWZpbmVkIGNoZWNrIGlzIHZlcmJvc2VcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlID09PSB1bmRlZmluZWQgb3Igb3B0aW9uYWwgY2hhaW5pbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2ZvclxccypcXChcXHMqdmFyXFxzKy9nLFxuICAgICAgICBtZXNzYWdlOiBcInZhciBpbiBmb3IgbG9vcHMgY2FuIGNhdXNlIHNjb3BlIGlzc3Vlc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgbGV0IGluIGZvciBsb29wc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvd2l0aFxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJ3aXRoIHN0YXRlbWVudCBpcyBkZXByZWNhdGVkIGFuZCBkYW5nZXJvdXNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGV4cGxpY2l0IHZhcmlhYmxlIHJlZmVyZW5jZXNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2V2YWxcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiZXZhbCgpIGlzIGRhbmdlcm91cyBhbmQgc2hvdWxkIGJlIGF2b2lkZWRcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHNhZmVyIGFsdGVybmF0aXZlcyBvciByZWZhY3RvciBjb2RlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9uZXdcXHMrRnVuY3Rpb25cXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwibmV3IEZ1bmN0aW9uKCkgaXMgZGFuZ2Vyb3VzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgb3IgYXJyb3cgZnVuY3Rpb25zXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9zZXRUaW1lb3V0XFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcInNldFRpbWVvdXQgd2l0aCBzdHJpbmcgaXMgZGFuZ2Vyb3VzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBmdW5jdGlvbiByZWZlcmVuY2VzIGluc3RlYWQgb2Ygc3RyaW5nc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvc2V0SW50ZXJ2YWxcXHMqXFwoXFxzKlsnXCJdL2csXG4gICAgICAgIG1lc3NhZ2U6IFwic2V0SW50ZXJ2YWwgd2l0aCBzdHJpbmcgaXMgZGFuZ2Vyb3VzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBmdW5jdGlvbiByZWZlcmVuY2VzIGluc3RlYWQgb2Ygc3RyaW5nc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvc2V0SW1tZWRpYXRlXFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcInNldEltbWVkaWF0ZSB3aXRoIHN0cmluZyBpcyBkYW5nZXJvdXNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGZ1bmN0aW9uIHJlZmVyZW5jZXMgaW5zdGVhZCBvZiBzdHJpbmdzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9wcm9jZXNzXFwubmV4dFRpY2tcXHMqXFwoXFxzKlsnXCJdL2csXG4gICAgICAgIG1lc3NhZ2U6IFwicHJvY2Vzcy5uZXh0VGljayB3aXRoIHN0cmluZyBpcyBkYW5nZXJvdXNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGZ1bmN0aW9uIHJlZmVyZW5jZXMgaW5zdGVhZCBvZiBzdHJpbmdzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9yZXF1aXJlXFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcIkR5bmFtaWMgcmVxdWlyZSgpIGNhbiBiZSBkYW5nZXJvdXNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHN0YXRpYyBpbXBvcnRzIG9yIHByb3BlciBtb2R1bGUgbG9hZGluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvaW1wb3J0XFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcIkR5bmFtaWMgaW1wb3J0KCkgY2FuIGJlIGRhbmdlcm91c1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2Ugc3RhdGljIGltcG9ydHMgb3IgcHJvcGVyIG1vZHVsZSBsb2FkaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9uZXdcXHMrUmVnRXhwXFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcIm5ldyBSZWdFeHAoKSB3aXRoIHVzZXIgaW5wdXQgaXMgZGFuZ2Vyb3VzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBsaXRlcmFsIHJlZ2V4IG9yIHNhbml0aXplIGlucHV0XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9SZWdFeHBcXHMqXFwoXFxzKlsnXCJdL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiUmVnRXhwKCkgd2l0aCB1c2VyIGlucHV0IGlzIGRhbmdlcm91c1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgbGl0ZXJhbCByZWdleCBvciBzYW5pdGl6ZSBpbnB1dFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvSlNPTlxcLnBhcnNlXFxzKlxcKFxccypbJ1wiXS9nLFxuICAgICAgICBtZXNzYWdlOiBcIkpTT04ucGFyc2UoKSB3aXRoIHVudHJ1c3RlZCBkYXRhIGlzIGRhbmdlcm91c1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJWYWxpZGF0ZSBhbmQgc2FuaXRpemUgaW5wdXQgYmVmb3JlIHBhcnNpbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL0pTT05cXC5zdHJpbmdpZnlcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiSlNPTi5zdHJpbmdpZnkoKSBjYW4gZXhwb3NlIHNlbnNpdGl2ZSBkYXRhXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIkZpbHRlciBzZW5zaXRpdmUgcHJvcGVydGllcyBiZWZvcmUgc3RyaW5naWZ5aW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9YTUxIdHRwUmVxdWVzdC9nLFxuICAgICAgICBtZXNzYWdlOiBcIlhNTEh0dHBSZXF1ZXN0IGlzIGRlcHJlY2F0ZWQsIHVzZSBmZXRjaCgpXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBmZXRjaCgpIEFQSSBvciBheGlvcyBsaWJyYXJ5XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9BY3RpdmVYT2JqZWN0L2csXG4gICAgICAgIG1lc3NhZ2U6IFwiQWN0aXZlWE9iamVjdCBpcyBkZXByZWNhdGVkIGFuZCBpbnNlY3VyZVwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgbW9kZXJuIGFsdGVybmF0aXZlc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvYXR0YWNoRXZlbnQvZyxcbiAgICAgICAgbWVzc2FnZTogXCJhdHRhY2hFdmVudCBpcyBkZXByZWNhdGVkLCB1c2UgYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgYWRkRXZlbnRMaXN0ZW5lcigpIG1ldGhvZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZGV0YWNoRXZlbnQvZyxcbiAgICAgICAgbWVzc2FnZTogXCJkZXRhY2hFdmVudCBpcyBkZXByZWNhdGVkLCB1c2UgcmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIG1ldGhvZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZG9jdW1lbnRcXC53cml0ZVxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJkb2N1bWVudC53cml0ZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIGRhbmdlcm91c1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgRE9NIG1hbmlwdWxhdGlvbiBtZXRob2RzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9pbm5lckhUTUxcXHMqPS9nLFxuICAgICAgICBtZXNzYWdlOiBcImlubmVySFRNTCBhc3NpZ25tZW50IGNhbiBiZSBkYW5nZXJvdXNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHRleHRDb250ZW50IG9yIHByb3BlciBET00gbWV0aG9kc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvb3V0ZXJIVE1MXFxzKj0vZyxcbiAgICAgICAgbWVzc2FnZTogXCJvdXRlckhUTUwgYXNzaWdubWVudCBjYW4gYmUgZGFuZ2Vyb3VzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBwcm9wZXIgRE9NIG1hbmlwdWxhdGlvbiBtZXRob2RzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9hbGVydFxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJhbGVydCgpIHNob3VsZCBub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBwcm9wZXIgdXNlciBpbnRlcmZhY2UgY29tcG9uZW50cyBvciBsb2dnaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9jb25maXJtXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcImNvbmZpcm0oKSBzaG91bGQgbm90IGJlIHVzZWQgaW4gcHJvZHVjdGlvblwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgcHJvcGVyIHVzZXIgaW50ZXJmYWNlIGNvbXBvbmVudHNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3Byb21wdFxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJwcm9tcHQoKSBzaG91bGQgbm90IGJlIHVzZWQgaW4gcHJvZHVjdGlvblwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgcHJvcGVyIHVzZXIgaW50ZXJmYWNlIGNvbXBvbmVudHNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2RlYnVnZ2VyXFxiL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiZGVidWdnZXIgc3RhdGVtZW50IHNob3VsZCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb25cIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiUmVtb3ZlIGRlYnVnZ2VyIHN0YXRlbWVudHMgb3IgdXNlIHByb3BlciBkZWJ1Z2dpbmcgdG9vbHNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2NvbnNvbGVcXC4obG9nfHdhcm58ZXJyb3J8aW5mb3xkZWJ1Z3x0cmFjZXxkaXJ8dGFibGV8dGltZXx0aW1lRW5kfGNvdW50fGNvdW50UmVzZXR8Z3JvdXB8Z3JvdXBFbmR8Z3JvdXBDb2xsYXBzZWR8YXNzZXJ0fGNsZWFyfHByb2ZpbGV8cHJvZmlsZUVuZHx0aW1lU3RhbXB8bWFya1RpbWVsaW5lfHRpbWVsaW5lfHRpbWVsaW5lRW5kfG1lbW9yeXxleGNlcHRpb24pXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcImNvbnNvbGUgbWV0aG9kcyBzaG91bGQgYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBwcm9wZXIgbG9nZ2luZyBsaWJyYXJ5IG9yIHJlbW92ZSBkZWJ1ZyBzdGF0ZW1lbnRzXCJcbiAgICAgIH1cbiAgICBdO1xuICAgIFxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBqc1BhdHRlcm5zKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybi5wYXR0ZXJuLnNvdXJjZSwgJ2cnKTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gQXZvaWQgaW5maW5pdGUgbG9vcHMgd2l0aCB6ZXJvLWxlbmd0aCBtYXRjaGVzXG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSByZWdleC5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgICAgcmVhc29uOiAnZGVwcmVjYXRlZC1hcGknLFxuICAgICAgICAgICAgaXNzdWU6IHBhdHRlcm4ubWVzc2FnZSxcbiAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4ucGF0dGVybi5zb3VyY2UsXG4gICAgICAgICAgICBxdWlja0ZpeDogcGF0dGVybi5hbHRlcm5hdGl2ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHJlZ2V4IHBhdHRlcm46ICR7cGF0dGVybi5wYXR0ZXJufSAtICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZmluZGluZ3M7XG59XG5cbi8qKlxuICogQW5hbHl6ZSBQeXRob24tc3BlY2lmaWMgcGF0dGVybnNcbiAqIEBwYXJhbSBmaWxlIEZpbGUgdG8gYW5hbHl6ZVxuICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlIGNvbnRleHRcbiAqIEByZXR1cm5zIEFycmF5IG9mIHBhdHRlcm4gZmluZGluZ3NcbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZVB5dGhvblBhdHRlcm5zKFxuICBmaWxlOiB7IHBhdGg/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZyB9LFxuICBsYW5ndWFnZTogTGFuZ3VhZ2Vcbik6IFBhdHRlcm5GaW5kaW5nW10ge1xuICBjb25zdCBmaW5kaW5nczogUGF0dGVybkZpbmRpbmdbXSA9IFtdO1xuICBjb25zdCBsaW5lcyA9IGZpbGUuY29udGVudC5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoIHx8IGZpbGUubmFtZSB8fCAndW5rbm93bic7XG4gIFxuICBmb3IgKGxldCBsaW5lSW5kZXggPSAwOyBsaW5lSW5kZXggPCBsaW5lcy5sZW5ndGg7IGxpbmVJbmRleCsrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2xpbmVJbmRleF07XG4gICAgY29uc3QgbGluZU51bWJlciA9IGxpbmVJbmRleCArIDE7XG4gICAgXG4gICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBhbmQgY29tbWVudHNcbiAgICBpZiAoaXNDb21tZW50TGluZShsaW5lLCBsYW5ndWFnZSkgfHwgbGluZS50cmltKCkgPT09ICcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBQeXRob24gaXNzdWVzXG4gICAgY29uc3QgcHlQYXR0ZXJucyA9IFtcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3VybGxpYjJcXC58dXJsbGliXFwucmVxdWVzdC9nLFxuICAgICAgICBtZXNzYWdlOiBcInVybGxpYjIgaXMgZGVwcmVjYXRlZCBpbiBQeXRob24gMywgdXNlIHVybGxpYi5yZXF1ZXN0XCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSB1cmxsaWIucmVxdWVzdCBvciByZXF1ZXN0cyBsaWJyYXJ5XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9leGVjZmlsZVxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJleGVjZmlsZSgpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGV4ZWMob3BlbihmaWxlbmFtZSkucmVhZCgpKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvcmVsb2FkXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcInJlbG9hZCgpIGlzIGRlcHJlY2F0ZWQsIHVzZSBpbXBvcnRsaWIucmVsb2FkKClcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGltcG9ydGxpYi5yZWxvYWQobW9kdWxlKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZmlsZVxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJmaWxlKCkgaXMgZGVwcmVjYXRlZCwgdXNlIG9wZW4oKVwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2Ugb3BlbigpIGZ1bmN0aW9uIGluc3RlYWRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3Jhd19pbnB1dFxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJyYXdfaW5wdXQoKSBpcyBkZXByZWNhdGVkIGluIFB5dGhvbiAzLCB1c2UgaW5wdXQoKVwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgaW5wdXQoKSBmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAveHJhbmdlXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcInhyYW5nZSgpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDMsIHVzZSByYW5nZSgpXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSByYW5nZSgpIGZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9iYXNlc3RyaW5nL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiYmFzZXN0cmluZyBpcyBkZXByZWNhdGVkIGluIFB5dGhvbiAzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBzdHIgb3IgYnl0ZXMgZGlyZWN0bHlcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3VuaWNvZGVcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwidW5pY29kZSgpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHN0cigpIGZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9sb25nXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcImxvbmcoKSBpcyBkZXByZWNhdGVkIGluIFB5dGhvbiAzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBpbnQoKSBmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvY21wXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcImNtcCgpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIChhID4gYikgLSAoYSA8IGIpIG9yIG9wZXJhdG9yIGZ1bmN0aW9uc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvcmVkdWNlXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcInJlZHVjZSgpIGlzIGRlcHJlY2F0ZWQsIHVzZSBmdW5jdG9vbHMucmVkdWNlKClcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiSW1wb3J0IGFuZCB1c2UgZnVuY3Rvb2xzLnJlZHVjZSgpXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9hcHBseVxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJhcHBseSgpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGZ1bmN0aW9uKCphcmdzLCAqKmt3YXJncykgc3ludGF4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9jb2VyY2VcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiY29lcmNlKCkgaXMgZGVwcmVjYXRlZCBpbiBQeXRob24gM1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgZXhwbGljaXQgdHlwZSBjb252ZXJzaW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9pbnRlcm5cXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiaW50ZXJuKCkgaXMgZGVwcmVjYXRlZCBpbiBQeXRob24gM1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2Ugc3lzLmludGVybigpIGlmIG5lZWRlZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvdW5pY2hyXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcInVuaWNocigpIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGNocigpIGZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9idWZmZXJcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiYnVmZmVyKCkgaXMgZGVwcmVjYXRlZCBpbiBQeXRob24gM1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgbWVtb3J5dmlldygpIG9yIGJ5dGVzKClcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL1N0YW5kYXJkRXJyb3IvZyxcbiAgICAgICAgbWVzc2FnZTogXCJTdGFuZGFyZEVycm9yIGlzIGRlcHJlY2F0ZWQgaW4gUHl0aG9uIDNcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIEV4Y2VwdGlvbiBvciBzcGVjaWZpYyBleGNlcHRpb24gdHlwZXNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2V4ZWNcXHMrXFx3K1xccytpblxccytcXHcrL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiZXhlYyB3aXRoICdpbicgc3ludGF4IGlzIGRlcHJlY2F0ZWRcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGV4ZWMoY29kZSwgZ2xvYmFscywgbG9jYWxzKSBzeW50YXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3ByaW50XFxzK1xcdysvZyxcbiAgICAgICAgbWVzc2FnZTogXCJwcmludCBzdGF0ZW1lbnQgaXMgZGVwcmVjYXRlZCBpbiBQeXRob24gM1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgcHJpbnQoKSBmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvcmFpc2VcXHMrXFx3KyxcXHMrXFx3Ky9nLFxuICAgICAgICBtZXNzYWdlOiBcInJhaXNlIHdpdGggY29tbWEgc3ludGF4IGlzIGRlcHJlY2F0ZWRcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHJhaXNlIEV4Y2VwdGlvbignbWVzc2FnZScpIHN5bnRheFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZXhjZXB0XFxzK1xcdyssXFxzK1xcdysvZyxcbiAgICAgICAgbWVzc2FnZTogXCJleGNlcHQgd2l0aCBjb21tYSBzeW50YXggaXMgZGVwcmVjYXRlZFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOiBzeW50YXhcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2RlZlxccytcXHcrXFxzKlxcKFteKV0qXFwpOi9nLFxuICAgICAgICBtZXNzYWdlOiBcIkNoZWNrIGZvciBQeXRob24gMiBzdHlsZSBmdW5jdGlvbiBkZWZpbml0aW9uc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJFbnN1cmUgUHl0aG9uIDMgY29tcGF0aWJpbGl0eVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZnJvbVxccytcXHcrXFxzK2ltcG9ydFxccytcXCovZyxcbiAgICAgICAgbWVzc2FnZTogXCJXaWxkY2FyZCBpbXBvcnRzIGFyZSBkaXNjb3VyYWdlZFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJJbXBvcnQgc3BlY2lmaWMgZnVuY3Rpb25zIG9yIHVzZSBxdWFsaWZpZWQgbmFtZXNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2V2YWxcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwiZXZhbCgpIGlzIGRhbmdlcm91cyBhbmQgc2hvdWxkIGJlIGF2b2lkZWRcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIHNhZmVyIGFsdGVybmF0aXZlcyBsaWtlIGFzdC5saXRlcmFsX2V2YWwoKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZXhlY1xccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJleGVjKCkgaXMgZGFuZ2Vyb3VzIGFuZCBzaG91bGQgYmUgYXZvaWRlZFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2Ugc2FmZXIgYWx0ZXJuYXRpdmVzIG9yIHJlZmFjdG9yIGNvZGVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3N1YnByb2Nlc3NcXC5jYWxsLipzaGVsbD1UcnVlL2csXG4gICAgICAgIG1lc3NhZ2U6IFwic2hlbGw9VHJ1ZSBpbiBzdWJwcm9jZXNzIGlzIGRhbmdlcm91c1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2Ugc2hlbGw9RmFsc2UgYW5kIHBhc3MgYXJndW1lbnRzIGFzIGxpc3RcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL29zXFwuc3lzdGVtXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcIm9zLnN5c3RlbSgpIGlzIGRlcHJlY2F0ZWQsIHVzZSBzdWJwcm9jZXNzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBzdWJwcm9jZXNzLnJ1bigpIG9yIHN1YnByb2Nlc3MuUG9wZW4oKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvcGlja2xlXFwubG9hZHNcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwicGlja2xlLmxvYWRzKCkgaXMgdW5zYWZlIHdpdGggdW50cnVzdGVkIGRhdGFcIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiVXNlIGpzb24ubG9hZHMoKSBvciBvdGhlciBzYWZlIHNlcmlhbGl6YXRpb25cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL3BpY2tsZVxcLmxvYWRcXHMqXFwoL2csXG4gICAgICAgIG1lc3NhZ2U6IFwicGlja2xlLmxvYWQoKSBpcyB1bnNhZmUgd2l0aCB1bnRydXN0ZWQgZGF0YVwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJVc2UganNvbi5sb2FkKCkgb3Igb3RoZXIgc2FmZSBzZXJpYWxpemF0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9tZDVcXC58c2hhMVxcLi9nLFxuICAgICAgICBtZXNzYWdlOiBcIk1ENSBhbmQgU0hBMSBhcmUgY3J5cHRvZ3JhcGhpY2FsbHkgYnJva2VuXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBoYXNobGliLnNoYTI1NigpIG9yIGhhc2hsaWIuc2hhM18yNTYoKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvcmFuZG9tXFwucmFuZG9tXFxzKlxcKC9nLFxuICAgICAgICBtZXNzYWdlOiBcInJhbmRvbS5yYW5kb20oKSBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSBzZWNyZXRzIG1vZHVsZSBmb3IgY3J5cHRvZ3JhcGhpYyByYW5kb21uZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC90aW1lXFwudGltZVxccypcXCgvZyxcbiAgICAgICAgbWVzc2FnZTogXCJ0aW1lLnRpbWUoKSBpcyBub3Qgc3VpdGFibGUgZm9yIHRpbWluZyBhdHRhY2tzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIlVzZSB0aW1lLnBlcmZfY291bnRlcigpIGZvciB0aW1pbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogL2NsYXNzXFxzK1xcdysuKjovZyxcbiAgICAgICAgbWVzc2FnZTogXCJDaGVjayBmb3Igb2xkLXN0eWxlIGNsYXNzIGRlZmluaXRpb25zXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIkVuc3VyZSBhbGwgY2xhc3NlcyBpbmhlcml0IGZyb20gb2JqZWN0IG9yIHVzZSBuZXctc3R5bGUgY2xhc3Nlc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvZGVmXFxzK1xcdytcXHMqXFwoc2VsZixcXHMqW14pXSpcXCk6L2csXG4gICAgICAgIG1lc3NhZ2U6IFwiQ2hlY2sgZm9yIFB5dGhvbiAyIHN0eWxlIG1ldGhvZCBkZWZpbml0aW9uc1wiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJFbnN1cmUgUHl0aG9uIDMgY29tcGF0aWJpbGl0eVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvaW1wb3J0XFxzK1xcdytcXHMqJC9nLFxuICAgICAgICBtZXNzYWdlOiBcIkNoZWNrIGZvciBQeXRob24gMiBzdHlsZSBpbXBvcnRzXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIkVuc3VyZSBQeXRob24gMyBjb21wYXRpYmlsaXR5XCJcbiAgICAgIH1cbiAgICBdO1xuICAgIFxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBweVBhdHRlcm5zKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybi5wYXR0ZXJuLnNvdXJjZSwgJ2cnKTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gQXZvaWQgaW5maW5pdGUgbG9vcHMgd2l0aCB6ZXJvLWxlbmd0aCBtYXRjaGVzXG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSByZWdleC5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6ICdwYXR0ZXJuJyxcbiAgICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgICAgZmlsZTogZmlsZVBhdGgsXG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgc3RhdHVzOiAnYWZmZWN0ZWQnLFxuICAgICAgICAgICAgcmVhc29uOiAnZGVwcmVjYXRlZC1hcGknLFxuICAgICAgICAgICAgaXNzdWU6IHBhdHRlcm4ubWVzc2FnZSxcbiAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4ucGF0dGVybi5zb3VyY2UsXG4gICAgICAgICAgICBxdWlja0ZpeDogcGF0dGVybi5hbHRlcm5hdGl2ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHJlZ2V4IHBhdHRlcm46ICR7cGF0dGVybi5wYXR0ZXJufSAtICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZmluZGluZ3M7XG59XG5cbi8qKlxuICogR2V0IGxpbmUgbnVtYmVycyB3aXRoIGRlcHJlY2F0ZWQgcGF0dGVybnMgZm9yIGEgZmlsZVxuICogQHBhcmFtIGZpbGVQYXRoIEZpbGUgcGF0aFxuICogQHBhcmFtIGZpbmRpbmdzIFBhdHRlcm4gZmluZGluZ3NcbiAqIEByZXR1cm5zIEFycmF5IG9mIGxpbmUgbnVtYmVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwcmVjYXRlZFBhdHRlcm5MaW5lcyhcbiAgZmlsZVBhdGg6IHN0cmluZyxcbiAgZmluZGluZ3M6IFBhdHRlcm5GaW5kaW5nW11cbik6IG51bWJlcltdIHtcbiAgcmV0dXJuIGZpbmRpbmdzXG4gICAgLmZpbHRlcihmID0+IGYuZmlsZSA9PT0gZmlsZVBhdGgpXG4gICAgLm1hcChmID0+IGYubGluZSlcbiAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xufVxuIl0sIm5hbWVzIjpbInNob3VsZFNjYW5GaWxlIiwic2hvdWxkSWdub3JlUGF0aCIsInNjYW5Tb3VyY2VGaWxlcyIsImZpbGVzIiwicnVsZXMiLCJmaW5kaW5ncyIsImZpbGUiLCJzaXplIiwibWF4X2ZpbGVfc2l6ZSIsImNvbnNvbGUiLCJ3YXJuIiwicGF0aCIsIm5hbWUiLCJmaWxlUGF0aCIsImV4dGVuc2lvbiIsImdldEZpbGVFeHRlbnNpb24iLCJsYW5ndWFnZSIsImRldGVjdExhbmd1YWdlRnJvbUV4dGVuc2lvbiIsInBhdHRlcm5zIiwiZGVwcmVjYXRlZF9wYXR0ZXJucyIsImxlbmd0aCIsImZpbGVGaW5kaW5ncyIsInNjYW5GaWxlQ29udGVudCIsInB1c2giLCJqc0ZpbmRpbmdzIiwiYW5hbHl6ZUphdmFTY3JpcHRQYXR0ZXJucyIsInB5RmluZGluZ3MiLCJhbmFseXplUHl0aG9uUGF0dGVybnMiLCJsaW5lcyIsImNvbnRlbnQiLCJzcGxpdCIsImxpbmVJbmRleCIsImxpbmUiLCJsaW5lTnVtYmVyIiwiaXNDb21tZW50TGluZSIsInRyaW0iLCJwYXR0ZXJuIiwicmVnZXgiLCJSZWdFeHAiLCJtYXRjaCIsImV4ZWMiLCJpbmRleCIsImxhc3RJbmRleCIsImtpbmQiLCJsYW5nIiwic3RhdHVzIiwicmVhc29uIiwiaXNzdWUiLCJtZXNzYWdlIiwicXVpY2tGaXgiLCJhbHRlcm5hdGl2ZSIsImVycm9yIiwibGFzdERvdCIsImxhc3RJbmRleE9mIiwic3Vic3RyaW5nIiwibGFuZ3VhZ2VNYXAiLCJ0cmltbWVkIiwic3RhcnRzV2l0aCIsImdldFBhdHRlcm5RdWlja0ZpeCIsInF1aWNrX2ZpeGVzIiwicGF0dGVybl9yZXBsYWNlbWVudCIsImdyb3VwUGF0dGVybkZpbmRpbmdzQnlGaWxlIiwiZ3JvdXBlZCIsImZpbmRpbmciLCJncm91cFBhdHRlcm5GaW5kaW5nc0J5TGFuZ3VhZ2UiLCJweXRob24iLCJub2RlIiwiamF2YSIsImdvIiwiZG90bmV0IiwiZ2V0UGF0dGVyblN1bW1hcnkiLCJ0b3RhbCIsImJ5TGFuZ3VhZ2UiLCJieUZpbGUiLCJhZmZlY3RlZEZpbGVzIiwiT2JqZWN0Iiwia2V5cyIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm1hcCIsImNvdW50IiwiU2V0IiwiZiIsImZpbHRlclBhdHRlcm5GaW5kaW5nc0J5TGFuZ3VhZ2UiLCJmaWx0ZXIiLCJmaWx0ZXJQYXR0ZXJuRmluZGluZ3NCeUZpbGUiLCJzb3J0UGF0dGVybkZpbmRpbmdzIiwic29ydCIsImEiLCJiIiwiZmlsZURpZmYiLCJsb2NhbGVDb21wYXJlIiwiZ2V0VW5pcXVlUGF0dGVybnMiLCJhZGQiLCJBcnJheSIsImZyb20iLCJnZXRQYXR0ZXJuRnJlcXVlbmN5IiwiZnJlcXVlbmN5IiwiZ2V0TW9zdENvbW1vblBhdHRlcm5zIiwibGltaXQiLCJzbGljZSIsImZpbGVIYXNEZXByZWNhdGVkUGF0dGVybnMiLCJzb21lIiwiZ2V0RmlsZXNXaXRoRGVwcmVjYXRlZFBhdHRlcm5zIiwianNQYXR0ZXJucyIsInNvdXJjZSIsInB5UGF0dGVybnMiLCJnZXREZXByZWNhdGVkUGF0dGVybkxpbmVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/analysis/scan.ts\n");

/***/ }),

/***/ "(rsc)/./lib/files/single-file.ts":
/*!**********************************!*\
  !*** ./lib/files/single-file.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectFileType: () => (/* binding */ detectFileType),\n/* harmony export */   processSingleFile: () => (/* binding */ processSingleFile),\n/* harmony export */   shouldAnalyzeFile: () => (/* binding */ shouldAnalyzeFile)\n/* harmony export */ });\n/**\n * Process a single file for analysis\n * @param filePath Path to the file\n * @param content File content\n * @param maxFileSize Maximum file size in bytes\n * @returns Single file result\n */ function processSingleFile(filePath, content, maxFileSize = 5 * 1024 * 1024 // 5MB\n) {\n    // Check file size\n    const fileSize = Buffer.byteLength(content, 'utf8');\n    if (fileSize > maxFileSize) {\n        return {\n            files: [],\n            totalFiles: 1,\n            skippedFiles: 1\n        };\n    }\n    // Create extracted file object\n    const extractedFile = {\n        path: filePath,\n        content: content,\n        size: fileSize\n    };\n    return {\n        files: [\n            extractedFile\n        ],\n        totalFiles: 1,\n        skippedFiles: 0\n    };\n}\n/**\n * Detect file type from extension\n * @param filename File name\n * @returns File type category\n */ function detectFileType(filename) {\n    const ext = filename.split('.').pop()?.toLowerCase();\n    const typeMap = {\n        // Web files\n        'js': 'javascript',\n        'jsx': 'javascript',\n        'ts': 'typescript',\n        'tsx': 'typescript',\n        'html': 'html',\n        'htm': 'html',\n        'css': 'css',\n        'scss': 'css',\n        'sass': 'css',\n        'less': 'css',\n        // Python\n        'py': 'python',\n        'pyw': 'python',\n        // Java\n        'java': 'java',\n        'kt': 'kotlin',\n        'scala': 'scala',\n        // C/C++\n        'c': 'c',\n        'cpp': 'cpp',\n        'cc': 'cpp',\n        'cxx': 'cpp',\n        'h': 'c',\n        'hpp': 'cpp',\n        // C#\n        'cs': 'csharp',\n        'fs': 'fsharp',\n        'vb': 'vbnet',\n        // Go\n        'go': 'go',\n        // Rust\n        'rs': 'rust',\n        // PHP\n        'php': 'php',\n        // Ruby\n        'rb': 'ruby',\n        // Swift\n        'swift': 'swift',\n        // Configuration files\n        'json': 'json',\n        'yaml': 'yaml',\n        'yml': 'yaml',\n        'xml': 'xml',\n        'toml': 'toml',\n        'ini': 'ini',\n        'cfg': 'config',\n        'conf': 'config',\n        // Documentation\n        'md': 'markdown',\n        'txt': 'text',\n        'rst': 'restructuredtext',\n        // Shell scripts\n        'sh': 'shell',\n        'bash': 'shell',\n        'zsh': 'shell',\n        'fish': 'shell',\n        'ps1': 'powershell',\n        'bat': 'batch',\n        'cmd': 'batch',\n        // SQL\n        'sql': 'sql',\n        // Docker\n        'dockerfile': 'dockerfile',\n        'dockerignore': 'dockerignore',\n        // Git\n        'gitignore': 'gitignore',\n        'gitattributes': 'gitattributes',\n        // Package managers\n        'package.json': 'package.json',\n        'requirements.txt': 'requirements.txt',\n        'pom.xml': 'pom.xml',\n        'build.gradle': 'gradle',\n        'go.mod': 'go.mod',\n        'cargo.toml': 'cargo.toml',\n        'composer.json': 'composer.json',\n        'gemfile': 'gemfile',\n        'podfile': 'podfile',\n        'pubspec.yaml': 'pubspec.yaml'\n    };\n    return typeMap[ext || ''] || 'unknown';\n}\n/**\n * Check if file should be analyzed\n * @param filename File name\n * @returns Whether file should be analyzed\n */ function shouldAnalyzeFile(filename) {\n    const ext = filename.split('.').pop()?.toLowerCase();\n    // Only allow web file types\n    const allowedExtensions = [\n        'html',\n        'htm',\n        'js',\n        'mjs',\n        'ts',\n        'json',\n        'webmanifest',\n        'wasm' // WebAssembly files\n    ];\n    return allowedExtensions.includes(ext || '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvZmlsZXMvc2luZ2xlLWZpbGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBUUE7Ozs7OztDQU1DLEdBQ00sU0FBU0Esa0JBQ2RDLFFBQWdCLEVBQ2hCQyxPQUFlLEVBQ2ZDLGNBQXNCLElBQUksT0FBTyxLQUFLLE1BQU07QUFBUDtJQUVyQyxrQkFBa0I7SUFDbEIsTUFBTUMsV0FBV0MsT0FBT0MsVUFBVSxDQUFDSixTQUFTO0lBQzVDLElBQUlFLFdBQVdELGFBQWE7UUFDMUIsT0FBTztZQUNMSSxPQUFPLEVBQUU7WUFDVEMsWUFBWTtZQUNaQyxjQUFjO1FBQ2hCO0lBQ0Y7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTUMsZ0JBQStCO1FBQ25DQyxNQUFNVjtRQUNOQyxTQUFTQTtRQUNUVSxNQUFNUjtJQUNSO0lBRUEsT0FBTztRQUNMRyxPQUFPO1lBQUNHO1NBQWM7UUFDdEJGLFlBQVk7UUFDWkMsY0FBYztJQUNoQjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNJLGVBQWVDLFFBQWdCO0lBQzdDLE1BQU1DLE1BQU1ELFNBQVNFLEtBQUssQ0FBQyxLQUFLQyxHQUFHLElBQUlDO0lBRXZDLE1BQU1DLFVBQWtDO1FBQ3RDLFlBQVk7UUFDWixNQUFNO1FBQ04sT0FBTztRQUNQLE1BQU07UUFDTixPQUFPO1FBQ1AsUUFBUTtRQUNSLE9BQU87UUFDUCxPQUFPO1FBQ1AsUUFBUTtRQUNSLFFBQVE7UUFDUixRQUFRO1FBRVIsU0FBUztRQUNULE1BQU07UUFDTixPQUFPO1FBRVAsT0FBTztRQUNQLFFBQVE7UUFDUixNQUFNO1FBQ04sU0FBUztRQUVULFFBQVE7UUFDUixLQUFLO1FBQ0wsT0FBTztRQUNQLE1BQU07UUFDTixPQUFPO1FBQ1AsS0FBSztRQUNMLE9BQU87UUFFUCxLQUFLO1FBQ0wsTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO1FBRU4sS0FBSztRQUNMLE1BQU07UUFFTixPQUFPO1FBQ1AsTUFBTTtRQUVOLE1BQU07UUFDTixPQUFPO1FBRVAsT0FBTztRQUNQLE1BQU07UUFFTixRQUFRO1FBQ1IsU0FBUztRQUVULHNCQUFzQjtRQUN0QixRQUFRO1FBQ1IsUUFBUTtRQUNSLE9BQU87UUFDUCxPQUFPO1FBQ1AsUUFBUTtRQUNSLE9BQU87UUFDUCxPQUFPO1FBQ1AsUUFBUTtRQUVSLGdCQUFnQjtRQUNoQixNQUFNO1FBQ04sT0FBTztRQUNQLE9BQU87UUFFUCxnQkFBZ0I7UUFDaEIsTUFBTTtRQUNOLFFBQVE7UUFDUixPQUFPO1FBQ1AsUUFBUTtRQUNSLE9BQU87UUFDUCxPQUFPO1FBQ1AsT0FBTztRQUVQLE1BQU07UUFDTixPQUFPO1FBRVAsU0FBUztRQUNULGNBQWM7UUFDZCxnQkFBZ0I7UUFFaEIsTUFBTTtRQUNOLGFBQWE7UUFDYixpQkFBaUI7UUFFakIsbUJBQW1CO1FBQ25CLGdCQUFnQjtRQUNoQixvQkFBb0I7UUFDcEIsV0FBVztRQUNYLGdCQUFnQjtRQUNoQixVQUFVO1FBQ1YsY0FBYztRQUNkLGlCQUFpQjtRQUNqQixXQUFXO1FBQ1gsV0FBVztRQUNYLGdCQUFnQjtJQUNsQjtJQUVBLE9BQU9BLE9BQU8sQ0FBQ0osT0FBTyxHQUFHLElBQUk7QUFDL0I7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0ssa0JBQWtCTixRQUFnQjtJQUNoRCxNQUFNQyxNQUFNRCxTQUFTRSxLQUFLLENBQUMsS0FBS0MsR0FBRyxJQUFJQztJQUV2Qyw0QkFBNEI7SUFDNUIsTUFBTUcsb0JBQW9CO1FBQ3hCO1FBQVE7UUFDUjtRQUFNO1FBQU87UUFDYjtRQUNBO1FBQ0EsT0FBeUIsb0JBQW9CO0tBQzlDO0lBRUQsT0FBT0Esa0JBQWtCQyxRQUFRLENBQUNQLE9BQU87QUFDM0MiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcZmlsZXNcXHNpbmdsZS1maWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dHJhY3RlZEZpbGUgfSBmcm9tICcuLi9hbmFseXNpcy9iYXNlbGluZS50eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2luZ2xlRmlsZVJlc3VsdCB7XG4gIGZpbGVzOiBFeHRyYWN0ZWRGaWxlW107XG4gIHRvdGFsRmlsZXM6IG51bWJlcjtcbiAgc2tpcHBlZEZpbGVzOiBudW1iZXI7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIHNpbmdsZSBmaWxlIGZvciBhbmFseXNpc1xuICogQHBhcmFtIGZpbGVQYXRoIFBhdGggdG8gdGhlIGZpbGVcbiAqIEBwYXJhbSBjb250ZW50IEZpbGUgY29udGVudFxuICogQHBhcmFtIG1heEZpbGVTaXplIE1heGltdW0gZmlsZSBzaXplIGluIGJ5dGVzXG4gKiBAcmV0dXJucyBTaW5nbGUgZmlsZSByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NTaW5nbGVGaWxlKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBjb250ZW50OiBzdHJpbmcsXG4gIG1heEZpbGVTaXplOiBudW1iZXIgPSA1ICogMTAyNCAqIDEwMjQgLy8gNU1CXG4pOiBTaW5nbGVGaWxlUmVzdWx0IHtcbiAgLy8gQ2hlY2sgZmlsZSBzaXplXG4gIGNvbnN0IGZpbGVTaXplID0gQnVmZmVyLmJ5dGVMZW5ndGgoY29udGVudCwgJ3V0ZjgnKTtcbiAgaWYgKGZpbGVTaXplID4gbWF4RmlsZVNpemUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsZXM6IFtdLFxuICAgICAgdG90YWxGaWxlczogMSxcbiAgICAgIHNraXBwZWRGaWxlczogMVxuICAgIH07XG4gIH1cblxuICAvLyBDcmVhdGUgZXh0cmFjdGVkIGZpbGUgb2JqZWN0XG4gIGNvbnN0IGV4dHJhY3RlZEZpbGU6IEV4dHJhY3RlZEZpbGUgPSB7XG4gICAgcGF0aDogZmlsZVBhdGgsXG4gICAgY29udGVudDogY29udGVudCxcbiAgICBzaXplOiBmaWxlU2l6ZVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZmlsZXM6IFtleHRyYWN0ZWRGaWxlXSxcbiAgICB0b3RhbEZpbGVzOiAxLFxuICAgIHNraXBwZWRGaWxlczogMFxuICB9O1xufVxuXG4vKipcbiAqIERldGVjdCBmaWxlIHR5cGUgZnJvbSBleHRlbnNpb25cbiAqIEBwYXJhbSBmaWxlbmFtZSBGaWxlIG5hbWVcbiAqIEByZXR1cm5zIEZpbGUgdHlwZSBjYXRlZ29yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0RmlsZVR5cGUoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGV4dCA9IGZpbGVuYW1lLnNwbGl0KCcuJykucG9wKCk/LnRvTG93ZXJDYXNlKCk7XG4gIFxuICBjb25zdCB0eXBlTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgIC8vIFdlYiBmaWxlc1xuICAgICdqcyc6ICdqYXZhc2NyaXB0JyxcbiAgICAnanN4JzogJ2phdmFzY3JpcHQnLFxuICAgICd0cyc6ICd0eXBlc2NyaXB0JyxcbiAgICAndHN4JzogJ3R5cGVzY3JpcHQnLFxuICAgICdodG1sJzogJ2h0bWwnLFxuICAgICdodG0nOiAnaHRtbCcsXG4gICAgJ2Nzcyc6ICdjc3MnLFxuICAgICdzY3NzJzogJ2NzcycsXG4gICAgJ3Nhc3MnOiAnY3NzJyxcbiAgICAnbGVzcyc6ICdjc3MnLFxuICAgIFxuICAgIC8vIFB5dGhvblxuICAgICdweSc6ICdweXRob24nLFxuICAgICdweXcnOiAncHl0aG9uJyxcbiAgICBcbiAgICAvLyBKYXZhXG4gICAgJ2phdmEnOiAnamF2YScsXG4gICAgJ2t0JzogJ2tvdGxpbicsXG4gICAgJ3NjYWxhJzogJ3NjYWxhJyxcbiAgICBcbiAgICAvLyBDL0MrK1xuICAgICdjJzogJ2MnLFxuICAgICdjcHAnOiAnY3BwJyxcbiAgICAnY2MnOiAnY3BwJyxcbiAgICAnY3h4JzogJ2NwcCcsXG4gICAgJ2gnOiAnYycsXG4gICAgJ2hwcCc6ICdjcHAnLFxuICAgIFxuICAgIC8vIEMjXG4gICAgJ2NzJzogJ2NzaGFycCcsXG4gICAgJ2ZzJzogJ2ZzaGFycCcsXG4gICAgJ3ZiJzogJ3ZibmV0JyxcbiAgICBcbiAgICAvLyBHb1xuICAgICdnbyc6ICdnbycsXG4gICAgXG4gICAgLy8gUnVzdFxuICAgICdycyc6ICdydXN0JyxcbiAgICBcbiAgICAvLyBQSFBcbiAgICAncGhwJzogJ3BocCcsXG4gICAgXG4gICAgLy8gUnVieVxuICAgICdyYic6ICdydWJ5JyxcbiAgICBcbiAgICAvLyBTd2lmdFxuICAgICdzd2lmdCc6ICdzd2lmdCcsXG4gICAgXG4gICAgLy8gQ29uZmlndXJhdGlvbiBmaWxlc1xuICAgICdqc29uJzogJ2pzb24nLFxuICAgICd5YW1sJzogJ3lhbWwnLFxuICAgICd5bWwnOiAneWFtbCcsXG4gICAgJ3htbCc6ICd4bWwnLFxuICAgICd0b21sJzogJ3RvbWwnLFxuICAgICdpbmknOiAnaW5pJyxcbiAgICAnY2ZnJzogJ2NvbmZpZycsXG4gICAgJ2NvbmYnOiAnY29uZmlnJyxcbiAgICBcbiAgICAvLyBEb2N1bWVudGF0aW9uXG4gICAgJ21kJzogJ21hcmtkb3duJyxcbiAgICAndHh0JzogJ3RleHQnLFxuICAgICdyc3QnOiAncmVzdHJ1Y3R1cmVkdGV4dCcsXG4gICAgXG4gICAgLy8gU2hlbGwgc2NyaXB0c1xuICAgICdzaCc6ICdzaGVsbCcsXG4gICAgJ2Jhc2gnOiAnc2hlbGwnLFxuICAgICd6c2gnOiAnc2hlbGwnLFxuICAgICdmaXNoJzogJ3NoZWxsJyxcbiAgICAncHMxJzogJ3Bvd2Vyc2hlbGwnLFxuICAgICdiYXQnOiAnYmF0Y2gnLFxuICAgICdjbWQnOiAnYmF0Y2gnLFxuICAgIFxuICAgIC8vIFNRTFxuICAgICdzcWwnOiAnc3FsJyxcbiAgICBcbiAgICAvLyBEb2NrZXJcbiAgICAnZG9ja2VyZmlsZSc6ICdkb2NrZXJmaWxlJyxcbiAgICAnZG9ja2VyaWdub3JlJzogJ2RvY2tlcmlnbm9yZScsXG4gICAgXG4gICAgLy8gR2l0XG4gICAgJ2dpdGlnbm9yZSc6ICdnaXRpZ25vcmUnLFxuICAgICdnaXRhdHRyaWJ1dGVzJzogJ2dpdGF0dHJpYnV0ZXMnLFxuICAgIFxuICAgIC8vIFBhY2thZ2UgbWFuYWdlcnNcbiAgICAncGFja2FnZS5qc29uJzogJ3BhY2thZ2UuanNvbicsXG4gICAgJ3JlcXVpcmVtZW50cy50eHQnOiAncmVxdWlyZW1lbnRzLnR4dCcsXG4gICAgJ3BvbS54bWwnOiAncG9tLnhtbCcsXG4gICAgJ2J1aWxkLmdyYWRsZSc6ICdncmFkbGUnLFxuICAgICdnby5tb2QnOiAnZ28ubW9kJyxcbiAgICAnY2FyZ28udG9tbCc6ICdjYXJnby50b21sJyxcbiAgICAnY29tcG9zZXIuanNvbic6ICdjb21wb3Nlci5qc29uJyxcbiAgICAnZ2VtZmlsZSc6ICdnZW1maWxlJyxcbiAgICAncG9kZmlsZSc6ICdwb2RmaWxlJyxcbiAgICAncHVic3BlYy55YW1sJzogJ3B1YnNwZWMueWFtbCdcbiAgfTtcblxuICByZXR1cm4gdHlwZU1hcFtleHQgfHwgJyddIHx8ICd1bmtub3duJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIHNob3VsZCBiZSBhbmFseXplZFxuICogQHBhcmFtIGZpbGVuYW1lIEZpbGUgbmFtZVxuICogQHJldHVybnMgV2hldGhlciBmaWxlIHNob3VsZCBiZSBhbmFseXplZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQW5hbHl6ZUZpbGUoZmlsZW5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBleHQgPSBmaWxlbmFtZS5zcGxpdCgnLicpLnBvcCgpPy50b0xvd2VyQ2FzZSgpO1xuICBcbiAgLy8gT25seSBhbGxvdyB3ZWIgZmlsZSB0eXBlc1xuICBjb25zdCBhbGxvd2VkRXh0ZW5zaW9ucyA9IFtcbiAgICAnaHRtbCcsICdodG0nLCAgICAgICAgICAgLy8gSFRNTCBmaWxlc1xuICAgICdqcycsICdtanMnLCAndHMnLCAgICAgICAvLyBKYXZhU2NyaXB0L1R5cGVTY3JpcHQgZmlsZXNcbiAgICAnanNvbicsICAgICAgICAgICAgICAgICAgLy8gSlNPTiBmaWxlc1xuICAgICd3ZWJtYW5pZmVzdCcsICAgICAgICAgICAvLyBXZWIgbWFuaWZlc3QgZmlsZXNcbiAgICAnd2FzbScgICAgICAgICAgICAgICAgICAgLy8gV2ViQXNzZW1ibHkgZmlsZXNcbiAgXTtcbiAgXG4gIHJldHVybiBhbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhleHQgfHwgJycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3NTaW5nbGVGaWxlIiwiZmlsZVBhdGgiLCJjb250ZW50IiwibWF4RmlsZVNpemUiLCJmaWxlU2l6ZSIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJmaWxlcyIsInRvdGFsRmlsZXMiLCJza2lwcGVkRmlsZXMiLCJleHRyYWN0ZWRGaWxlIiwicGF0aCIsInNpemUiLCJkZXRlY3RGaWxlVHlwZSIsImZpbGVuYW1lIiwiZXh0Iiwic3BsaXQiLCJwb3AiLCJ0b0xvd2VyQ2FzZSIsInR5cGVNYXAiLCJzaG91bGRBbmFseXplRmlsZSIsImFsbG93ZWRFeHRlbnNpb25zIiwiaW5jbHVkZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/files/single-file.ts\n");

/***/ }),

/***/ "(rsc)/./lib/files/store.ts":
/*!****************************!*\
  !*** ./lib/files/store.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analysisExists: () => (/* binding */ analysisExists),\n/* harmony export */   getStoredAnalysis: () => (/* binding */ getStoredAnalysis),\n/* harmony export */   storeAnalysisResults: () => (/* binding */ storeAnalysisResults)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! papaparse */ \"(rsc)/./node_modules/papaparse/papaparse.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n/**\r\n * Store analysis results and return public URLs\r\n * @param report Analysis report\r\n * @param options Storage options\r\n * @returns Stored artifacts with public URLs\r\n */ function storeAnalysisResults(report, options = {}) {\n    const analysisId = (0,crypto__WEBPACK_IMPORTED_MODULE_2__.randomUUID)();\n    // On local development, store files on disk\n    if (!process.env.VERCEL) {\n        const { baseDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis'), publicUrl = 'http://localhost:3000', ttl = 24 * 60 * 60 * 1000 } = options;\n        // Ensure base directory exists\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(baseDir)) {\n            (0,fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync)(baseDir, {\n                recursive: true\n            });\n        }\n        // Create analysis directory\n        const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir)) {\n            (0,fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync)(analysisDir, {\n                recursive: true\n            });\n        }\n        // Store JSON report\n        const jsonPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(analysisDir, 'report.json');\n        (0,fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync)(jsonPath, JSON.stringify(report, null, 2));\n        // Store CSV report\n        const csvPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(analysisDir, 'report.csv');\n        const csvContent = generateCSV(report);\n        (0,fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync)(csvPath, csvContent);\n        // Schedule cleanup\n        scheduleCleanup(analysisDir, ttl);\n        return {\n            jsonUrl: `${publicUrl}/api/analyze/${analysisId}?format=json`,\n            csvUrl: `${publicUrl}/api/analyze/${analysisId}?format=csv`,\n            analysisId\n        };\n    }\n    // On Vercel, return in-memory URLs (no file storage)\n    const publicUrl = process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : 'https://your-app.vercel.app';\n    return {\n        jsonUrl: `${publicUrl}/api/analyze/${analysisId}?format=json`,\n        csvUrl: `${publicUrl}/api/analyze/${analysisId}?format=csv`,\n        analysisId\n    };\n}\n/**\r\n * Generate CSV content from report\r\n * @param report Analysis report\r\n * @returns CSV content\r\n */ function generateCSV(report) {\n    const rows = [];\n    // Add findings\n    for (const finding of report.findings){\n        if (finding.kind === 'dependency') {\n            rows.push({\n                Kind: 'Dependency',\n                Language: finding.lang,\n                Component: finding.component,\n                'Found Version': finding.foundVersion || '',\n                'Required Version': finding.baselineRequired || '',\n                Status: finding.status,\n                Reason: finding.reason,\n                File: finding.file,\n                Line: '',\n                'Quick Fix': finding.quickFix || ''\n            });\n        } else {\n            rows.push({\n                Kind: 'Pattern',\n                Language: finding.lang,\n                Component: '',\n                'Found Version': '',\n                Status: finding.status,\n                Reason: finding.issue,\n                File: finding.file,\n                Line: finding.line.toString(),\n                'Quick Fix': finding.quickFix || '',\n                'Required Version': ''\n            });\n        }\n    }\n    return papaparse__WEBPACK_IMPORTED_MODULE_3___default().unparse(rows);\n}\n/**\r\n * Schedule cleanup of analysis files\r\n * @param analysisDir Analysis directory path\r\n * @param ttl Time to live in milliseconds\r\n */ function scheduleCleanup(analysisDir, ttl) {\n    setTimeout(async ()=>{\n        try {\n            if ((0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir)) {\n                // Remove directory and all contents\n                const { rmSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n                rmSync(analysisDir, {\n                    recursive: true,\n                    force: true\n                });\n            }\n        } catch (error) {\n            console.warn(`Failed to cleanup analysis directory ${analysisDir}: ${error}`);\n        }\n    }, ttl);\n}\n/**\r\n * Get stored analysis report\r\n * @param analysisId Analysis ID\r\n * @param format Format (json or csv)\r\n * @param baseDir Base directory for storage\r\n * @returns Report content or null if not found\r\n */ async function getStoredAnalysis(analysisId, format = 'json', baseDir = process.env.VERCEL ? '/tmp/analysis' : (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    // On Vercel, files are not stored persistently\n    if (process.env.VERCEL) {\n        console.log('File storage not available on Vercel:', analysisId);\n        return null;\n    }\n    try {\n        const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n        const filePath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(analysisDir, `report.${format}`);\n        if (!(0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(filePath)) {\n            return null;\n        }\n        const { readFileSync } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ \"fs\", 23));\n        const content = readFileSync(filePath, 'utf8');\n        return content;\n    } catch (error) {\n        console.warn(`Failed to read stored analysis ${analysisId}: ${error}`);\n        return null;\n    }\n}\n/**\r\n * Check if analysis exists\r\n * @param analysisId Analysis ID\r\n * @param baseDir Base directory for storage\r\n * @returns True if analysis exists\r\n */ function analysisExists(analysisId, baseDir = process.env.VERCEL ? '/tmp/analysis' : (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'tmp', 'analysis')) {\n    // On Vercel, files are not stored persistently\n    if (process.env.VERCEL) {\n        console.log('File existence check not available on Vercel:', analysisId);\n        return false;\n    }\n    const analysisDir = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(baseDir, analysisId);\n    return (0,fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(analysisDir);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUMsVUFBVUQsYUFBYUQsVUFBVTtRQUN2QyxPQUFPRTtJQUNULEVBQUUsT0FBT1IsT0FBTztRQUNkQyxRQUFRQyxJQUFJLENBQUMsQ0FBQywrQkFBK0IsRUFBRWpELFdBQVcsRUFBRSxFQUFFK0MsT0FBTztRQUNyRSxPQUFPO0lBQ1Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU1MsZUFDZHhELFVBQWtCLEVBQ2xCSSxVQUFrQkgsUUFBUUMsR0FBRyxDQUFDQyxNQUFNLEdBQUcsa0JBQWtCVCwwQ0FBSUEsQ0FBQ08sUUFBUUksR0FBRyxJQUFJLE9BQU8sV0FBVztJQUUvRiwrQ0FBK0M7SUFDL0MsSUFBSUosUUFBUUMsR0FBRyxDQUFDQyxNQUFNLEVBQUU7UUFDdEI2QyxRQUFRSSxHQUFHLENBQUMsaURBQWlEcEQ7UUFDN0QsT0FBTztJQUNUO0lBRUEsTUFBTVMsY0FBY2YsMENBQUlBLENBQUNVLFNBQVNKO0lBQ2xDLE9BQU9QLDhDQUFVQSxDQUFDZ0I7QUFDcEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQ2toYWRhclxcRG93bmxvYWRzXFxBSV9CYXNlbGluZV9NYXBcXGxpYlxcZmlsZXNcXHN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdyaXRlRmlsZVN5bmMsIG1rZGlyU3luYywgZXhpc3RzU3luYyB9IGZyb20gJ2ZzJztcclxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgeyByYW5kb21VVUlEIH0gZnJvbSAnY3J5cHRvJztcclxuaW1wb3J0IFBhcGEgZnJvbSAncGFwYXBhcnNlJztcclxuaW1wb3J0IHsgUmVwb3J0LCBDU1ZSb3cgfSBmcm9tICcuLi9hbmFseXNpcy9iYXNlbGluZS50eXBlcyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0b3JlZEFydGlmYWN0cyB7XHJcbiAganNvblVybDogc3RyaW5nO1xyXG4gIGNzdlVybDogc3RyaW5nO1xyXG4gIGFuYWx5c2lzSWQ6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdG9yYWdlT3B0aW9ucyB7XHJcbiAgYmFzZURpcj86IHN0cmluZztcclxuICBwdWJsaWNVcmw/OiBzdHJpbmc7XHJcbiAgdHRsPzogbnVtYmVyOyAvLyBUaW1lIHRvIGxpdmUgaW4gbWlsbGlzZWNvbmRzXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdG9yZSBhbmFseXNpcyByZXN1bHRzIGFuZCByZXR1cm4gcHVibGljIFVSTHNcclxuICogQHBhcmFtIHJlcG9ydCBBbmFseXNpcyByZXBvcnRcclxuICogQHBhcmFtIG9wdGlvbnMgU3RvcmFnZSBvcHRpb25zXHJcbiAqIEByZXR1cm5zIFN0b3JlZCBhcnRpZmFjdHMgd2l0aCBwdWJsaWMgVVJMc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlQW5hbHlzaXNSZXN1bHRzKFxyXG4gIHJlcG9ydDogUmVwb3J0LFxyXG4gIG9wdGlvbnM6IFN0b3JhZ2VPcHRpb25zID0ge31cclxuKTogU3RvcmVkQXJ0aWZhY3RzIHtcclxuICBjb25zdCBhbmFseXNpc0lkID0gcmFuZG9tVVVJRCgpO1xyXG4gIFxyXG4gIC8vIE9uIGxvY2FsIGRldmVsb3BtZW50LCBzdG9yZSBmaWxlcyBvbiBkaXNrXHJcbiAgaWYgKCFwcm9jZXNzLmVudi5WRVJDRUwpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgYmFzZURpciA9IGpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdhbmFseXNpcycpLFxyXG4gICAgICBwdWJsaWNVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyxcclxuICAgICAgdHRsID0gMjQgKiA2MCAqIDYwICogMTAwMCwgLy8gMjQgaG91cnNcclxuICAgIH0gPSBvcHRpb25zO1xyXG5cclxuICAgIC8vIEVuc3VyZSBiYXNlIGRpcmVjdG9yeSBleGlzdHNcclxuICAgIGlmICghZXhpc3RzU3luYyhiYXNlRGlyKSkge1xyXG4gICAgICBta2RpclN5bmMoYmFzZURpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGFuYWx5c2lzIGRpcmVjdG9yeVxyXG4gICAgY29uc3QgYW5hbHlzaXNEaXIgPSBqb2luKGJhc2VEaXIsIGFuYWx5c2lzSWQpO1xyXG4gICAgaWYgKCFleGlzdHNTeW5jKGFuYWx5c2lzRGlyKSkge1xyXG4gICAgICBta2RpclN5bmMoYW5hbHlzaXNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0b3JlIEpTT04gcmVwb3J0XHJcbiAgICBjb25zdCBqc29uUGF0aCA9IGpvaW4oYW5hbHlzaXNEaXIsICdyZXBvcnQuanNvbicpO1xyXG4gICAgd3JpdGVGaWxlU3luYyhqc29uUGF0aCwgSlNPTi5zdHJpbmdpZnkocmVwb3J0LCBudWxsLCAyKSk7XHJcblxyXG4gICAgLy8gU3RvcmUgQ1NWIHJlcG9ydFxyXG4gICAgY29uc3QgY3N2UGF0aCA9IGpvaW4oYW5hbHlzaXNEaXIsICdyZXBvcnQuY3N2Jyk7XHJcbiAgICBjb25zdCBjc3ZDb250ZW50ID0gZ2VuZXJhdGVDU1YocmVwb3J0KTtcclxuICAgIHdyaXRlRmlsZVN5bmMoY3N2UGF0aCwgY3N2Q29udGVudCk7XHJcblxyXG4gICAgLy8gU2NoZWR1bGUgY2xlYW51cFxyXG4gICAgc2NoZWR1bGVDbGVhbnVwKGFuYWx5c2lzRGlyLCB0dGwpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGpzb25Vcmw6IGAke3B1YmxpY1VybH0vYXBpL2FuYWx5emUvJHthbmFseXNpc0lkfT9mb3JtYXQ9anNvbmAsXHJcbiAgICAgIGNzdlVybDogYCR7cHVibGljVXJsfS9hcGkvYW5hbHl6ZS8ke2FuYWx5c2lzSWR9P2Zvcm1hdD1jc3ZgLFxyXG4gICAgICBhbmFseXNpc0lkLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIE9uIFZlcmNlbCwgcmV0dXJuIGluLW1lbW9yeSBVUkxzIChubyBmaWxlIHN0b3JhZ2UpXHJcbiAgY29uc3QgcHVibGljVXJsID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX1VSTCA/IGBodHRwczovLyR7cHJvY2Vzcy5lbnYuVkVSQ0VMX1VSTH1gIDogJ2h0dHBzOi8veW91ci1hcHAudmVyY2VsLmFwcCc7XHJcbiAgcmV0dXJuIHtcclxuICAgIGpzb25Vcmw6IGAke3B1YmxpY1VybH0vYXBpL2FuYWx5emUvJHthbmFseXNpc0lkfT9mb3JtYXQ9anNvbmAsXHJcbiAgICBjc3ZVcmw6IGAke3B1YmxpY1VybH0vYXBpL2FuYWx5emUvJHthbmFseXNpc0lkfT9mb3JtYXQ9Y3N2YCxcclxuICAgIGFuYWx5c2lzSWQsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIENTViBjb250ZW50IGZyb20gcmVwb3J0XHJcbiAqIEBwYXJhbSByZXBvcnQgQW5hbHlzaXMgcmVwb3J0XHJcbiAqIEByZXR1cm5zIENTViBjb250ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNTVihyZXBvcnQ6IFJlcG9ydCk6IHN0cmluZyB7XHJcbiAgY29uc3Qgcm93czogQ1NWUm93W10gPSBbXTtcclxuXHJcbiAgLy8gQWRkIGZpbmRpbmdzXHJcbiAgZm9yIChjb25zdCBmaW5kaW5nIG9mIHJlcG9ydC5maW5kaW5ncykge1xyXG4gICAgaWYgKGZpbmRpbmcua2luZCA9PT0gJ2RlcGVuZGVuY3knKSB7XHJcbiAgICAgIHJvd3MucHVzaCh7XHJcbiAgICAgICAgS2luZDogJ0RlcGVuZGVuY3knLFxyXG4gICAgICAgIExhbmd1YWdlOiBmaW5kaW5nLmxhbmcsXHJcbiAgICAgICAgQ29tcG9uZW50OiBmaW5kaW5nLmNvbXBvbmVudCxcclxuICAgICAgICAnRm91bmQgVmVyc2lvbic6IGZpbmRpbmcuZm91bmRWZXJzaW9uIHx8ICcnLFxyXG4gICAgICAgICdSZXF1aXJlZCBWZXJzaW9uJzogZmluZGluZy5iYXNlbGluZVJlcXVpcmVkIHx8ICcnLFxyXG4gICAgICAgIFN0YXR1czogZmluZGluZy5zdGF0dXMsXHJcbiAgICAgICAgUmVhc29uOiBmaW5kaW5nLnJlYXNvbixcclxuICAgICAgICBGaWxlOiBmaW5kaW5nLmZpbGUsXHJcbiAgICAgICAgTGluZTogJycsXHJcbiAgICAgICAgJ1F1aWNrIEZpeCc6IGZpbmRpbmcucXVpY2tGaXggfHwgJycsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcm93cy5wdXNoKHtcclxuICAgICAgICBLaW5kOiAnUGF0dGVybicsXHJcbiAgICAgICAgTGFuZ3VhZ2U6IGZpbmRpbmcubGFuZyxcclxuICAgICAgICBDb21wb25lbnQ6ICcnLFxyXG4gICAgICAgICdGb3VuZCBWZXJzaW9uJzogJycsXHJcbiAgICAgICAgU3RhdHVzOiBmaW5kaW5nLnN0YXR1cyxcclxuICAgICAgICBSZWFzb246IGZpbmRpbmcuaXNzdWUsXHJcbiAgICAgICAgRmlsZTogZmluZGluZy5maWxlLFxyXG4gICAgICAgIExpbmU6IGZpbmRpbmcubGluZS50b1N0cmluZygpLFxyXG4gICAgICAgICdRdWljayBGaXgnOiBmaW5kaW5nLnF1aWNrRml4IHx8ICcnLFxyXG4gICAgICAgICdSZXF1aXJlZCBWZXJzaW9uJzogJycsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFBhcGEudW5wYXJzZShyb3dzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNjaGVkdWxlIGNsZWFudXAgb2YgYW5hbHlzaXMgZmlsZXNcclxuICogQHBhcmFtIGFuYWx5c2lzRGlyIEFuYWx5c2lzIGRpcmVjdG9yeSBwYXRoXHJcbiAqIEBwYXJhbSB0dGwgVGltZSB0byBsaXZlIGluIG1pbGxpc2Vjb25kc1xyXG4gKi9cclxuZnVuY3Rpb24gc2NoZWR1bGVDbGVhbnVwKGFuYWx5c2lzRGlyOiBzdHJpbmcsIHR0bDogbnVtYmVyKTogdm9pZCB7XHJcbiAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoZXhpc3RzU3luYyhhbmFseXNpc0RpcikpIHtcclxuICAgICAgICAvLyBSZW1vdmUgZGlyZWN0b3J5IGFuZCBhbGwgY29udGVudHNcclxuICAgICAgICBjb25zdCB7IHJtU3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgICAgIHJtU3luYyhhbmFseXNpc0RpciwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBjbGVhbnVwIGFuYWx5c2lzIGRpcmVjdG9yeSAke2FuYWx5c2lzRGlyfTogJHtlcnJvcn1gKTtcclxuICAgIH1cclxuICB9LCB0dGwpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHN0b3JlZCBhbmFseXNpcyByZXBvcnRcclxuICogQHBhcmFtIGFuYWx5c2lzSWQgQW5hbHlzaXMgSURcclxuICogQHBhcmFtIGZvcm1hdCBGb3JtYXQgKGpzb24gb3IgY3N2KVxyXG4gKiBAcGFyYW0gYmFzZURpciBCYXNlIGRpcmVjdG9yeSBmb3Igc3RvcmFnZVxyXG4gKiBAcmV0dXJucyBSZXBvcnQgY29udGVudCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JlZEFuYWx5c2lzKFxyXG4gIGFuYWx5c2lzSWQ6IHN0cmluZyxcclxuICBmb3JtYXQ6ICdqc29uJyB8ICdjc3YnID0gJ2pzb24nLFxyXG4gIGJhc2VEaXI6IHN0cmluZyA9IHByb2Nlc3MuZW52LlZFUkNFTCA/ICcvdG1wL2FuYWx5c2lzJyA6IGpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdhbmFseXNpcycpXHJcbik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gIC8vIE9uIFZlcmNlbCwgZmlsZXMgYXJlIG5vdCBzdG9yZWQgcGVyc2lzdGVudGx5XHJcbiAgaWYgKHByb2Nlc3MuZW52LlZFUkNFTCkge1xyXG4gICAgY29uc29sZS5sb2coJ0ZpbGUgc3RvcmFnZSBub3QgYXZhaWxhYmxlIG9uIFZlcmNlbDonLCBhbmFseXNpc0lkKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGFuYWx5c2lzRGlyID0gam9pbihiYXNlRGlyLCBhbmFseXNpc0lkKTtcclxuICAgIGNvbnN0IGZpbGVQYXRoID0gam9pbihhbmFseXNpc0RpciwgYHJlcG9ydC4ke2Zvcm1hdH1gKTtcclxuICAgIFxyXG4gICAgaWYgKCFleGlzdHNTeW5jKGZpbGVQYXRoKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHJlYWRGaWxlU3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgY29uc3QgY29udGVudCA9IHJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byByZWFkIHN0b3JlZCBhbmFseXNpcyAke2FuYWx5c2lzSWR9OiAke2Vycm9yfWApO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYW5hbHlzaXMgZXhpc3RzXHJcbiAqIEBwYXJhbSBhbmFseXNpc0lkIEFuYWx5c2lzIElEXHJcbiAqIEBwYXJhbSBiYXNlRGlyIEJhc2UgZGlyZWN0b3J5IGZvciBzdG9yYWdlXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgYW5hbHlzaXMgZXhpc3RzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYW5hbHlzaXNFeGlzdHMoXHJcbiAgYW5hbHlzaXNJZDogc3RyaW5nLFxyXG4gIGJhc2VEaXI6IHN0cmluZyA9IHByb2Nlc3MuZW52LlZFUkNFTCA/ICcvdG1wL2FuYWx5c2lzJyA6IGpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RtcCcsICdhbmFseXNpcycpXHJcbik6IGJvb2xlYW4ge1xyXG4gIC8vIE9uIFZlcmNlbCwgZmlsZXMgYXJlIG5vdCBzdG9yZWQgcGVyc2lzdGVudGx5XHJcbiAgaWYgKHByb2Nlc3MuZW52LlZFUkNFTCkge1xyXG4gICAgY29uc29sZS5sb2coJ0ZpbGUgZXhpc3RlbmNlIGNoZWNrIG5vdCBhdmFpbGFibGUgb24gVmVyY2VsOicsIGFuYWx5c2lzSWQpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYW5hbHlzaXNEaXIgPSBqb2luKGJhc2VEaXIsIGFuYWx5c2lzSWQpO1xyXG4gIHJldHVybiBleGlzdHNTeW5jKGFuYWx5c2lzRGlyKTtcclxufSJdLCJuYW1lcyI6WyJ3cml0ZUZpbGVTeW5jIiwibWtkaXJTeW5jIiwiZXhpc3RzU3luYyIsImpvaW4iLCJyYW5kb21VVUlEIiwiUGFwYSIsInN0b3JlQW5hbHlzaXNSZXN1bHRzIiwicmVwb3J0Iiwib3B0aW9ucyIsImFuYWx5c2lzSWQiLCJwcm9jZXNzIiwiZW52IiwiVkVSQ0VMIiwiYmFzZURpciIsImN3ZCIsInB1YmxpY1VybCIsInR0bCIsInJlY3Vyc2l2ZSIsImFuYWx5c2lzRGlyIiwianNvblBhdGgiLCJKU09OIiwic3RyaW5naWZ5IiwiY3N2UGF0aCIsImNzdkNvbnRlbnQiLCJnZW5lcmF0ZUNTViIsInNjaGVkdWxlQ2xlYW51cCIsImpzb25VcmwiLCJjc3ZVcmwiLCJWRVJDRUxfVVJMIiwicm93cyIsImZpbmRpbmciLCJmaW5kaW5ncyIsImtpbmQiLCJwdXNoIiwiS2luZCIsIkxhbmd1YWdlIiwibGFuZyIsIkNvbXBvbmVudCIsImNvbXBvbmVudCIsImZvdW5kVmVyc2lvbiIsImJhc2VsaW5lUmVxdWlyZWQiLCJTdGF0dXMiLCJzdGF0dXMiLCJSZWFzb24iLCJyZWFzb24iLCJGaWxlIiwiZmlsZSIsIkxpbmUiLCJxdWlja0ZpeCIsImlzc3VlIiwibGluZSIsInRvU3RyaW5nIiwidW5wYXJzZSIsInNldFRpbWVvdXQiLCJybVN5bmMiLCJmb3JjZSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJnZXRTdG9yZWRBbmFseXNpcyIsImZvcm1hdCIsImxvZyIsImZpbGVQYXRoIiwicmVhZEZpbGVTeW5jIiwiY29udGVudCIsImFuYWx5c2lzRXhpc3RzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/files/store.ts\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fanalyze%2Froute&page=%2Fapi%2Fanalyze%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze%2Froute.ts&appDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fanalyze%2Froute&page=%2Fapi%2Fanalyze%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze%2Froute.ts&appDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/./node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/./node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var C_Users_Ckhadar_Downloads_AI_Baseline_Map_app_api_analyze_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./app/api/analyze/route.ts */ \"(rsc)/./app/api/analyze/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/analyze/route\",\n        pathname: \"/api/analyze\",\n        filename: \"route\",\n        bundlePath: \"app/api/analyze/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"C:\\\\Users\\\\Ckhadar\\\\Downloads\\\\AI_Baseline_Map\\\\app\\\\api\\\\analyze\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_Ckhadar_Downloads_AI_Baseline_Map_app_api_analyze_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/analyze/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZhbmFseXplJTJGcm91dGUmcGFnZT0lMkZhcGklMkZhbmFseXplJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGYW5hbHl6ZSUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNDa2hhZGFyJTVDRG93bmxvYWRzJTVDQUlfQmFzZWxpbmVfTWFwJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1DJTNBJTVDVXNlcnMlNUNDa2hhZGFyJTVDRG93bmxvYWRzJTVDQUlfQmFzZWxpbmVfTWFwJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PXN0YW5kYWxvbmUmcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCZpc0dsb2JhbE5vdEZvdW5kRW5hYmxlZD0hIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ3FCO0FBQ2Q7QUFDUztBQUNPO0FBQ0s7QUFDbUM7QUFDakQ7QUFDTztBQUNmO0FBQ3NDO0FBQ3pCO0FBQ007QUFDQztBQUNoQjtBQUNzQztBQUN4RztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhLE9BQW9DLElBQUksQ0FBRTtBQUN2RCx3QkFBd0IsTUFBdUM7QUFDL0Q7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7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WTtBQUM5QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2RUFBNkUsZ0ZBQWM7QUFDM0YsaUNBQWlDLFFBQVEsRUFBRSxRQUFRO0FBQ25ELDBCQUEwQix1RUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTiw2QkFBNkIsNkZBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkZBQW1CO0FBQ3JEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZFQUFZO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCB7IGdldFJlcXVlc3RNZXRhIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcmVxdWVzdC1tZXRhXCI7XG5pbXBvcnQgeyBnZXRUcmFjZXIsIFNwYW5LaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL3RyYWNlclwiO1xuaW1wb3J0IHsgbm9ybWFsaXplQXBwUGF0aCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYXBwLXBhdGhzXCI7XG5pbXBvcnQgeyBOb2RlTmV4dFJlcXVlc3QsIE5vZGVOZXh0UmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9iYXNlLWh0dHAvbm9kZVwiO1xuaW1wb3J0IHsgTmV4dFJlcXVlc3RBZGFwdGVyLCBzaWduYWxGcm9tTm9kZVJlc3BvbnNlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL25leHQtcmVxdWVzdFwiO1xuaW1wb3J0IHsgQmFzZVNlcnZlclNwYW4gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBnZXRSZXZhbGlkYXRlUmVhc29uIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvaW5zdHJ1bWVudGF0aW9uL3V0aWxzXCI7XG5pbXBvcnQgeyBzZW5kUmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9zZW5kLXJlc3BvbnNlXCI7XG5pbXBvcnQgeyBmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMsIHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci93ZWIvdXRpbHNcIjtcbmltcG9ydCB7IGdldENhY2hlQ29udHJvbEhlYWRlciB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9jYWNoZS1jb250cm9sXCI7XG5pbXBvcnQgeyBJTkZJTklURV9DQUNIRSwgTkVYVF9DQUNIRV9UQUdTX0hFQURFUiB9IGZyb20gXCJuZXh0L2Rpc3QvbGliL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgTm9GYWxsYmFja0Vycm9yIH0gZnJvbSBcIm5leHQvZGlzdC9zaGFyZWQvbGliL25vLWZhbGxiYWNrLWVycm9yLmV4dGVybmFsXCI7XG5pbXBvcnQgeyBDYWNoZWRSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZXNwb25zZS1jYWNoZVwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIkM6XFxcXFVzZXJzXFxcXENraGFkYXJcXFxcRG93bmxvYWRzXFxcXEFJX0Jhc2VsaW5lX01hcFxcXFxhcHBcXFxcYXBpXFxcXGFuYWx5emVcXFxccm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwic3RhbmRhbG9uZVwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9hbmFseXplL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvYW5hbHl6ZVwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvYW5hbHl6ZS9yb3V0ZVwiXG4gICAgfSxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcmVsYXRpdmVQcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJycsXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJDOlxcXFxVc2Vyc1xcXFxDa2hhZGFyXFxcXERvd25sb2Fkc1xcXFxBSV9CYXNlbGluZV9NYXBcXFxcYXBwXFxcXGFwaVxcXFxhbmFseXplXFxcXHJvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICAgICAgd29ya1VuaXRBc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIHBhdGNoRmV0Y2gsICB9O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMsIGN0eCkge1xuICAgIHZhciBfbmV4dENvbmZpZ19leHBlcmltZW50YWw7XG4gICAgbGV0IHNyY1BhZ2UgPSBcIi9hcGkvYW5hbHl6ZS9yb3V0ZVwiO1xuICAgIC8vIHR1cmJvcGFjayBkb2Vzbid0IG5vcm1hbGl6ZSBgL2luZGV4YCBpbiB0aGUgcGFnZSBuYW1lXG4gICAgLy8gc28gd2UgbmVlZCB0byB0byBwcm9jZXNzIGR5bmFtaWMgcm91dGVzIHByb3Blcmx5XG4gICAgLy8gVE9ETzogZml4IHR1cmJvcGFjayBwcm92aWRpbmcgZGlmZmVyaW5nIHZhbHVlIGZyb20gd2VicGFja1xuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgc3JjUGFnZSA9IHNyY1BhZ2UucmVwbGFjZSgvXFwvaW5kZXgkLywgJycpIHx8ICcvJztcbiAgICB9IGVsc2UgaWYgKHNyY1BhZ2UgPT09ICcvaW5kZXgnKSB7XG4gICAgICAgIC8vIHdlIGFsd2F5cyBub3JtYWxpemUgL2luZGV4IHNwZWNpZmljYWxseVxuICAgICAgICBzcmNQYWdlID0gJy8nO1xuICAgIH1cbiAgICBjb25zdCBtdWx0aVpvbmVEcmFmdE1vZGUgPSBwcm9jZXNzLmVudi5fX05FWFRfTVVMVElfWk9ORV9EUkFGVF9NT0RFO1xuICAgIGNvbnN0IHByZXBhcmVSZXN1bHQgPSBhd2FpdCByb3V0ZU1vZHVsZS5wcmVwYXJlKHJlcSwgcmVzLCB7XG4gICAgICAgIHNyY1BhZ2UsXG4gICAgICAgIG11bHRpWm9uZURyYWZ0TW9kZVxuICAgIH0pO1xuICAgIGlmICghcHJlcGFyZVJlc3VsdCkge1xuICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQwMDtcbiAgICAgICAgcmVzLmVuZCgnQmFkIFJlcXVlc3QnKTtcbiAgICAgICAgY3R4LndhaXRVbnRpbCA9PSBudWxsID8gdm9pZCAwIDogY3R4LndhaXRVbnRpbC5jYWxsKGN0eCwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBidWlsZElkLCBwYXJhbXMsIG5leHRDb25maWcsIGlzRHJhZnRNb2RlLCBwcmVyZW5kZXJNYW5pZmVzdCwgcm91dGVyU2VydmVyQ29udGV4dCwgaXNPbkRlbWFuZFJldmFsaWRhdGUsIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLCByZXNvbHZlZFBhdGhuYW1lIH0gPSBwcmVwYXJlUmVzdWx0O1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRTcmNQYWdlID0gbm9ybWFsaXplQXBwUGF0aChzcmNQYWdlKTtcbiAgICBsZXQgaXNJc3IgPSBCb29sZWFuKHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdIHx8IHByZXJlbmRlck1hbmlmZXN0LnJvdXRlc1tyZXNvbHZlZFBhdGhuYW1lXSk7XG4gICAgaWYgKGlzSXNyICYmICFpc0RyYWZ0TW9kZSkge1xuICAgICAgICBjb25zdCBpc1ByZXJlbmRlcmVkID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgICAgICBjb25zdCBwcmVyZW5kZXJJbmZvID0gcHJlcmVuZGVyTWFuaWZlc3QuZHluYW1pY1JvdXRlc1tub3JtYWxpemVkU3JjUGFnZV07XG4gICAgICAgIGlmIChwcmVyZW5kZXJJbmZvKSB7XG4gICAgICAgICAgICBpZiAocHJlcmVuZGVySW5mby5mYWxsYmFjayA9PT0gZmFsc2UgJiYgIWlzUHJlcmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9GYWxsYmFja0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNhY2hlS2V5ID0gbnVsbDtcbiAgICBpZiAoaXNJc3IgJiYgIXJvdXRlTW9kdWxlLmlzRGV2ICYmICFpc0RyYWZ0TW9kZSkge1xuICAgICAgICBjYWNoZUtleSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgICAgIC8vIGVuc3VyZSAvaW5kZXggYW5kIC8gaXMgbm9ybWFsaXplZCB0byBvbmUga2V5XG4gICAgICAgIGNhY2hlS2V5ID0gY2FjaGVLZXkgPT09ICcvaW5kZXgnID8gJy8nIDogY2FjaGVLZXk7XG4gICAgfVxuICAgIGNvbnN0IHN1cHBvcnRzRHluYW1pY1Jlc3BvbnNlID0gLy8gSWYgd2UncmUgaW4gZGV2ZWxvcG1lbnQsIHdlIGFsd2F5cyBzdXBwb3J0IGR5bmFtaWMgSFRNTFxuICAgIHJvdXRlTW9kdWxlLmlzRGV2ID09PSB0cnVlIHx8IC8vIElmIHRoaXMgaXMgbm90IFNTRyBvciBkb2VzIG5vdCBoYXZlIHN0YXRpYyBwYXRocywgdGhlbiBpdCBzdXBwb3J0c1xuICAgIC8vIGR5bmFtaWMgSFRNTC5cbiAgICAhaXNJc3I7XG4gICAgLy8gVGhpcyBpcyBhIHJldmFsaWRhdGlvbiByZXF1ZXN0IGlmIHRoZSByZXF1ZXN0IGlzIGZvciBhIHN0YXRpY1xuICAgIC8vIHBhZ2UgYW5kIGl0IGlzIG5vdCBiZWluZyByZXN1bWVkIGZyb20gYSBwb3N0cG9uZWQgcmVuZGVyIGFuZFxuICAgIC8vIGl0IGlzIG5vdCBhIGR5bmFtaWMgUlNDIHJlcXVlc3QgdGhlbiBpdCBpcyBhIHJldmFsaWRhdGlvblxuICAgIC8vIHJlcXVlc3QuXG4gICAgY29uc3QgaXNSZXZhbGlkYXRlID0gaXNJc3IgJiYgIXN1cHBvcnRzRHluYW1pY1Jlc3BvbnNlO1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlcS5tZXRob2QgfHwgJ0dFVCc7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG4gICAgY29uc3QgYWN0aXZlU3BhbiA9IHRyYWNlci5nZXRBY3RpdmVTY29wZVNwYW4oKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHByZXJlbmRlck1hbmlmZXN0LFxuICAgICAgICByZW5kZXJPcHRzOiB7XG4gICAgICAgICAgICBleHBlcmltZW50YWw6IHtcbiAgICAgICAgICAgICAgICBjYWNoZUNvbXBvbmVudHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuY2FjaGVDb21wb25lbnRzKSxcbiAgICAgICAgICAgICAgICBhdXRoSW50ZXJydXB0czogQm9vbGVhbihuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5hdXRoSW50ZXJydXB0cylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSxcbiAgICAgICAgICAgIGluY3JlbWVudGFsQ2FjaGU6IGdldFJlcXVlc3RNZXRhKHJlcSwgJ2luY3JlbWVudGFsQ2FjaGUnKSxcbiAgICAgICAgICAgIGNhY2hlTGlmZVByb2ZpbGVzOiAoX25leHRDb25maWdfZXhwZXJpbWVudGFsID0gbmV4dENvbmZpZy5leHBlcmltZW50YWwpID09IG51bGwgPyB2b2lkIDAgOiBfbmV4dENvbmZpZ19leHBlcmltZW50YWwuY2FjaGVMaWZlLFxuICAgICAgICAgICAgaXNSZXZhbGlkYXRlLFxuICAgICAgICAgICAgd2FpdFVudGlsOiBjdHgud2FpdFVudGlsLFxuICAgICAgICAgICAgb25DbG9zZTogKGNiKT0+e1xuICAgICAgICAgICAgICAgIHJlcy5vbignY2xvc2UnLCBjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BZnRlclRhc2tFcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb25JbnN0cnVtZW50YXRpb25SZXF1ZXN0RXJyb3I6IChlcnJvciwgX3JlcXVlc3QsIGVycm9yQ29udGV4dCk9PnJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyb3IsIGVycm9yQ29udGV4dCwgcm91dGVyU2VydmVyQ29udGV4dClcbiAgICAgICAgfSxcbiAgICAgICAgc2hhcmVkQ29udGV4dDoge1xuICAgICAgICAgICAgYnVpbGRJZFxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub2RlTmV4dFJlcSA9IG5ldyBOb2RlTmV4dFJlcXVlc3QocmVxKTtcbiAgICBjb25zdCBub2RlTmV4dFJlcyA9IG5ldyBOb2RlTmV4dFJlc3BvbnNlKHJlcyk7XG4gICAgY29uc3QgbmV4dFJlcSA9IE5leHRSZXF1ZXN0QWRhcHRlci5mcm9tTm9kZU5leHRSZXF1ZXN0KG5vZGVOZXh0UmVxLCBzaWduYWxGcm9tTm9kZVJlc3BvbnNlKHJlcykpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGludm9rZVJvdXRlTW9kdWxlID0gYXN5bmMgKHNwYW4pPT57XG4gICAgICAgICAgICByZXR1cm4gcm91dGVNb2R1bGUuaGFuZGxlKG5leHRSZXEsIGNvbnRleHQpLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXNwYW4pIHJldHVybjtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAnaHR0cC5zdGF0dXNfY29kZSc6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAnbmV4dC5yc2MnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RTcGFuQXR0cmlidXRlcyA9IHRyYWNlci5nZXRSb290U3BhbkF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBnZXQgYXR0cmlidXRlcywgcHJvYmFibHkgT1RFTCBpcyBub3QgZW5hYmxlZFxuICAgICAgICAgICAgICAgIGlmICghcm9vdFNwYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RTcGFuQXR0cmlidXRlcy5nZXQoJ25leHQuc3Bhbl90eXBlJykgIT09IEJhc2VTZXJ2ZXJTcGFuLmhhbmRsZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmV4cGVjdGVkIHJvb3Qgc3BhbiB0eXBlICcke3Jvb3RTcGFuQXR0cmlidXRlcy5nZXQoJ25leHQuc3Bhbl90eXBlJyl9Jy4gUGxlYXNlIHJlcG9ydCB0aGlzIE5leHQuanMgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGUgPSByb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnJvdXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBgJHttZXRob2R9ICR7cm91dGV9YDtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnJvdXRlJzogcm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25leHQuc3Bhbl9uYW1lJzogbmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi51cGRhdGVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShgJHttZXRob2R9ICR7cmVxLnVybH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSBhc3luYyAoY3VycmVudFNwYW4pPT57XG4gICAgICAgICAgICB2YXIgX2NhY2hlRW50cnlfdmFsdWU7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUdlbmVyYXRvciA9IGFzeW5jICh7IHByZXZpb3VzQ2FjaGVFbnRyeSB9KT0+e1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc09uRGVtYW5kUmV2YWxpZGF0ZSAmJiByZXZhbGlkYXRlT25seUdlbmVyYXRlZCAmJiAhcHJldmlvdXNDYWNoZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQwNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uLWRlbWFuZCByZXZhbGlkYXRlIGFsd2F5cyBzZXRzIHRoaXMgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKCd4LW5leHRqcy1jYWNoZScsICdSRVZBTElEQVRFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmVuZCgnVGhpcyBwYWdlIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBpbnZva2VSb3V0ZU1vZHVsZShjdXJyZW50U3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5mZXRjaE1ldHJpY3MgPSBjb250ZXh0LnJlbmRlck9wdHMuZmV0Y2hNZXRyaWNzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGVuZGluZ1dhaXRVbnRpbCA9IGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsO1xuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHVzaW5nIHByb3ZpZGVkIHdhaXRVbnRpbCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQncyBub3Qgd2UgZmFsbGJhY2sgdG8gc2VuZFJlc3BvbnNlJ3MgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdXYWl0VW50aWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHgud2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LndhaXRVbnRpbChwZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nV2FpdFVudGlsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlVGFncyA9IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRUYWdzO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWMgcmVzcG9uc2UsIHdlIGNhbiBjYWNoZSBpdCBzbyBsb25nXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGl0J3Mgbm90IGVkZ2UuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0lzcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGhlYWRlcnMgZnJvbSB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW05FWFRfQ0FDSEVfVEFHU19IRUFERVJdID0gY2FjaGVUYWdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXJzWydjb250ZW50LXR5cGUnXSAmJiBibG9iLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IGJsb2IudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdGUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGUgPT09ICd1bmRlZmluZWQnIHx8IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID49IElORklOSVRFX0NBQ0hFID8gZmFsc2UgOiBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cGlyZSA9IHR5cGVvZiBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkRXhwaXJlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkRXhwaXJlID49IElORklOSVRFX0NBQ0hFID8gdW5kZWZpbmVkIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgY2FjaGUgZW50cnkgZm9yIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlRW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogQ2FjaGVkUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEJ1ZmZlci5mcm9tKGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kIHJlc3BvbnNlIHdpdGhvdXQgY2FjaGluZyBpZiBub3QgSVNSXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCByZXNwb25zZSwgY29udGV4dC5yZW5kZXJPcHRzLnBlbmRpbmdXYWl0VW50aWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGJhY2tncm91bmQgcmV2YWxpZGF0ZSB3ZSBuZWVkIHRvIHJlcG9ydFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBlcnJvciBoZXJlIGFzIGl0IHdvbid0IGJlIGJ1YmJsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQ2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXNDYWNoZUVudHJ5LmlzU3RhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogc3JjUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVR5cGU6ICdyb3V0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZVJlYXNvbjogZ2V0UmV2YWxpZGF0ZVJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcm91dGVyU2VydmVyQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0gYXdhaXQgcm91dGVNb2R1bGUuaGFuZGxlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgIHJvdXRlS2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgICAgICAgICBpc1JvdXRlUFBSRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VHZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgd2FpdFVudGlsOiBjdHgud2FpdFVudGlsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNyZWF0ZSBhIGNhY2hlRW50cnkgZm9yIElTUlxuICAgICAgICAgICAgaWYgKCFpc0lzcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChjYWNoZUVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAoX2NhY2hlRW50cnlfdmFsdWUgPSBjYWNoZUVudHJ5LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2NhY2hlRW50cnlfdmFsdWUua2luZCkgIT09IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2NhY2hlRW50cnlfdmFsdWUxO1xuICAgICAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoYEludmFyaWFudDogYXBwLXJvdXRlIHJlY2VpdmVkIGludmFsaWQgY2FjaGUgZW50cnkgJHtjYWNoZUVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAoX2NhY2hlRW50cnlfdmFsdWUxID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlMS5raW5kfWApLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTcwMVwiLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykpIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKCd4LW5leHRqcy1jYWNoZScsIGlzT25EZW1hbmRSZXZhbGlkYXRlID8gJ1JFVkFMSURBVEVEJyA6IGNhY2hlRW50cnkuaXNNaXNzID8gJ01JU1MnIDogY2FjaGVFbnRyeS5pc1N0YWxlID8gJ1NUQUxFJyA6ICdISVQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERyYWZ0IG1vZGUgc2hvdWxkIG5ldmVyIGJlIGNhY2hlZFxuICAgICAgICAgICAgaWYgKGlzRHJhZnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcignQ2FjaGUtQ29udHJvbCcsICdwcml2YXRlLCBuby1jYWNoZSwgbm8tc3RvcmUsIG1heC1hZ2U9MCwgbXVzdC1yZXZhbGlkYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKGNhY2hlRW50cnkudmFsdWUuaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAoIShnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpICYmIGlzSXNyKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuZGVsZXRlKE5FWFRfQ0FDSEVfVEFHU19IRUFERVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgY2FjaGUgY29udHJvbCBpcyBhbHJlYWR5IHNldCBvbiB0aGUgcmVzcG9uc2Ugd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlIGl0IHRvIGFsbG93IHVzZXJzIHRvIGN1c3RvbWl6ZSBpdCB2aWEgbmV4dC5jb25maWdcbiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmNhY2hlQ29udHJvbCAmJiAhcmVzLmdldEhlYWRlcignQ2FjaGUtQ29udHJvbCcpICYmICFoZWFkZXJzLmdldCgnQ2FjaGUtQ29udHJvbCcpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoJ0NhY2hlLUNvbnRyb2wnLCBnZXRDYWNoZUNvbnRyb2xIZWFkZXIoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHNlbmRSZXNwb25zZShub2RlTmV4dFJlcSwgbm9kZU5leHRSZXMsIG5ldyBSZXNwb25zZShjYWNoZUVudHJ5LnZhbHVlLmJvZHksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHN0YXR1czogY2FjaGVFbnRyeS52YWx1ZS5zdGF0dXMgfHwgMjAwXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogYWN0aXZlU3BhbiBjb2RlIHBhdGggaXMgZm9yIHdoZW4gd3JhcHBlZCBieVxuICAgICAgICAvLyBuZXh0LXNlcnZlciBjYW4gYmUgcmVtb3ZlZCB3aGVuIHRoaXMgaXMgbm8gbG9uZ2VyIHVzZWRcbiAgICAgICAgaWYgKGFjdGl2ZVNwYW4pIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZVJlc3BvbnNlKGFjdGl2ZVNwYW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdHJhY2VyLndpdGhQcm9wYWdhdGVkQ29udGV4dChyZXEuaGVhZGVycywgKCk9PnRyYWNlci50cmFjZShCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5OYW1lOiBgJHttZXRob2R9ICR7cmVxLnVybH1gLFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBTcGFuS2luZC5TRVJWRVIsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLm1ldGhvZCc6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLnRhcmdldCc6IHJlcS51cmxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGhhbmRsZVJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgTm9GYWxsYmFja0Vycm9yKSkge1xuICAgICAgICAgICAgYXdhaXQgcm91dGVNb2R1bGUub25SZXF1ZXN0RXJyb3IocmVxLCBlcnIsIHtcbiAgICAgICAgICAgICAgICByb3V0ZXJLaW5kOiAnQXBwIFJvdXRlcicsXG4gICAgICAgICAgICAgICAgcm91dGVQYXRoOiBub3JtYWxpemVkU3JjUGFnZSxcbiAgICAgICAgICAgICAgICByb3V0ZVR5cGU6ICdyb3V0ZScsXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZVJlYXNvbjogZ2V0UmV2YWxpZGF0ZVJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0aHJvdyBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgc2VydmluZyBlcnJvciBwYWdlXG4gICAgICAgIC8vIElmIHRoaXMgaXMgZHVyaW5nIHN0YXRpYyBnZW5lcmF0aW9uLCB0aHJvdyB0aGUgZXJyb3IgYWdhaW4uXG4gICAgICAgIGlmIChpc0lzcikgdGhyb3cgZXJyO1xuICAgICAgICAvLyBPdGhlcndpc2UsIHNlbmQgYSA1MDAgcmVzcG9uc2UuXG4gICAgICAgIGF3YWl0IHNlbmRSZXNwb25zZShub2RlTmV4dFJlcSwgbm9kZU5leHRSZXMsIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fanalyze%2Froute&page=%2Fapi%2Fanalyze%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze%2Froute.ts&appDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "./work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/zod","vendor-chunks/yaml","vendor-chunks/semver","vendor-chunks/papaparse"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fanalyze%2Froute&page=%2Fapi%2Fanalyze%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze%2Froute.ts&appDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CCkhadar%5CDownloads%5CAI_Baseline_Map&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();