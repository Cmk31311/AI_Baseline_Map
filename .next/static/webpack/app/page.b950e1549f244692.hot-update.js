"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/baseline.ts":
/*!*****************************!*\
  !*** ./src/lib/baseline.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildHierarchy: () => (/* binding */ buildHierarchy),\n/* harmony export */   colorForBaseline: () => (/* binding */ colorForBaseline),\n/* harmony export */   getAllFeatures: () => (/* binding */ getAllFeatures),\n/* harmony export */   labelForBaseline: () => (/* binding */ labelForBaseline)\n/* harmony export */ });\n/* harmony import */ var web_features_data_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web-features/data.json */ \"(app-pages-browser)/./node_modules/web-features/data.json\");\n\nconst { features: featureMap, groups: groupMap } = web_features_data_json__WEBPACK_IMPORTED_MODULE_0__;\n/**\r\n * Transform web-features data into normalized feature nodes\r\n * Adds consistent baseline mapping for our UI components\r\n */ function getAllFeatures() {\n    return Object.entries(featureMap).map((param)=>{\n        let [id, featureData] = param;\n        var _typedFeature_status, _typedFeature_compat, _typedFeature_status1, _typedFeature_status2, _typedFeature_status3;\n        const typedFeature = featureData;\n        var _typedFeature_status_baseline;\n        const rawBaseline = (_typedFeature_status_baseline = (_typedFeature_status = typedFeature.status) === null || _typedFeature_status === void 0 ? void 0 : _typedFeature_status.baseline) !== null && _typedFeature_status_baseline !== void 0 ? _typedFeature_status_baseline : false;\n        let normalizedBaseline = false;\n        // Normalize baseline to our standard levels\n        if (rawBaseline === 'high' || rawBaseline === true) {\n            normalizedBaseline = 'high';\n        } else if (rawBaseline === 'low') {\n            normalizedBaseline = 'low';\n        } else {\n            normalizedBaseline = false;\n        }\n        return {\n            id,\n            name: typedFeature.name || id,\n            description: typedFeature.description || '',\n            group: Array.isArray(typedFeature.group) ? typedFeature.group[0] : typedFeature.group || extractGroupFromFeature(id),\n            spec: Array.isArray(typedFeature.spec) ? typedFeature.spec[0] : typedFeature.spec,\n            caniuse: (_typedFeature_compat = typedFeature.compat) === null || _typedFeature_compat === void 0 ? void 0 : _typedFeature_compat.caniuse,\n            baseline: normalizedBaseline,\n            baseline_low_date: (_typedFeature_status1 = typedFeature.status) === null || _typedFeature_status1 === void 0 ? void 0 : _typedFeature_status1.baseline_low_date,\n            baseline_high_date: (_typedFeature_status2 = typedFeature.status) === null || _typedFeature_status2 === void 0 ? void 0 : _typedFeature_status2.baseline_high_date,\n            support: (_typedFeature_status3 = typedFeature.status) === null || _typedFeature_status3 === void 0 ? void 0 : _typedFeature_status3.support\n        };\n    });\n}\n/**\r\n * Build a hierarchical structure of features and groups for map visualization\r\n * Filters features by IDs if provided, otherwise returns all features\r\n */ function buildHierarchy(filteredIds) {\n    // Create group nodes from web-features data\n    const groups = {};\n    Object.entries(groupMap).forEach((param)=>{\n        let [id, groupData] = param;\n        const typedGroup = groupData;\n        groups[id] = {\n            id,\n            name: typedGroup.name || id,\n            parent: typedGroup.parent,\n            children: []\n        };\n    });\n    // Helper: get top-level groups without parents\n    function getRootGroups() {\n        return Object.values(groups).filter((group)=>!group.parent);\n    }\n    // Create parent-child relationships between groups\n    Object.values(groups).forEach((group)=>{\n        if (group.parent && groups[group.parent]) {\n            groups[group.parent].children.push(group);\n        }\n    });\n    // Create fallback group for baseline features\n    const baselineId = 'baseline';\n    if (!groups[baselineId]) {\n        groups[baselineId] = {\n            id: baselineId,\n            name: 'Baseline Features',\n            children: []\n        };\n    }\n    // Process each feature and attach to appropriate group\n    Object.entries(featureMap).forEach((param)=>{\n        let [featureId, featureData] = param;\n        var _typedFeature_status, _typedFeature_compat, _typedFeature_status1, _typedFeature_status2, _typedFeature_status3;\n        if (filteredIds && !filteredIds.has(featureId)) return;\n        // Normalize baseline level consistently\n        const typedFeature = featureData;\n        var _typedFeature_status_baseline;\n        const rawBaseline = (_typedFeature_status_baseline = (_typedFeature_status = typedFeature.status) === null || _typedFeature_status === void 0 ? void 0 : _typedFeature_status.baseline) !== null && _typedFeature_status_baseline !== void 0 ? _typedFeature_status_baseline : false;\n        let normalizedBaseline = false;\n        if (rawBaseline === 'high' || rawBaseline === true) {\n            normalizedBaseline = 'high';\n        } else if (rawBaseline === 'low') {\n            normalizedBaseline = 'low';\n        }\n        const leaf = {\n            type: 'feature',\n            data: {\n                id: featureId,\n                name: typedFeature.name || featureId,\n                description: typedFeature.description || '',\n                group: Array.isArray(typedFeature.group) ? typedFeature.group[0] : typedFeature.group || extractGroupFromFeature(featureId),\n                spec: Array.isArray(typedFeature.spec) ? typedFeature.spec[0] : typedFeature.spec,\n                caniuse: (_typedFeature_compat = typedFeature.compat) === null || _typedFeature_compat === void 0 ? void 0 : _typedFeature_compat.caniuse,\n                baseline: normalizedBaseline,\n                baseline_low_date: (_typedFeature_status1 = typedFeature.status) === null || _typedFeature_status1 === void 0 ? void 0 : _typedFeature_status1.baseline_low_date,\n                baseline_high_date: (_typedFeature_status2 = typedFeature.status) === null || _typedFeature_status2 === void 0 ? void 0 : _typedFeature_status2.baseline_high_date,\n                support: (_typedFeature_status3 = typedFeature.status) === null || _typedFeature_status3 === void 0 ? void 0 : _typedFeature_status3.support\n            }\n        };\n        var _leaf_data_group;\n        // Attach feature to its corresponding group or baseline\n        const groupId = (_leaf_data_group = leaf.data.group) !== null && _leaf_data_group !== void 0 ? _leaf_data_group : baselineId;\n        var _groups_groupId;\n        const targetGroup = (_groups_groupId = groups[groupId]) !== null && _groups_groupId !== void 0 ? _groups_groupId : groups[baselineId];\n        targetGroup.children.push(leaf);\n    });\n    // Filter out empty groups and return top-level structure\n    const populatedRootGroups = getRootGroups().filter((group)=>group.children.length > 0);\n    return {\n        name: 'Web Platform',\n        children: populatedRootGroups\n    };\n}\n/**\r\n * Extract category group from feature ID based on common patterns\r\n */ function extractGroupFromFeature(featureId) {\n    if (featureId.startsWith('css-')) return 'css';\n    if (featureId.startsWith('js-')) return 'javascript';\n    if (featureId.startsWith('html-')) return 'html';\n    if (featureId.startsWith('api-')) return 'api';\n    if (featureId.startsWith('security-')) return 'security';\n    return 'baseline';\n}\nfunction colorForBaseline(level) {\n    if (level === 'high') return '#22c55e'; // green\n    if (level === 'low') return '#3b82f6'; // blue\n    return '#B8860B'; // dark gold\n}\nfunction labelForBaseline(level) {\n    if (level === 'high') return 'Baseline: Widely available';\n    if (level === 'low') return 'Baseline: Newly available';\n    return 'Baseline: Limited availability';\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TyxTQUFTQyxpQkFBaUJELEtBQW9CO0lBQ25ELElBQUlBLFVBQVUsUUFBUSxPQUFPO0lBQzdCLElBQUlBLFVBQVUsT0FBTyxPQUFPO0lBQzVCLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxDa2hhZGFyXFxEb3dubG9hZHNcXEFJX0Jhc2VsaW5lX01hcFxcc3JjXFxsaWJcXGJhc2VsaW5lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkYXRhIGZyb20gJ3dlYi1mZWF0dXJlcy9kYXRhLmpzb24nO1xyXG5cclxuXHJcbmNvbnN0IHsgZmVhdHVyZXM6IGZlYXR1cmVNYXAsIGdyb3VwczogZ3JvdXBNYXAgfSA9IGRhdGEgYXMgeyBmZWF0dXJlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47IGdyb3VwczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfTtcclxuXHJcbmV4cG9ydCB0eXBlIEJhc2VsaW5lTGV2ZWwgPSAnaGlnaCcgfCAnbG93JyB8IGZhbHNlO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGZWF0dXJlTm9kZSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XHJcbiAgZ3JvdXA/OiBzdHJpbmc7XHJcbiAgc3BlYz86IHN0cmluZztcclxuICBjYW5pdXNlPzogc3RyaW5nO1xyXG4gIGJhc2VsaW5lOiBCYXNlbGluZUxldmVsO1xyXG4gIGJhc2VsaW5lX2xvd19kYXRlPzogc3RyaW5nO1xyXG4gIGJhc2VsaW5lX2hpZ2hfZGF0ZT86IHN0cmluZztcclxuICBzdXBwb3J0PzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHcm91cE5vZGUge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIHBhcmVudD86IHN0cmluZztcclxuICBjaGlsZHJlbjogQXJyYXk8R3JvdXBOb2RlIHwgRmVhdHVyZUxlYWY+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZlYXR1cmVMZWFmIHtcclxuICB0eXBlOiAnZmVhdHVyZSc7XHJcbiAgZGF0YTogRmVhdHVyZU5vZGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUm9vdE5vZGUge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBjaGlsZHJlbjogR3JvdXBOb2RlW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm0gd2ViLWZlYXR1cmVzIGRhdGEgaW50byBub3JtYWxpemVkIGZlYXR1cmUgbm9kZXNcclxuICogQWRkcyBjb25zaXN0ZW50IGJhc2VsaW5lIG1hcHBpbmcgZm9yIG91ciBVSSBjb21wb25lbnRzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsRmVhdHVyZXMoKTogRmVhdHVyZU5vZGVbXSB7XHJcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGZlYXR1cmVNYXApLm1hcCgoW2lkLCBmZWF0dXJlRGF0YV0pID0+IHtcclxuICAgIGNvbnN0IHR5cGVkRmVhdHVyZSA9IGZlYXR1cmVEYXRhIGFzIHsgXHJcbiAgICAgIHN0YXR1cz86IHsgXHJcbiAgICAgICAgYmFzZWxpbmU/OiBzdHJpbmcgfCBib29sZWFuOyBcclxuICAgICAgICBiYXNlbGluZV9sb3dfZGF0ZT86IHN0cmluZztcclxuICAgICAgICBiYXNlbGluZV9oaWdoX2RhdGU/OiBzdHJpbmc7XHJcbiAgICAgICAgc3VwcG9ydD86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbiAgICAgIH07IFxyXG4gICAgICBuYW1lPzogc3RyaW5nOyBcclxuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7IFxyXG4gICAgICBncm91cD86IHN0cmluZyB8IHN0cmluZ1tdOyBcclxuICAgICAgc3BlYz86IHN0cmluZyB8IHN0cmluZ1tdO1xyXG4gICAgICBjb21wYXQ/OiB7XHJcbiAgICAgICAgc3BlYz86IHN0cmluZztcclxuICAgICAgICBjYW5pdXNlPzogc3RyaW5nO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJhd0Jhc2VsaW5lID0gdHlwZWRGZWF0dXJlLnN0YXR1cz8uYmFzZWxpbmUgPz8gZmFsc2U7XHJcbiAgICBsZXQgbm9ybWFsaXplZEJhc2VsaW5lOiBCYXNlbGluZUxldmVsID0gZmFsc2U7XHJcbiAgICBcclxuICAgIC8vIE5vcm1hbGl6ZSBiYXNlbGluZSB0byBvdXIgc3RhbmRhcmQgbGV2ZWxzXHJcbiAgICBpZiAocmF3QmFzZWxpbmUgPT09ICdoaWdoJyB8fCByYXdCYXNlbGluZSA9PT0gdHJ1ZSkge1xyXG4gICAgICBub3JtYWxpemVkQmFzZWxpbmUgPSAnaGlnaCc7XHJcbiAgICB9IGVsc2UgaWYgKHJhd0Jhc2VsaW5lID09PSAnbG93Jykge1xyXG4gICAgICBub3JtYWxpemVkQmFzZWxpbmUgPSAnbG93JztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5vcm1hbGl6ZWRCYXNlbGluZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZCxcclxuICAgICAgbmFtZTogdHlwZWRGZWF0dXJlLm5hbWUgfHwgaWQsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0eXBlZEZlYXR1cmUuZGVzY3JpcHRpb24gfHwgJycsXHJcbiAgICAgIGdyb3VwOiBBcnJheS5pc0FycmF5KHR5cGVkRmVhdHVyZS5ncm91cCkgPyB0eXBlZEZlYXR1cmUuZ3JvdXBbMF0gOiB0eXBlZEZlYXR1cmUuZ3JvdXAgfHwgZXh0cmFjdEdyb3VwRnJvbUZlYXR1cmUoaWQpLFxyXG4gICAgICBzcGVjOiBBcnJheS5pc0FycmF5KHR5cGVkRmVhdHVyZS5zcGVjKSA/IHR5cGVkRmVhdHVyZS5zcGVjWzBdIDogdHlwZWRGZWF0dXJlLnNwZWMsXHJcbiAgICAgIGNhbml1c2U6IHR5cGVkRmVhdHVyZS5jb21wYXQ/LmNhbml1c2UsXHJcbiAgICAgIGJhc2VsaW5lOiBub3JtYWxpemVkQmFzZWxpbmUsXHJcbiAgICAgIGJhc2VsaW5lX2xvd19kYXRlOiB0eXBlZEZlYXR1cmUuc3RhdHVzPy5iYXNlbGluZV9sb3dfZGF0ZSxcclxuICAgICAgYmFzZWxpbmVfaGlnaF9kYXRlOiB0eXBlZEZlYXR1cmUuc3RhdHVzPy5iYXNlbGluZV9oaWdoX2RhdGUsXHJcbiAgICAgIHN1cHBvcnQ6IHR5cGVkRmVhdHVyZS5zdGF0dXM/LnN1cHBvcnRcclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCdWlsZCBhIGhpZXJhcmNoaWNhbCBzdHJ1Y3R1cmUgb2YgZmVhdHVyZXMgYW5kIGdyb3VwcyBmb3IgbWFwIHZpc3VhbGl6YXRpb25cclxuICogRmlsdGVycyBmZWF0dXJlcyBieSBJRHMgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSByZXR1cm5zIGFsbCBmZWF0dXJlc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkSGllcmFyY2h5KGZpbHRlcmVkSWRzPzogU2V0PHN0cmluZz4pOiBSb290Tm9kZSB7XHJcbiAgLy8gQ3JlYXRlIGdyb3VwIG5vZGVzIGZyb20gd2ViLWZlYXR1cmVzIGRhdGFcclxuICBjb25zdCBncm91cHM6IFJlY29yZDxzdHJpbmcsIEdyb3VwTm9kZT4gPSB7fTtcclxuICBPYmplY3QuZW50cmllcyhncm91cE1hcCkuZm9yRWFjaCgoW2lkLCBncm91cERhdGFdKSA9PiB7XHJcbiAgICBjb25zdCB0eXBlZEdyb3VwID0gZ3JvdXBEYXRhIGFzIHsgbmFtZT86IHN0cmluZzsgcGFyZW50Pzogc3RyaW5nIH07XHJcbiAgICBncm91cHNbaWRdID0geyBpZCwgbmFtZTogdHlwZWRHcm91cC5uYW1lIHx8IGlkLCBwYXJlbnQ6IHR5cGVkR3JvdXAucGFyZW50LCBjaGlsZHJlbjogW10gfTtcclxuICB9KTtcclxuXHJcbiAgLy8gSGVscGVyOiBnZXQgdG9wLWxldmVsIGdyb3VwcyB3aXRob3V0IHBhcmVudHNcclxuICBmdW5jdGlvbiBnZXRSb290R3JvdXBzKCk6IEdyb3VwTm9kZVtdIHtcclxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGdyb3VwcykuZmlsdGVyKGdyb3VwID0+ICFncm91cC5wYXJlbnQpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXBzIGJldHdlZW4gZ3JvdXBzXHJcbiAgT2JqZWN0LnZhbHVlcyhncm91cHMpLmZvckVhY2goZ3JvdXAgPT4ge1xyXG4gICAgaWYgKGdyb3VwLnBhcmVudCAmJiBncm91cHNbZ3JvdXAucGFyZW50XSkge1xyXG4gICAgICBncm91cHNbZ3JvdXAucGFyZW50XS5jaGlsZHJlbi5wdXNoKGdyb3VwKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gQ3JlYXRlIGZhbGxiYWNrIGdyb3VwIGZvciBiYXNlbGluZSBmZWF0dXJlc1xyXG4gIGNvbnN0IGJhc2VsaW5lSWQgPSAnYmFzZWxpbmUnO1xyXG4gIGlmICghZ3JvdXBzW2Jhc2VsaW5lSWRdKSB7XHJcbiAgICBncm91cHNbYmFzZWxpbmVJZF0gPSB7IGlkOiBiYXNlbGluZUlkLCBuYW1lOiAnQmFzZWxpbmUgRmVhdHVyZXMnLCBjaGlsZHJlbjogW10gfTtcclxuICB9XHJcblxyXG4gIC8vIFByb2Nlc3MgZWFjaCBmZWF0dXJlIGFuZCBhdHRhY2ggdG8gYXBwcm9wcmlhdGUgZ3JvdXBcclxuICBPYmplY3QuZW50cmllcyhmZWF0dXJlTWFwKS5mb3JFYWNoKChbZmVhdHVyZUlkLCBmZWF0dXJlRGF0YV0pID0+IHtcclxuICAgIGlmIChmaWx0ZXJlZElkcyAmJiAhZmlsdGVyZWRJZHMuaGFzKGZlYXR1cmVJZCkpIHJldHVybjtcclxuXHJcbiAgICAvLyBOb3JtYWxpemUgYmFzZWxpbmUgbGV2ZWwgY29uc2lzdGVudGx5XHJcbiAgICBjb25zdCB0eXBlZEZlYXR1cmUgPSBmZWF0dXJlRGF0YSBhcyB7IFxyXG4gICAgICBzdGF0dXM/OiB7IFxyXG4gICAgICAgIGJhc2VsaW5lPzogc3RyaW5nIHwgYm9vbGVhbjsgXHJcbiAgICAgICAgYmFzZWxpbmVfbG93X2RhdGU/OiBzdHJpbmc7XHJcbiAgICAgICAgYmFzZWxpbmVfaGlnaF9kYXRlPzogc3RyaW5nO1xyXG4gICAgICAgIHN1cHBvcnQ/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xyXG4gICAgICB9OyBcclxuICAgICAgbmFtZT86IHN0cmluZzsgXHJcbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nOyBcclxuICAgICAgZ3JvdXA/OiBzdHJpbmcgfCBzdHJpbmdbXTsgXHJcbiAgICAgIHNwZWM/OiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuICAgICAgY29tcGF0Pzoge1xyXG4gICAgICAgIHNwZWM/OiBzdHJpbmc7XHJcbiAgICAgICAgY2FuaXVzZT86IHN0cmluZztcclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgICBjb25zdCByYXdCYXNlbGluZSA9IHR5cGVkRmVhdHVyZS5zdGF0dXM/LmJhc2VsaW5lID8/IGZhbHNlO1xyXG4gICAgbGV0IG5vcm1hbGl6ZWRCYXNlbGluZTogQmFzZWxpbmVMZXZlbCA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICBpZiAocmF3QmFzZWxpbmUgPT09ICdoaWdoJyB8fCByYXdCYXNlbGluZSA9PT0gdHJ1ZSkge1xyXG4gICAgICBub3JtYWxpemVkQmFzZWxpbmUgPSAnaGlnaCc7XHJcbiAgICB9IGVsc2UgaWYgKHJhd0Jhc2VsaW5lID09PSAnbG93Jykge1xyXG4gICAgICBub3JtYWxpemVkQmFzZWxpbmUgPSAnbG93JztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsZWFmOiBGZWF0dXJlTGVhZiA9IHtcclxuICAgICAgdHlwZTogJ2ZlYXR1cmUnLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgaWQ6IGZlYXR1cmVJZCxcclxuICAgICAgICBuYW1lOiB0eXBlZEZlYXR1cmUubmFtZSB8fCBmZWF0dXJlSWQsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IHR5cGVkRmVhdHVyZS5kZXNjcmlwdGlvbiB8fCAnJyxcclxuICAgICAgICBncm91cDogQXJyYXkuaXNBcnJheSh0eXBlZEZlYXR1cmUuZ3JvdXApID8gdHlwZWRGZWF0dXJlLmdyb3VwWzBdIDogdHlwZWRGZWF0dXJlLmdyb3VwIHx8IGV4dHJhY3RHcm91cEZyb21GZWF0dXJlKGZlYXR1cmVJZCksXHJcbiAgICAgICAgc3BlYzogQXJyYXkuaXNBcnJheSh0eXBlZEZlYXR1cmUuc3BlYykgPyB0eXBlZEZlYXR1cmUuc3BlY1swXSA6IHR5cGVkRmVhdHVyZS5zcGVjLFxyXG4gICAgICAgIGNhbml1c2U6IHR5cGVkRmVhdHVyZS5jb21wYXQ/LmNhbml1c2UsXHJcbiAgICAgICAgYmFzZWxpbmU6IG5vcm1hbGl6ZWRCYXNlbGluZSxcclxuICAgICAgICBiYXNlbGluZV9sb3dfZGF0ZTogdHlwZWRGZWF0dXJlLnN0YXR1cz8uYmFzZWxpbmVfbG93X2RhdGUsXHJcbiAgICAgICAgYmFzZWxpbmVfaGlnaF9kYXRlOiB0eXBlZEZlYXR1cmUuc3RhdHVzPy5iYXNlbGluZV9oaWdoX2RhdGUsXHJcbiAgICAgICAgc3VwcG9ydDogdHlwZWRGZWF0dXJlLnN0YXR1cz8uc3VwcG9ydCxcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gQXR0YWNoIGZlYXR1cmUgdG8gaXRzIGNvcnJlc3BvbmRpbmcgZ3JvdXAgb3IgYmFzZWxpbmVcclxuICAgIGNvbnN0IGdyb3VwSWQgPSBsZWFmLmRhdGEuZ3JvdXAgPz8gYmFzZWxpbmVJZDtcclxuICAgIGNvbnN0IHRhcmdldEdyb3VwID0gZ3JvdXBzW2dyb3VwSWRdID8/IGdyb3Vwc1tiYXNlbGluZUlkXTtcclxuICAgIHRhcmdldEdyb3VwLmNoaWxkcmVuLnB1c2gobGVhZik7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEZpbHRlciBvdXQgZW1wdHkgZ3JvdXBzIGFuZCByZXR1cm4gdG9wLWxldmVsIHN0cnVjdHVyZVxyXG4gIGNvbnN0IHBvcHVsYXRlZFJvb3RHcm91cHMgPSBnZXRSb290R3JvdXBzKCkuZmlsdGVyKGdyb3VwID0+IGdyb3VwLmNoaWxkcmVuLmxlbmd0aCA+IDApO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ1dlYiBQbGF0Zm9ybScsXHJcbiAgICBjaGlsZHJlbjogcG9wdWxhdGVkUm9vdEdyb3VwcyxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogRXh0cmFjdCBjYXRlZ29yeSBncm91cCBmcm9tIGZlYXR1cmUgSUQgYmFzZWQgb24gY29tbW9uIHBhdHRlcm5zXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0R3JvdXBGcm9tRmVhdHVyZShmZWF0dXJlSWQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKGZlYXR1cmVJZC5zdGFydHNXaXRoKCdjc3MtJykpIHJldHVybiAnY3NzJztcclxuICBpZiAoZmVhdHVyZUlkLnN0YXJ0c1dpdGgoJ2pzLScpKSByZXR1cm4gJ2phdmFzY3JpcHQnO1xyXG4gIGlmIChmZWF0dXJlSWQuc3RhcnRzV2l0aCgnaHRtbC0nKSkgcmV0dXJuICdodG1sJztcclxuICBpZiAoZmVhdHVyZUlkLnN0YXJ0c1dpdGgoJ2FwaS0nKSkgcmV0dXJuICdhcGknO1xyXG4gIGlmIChmZWF0dXJlSWQuc3RhcnRzV2l0aCgnc2VjdXJpdHktJykpIHJldHVybiAnc2VjdXJpdHknO1xyXG4gIHJldHVybiAnYmFzZWxpbmUnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29sb3JGb3JCYXNlbGluZShsZXZlbDogQmFzZWxpbmVMZXZlbCk6IHN0cmluZyB7XHJcbiAgaWYgKGxldmVsID09PSAnaGlnaCcpIHJldHVybiAnIzIyYzU1ZSc7IC8vIGdyZWVuXHJcbiAgaWYgKGxldmVsID09PSAnbG93JykgcmV0dXJuICcjM2I4MmY2JzsgIC8vIGJsdWVcclxuICByZXR1cm4gJyNCODg2MEInOyAgICAgICAgICAgICAgICAgICAgICAgLy8gZGFyayBnb2xkXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsYWJlbEZvckJhc2VsaW5lKGxldmVsOiBCYXNlbGluZUxldmVsKTogc3RyaW5nIHtcclxuICBpZiAobGV2ZWwgPT09ICdoaWdoJykgcmV0dXJuICdCYXNlbGluZTogV2lkZWx5IGF2YWlsYWJsZSc7XHJcbiAgaWYgKGxldmVsID09PSAnbG93JykgcmV0dXJuICdCYXNlbGluZTogTmV3bHkgYXZhaWxhYmxlJztcclxuICByZXR1cm4gJ0Jhc2VsaW5lOiBMaW1pdGVkIGF2YWlsYWJpbGl0eSc7XHJcbn1cclxuIl0sIm5hbWVzIjpbImRhdGEiLCJmZWF0dXJlcyIsImZlYXR1cmVNYXAiLCJncm91cHMiLCJncm91cE1hcCIsImdldEFsbEZlYXR1cmVzIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsImlkIiwiZmVhdHVyZURhdGEiLCJ0eXBlZEZlYXR1cmUiLCJyYXdCYXNlbGluZSIsInN0YXR1cyIsImJhc2VsaW5lIiwibm9ybWFsaXplZEJhc2VsaW5lIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiZ3JvdXAiLCJBcnJheSIsImlzQXJyYXkiLCJleHRyYWN0R3JvdXBGcm9tRmVhdHVyZSIsInNwZWMiLCJjYW5pdXNlIiwiY29tcGF0IiwiYmFzZWxpbmVfbG93X2RhdGUiLCJiYXNlbGluZV9oaWdoX2RhdGUiLCJzdXBwb3J0IiwiYnVpbGRIaWVyYXJjaHkiLCJmaWx0ZXJlZElkcyIsImZvckVhY2giLCJncm91cERhdGEiLCJ0eXBlZEdyb3VwIiwicGFyZW50IiwiY2hpbGRyZW4iLCJnZXRSb290R3JvdXBzIiwidmFsdWVzIiwiZmlsdGVyIiwicHVzaCIsImJhc2VsaW5lSWQiLCJmZWF0dXJlSWQiLCJoYXMiLCJsZWFmIiwidHlwZSIsImdyb3VwSWQiLCJ0YXJnZXRHcm91cCIsInBvcHVsYXRlZFJvb3RHcm91cHMiLCJsZW5ndGgiLCJzdGFydHNXaXRoIiwiY29sb3JGb3JCYXNlbGluZSIsImxldmVsIiwibGFiZWxGb3JCYXNlbGluZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/baseline.ts\n"));

/***/ })

});