"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/baseline.ts":
/*!*****************************!*\
  !*** ./src/lib/baseline.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildHierarchy: () => (/* binding */ buildHierarchy),\n/* harmony export */   colorForBaseline: () => (/* binding */ colorForBaseline),\n/* harmony export */   getAllFeatures: () => (/* binding */ getAllFeatures),\n/* harmony export */   labelForBaseline: () => (/* binding */ labelForBaseline)\n/* harmony export */ });\n/* harmony import */ var web_features_data_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web-features/data.json */ \"(app-pages-browser)/./node_modules/web-features/data.json\");\n\nconst { features: featureMap, groups: groupMap } = web_features_data_json__WEBPACK_IMPORTED_MODULE_0__;\n/**\r\n * Transform web-features data into normalized feature nodes\r\n * Adds consistent baseline mapping for our UI components\r\n */ function getAllFeatures() {\n    return Object.entries(featureMap).map((param)=>{\n        let [id, featureData] = param;\n        var _typedFeature_status, _typedFeature_compat, _typedFeature_status1, _typedFeature_status2, _typedFeature_status3;\n        const typedFeature = featureData;\n        var _typedFeature_status_baseline;\n        const rawBaseline = (_typedFeature_status_baseline = (_typedFeature_status = typedFeature.status) === null || _typedFeature_status === void 0 ? void 0 : _typedFeature_status.baseline) !== null && _typedFeature_status_baseline !== void 0 ? _typedFeature_status_baseline : false;\n        let normalizedBaseline = false;\n        // Normalize baseline to our standard levels\n        if (rawBaseline === 'high' || rawBaseline === true) {\n            normalizedBaseline = 'high';\n        } else if (rawBaseline === 'low') {\n            normalizedBaseline = 'low';\n        } else {\n            normalizedBaseline = false;\n        }\n        return {\n            id,\n            name: typedFeature.name || id,\n            description: typedFeature.description || '',\n            group: Array.isArray(typedFeature.group) ? typedFeature.group[0] : typedFeature.group || extractGroupFromFeature(id),\n            spec: Array.isArray(typedFeature.spec) ? typedFeature.spec[0] : typedFeature.spec,\n            caniuse: (_typedFeature_compat = typedFeature.compat) === null || _typedFeature_compat === void 0 ? void 0 : _typedFeature_compat.caniuse,\n            baseline: normalizedBaseline,\n            baseline_low_date: (_typedFeature_status1 = typedFeature.status) === null || _typedFeature_status1 === void 0 ? void 0 : _typedFeature_status1.baseline_low_date,\n            baseline_high_date: (_typedFeature_status2 = typedFeature.status) === null || _typedFeature_status2 === void 0 ? void 0 : _typedFeature_status2.baseline_high_date,\n            support: (_typedFeature_status3 = typedFeature.status) === null || _typedFeature_status3 === void 0 ? void 0 : _typedFeature_status3.support\n        };\n    });\n}\n/**\r\n * Build a hierarchical structure of features and groups for map visualization\r\n * Filters features by IDs if provided, otherwise returns all features\r\n */ function buildHierarchy(filteredIds) {\n    // Create group nodes from web-features data\n    const groups = {};\n    Object.entries(groupMap).forEach((param)=>{\n        let [id, groupData] = param;\n        const typedGroup = groupData;\n        groups[id] = {\n            id,\n            name: typedGroup.name || id,\n            parent: typedGroup.parent,\n            children: []\n        };\n    });\n    // Helper: get top-level groups without parents\n    function getRootGroups() {\n        return Object.values(groups).filter((group)=>!group.parent);\n    }\n    // Create parent-child relationships between groups\n    Object.values(groups).forEach((group)=>{\n        if (group.parent && groups[group.parent]) {\n            groups[group.parent].children.push(group);\n        }\n    });\n    // Create fallback group for baseline features\n    const baselineId = 'baseline';\n    if (!groups[baselineId]) {\n        groups[baselineId] = {\n            id: baselineId,\n            name: 'Baseline Features',\n            children: []\n        };\n    }\n    // Process each feature and attach to appropriate group\n    Object.entries(featureMap).forEach((param)=>{\n        let [featureId, featureData] = param;\n        var _typedFeature_status, _typedFeature_compat, _typedFeature_compat1, _typedFeature_status1, _typedFeature_status2, _typedFeature_status3;\n        if (filteredIds && !filteredIds.has(featureId)) return;\n        // Normalize baseline level consistently\n        const typedFeature = featureData;\n        var _typedFeature_status_baseline;\n        const rawBaseline = (_typedFeature_status_baseline = (_typedFeature_status = typedFeature.status) === null || _typedFeature_status === void 0 ? void 0 : _typedFeature_status.baseline) !== null && _typedFeature_status_baseline !== void 0 ? _typedFeature_status_baseline : false;\n        let normalizedBaseline = false;\n        if (rawBaseline === 'high' || rawBaseline === true) {\n            normalizedBaseline = 'high';\n        } else if (rawBaseline === 'low') {\n            normalizedBaseline = 'low';\n        }\n        const leaf = {\n            type: 'feature',\n            data: {\n                id: featureId,\n                name: typedFeature.name || featureId,\n                description: typedFeature.description || '',\n                group: extractGroupFromFeature(featureId),\n                spec: (_typedFeature_compat = typedFeature.compat) === null || _typedFeature_compat === void 0 ? void 0 : _typedFeature_compat.spec,\n                caniuse: (_typedFeature_compat1 = typedFeature.compat) === null || _typedFeature_compat1 === void 0 ? void 0 : _typedFeature_compat1.caniuse,\n                baseline: normalizedBaseline,\n                baseline_low_date: (_typedFeature_status1 = typedFeature.status) === null || _typedFeature_status1 === void 0 ? void 0 : _typedFeature_status1.baseline_low_date,\n                baseline_high_date: (_typedFeature_status2 = typedFeature.status) === null || _typedFeature_status2 === void 0 ? void 0 : _typedFeature_status2.baseline_high_date,\n                support: (_typedFeature_status3 = typedFeature.status) === null || _typedFeature_status3 === void 0 ? void 0 : _typedFeature_status3.support\n            }\n        };\n        var _leaf_data_group;\n        // Attach feature to its corresponding group or baseline\n        const groupId = (_leaf_data_group = leaf.data.group) !== null && _leaf_data_group !== void 0 ? _leaf_data_group : baselineId;\n        var _groups_groupId;\n        const targetGroup = (_groups_groupId = groups[groupId]) !== null && _groups_groupId !== void 0 ? _groups_groupId : groups[baselineId];\n        targetGroup.children.push(leaf);\n    });\n    // Filter out empty groups and return top-level structure\n    const populatedRootGroups = getRootGroups().filter((group)=>group.children.length > 0);\n    return {\n        name: 'Web Platform',\n        children: populatedRootGroups\n    };\n}\n/**\r\n * Extract category group from feature ID based on common patterns\r\n */ function extractGroupFromFeature(featureId) {\n    if (featureId.startsWith('css-')) return 'css';\n    if (featureId.startsWith('js-')) return 'javascript';\n    if (featureId.startsWith('html-')) return 'html';\n    if (featureId.startsWith('api-')) return 'api';\n    if (featureId.startsWith('security-')) return 'security';\n    return 'baseline';\n}\nfunction colorForBaseline(level) {\n    if (level === 'high') return '#22c55e'; // green\n    if (level === 'low') return '#3b82f6'; // blue\n    return '#B8860B'; // dark gold\n}\nfunction labelForBaseline(level) {\n    if (level === 'high') return 'Baseline: Widely available';\n    if (level === 'low') return 'Baseline: Newly available';\n    return 'Baseline: Limited availability';\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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InNvdXJjZXMiOlsiQzpcXFVzZXJzXFxDa2hhZGFyXFxEb3dubG9hZHNcXEFJX0Jhc2VsaW5lX01hcFxcc3JjXFxsaWJcXGJhc2VsaW5lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkYXRhIGZyb20gJ3dlYi1mZWF0dXJlcy9kYXRhLmpzb24nO1xyXG5cclxuXHJcbmNvbnN0IHsgZmVhdHVyZXM6IGZlYXR1cmVNYXAsIGdyb3VwczogZ3JvdXBNYXAgfSA9IGRhdGEgYXMgeyBmZWF0dXJlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47IGdyb3VwczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfTtcclxuXHJcbmV4cG9ydCB0eXBlIEJhc2VsaW5lTGV2ZWwgPSAnaGlnaCcgfCAnbG93JyB8IGZhbHNlO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGZWF0dXJlTm9kZSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XHJcbiAgZ3JvdXA/OiBzdHJpbmc7XHJcbiAgc3BlYz86IHN0cmluZztcclxuICBjYW5pdXNlPzogc3RyaW5nO1xyXG4gIGJhc2VsaW5lOiBCYXNlbGluZUxldmVsO1xyXG4gIGJhc2VsaW5lX2xvd19kYXRlPzogc3RyaW5nO1xyXG4gIGJhc2VsaW5lX2hpZ2hfZGF0ZT86IHN0cmluZztcclxuICBzdXBwb3J0PzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHcm91cE5vZGUge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIHBhcmVudD86IHN0cmluZztcclxuICBjaGlsZHJlbjogQXJyYXk8R3JvdXBOb2RlIHwgRmVhdHVyZUxlYWY+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZlYXR1cmVMZWFmIHtcclxuICB0eXBlOiAnZmVhdHVyZSc7XHJcbiAgZGF0YTogRmVhdHVyZU5vZGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUm9vdE5vZGUge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBjaGlsZHJlbjogR3JvdXBOb2RlW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm0gd2ViLWZlYXR1cmVzIGRhdGEgaW50byBub3JtYWxpemVkIGZlYXR1cmUgbm9kZXNcclxuICogQWRkcyBjb25zaXN0ZW50IGJhc2VsaW5lIG1hcHBpbmcgZm9yIG91ciBVSSBjb21wb25lbnRzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsRmVhdHVyZXMoKTogRmVhdHVyZU5vZGVbXSB7XHJcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGZlYXR1cmVNYXApLm1hcCgoW2lkLCBmZWF0dXJlRGF0YV0pID0+IHtcclxuICAgIGNvbnN0IHR5cGVkRmVhdHVyZSA9IGZlYXR1cmVEYXRhIGFzIHsgXHJcbiAgICAgIHN0YXR1cz86IHsgXHJcbiAgICAgICAgYmFzZWxpbmU/OiBzdHJpbmcgfCBib29sZWFuOyBcclxuICAgICAgICBiYXNlbGluZV9sb3dfZGF0ZT86IHN0cmluZztcclxuICAgICAgICBiYXNlbGluZV9oaWdoX2RhdGU/OiBzdHJpbmc7XHJcbiAgICAgICAgc3VwcG9ydD86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbiAgICAgIH07IFxyXG4gICAgICBuYW1lPzogc3RyaW5nOyBcclxuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7IFxyXG4gICAgICBncm91cD86IHN0cmluZzsgXHJcbiAgICAgIHNwZWM/OiBzdHJpbmc7XHJcbiAgICAgIGNvbXBhdD86IHtcclxuICAgICAgICBzcGVjPzogc3RyaW5nO1xyXG4gICAgICAgIGNhbml1c2U/OiBzdHJpbmc7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmF3QmFzZWxpbmUgPSB0eXBlZEZlYXR1cmUuc3RhdHVzPy5iYXNlbGluZSA/PyBmYWxzZTtcclxuICAgIGxldCBub3JtYWxpemVkQmFzZWxpbmU6IEJhc2VsaW5lTGV2ZWwgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgLy8gTm9ybWFsaXplIGJhc2VsaW5lIHRvIG91ciBzdGFuZGFyZCBsZXZlbHNcclxuICAgIGlmIChyYXdCYXNlbGluZSA9PT0gJ2hpZ2gnIHx8IHJhd0Jhc2VsaW5lID09PSB0cnVlKSB7XHJcbiAgICAgIG5vcm1hbGl6ZWRCYXNlbGluZSA9ICdoaWdoJztcclxuICAgIH0gZWxzZSBpZiAocmF3QmFzZWxpbmUgPT09ICdsb3cnKSB7XHJcbiAgICAgIG5vcm1hbGl6ZWRCYXNlbGluZSA9ICdsb3cnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9ybWFsaXplZEJhc2VsaW5lID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkLFxyXG4gICAgICBuYW1lOiB0eXBlZEZlYXR1cmUubmFtZSB8fCBpZCxcclxuICAgICAgZGVzY3JpcHRpb246IHR5cGVkRmVhdHVyZS5kZXNjcmlwdGlvbiB8fCAnJyxcclxuICAgICAgZ3JvdXA6IEFycmF5LmlzQXJyYXkodHlwZWRGZWF0dXJlLmdyb3VwKSA/IHR5cGVkRmVhdHVyZS5ncm91cFswXSA6IHR5cGVkRmVhdHVyZS5ncm91cCB8fCBleHRyYWN0R3JvdXBGcm9tRmVhdHVyZShpZCksXHJcbiAgICAgIHNwZWM6IEFycmF5LmlzQXJyYXkodHlwZWRGZWF0dXJlLnNwZWMpID8gdHlwZWRGZWF0dXJlLnNwZWNbMF0gOiB0eXBlZEZlYXR1cmUuc3BlYyxcclxuICAgICAgY2FuaXVzZTogdHlwZWRGZWF0dXJlLmNvbXBhdD8uY2FuaXVzZSxcclxuICAgICAgYmFzZWxpbmU6IG5vcm1hbGl6ZWRCYXNlbGluZSxcclxuICAgICAgYmFzZWxpbmVfbG93X2RhdGU6IHR5cGVkRmVhdHVyZS5zdGF0dXM/LmJhc2VsaW5lX2xvd19kYXRlLFxyXG4gICAgICBiYXNlbGluZV9oaWdoX2RhdGU6IHR5cGVkRmVhdHVyZS5zdGF0dXM/LmJhc2VsaW5lX2hpZ2hfZGF0ZSxcclxuICAgICAgc3VwcG9ydDogdHlwZWRGZWF0dXJlLnN0YXR1cz8uc3VwcG9ydFxyXG4gICAgfTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIGEgaGllcmFyY2hpY2FsIHN0cnVjdHVyZSBvZiBmZWF0dXJlcyBhbmQgZ3JvdXBzIGZvciBtYXAgdmlzdWFsaXphdGlvblxyXG4gKiBGaWx0ZXJzIGZlYXR1cmVzIGJ5IElEcyBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHJldHVybnMgYWxsIGZlYXR1cmVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRIaWVyYXJjaHkoZmlsdGVyZWRJZHM/OiBTZXQ8c3RyaW5nPik6IFJvb3ROb2RlIHtcclxuICAvLyBDcmVhdGUgZ3JvdXAgbm9kZXMgZnJvbSB3ZWItZmVhdHVyZXMgZGF0YVxyXG4gIGNvbnN0IGdyb3VwczogUmVjb3JkPHN0cmluZywgR3JvdXBOb2RlPiA9IHt9O1xyXG4gIE9iamVjdC5lbnRyaWVzKGdyb3VwTWFwKS5mb3JFYWNoKChbaWQsIGdyb3VwRGF0YV0pID0+IHtcclxuICAgIGNvbnN0IHR5cGVkR3JvdXAgPSBncm91cERhdGEgYXMgeyBuYW1lPzogc3RyaW5nOyBwYXJlbnQ/OiBzdHJpbmcgfTtcclxuICAgIGdyb3Vwc1tpZF0gPSB7IGlkLCBuYW1lOiB0eXBlZEdyb3VwLm5hbWUgfHwgaWQsIHBhcmVudDogdHlwZWRHcm91cC5wYXJlbnQsIGNoaWxkcmVuOiBbXSB9O1xyXG4gIH0pO1xyXG5cclxuICAvLyBIZWxwZXI6IGdldCB0b3AtbGV2ZWwgZ3JvdXBzIHdpdGhvdXQgcGFyZW50c1xyXG4gIGZ1bmN0aW9uIGdldFJvb3RHcm91cHMoKTogR3JvdXBOb2RlW10ge1xyXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZ3JvdXBzKS5maWx0ZXIoZ3JvdXAgPT4gIWdyb3VwLnBhcmVudCk7XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgcGFyZW50LWNoaWxkIHJlbGF0aW9uc2hpcHMgYmV0d2VlbiBncm91cHNcclxuICBPYmplY3QudmFsdWVzKGdyb3VwcykuZm9yRWFjaChncm91cCA9PiB7XHJcbiAgICBpZiAoZ3JvdXAucGFyZW50ICYmIGdyb3Vwc1tncm91cC5wYXJlbnRdKSB7XHJcbiAgICAgIGdyb3Vwc1tncm91cC5wYXJlbnRdLmNoaWxkcmVuLnB1c2goZ3JvdXApO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBDcmVhdGUgZmFsbGJhY2sgZ3JvdXAgZm9yIGJhc2VsaW5lIGZlYXR1cmVzXHJcbiAgY29uc3QgYmFzZWxpbmVJZCA9ICdiYXNlbGluZSc7XHJcbiAgaWYgKCFncm91cHNbYmFzZWxpbmVJZF0pIHtcclxuICAgIGdyb3Vwc1tiYXNlbGluZUlkXSA9IHsgaWQ6IGJhc2VsaW5lSWQsIG5hbWU6ICdCYXNlbGluZSBGZWF0dXJlcycsIGNoaWxkcmVuOiBbXSB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHJvY2VzcyBlYWNoIGZlYXR1cmUgYW5kIGF0dGFjaCB0byBhcHByb3ByaWF0ZSBncm91cFxyXG4gIE9iamVjdC5lbnRyaWVzKGZlYXR1cmVNYXApLmZvckVhY2goKFtmZWF0dXJlSWQsIGZlYXR1cmVEYXRhXSkgPT4ge1xyXG4gICAgaWYgKGZpbHRlcmVkSWRzICYmICFmaWx0ZXJlZElkcy5oYXMoZmVhdHVyZUlkKSkgcmV0dXJuO1xyXG5cclxuICAgIC8vIE5vcm1hbGl6ZSBiYXNlbGluZSBsZXZlbCBjb25zaXN0ZW50bHlcclxuICAgIGNvbnN0IHR5cGVkRmVhdHVyZSA9IGZlYXR1cmVEYXRhIGFzIHsgXHJcbiAgICAgIHN0YXR1cz86IHsgXHJcbiAgICAgICAgYmFzZWxpbmU/OiBzdHJpbmcgfCBib29sZWFuOyBcclxuICAgICAgICBiYXNlbGluZV9sb3dfZGF0ZT86IHN0cmluZztcclxuICAgICAgICBiYXNlbGluZV9oaWdoX2RhdGU/OiBzdHJpbmc7XHJcbiAgICAgICAgc3VwcG9ydD86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbiAgICAgIH07IFxyXG4gICAgICBuYW1lPzogc3RyaW5nOyBcclxuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7IFxyXG4gICAgICBncm91cD86IHN0cmluZzsgXHJcbiAgICAgIHNwZWM/OiBzdHJpbmc7XHJcbiAgICAgIGNvbXBhdD86IHtcclxuICAgICAgICBzcGVjPzogc3RyaW5nO1xyXG4gICAgICAgIGNhbml1c2U/OiBzdHJpbmc7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmF3QmFzZWxpbmUgPSB0eXBlZEZlYXR1cmUuc3RhdHVzPy5iYXNlbGluZSA/PyBmYWxzZTtcclxuICAgIGxldCBub3JtYWxpemVkQmFzZWxpbmU6IEJhc2VsaW5lTGV2ZWwgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgaWYgKHJhd0Jhc2VsaW5lID09PSAnaGlnaCcgfHwgcmF3QmFzZWxpbmUgPT09IHRydWUpIHtcclxuICAgICAgbm9ybWFsaXplZEJhc2VsaW5lID0gJ2hpZ2gnO1xyXG4gICAgfSBlbHNlIGlmIChyYXdCYXNlbGluZSA9PT0gJ2xvdycpIHtcclxuICAgICAgbm9ybWFsaXplZEJhc2VsaW5lID0gJ2xvdyc7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbGVhZjogRmVhdHVyZUxlYWYgPSB7XHJcbiAgICAgIHR5cGU6ICdmZWF0dXJlJyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIGlkOiBmZWF0dXJlSWQsXHJcbiAgICAgICAgbmFtZTogdHlwZWRGZWF0dXJlLm5hbWUgfHwgZmVhdHVyZUlkLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0eXBlZEZlYXR1cmUuZGVzY3JpcHRpb24gfHwgJycsXHJcbiAgICAgICAgZ3JvdXA6IGV4dHJhY3RHcm91cEZyb21GZWF0dXJlKGZlYXR1cmVJZCksXHJcbiAgICAgICAgc3BlYzogdHlwZWRGZWF0dXJlLmNvbXBhdD8uc3BlYyxcclxuICAgICAgICBjYW5pdXNlOiB0eXBlZEZlYXR1cmUuY29tcGF0Py5jYW5pdXNlLFxyXG4gICAgICAgIGJhc2VsaW5lOiBub3JtYWxpemVkQmFzZWxpbmUsXHJcbiAgICAgICAgYmFzZWxpbmVfbG93X2RhdGU6IHR5cGVkRmVhdHVyZS5zdGF0dXM/LmJhc2VsaW5lX2xvd19kYXRlLFxyXG4gICAgICAgIGJhc2VsaW5lX2hpZ2hfZGF0ZTogdHlwZWRGZWF0dXJlLnN0YXR1cz8uYmFzZWxpbmVfaGlnaF9kYXRlLFxyXG4gICAgICAgIHN1cHBvcnQ6IHR5cGVkRmVhdHVyZS5zdGF0dXM/LnN1cHBvcnQsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEF0dGFjaCBmZWF0dXJlIHRvIGl0cyBjb3JyZXNwb25kaW5nIGdyb3VwIG9yIGJhc2VsaW5lXHJcbiAgICBjb25zdCBncm91cElkID0gbGVhZi5kYXRhLmdyb3VwID8/IGJhc2VsaW5lSWQ7XHJcbiAgICBjb25zdCB0YXJnZXRHcm91cCA9IGdyb3Vwc1tncm91cElkXSA/PyBncm91cHNbYmFzZWxpbmVJZF07XHJcbiAgICB0YXJnZXRHcm91cC5jaGlsZHJlbi5wdXNoKGxlYWYpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBGaWx0ZXIgb3V0IGVtcHR5IGdyb3VwcyBhbmQgcmV0dXJuIHRvcC1sZXZlbCBzdHJ1Y3R1cmVcclxuICBjb25zdCBwb3B1bGF0ZWRSb290R3JvdXBzID0gZ2V0Um9vdEdyb3VwcygpLmZpbHRlcihncm91cCA9PiBncm91cC5jaGlsZHJlbi5sZW5ndGggPiAwKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdXZWIgUGxhdGZvcm0nLFxyXG4gICAgY2hpbGRyZW46IHBvcHVsYXRlZFJvb3RHcm91cHMsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgY2F0ZWdvcnkgZ3JvdXAgZnJvbSBmZWF0dXJlIElEIGJhc2VkIG9uIGNvbW1vbiBwYXR0ZXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdEdyb3VwRnJvbUZlYXR1cmUoZmVhdHVyZUlkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGlmIChmZWF0dXJlSWQuc3RhcnRzV2l0aCgnY3NzLScpKSByZXR1cm4gJ2Nzcyc7XHJcbiAgaWYgKGZlYXR1cmVJZC5zdGFydHNXaXRoKCdqcy0nKSkgcmV0dXJuICdqYXZhc2NyaXB0JztcclxuICBpZiAoZmVhdHVyZUlkLnN0YXJ0c1dpdGgoJ2h0bWwtJykpIHJldHVybiAnaHRtbCc7XHJcbiAgaWYgKGZlYXR1cmVJZC5zdGFydHNXaXRoKCdhcGktJykpIHJldHVybiAnYXBpJztcclxuICBpZiAoZmVhdHVyZUlkLnN0YXJ0c1dpdGgoJ3NlY3VyaXR5LScpKSByZXR1cm4gJ3NlY3VyaXR5JztcclxuICByZXR1cm4gJ2Jhc2VsaW5lJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yRm9yQmFzZWxpbmUobGV2ZWw6IEJhc2VsaW5lTGV2ZWwpOiBzdHJpbmcge1xyXG4gIGlmIChsZXZlbCA9PT0gJ2hpZ2gnKSByZXR1cm4gJyMyMmM1NWUnOyAvLyBncmVlblxyXG4gIGlmIChsZXZlbCA9PT0gJ2xvdycpIHJldHVybiAnIzNiODJmNic7ICAvLyBibHVlXHJcbiAgcmV0dXJuICcjQjg4NjBCJzsgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhcmsgZ29sZFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxGb3JCYXNlbGluZShsZXZlbDogQmFzZWxpbmVMZXZlbCk6IHN0cmluZyB7XHJcbiAgaWYgKGxldmVsID09PSAnaGlnaCcpIHJldHVybiAnQmFzZWxpbmU6IFdpZGVseSBhdmFpbGFibGUnO1xyXG4gIGlmIChsZXZlbCA9PT0gJ2xvdycpIHJldHVybiAnQmFzZWxpbmU6IE5ld2x5IGF2YWlsYWJsZSc7XHJcbiAgcmV0dXJuICdCYXNlbGluZTogTGltaXRlZCBhdmFpbGFiaWxpdHknO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJkYXRhIiwiZmVhdHVyZXMiLCJmZWF0dXJlTWFwIiwiZ3JvdXBzIiwiZ3JvdXBNYXAiLCJnZXRBbGxGZWF0dXJlcyIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJpZCIsImZlYXR1cmVEYXRhIiwidHlwZWRGZWF0dXJlIiwicmF3QmFzZWxpbmUiLCJzdGF0dXMiLCJiYXNlbGluZSIsIm5vcm1hbGl6ZWRCYXNlbGluZSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImdyb3VwIiwiQXJyYXkiLCJpc0FycmF5IiwiZXh0cmFjdEdyb3VwRnJvbUZlYXR1cmUiLCJzcGVjIiwiY2FuaXVzZSIsImNvbXBhdCIsImJhc2VsaW5lX2xvd19kYXRlIiwiYmFzZWxpbmVfaGlnaF9kYXRlIiwic3VwcG9ydCIsImJ1aWxkSGllcmFyY2h5IiwiZmlsdGVyZWRJZHMiLCJmb3JFYWNoIiwiZ3JvdXBEYXRhIiwidHlwZWRHcm91cCIsInBhcmVudCIsImNoaWxkcmVuIiwiZ2V0Um9vdEdyb3VwcyIsInZhbHVlcyIsImZpbHRlciIsInB1c2giLCJiYXNlbGluZUlkIiwiZmVhdHVyZUlkIiwiaGFzIiwibGVhZiIsInR5cGUiLCJncm91cElkIiwidGFyZ2V0R3JvdXAiLCJwb3B1bGF0ZWRSb290R3JvdXBzIiwibGVuZ3RoIiwic3RhcnRzV2l0aCIsImNvbG9yRm9yQmFzZWxpbmUiLCJsZXZlbCIsImxhYmVsRm9yQmFzZWxpbmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/baseline.ts\n"));

/***/ })

});